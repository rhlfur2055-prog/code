# -*- coding: utf-8 -*-
import json

def get_context_switching_content():
    return {
        "id": "02_프로세스스레드/context-switching",
        "title": "Context Switching",
        "category": "os",
        "subCategory": "02_프로세스스레드",
        "language": "C",
        "description": "CPU가 현재 프로세스를 멈추고 다른 프로세스로 전환하는 컨텍스트 스위칭의 원리를 학습합니다.",
        "isPlaceholder": False,
        "sections": [
            {
                "type": "concept",
                "title": "컨텍스트 스위칭 완전 정복",
                "content": "# 컨텍스트 스위칭 (Context Switching)\n\n## 한 줄 요약\n**CPU가 현재 실행 중인 프로세스를 멈추고, 다른 프로세스로 전환하는 작업**\n\n## 생활 비유: 요리사의 멀티태스킹\n```\n[요리사 = CPU, 요리 = 프로세스]\n\n요리사가 파스타를 만들다가 스테이크 주문이 들어옴\n\n1. 파스타 상태 저장 (면 삶는 중, 소스 준비됨)\n2. 파스타 재료 치워두기\n3. 스테이크 재료 꺼내기\n4. 스테이크 굽기 시작\n\n이 전환 과정 = Context Switching!\n```\n\n## 왜 필요한가?\n```\n[단일 코어에서 멀티태스킹]\n\n시간 -->  |--P1--|--P2--|--P1--|--P3--|--P1--|\n           ^      ^      ^      ^      ^\n           컨텍스트 스위칭 발생 지점\n\n- 하나의 CPU로 여러 프로세스를 동시에 실행하는 것처럼 보이게 함\n- 시분할(Time Sharing) 시스템의 핵심 메커니즘\n```\n\n## 핵심 개념\n| 용어 | 설명 |\n|------|------|\n| Context | 프로세스의 현재 상태 (레지스터, PC, 스택 등) |\n| PCB | 프로세스 컨텍스트를 저장하는 자료구조 |\n| Overhead | 스위칭에 소요되는 시간 (순수 낭비) |\n| Dispatcher | 실제 컨텍스트 스위칭을 수행하는 모듈 |"
            },
            {
                "type": "code",
                "title": "동작 원리",
                "language": "text",
                "code": "========================================\n    컨텍스트 스위칭 상세 과정\n========================================\n\n[STEP 1] 인터럽트 또는 시스템 콜 발생\n------------------------------------------\n  Process A (Running)\n       |\n       v\n  [Timer Interrupt!]  <-- 타임 퀀텀 만료\n       |\n       v\n  커널 모드로 전환\n\n\n[STEP 2] 현재 프로세스 상태 저장\n------------------------------------------\n  Process A의 PCB에 저장:\n  +---------------------------+\n  |  PC: 0x00401234          |  <- 다음 실행할 명령어 주소\n  |  SP: 0x7FFF1000          |  <- 스택 포인터\n  |  Registers: R1=5, R2=10  |  <- 범용 레지스터\n  |  State: Ready            |  <- 상태 변경\n  +---------------------------+\n\n\n[STEP 3] 다음 프로세스 선택 (스케줄러)\n------------------------------------------\n  Ready Queue: [B] -> [C] -> [D]\n                ^\n                |\n           선택: Process B\n\n\n[STEP 4] 새 프로세스 상태 복원\n------------------------------------------\n  Process B의 PCB에서 복원:\n  +---------------------------+\n  |  PC: 0x00405678          |  -> CPU의 PC 레지스터\n  |  SP: 0x7FFF2000          |  -> CPU의 SP 레지스터\n  |  Registers: R1=3, R2=7   |  -> CPU의 범용 레지스터\n  |  State: Running          |  <- 상태 변경\n  +---------------------------+\n\n\n[STEP 5] 사용자 모드로 전환, 실행 재개\n------------------------------------------\n  Process B (Running)\n       |\n       v\n  PC가 가리키는 명령어부터 실행\n\n\n========================================\n    타임라인으로 보는 오버헤드\n========================================\n\n시간 ->  |====|##|====|##|====|##|====|\n          P1   C  P2   C  P1   C  P3\n               S      S      S\n\n====  : 실제 프로세스 실행 (유용한 작업)\n##    : Context Switching (오버헤드)\n\n오버헤드 발생 원인:\n1. PCB 저장/복원 시간\n2. 메모리 맵 전환 (TLB Flush)\n3. 캐시 무효화 (Cache Miss 증가)\n4. 파이프라인 비우기"
            },
            {
                "type": "code",
                "title": "실무 활용",
                "language": "java",
                "code": "// ========================================\n//   Java에서 컨텍스트 스위칭 이해하기\n// ========================================\n\nimport java.util.concurrent.*;\n\npublic class ContextSwitchingDemo {\n    \n    // 컨텍스트 스위칭 오버헤드 측정\n    public static void measureContextSwitchOverhead() \n            throws InterruptedException {\n        \n        final int ITERATIONS = 1_000_000;\n        Object lock = new Object();\n        \n        // 두 스레드가 번갈아가며 실행 (강제 컨텍스트 스위칭)\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < ITERATIONS; i++) {\n                synchronized (lock) {\n                    lock.notify();\n                    try {\n                        lock.wait();\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                    }\n                }\n            }\n        });\n        \n        Thread t2 = new Thread(() -> {\n            for (int i = 0; i < ITERATIONS; i++) {\n                synchronized (lock) {\n                    lock.notify();\n                    try {\n                        lock.wait();\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                    }\n                }\n            }\n        });\n        \n        long start = System.nanoTime();\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        long end = System.nanoTime();\n        \n        double avgSwitchTime = (end - start) / (double)(ITERATIONS * 2);\n        System.out.printf(\"평균 컨텍스트 스위칭 시간: %.2f ns%n\", avgSwitchTime);\n    }\n    \n    // 스레드 풀로 컨텍스트 스위칭 최소화\n    public static void minimizeContextSwitching() {\n        // CPU 코어 수만큼 스레드 생성 -> 컨텍스트 스위칭 최소화\n        int cores = Runtime.getRuntime().availableProcessors();\n        ExecutorService executor = Executors.newFixedThreadPool(cores);\n        \n        System.out.println(\"CPU 코어 수: \" + cores);\n        System.out.println(\"스레드 풀 크기: \" + cores + \" (최적화됨)\");\n        \n        // 작업 제출\n        for (int i = 0; i < 100; i++) {\n            final int taskId = i;\n            executor.submit(() -> {\n                // CPU 바운드 작업\n                double result = 0;\n                for (int j = 0; j < 1000000; j++) {\n                    result += Math.sqrt(j);\n                }\n                return result;\n            });\n        }\n        \n        executor.shutdown();\n    }\n    \n    public static void main(String[] args) throws Exception {\n        System.out.println(\"=== 컨텍스트 스위칭 데모 ===\");\n        measureContextSwitchOverhead();\n        minimizeContextSwitching();\n    }\n}\n\n// ========================================\n//   Spring Boot에서의 최적화 전략\n// ========================================\n\n/*\n@Configuration\npublic class ThreadPoolConfig {\n    \n    @Bean\n    public Executor taskExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        \n        int coreCount = Runtime.getRuntime().availableProcessors();\n        \n        // CPU 바운드: 코어 수와 동일\n        // I/O 바운드: 코어 수 * 2 이상\n        executor.setCorePoolSize(coreCount);\n        executor.setMaxPoolSize(coreCount * 2);\n        executor.setQueueCapacity(500);\n        executor.setThreadNamePrefix(\"Async-\");\n        executor.initialize();\n        \n        return executor;\n    }\n}\n*/"
            },
            {
                "type": "tip",
                "title": "체크리스트 & 면접",
                "content": "## 컨텍스트 스위칭 체크리스트\n\n### 핵심 포인트\n- [ ] Context = 프로세스의 현재 실행 상태 (레지스터, PC, SP 등)\n- [ ] PCB에 저장되고 복원됨\n- [ ] 오버헤드가 발생하는 순수 비용\n- [ ] 프로세스 vs 스레드 스위칭 비용 차이 이해\n\n### 스위칭 비용 비교\n| 구분 | 비용 | 이유 |\n|------|------|------|\n| 프로세스 간 | 높음 | 메모리 맵, TLB, 캐시 전환 필요 |\n| 스레드 간 | 낮음 | 메모리 공유, 레지스터만 전환 |\n| 코루틴 | 매우 낮음 | 사용자 수준, 커널 개입 없음 |\n\n## 면접 예상 질문\n\n**Q1: 컨텍스트 스위칭이란 무엇인가요?**\n> CPU가 현재 프로세스의 상태를 PCB에 저장하고, 다음 프로세스의 상태를 PCB에서 복원하여 실행을 전환하는 과정입니다.\n\n**Q2: 왜 오버헤드가 발생하나요?**\n> 1) 레지스터 저장/복원 시간\n> 2) TLB Flush로 인한 캐시 미스 증가\n> 3) 파이프라인 비우기\n> 4) 메모리 맵 전환 시간\n\n**Q3: 프로세스와 스레드의 컨텍스트 스위칭 비용 차이는?**\n> 스레드는 같은 프로세스 내에서 메모리를 공유하므로 메모리 맵과 TLB를 전환할 필요가 없어 비용이 훨씬 적습니다.\n\n**Q4: 컨텍스트 스위칭을 최소화하는 방법은?**\n> 1) 스레드 풀 사용 (적정 크기 유지)\n> 2) 비동기 I/O 활용\n> 3) CPU 코어 수에 맞는 스레드 수 설정\n> 4) 코루틴/경량 스레드 사용"
            }
        ]
    }

def get_race_condition_content():
    return {
        "id": "03_동기화/race-condition",
        "title": "Race Condition",
        "category": "os",
        "subCategory": "03_동기화",
        "language": "C",
        "description": "여러 스레드가 공유 자원에 동시에 접근할 때 발생하는 경쟁 조건의 원인과 해결책을 학습합니다.",
        "isPlaceholder": False,
        "sections": [
            {
                "type": "concept",
                "title": "경쟁 조건 완전 정복",
                "content": "# Race Condition (경쟁 조건)\n\n## 한 줄 요약\n**여러 스레드가 공유 자원에 동시에 접근하여 실행 순서에 따라 결과가 달라지는 상황**\n\n## 생활 비유: 은행 ATM 동시 인출\n```\n[계좌 잔액: 100만원]\n\n     아내 (ATM 1)              남편 (ATM 2)\n         |                         |\n    잔액 확인: 100만원         잔액 확인: 100만원\n         |                         |\n    80만원 인출 요청           70만원 인출 요청\n         |                         |\n    잔액 = 100-80 = 20만원     잔액 = 100-70 = 30만원\n         |                         |\n         +-----> 최종 잔액? <------+\n\n예상: 100-80-70 = -50만원 (거부되어야 함)\n실제: 20만원 또는 30만원 (누가 먼저 쓰느냐에 따라)\n\n이것이 바로 Race Condition!\n```\n\n## 왜 발생하는가?\n```\n[경쟁 조건의 원인: 비원자적 연산]\n\n  count++  이 한 줄이 실제로는:\n  \n  1. LOAD  count -> R1   (메모리에서 레지스터로)\n  2. ADD   R1, 1         (레지스터에서 +1)\n  3. STORE R1 -> count   (레지스터에서 메모리로)\n\n  이 3단계 사이에 다른 스레드가 끼어들 수 있음!\n```\n\n## 핵심 개념\n| 용어 | 설명 |\n|------|------|\n| 임계 영역 | 공유 자원에 접근하는 코드 영역 |\n| 원자적 연산 | 중간에 끼어들 수 없는 연산 |\n| 데이터 레이스 | 동기화 없이 공유 데이터에 동시 접근 |"
            },
            {
                "type": "code",
                "title": "동작 원리",
                "language": "text",
                "code": "========================================\n    Race Condition 발생 시나리오\n========================================\n\n[초기 상태] counter = 0\n\n  Thread A                    Thread B\n  ---------                   ---------\n  LOAD counter (0)            \n                              LOAD counter (0)\n  ADD 1 (결과: 1)             \n                              ADD 1 (결과: 1)\n  STORE counter (1)           \n                              STORE counter (1)\n\n[결과] counter = 1  (예상: 2)\n\n\n========================================\n    더 복잡한 시나리오: Check-Then-Act\n========================================\n\n[파일 존재 여부 확인 후 생성]\n\n  Thread A                    Thread B\n  ---------                   ---------\n  if (!file.exists())         \n                              if (!file.exists())\n    // 파일 없음!             \n                                // 파일 없음!\n    file.create()             \n                                file.create()  // 에러!\n\n\n========================================\n    C 코드로 보는 Race Condition\n========================================\n\n#include <pthread.h>\n#include <stdio.h>\n\nint counter = 0;  // 공유 자원\n\nvoid* increment(void* arg) {\n    for (int i = 0; i < 100000; i++) {\n        counter++;  // 임계 영역 (비원자적 연산)\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    \n    pthread_create(&t1, NULL, increment, NULL);\n    pthread_create(&t2, NULL, increment, NULL);\n    \n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    \n    printf(\"Expected: 200000\\n\");\n    printf(\"Actual: %d\\n\", counter);  // 매번 다른 결과!\n    \n    return 0;\n}\n\n실행 결과 예시:\n  실행 1: 143256\n  실행 2: 167892\n  실행 3: 152341\n  (매번 다름 = Race Condition!)"
            },
            {
                "type": "code",
                "title": "실무 활용",
                "language": "java",
                "code": "// ========================================\n//   Java에서 Race Condition 재현 및 해결\n// ========================================\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class RaceConditionDemo {\n    \n    // 문제 상황: Race Condition 발생\n    static int unsafeCounter = 0;\n    \n    // 해결책 1: synchronized 사용\n    static int syncCounter = 0;\n    static final Object lock = new Object();\n    \n    // 해결책 2: AtomicInteger 사용\n    static AtomicInteger atomicCounter = new AtomicInteger(0);\n    \n    public static void main(String[] args) throws InterruptedException {\n        int numThreads = 10;\n        int iterations = 100000;\n        \n        // 1. 안전하지 않은 카운터 테스트\n        Thread[] threads1 = new Thread[numThreads];\n        for (int i = 0; i < numThreads; i++) {\n            threads1[i] = new Thread(() -> {\n                for (int j = 0; j < iterations; j++) {\n                    unsafeCounter++;  // Race Condition!\n                }\n            });\n            threads1[i].start();\n        }\n        for (Thread t : threads1) t.join();\n        \n        // 2. synchronized 카운터 테스트\n        Thread[] threads2 = new Thread[numThreads];\n        for (int i = 0; i < numThreads; i++) {\n            threads2[i] = new Thread(() -> {\n                for (int j = 0; j < iterations; j++) {\n                    synchronized (lock) {\n                        syncCounter++;  // 안전!\n                    }\n                }\n            });\n            threads2[i].start();\n        }\n        for (Thread t : threads2) t.join();\n        \n        // 3. AtomicInteger 테스트\n        Thread[] threads3 = new Thread[numThreads];\n        for (int i = 0; i < numThreads; i++) {\n            threads3[i] = new Thread(() -> {\n                for (int j = 0; j < iterations; j++) {\n                    atomicCounter.incrementAndGet();  // 안전!\n                }\n            });\n            threads3[i].start();\n        }\n        for (Thread t : threads3) t.join();\n        \n        int expected = numThreads * iterations;\n        System.out.println(\"Expected: \" + expected);\n        System.out.println(\"Unsafe: \" + unsafeCounter + \" (Race Condition!)\");\n        System.out.println(\"Synchronized: \" + syncCounter);\n        System.out.println(\"Atomic: \" + atomicCounter.get());\n    }\n}\n\n// ========================================\n//   Spring에서의 Race Condition 방지\n// ========================================\n\n/*\n@Service\npublic class AccountService {\n    \n    @Autowired\n    private AccountRepository accountRepository;\n    \n    // 문제: Race Condition 발생 가능\n    public void transferUnsafe(Long fromId, Long toId, BigDecimal amount) {\n        Account from = accountRepository.findById(fromId).get();\n        Account to = accountRepository.findById(toId).get();\n        \n        from.setBalance(from.getBalance().subtract(amount));\n        to.setBalance(to.getBalance().add(amount));\n        \n        accountRepository.save(from);\n        accountRepository.save(to);\n    }\n    \n    // 해결책: @Transactional + 비관적 잠금\n    @Transactional\n    public void transferSafe(Long fromId, Long toId, BigDecimal amount) {\n        Account from = accountRepository.findByIdWithLock(fromId);  // SELECT FOR UPDATE\n        Account to = accountRepository.findByIdWithLock(toId);\n        \n        if (from.getBalance().compareTo(amount) < 0) {\n            throw new InsufficientBalanceException();\n        }\n        \n        from.setBalance(from.getBalance().subtract(amount));\n        to.setBalance(to.getBalance().add(amount));\n    }\n}\n*/"
            },
            {
                "type": "tip",
                "title": "체크리스트 & 면접",
                "content": "## Race Condition 체크리스트\n\n### 발생 조건 (모두 충족 시 발생)\n- [ ] 공유 자원 존재\n- [ ] 둘 이상의 스레드가 동시 접근\n- [ ] 최소 하나의 스레드가 쓰기 작업\n- [ ] 동기화 메커니즘 부재\n\n### 해결 방법\n| 방법 | 장점 | 단점 |\n|------|------|------|\n| synchronized | 간단함 | 성능 저하 |\n| Lock (ReentrantLock) | 세밀한 제어 | 복잡함 |\n| Atomic 클래스 | 고성능 | 단순 연산만 |\n| 불변 객체 | 안전함 | 메모리 사용 |\n| ThreadLocal | 스레드별 독립 | 공유 불가 |\n\n## 면접 예상 질문\n\n**Q1: Race Condition이란?**\n> 여러 스레드가 공유 자원에 동시 접근하여 실행 순서에 따라 결과가 달라지는 상황입니다. 비원자적 연산이 원인입니다.\n\n**Q2: 어떻게 방지하나요?**\n> 1) 뮤텍스/락으로 임계 영역 보호\n> 2) Atomic 연산 사용\n> 3) 불변 객체 사용\n> 4) ThreadLocal 사용\n\n**Q3: Check-Then-Act 패턴의 문제점은?**\n> 조건 확인과 행동 사이에 다른 스레드가 개입할 수 있어 Race Condition이 발생합니다. 원자적으로 처리해야 합니다.\n\n**Q4: 실무에서 겪은 Race Condition 경험은?**\n> 동시 주문 시 재고 차감 문제, 계좌 이체 시 잔액 불일치 등을 예로 들고, DB 락이나 분산 락으로 해결했다고 답변하세요."
            }
        ]
    }

def get_mutex_content():
    return {
        "id": "03_동기화/mutex",
        "title": "Mutex",
        "category": "os",
        "subCategory": "03_동기화",
        "language": "C",
        "description": "뮤텍스(Mutual Exclusion)를 통해 한 번에 하나의 스레드만 임계 영역에 접근하도록 하는 방법을 학습합니다.",
        "isPlaceholder": False,
        "sections": [
            {
                "type": "concept",
                "title": "뮤텍스 완전 정복",
                "content": "# Mutex (뮤텍스)\n\n## 한 줄 요약\n**한 번에 하나의 스레드만 임계 영역에 접근하도록 보장하는 잠금 장치**\n\n## 생활 비유: 화장실 열쇠\n```\n[1인용 화장실]\n\n   열쇠 = Mutex (하나만 존재)\n   \n   상황 1: A가 열쇠를 가지고 들어감\n   +--------+\n   | 사용중 |  <- A가 열쇠로 잠금 (lock)\n   +--------+\n   B, C: \"대기...\" (blocked)\n\n   상황 2: A가 나오면서 열쇠 반납\n   +--------+\n   |  비어  |  <- A가 열쇠 반납 (unlock)\n   +--------+\n   B: 열쇠 획득! 들어감\n   C: 계속 대기...\n```\n\n## 핵심 특징\n```\n[Mutex의 3가지 특성]\n\n1. 상호 배제 (Mutual Exclusion)\n   - 한 번에 하나의 스레드만 임계 영역 진입\n\n2. 소유권 (Ownership)\n   - 잠근 스레드만 해제 가능\n   - 다른 스레드가 unlock 불가!\n\n3. Blocking\n   - 락 획득 실패 시 대기 (sleep)\n   - CPU 낭비 없음\n```\n\n## 핵심 개념\n| 용어 | 설명 |\n|------|------|\n| lock() | 뮤텍스 획득 (실패 시 대기) |\n| unlock() | 뮤텍스 해제 |\n| tryLock() | 획득 시도 (실패 시 즉시 반환) |\n| 임계 영역 | 뮤텍스로 보호되는 코드 영역 |"
            },
            {
                "type": "code",
                "title": "동작 원리",
                "language": "text",
                "code": "========================================\n    Mutex 동작 과정\n========================================\n\n[시나리오] Thread A, B가 counter++ 수행\n\n  Mutex 상태: UNLOCKED\n  counter = 0\n\n  Thread A                    Thread B\n  ---------                   ---------\n  mutex.lock()                \n  (Mutex: LOCKED by A)        mutex.lock()\n                              (Blocked! 대기...)\n  counter++  (1)              \n  mutex.unlock()              \n  (Mutex: UNLOCKED)           (깨어남!)\n                              (Mutex: LOCKED by B)\n                              counter++  (2)\n                              mutex.unlock()\n                              (Mutex: UNLOCKED)\n\n[결과] counter = 2  (정확!)\n\n\n========================================\n    C 코드: pthread_mutex 사용\n========================================\n\n#include <pthread.h>\n#include <stdio.h>\n\nint counter = 0;\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\nvoid* increment(void* arg) {\n    for (int i = 0; i < 100000; i++) {\n        pthread_mutex_lock(&mutex);    // 잠금\n        counter++;                      // 임계 영역\n        pthread_mutex_unlock(&mutex);  // 해제\n    }\n    return NULL;\n}\n\nint main() {\n    pthread_t t1, t2;\n    \n    pthread_create(&t1, NULL, increment, NULL);\n    pthread_create(&t2, NULL, increment, NULL);\n    \n    pthread_join(t1, NULL);\n    pthread_join(t2, NULL);\n    \n    printf(\"Counter: %d\\n\", counter);  // 항상 200000!\n    \n    pthread_mutex_destroy(&mutex);\n    return 0;\n}\n\n\n========================================\n    Mutex vs Spinlock 비교\n========================================\n\n  Mutex (Sleep Lock)           Spinlock (Busy Wait)\n  ------------------           -------------------\n  lock 실패 -> Sleep           lock 실패 -> Loop\n  OS 스케줄러 개입              CPU 계속 사용\n  컨텍스트 스위칭 발생          컨텍스트 스위칭 없음\n  긴 대기 시간에 유리           짧은 대기 시간에 유리\n  \n  while (!acquired) {          while (!acquired) {\n      sleep();  // CPU 양보         // Busy waiting!\n  }                            }"
            },
            {
                "type": "code",
                "title": "실무 활용",
                "language": "java",
                "code": "// ========================================\n//   Java에서 Mutex 구현 방법들\n// ========================================\n\nimport java.util.concurrent.locks.*;\n\npublic class MutexDemo {\n    \n    private int counter = 0;\n    \n    // 방법 1: synchronized (내장 모니터 락)\n    public synchronized void incrementSync() {\n        counter++;\n    }\n    \n    // 방법 2: synchronized 블록\n    private final Object lock = new Object();\n    public void incrementSyncBlock() {\n        synchronized (lock) {\n            counter++;\n        }\n    }\n    \n    // 방법 3: ReentrantLock (명시적 락)\n    private final ReentrantLock reentrantLock = new ReentrantLock();\n    public void incrementReentrant() {\n        reentrantLock.lock();\n        try {\n            counter++;\n        } finally {\n            reentrantLock.unlock();  // 반드시 finally에서!\n        }\n    }\n    \n    // 방법 4: tryLock (타임아웃)\n    public boolean incrementWithTimeout() throws InterruptedException {\n        if (reentrantLock.tryLock(1, java.util.concurrent.TimeUnit.SECONDS)) {\n            try {\n                counter++;\n                return true;\n            } finally {\n                reentrantLock.unlock();\n            }\n        }\n        return false;  // 락 획득 실패\n    }\n}\n\n// ========================================\n//   Spring에서의 동시성 제어\n// ========================================\n\n/*\n@Service\npublic class InventoryService {\n    \n    private final ReentrantLock lock = new ReentrantLock();\n    \n    // 재고 차감 (동시성 안전)\n    public boolean decreaseStock(Long productId, int quantity) {\n        lock.lock();\n        try {\n            Product product = productRepository.findById(productId)\n                .orElseThrow();\n            \n            if (product.getStock() < quantity) {\n                return false;  // 재고 부족\n            }\n            \n            product.setStock(product.getStock() - quantity);\n            productRepository.save(product);\n            return true;\n            \n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    // 더 나은 방법: DB 레벨 락\n    @Transactional\n    public boolean decreaseStockWithDBLock(Long productId, int quantity) {\n        // 비관적 락 사용\n        Product product = productRepository.findByIdForUpdate(productId);\n        \n        if (product.getStock() < quantity) {\n            return false;\n        }\n        \n        product.decreaseStock(quantity);\n        return true;\n    }\n}\n\n@Repository\npublic interface ProductRepository extends JpaRepository<Product, Long> {\n    \n    @Lock(LockModeType.PESSIMISTIC_WRITE)\n    @Query(\"SELECT p FROM Product p WHERE p.id = :id\")\n    Product findByIdForUpdate(@Param(\"id\") Long id);\n}\n*/"
            },
            {
                "type": "tip",
                "title": "체크리스트 & 면접",
                "content": "## Mutex 체크리스트\n\n### 사용 시 주의사항\n- [ ] lock() 후 반드시 unlock() 호출 (finally 사용)\n- [ ] 같은 스레드가 lock/unlock 수행\n- [ ] 데드락 방지 (락 순서 일관성)\n- [ ] 락 범위 최소화 (성능 고려)\n\n### Mutex vs 다른 동기화 도구\n| 도구 | 접근 가능 수 | 소유권 | 용도 |\n|------|-------------|--------|------|\n| Mutex | 1개 | 있음 | 상호 배제 |\n| Semaphore | N개 | 없음 | 리소스 풀 제한 |\n| Spinlock | 1개 | 있음 | 짧은 임계 영역 |\n\n## 면접 예상 질문\n\n**Q1: Mutex란 무엇인가요?**\n> 한 번에 하나의 스레드만 임계 영역에 접근하도록 보장하는 동기화 도구입니다. lock/unlock으로 사용하며, 소유권 개념이 있어 잠근 스레드만 해제할 수 있습니다.\n\n**Q2: Mutex와 Semaphore의 차이는?**\n> Mutex는 이진 잠금(0 또는 1)이고 소유권이 있습니다. Semaphore는 N개까지 허용 가능하고 소유권이 없어 다른 스레드가 signal 가능합니다.\n\n**Q3: synchronized와 ReentrantLock 차이는?**\n> ReentrantLock은 tryLock(), 타임아웃, 공정성 설정, Condition 분리 등 더 세밀한 제어가 가능합니다. synchronized는 간단하지만 유연성이 떨어집니다.\n\n**Q4: 데드락을 어떻게 방지하나요?**\n> 1) 락 획득 순서 일관성 유지\n> 2) tryLock() 타임아웃 사용\n> 3) 락 범위 최소화\n> 4) 단일 락 사용 고려"
            }
        ]
    }

def get_semaphore_content():
    return {
        "id": "03_동기화/semaphore",
        "title": "Semaphore",
        "category": "os",
        "subCategory": "03_동기화",
        "language": "C",
        "description": "세마포어를 통해 N개의 스레드까지 동시에 접근을 허용하는 동기화 메커니즘을 학습합니다.",
        "isPlaceholder": False,
        "sections": [
            {
                "type": "concept",
                "title": "세마포어 완전 정복",
                "content": "# Semaphore (세마포어)\n\n## 한 줄 요약\n**N개의 스레드까지 동시에 공유 자원에 접근할 수 있도록 허용하는 동기화 도구**\n\n## 생활 비유: 주차장 관리 시스템\n```\n[주차장 = 세마포어(N=3)]\n\n주차 가능 대수: 3대\n현재 주차: 0대\n\n  차량 A 진입 -> 카운터: 3->2 (P 연산)\n  차량 B 진입 -> 카운터: 2->1\n  차량 C 진입 -> 카운터: 1->0\n  \n  차량 D 진입 시도 -> 만차! 대기...\n  \n  차량 A 출차 -> 카운터: 0->1 (V 연산)\n  차량 D 진입 -> 카운터: 1->0\n\n세마포어 = 주차 가능 대수를 관리하는 시스템!\n```\n\n## 세마포어 종류\n```\n1. 이진 세마포어 (Binary Semaphore)\n   - 값: 0 또는 1\n   - Mutex와 유사 (하지만 소유권 없음)\n\n2. 카운팅 세마포어 (Counting Semaphore)\n   - 값: 0 ~ N\n   - 리소스 풀 관리에 사용\n```\n\n## 핵심 연산\n| 연산 | 다른 이름 | 동작 |\n|------|----------|------|\n| P (Wait) | acquire, down | 값 감소, 0이면 대기 |\n| V (Signal) | release, up | 값 증가, 대기 스레드 깨움 |"
            },
            {
                "type": "code",
                "title": "동작 원리",
                "language": "text",
                "code": "========================================\n    Semaphore 연산 상세\n========================================\n\n[P 연산 (Wait/Acquire)]\n\nP(S) {\n    while (S <= 0) {\n        // 대기 (block)\n    }\n    S = S - 1;  // 리소스 획득\n}\n\n\n[V 연산 (Signal/Release)]\n\nV(S) {\n    S = S + 1;  // 리소스 반환\n    // 대기 중인 스레드가 있다면 깨움\n}\n\n\n========================================\n    시나리오: 커넥션 풀 (N=3)\n========================================\n\n세마포어 값: 3 (최대 동시 접속 3)\n\n시간 -->  T1    T2    T3    T4    T5    T6\n--------------------------------------------------------\nThread A  P(3->2)                 V(2->3)\nThread B        P(2->1)                 V(3->3)\nThread C              P(1->0)           V(3->3)\nThread D                    P(대기)...(0->?)\n\nThread D는 누군가 V()를 호출할 때까지 대기!\n\n\n========================================\n    C 코드: POSIX Semaphore\n========================================\n\n#include <semaphore.h>\n#include <pthread.h>\n#include <stdio.h>\n\n#define MAX_CONCURRENT 3\n\nsem_t semaphore;\nint active_count = 0;\n\nvoid* worker(void* arg) {\n    int id = *(int*)arg;\n    \n    sem_wait(&semaphore);  // P 연산\n    \n    // 임계 영역 시작\n    active_count++;\n    printf(\"Thread %d 진입 (현재 %d개 실행 중)\\n\", id, active_count);\n    sleep(1);  // 작업 수행\n    printf(\"Thread %d 종료\\n\", id);\n    active_count--;\n    // 임계 영역 끝\n    \n    sem_post(&semaphore);  // V 연산\n    \n    return NULL;\n}\n\nint main() {\n    pthread_t threads[10];\n    int ids[10];\n    \n    sem_init(&semaphore, 0, MAX_CONCURRENT);  // 초기값 3\n    \n    for (int i = 0; i < 10; i++) {\n        ids[i] = i;\n        pthread_create(&threads[i], NULL, worker, &ids[i]);\n    }\n    \n    for (int i = 0; i < 10; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    \n    sem_destroy(&semaphore);\n    return 0;\n}\n\n출력:\n  Thread 0 진입 (현재 1개 실행 중)\n  Thread 1 진입 (현재 2개 실행 중)\n  Thread 2 진입 (현재 3개 실행 중)\n  // Thread 3~9는 대기...\n  Thread 0 종료\n  Thread 3 진입 (현재 3개 실행 중)\n  ..."
            },
            {
                "type": "code",
                "title": "실무 활용",
                "language": "java",
                "code": "// ========================================\n//   Java Semaphore 사용법\n// ========================================\n\nimport java.util.concurrent.Semaphore;\n\npublic class SemaphoreDemo {\n    \n    // 동시 접근 3개 제한\n    private final Semaphore semaphore = new Semaphore(3);\n    \n    public void accessResource(int threadId) {\n        try {\n            System.out.println(\"Thread \" + threadId + \": 접근 시도...\");\n            \n            semaphore.acquire();  // P 연산\n            \n            try {\n                System.out.println(\"Thread \" + threadId + \": 접근 성공! \" +\n                    \"(가용: \" + semaphore.availablePermits() + \")\");\n                Thread.sleep(2000);  // 작업 수행\n            } finally {\n                semaphore.release();  // V 연산 (반드시!)\n                System.out.println(\"Thread \" + threadId + \": 반환\");\n            }\n            \n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n    \n    public static void main(String[] args) {\n        SemaphoreDemo demo = new SemaphoreDemo();\n        \n        // 10개 스레드 생성 (3개만 동시 실행)\n        for (int i = 0; i < 10; i++) {\n            final int id = i;\n            new Thread(() -> demo.accessResource(id)).start();\n        }\n    }\n}\n\n// ========================================\n//   실무 예제: DB 커넥션 풀\n// ========================================\n\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class ConnectionPool {\n    \n    private final Semaphore semaphore;\n    private final BlockingQueue<Connection> pool;\n    \n    public ConnectionPool(int poolSize) {\n        this.semaphore = new Semaphore(poolSize);\n        this.pool = new LinkedBlockingQueue<>();\n        \n        // 커넥션 초기화\n        for (int i = 0; i < poolSize; i++) {\n            pool.add(new Connection(\"Connection-\" + i));\n        }\n    }\n    \n    public Connection getConnection() throws InterruptedException {\n        semaphore.acquire();  // 풀에 여유가 있을 때만 통과\n        return pool.poll();\n    }\n    \n    public void releaseConnection(Connection conn) {\n        pool.offer(conn);\n        semaphore.release();  // 다음 대기자 허용\n    }\n    \n    // 타임아웃 버전\n    public Connection getConnection(long timeout, java.util.concurrent.TimeUnit unit) \n            throws InterruptedException {\n        if (semaphore.tryAcquire(timeout, unit)) {\n            return pool.poll();\n        }\n        throw new RuntimeException(\"Connection timeout\");\n    }\n}\n\nclass Connection {\n    private final String name;\n    public Connection(String name) { this.name = name; }\n}\n\n// ========================================\n//   Spring Rate Limiter 예제\n// ========================================\n\n/*\n@Component\npublic class RateLimiter {\n    \n    // 초당 10개 요청 제한\n    private final Semaphore semaphore = new Semaphore(10);\n    \n    @Scheduled(fixedRate = 1000)\n    public void resetPermits() {\n        int currentPermits = semaphore.availablePermits();\n        if (currentPermits < 10) {\n            semaphore.release(10 - currentPermits);\n        }\n    }\n    \n    public boolean tryAcquire() {\n        return semaphore.tryAcquire();\n    }\n}\n\n@RestController\npublic class ApiController {\n    \n    @Autowired\n    private RateLimiter rateLimiter;\n    \n    @GetMapping(\"/api/data\")\n    public ResponseEntity<?> getData() {\n        if (!rateLimiter.tryAcquire()) {\n            return ResponseEntity.status(429).body(\"Too Many Requests\");\n        }\n        return ResponseEntity.ok(\"Data\");\n    }\n}\n*/"
            },
            {
                "type": "tip",
                "title": "체크리스트 & 면접",
                "content": "## Semaphore 체크리스트\n\n### 사용 시나리오\n- [ ] 동시 접근 수 제한 (커넥션 풀, 스레드 풀)\n- [ ] Rate Limiting (API 호출 제한)\n- [ ] Producer-Consumer 문제\n- [ ] Reader-Writer 문제\n\n### Mutex vs Semaphore 비교\n| 특성 | Mutex | Semaphore |\n|------|-------|----------|\n| 동시 접근 | 1개 | N개 |\n| 소유권 | 있음 | 없음 |\n| unlock 주체 | lock한 스레드만 | 누구나 가능 |\n| 용도 | 상호 배제 | 리소스 풀 관리 |\n\n## 면접 예상 질문\n\n**Q1: Semaphore란 무엇인가요?**\n> N개의 스레드까지 동시에 공유 자원에 접근하도록 허용하는 동기화 도구입니다. P(wait)와 V(signal) 연산으로 제어합니다.\n\n**Q2: Mutex와 Semaphore의 차이는?**\n> Mutex는 이진(0/1)이고 소유권이 있어 잠근 스레드만 해제 가능합니다. Semaphore는 N개 허용하고 소유권이 없어 누구나 signal 가능합니다.\n\n**Q3: 이진 세마포어와 Mutex는 같은가요?**\n> 기능적으로 유사하지만 다릅니다. Mutex는 소유권이 있어 잠근 스레드만 해제 가능하지만, 이진 세마포어는 소유권이 없어 다른 스레드가 signal 가능합니다.\n\n**Q4: 실무에서 세마포어 사용 예시는?**\n> 1) DB 커넥션 풀 관리\n> 2) API Rate Limiting\n> 3) 동시 파일 처리 수 제한\n> 4) 동시 다운로드 수 제한"
            }
        ]
    }

def get_monitor_content():
    return {
        "id": "03_동기화/monitor",
        "title": "Monitor",
        "category": "os",
        "subCategory": "03_동기화",
        "language": "Java",
        "description": "모니터 개념과 Java의 synchronized, wait(), notify()를 통한 동기화 메커니즘을 학습합니다.",
        "isPlaceholder": False,
        "sections": [
            {
                "type": "concept",
                "title": "모니터 완전 정복",
                "content": "# Monitor (모니터)\n\n## 한 줄 요약\n**상호 배제와 조건 동기화를 하나로 캡슐화한 고수준 동기화 구조 (Java synchronized의 기반)**\n\n## 생활 비유: VIP 대기실 시스템\n```\n[VIP 라운지 = 모니터]\n\n+------------------------------------------+\n|            VIP 라운지                      |\n|  (한 번에 1명만 입장 = 상호 배제)           |\n|                                          |\n|  [조건 대기석]                             |\n|   - 음식 준비될 때까지 대기               |\n|   - 음식 준비되면 알림 받음 (condition)   |\n+------------------------------------------+\n\n  입장 대기줄 (Entry Queue)\n  [손님A] [손님B] [손님C]\n\n모니터 = 입장 관리 + 내부 조건 대기 관리\n```\n\n## 모니터의 구성 요소\n```\n+----------------------------------+\n|           Monitor                |\n+----------------------------------+\n|  - 공유 데이터                    |\n|  - 뮤텍스 락 (상호 배제)          |\n|  - 조건 변수 (Condition Variable) |\n+----------------------------------+\n|  + enter()   // 락 획득          |\n|  + leave()   // 락 해제          |\n|  + wait()    // 조건 대기         |\n|  + notify()  // 대기자 깨움       |\n+----------------------------------+\n```\n\n## 핵심 개념\n| 용어 | Java 대응 | 설명 |\n|------|-----------|------|\n| Monitor Lock | synchronized | 상호 배제 보장 |\n| Entry Queue | - | 락 대기 스레드 큐 |\n| Wait Set | wait() 호출 스레드 | 조건 대기 스레드 집합 |\n| Condition | wait/notify | 조건 동기화 |"
            },
            {
                "type": "code",
                "title": "동작 원리",
                "language": "text",
                "code": "========================================\n    Monitor 동작 메커니즘\n========================================\n\n[모니터 구조]\n\n              +-- 락 대기 (Entry Queue)\n              |   [Thread B] [Thread C]\n              v\n  +---------------------------+\n  |        Monitor            |\n  |  +---------------------+  |\n  |  |   Mutex Lock        |<---- Thread A (Owner)\n  |  +---------------------+  |\n  |                           |\n  |  +---------------------+  |\n  |  |   조건 대기          |  |\n  |  |   (Wait Set)        |  |\n  |  |   [Thread D]        |  |\n  |  |   [Thread E]        |  |\n  |  +---------------------+  |\n  +---------------------------+\n\n\n========================================\n    wait() / notify() 동작 과정\n========================================\n\n[시나리오: Producer-Consumer]\n\n  Consumer                    Producer\n  ---------                   ---------\n  synchronized(lock) {        \n    while (buffer.isEmpty())  \n      lock.wait();            // 락 해제 + Wait Set 이동\n                              synchronized(lock) {\n                                buffer.add(item);\n                                lock.notify();  // Wait Set에서 1개 깨움\n                              }  // 락 해제\n    // 깨어남! 락 재획득 시도\n    item = buffer.remove();\n  }\n\n\n========================================\n    상태 전이 다이어그램\n========================================\n\n                      notify()\n  [Entry Queue] <---------------- [Wait Set]\n        |                              ^\n        | 락 획득                       | wait()\n        v                              |\n  [Running] ------------------------->+\n        |           조건 불만족\n        | 작업 완료\n        v\n  [Exit] (락 해제)\n\n\n========================================\n    Java Monitor 내부 구조\n========================================\n\nclass Object {\n    // 모든 객체가 모니터를 가짐\n    private transient int _mark;     // 락 상태\n    private transient Thread _owner; // 락 소유자\n    private transient Object[] _waitSet; // 대기 스레드\n    \n    public final void wait() { ... }\n    public final void notify() { ... }\n    public final void notifyAll() { ... }\n}\n\n// 모든 Java 객체는 잠재적 모니터!\nsynchronized(anyObject) {\n    // anyObject의 모니터 락 획득\n    anyObject.wait();    // 조건 대기\n    anyObject.notify();  // 대기자 깨움\n}"
            },
            {
                "type": "code",
                "title": "실무 활용",
                "language": "java",
                "code": "// ========================================\n//   Java Monitor 패턴: Producer-Consumer\n// ========================================\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class BoundedBuffer<T> {\n    \n    private final Queue<T> buffer = new LinkedList<>();\n    private final int capacity;\n    \n    public BoundedBuffer(int capacity) {\n        this.capacity = capacity;\n    }\n    \n    // Producer: 버퍼에 데이터 추가\n    public synchronized void put(T item) throws InterruptedException {\n        // 버퍼가 가득 찼으면 대기\n        while (buffer.size() == capacity) {\n            System.out.println(Thread.currentThread().getName() + \n                \": 버퍼 가득참, 대기...\");\n            wait();  // 락 해제 + Wait Set 이동\n        }\n        \n        buffer.add(item);\n        System.out.println(Thread.currentThread().getName() + \n            \": 추가 \" + item + \" (size: \" + buffer.size() + \")\");\n        \n        notifyAll();  // Consumer 깨움\n    }\n    \n    // Consumer: 버퍼에서 데이터 추출\n    public synchronized T take() throws InterruptedException {\n        // 버퍼가 비었으면 대기\n        while (buffer.isEmpty()) {\n            System.out.println(Thread.currentThread().getName() + \n                \": 버퍼 비어있음, 대기...\");\n            wait();  // 락 해제 + Wait Set 이동\n        }\n        \n        T item = buffer.poll();\n        System.out.println(Thread.currentThread().getName() + \n            \": 추출 \" + item + \" (size: \" + buffer.size() + \")\");\n        \n        notifyAll();  // Producer 깨움\n        return item;\n    }\n}\n\n// ========================================\n//   ReentrantLock + Condition (더 세밀한 제어)\n// ========================================\n\nimport java.util.concurrent.locks.*;\n\npublic class BoundedBufferWithCondition<T> {\n    \n    private final Queue<T> buffer = new LinkedList<>();\n    private final int capacity;\n    \n    private final ReentrantLock lock = new ReentrantLock();\n    private final Condition notFull = lock.newCondition();   // 생산자용\n    private final Condition notEmpty = lock.newCondition();  // 소비자용\n    \n    public BoundedBufferWithCondition(int capacity) {\n        this.capacity = capacity;\n    }\n    \n    public void put(T item) throws InterruptedException {\n        lock.lock();\n        try {\n            while (buffer.size() == capacity) {\n                notFull.await();  // 생산자만 대기\n            }\n            buffer.add(item);\n            notEmpty.signal();    // 소비자만 깨움 (더 효율적!)\n        } finally {\n            lock.unlock();\n        }\n    }\n    \n    public T take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (buffer.isEmpty()) {\n                notEmpty.await();  // 소비자만 대기\n            }\n            T item = buffer.poll();\n            notFull.signal();      // 생산자만 깨움\n            return item;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n// ========================================\n//   Spring에서의 동시성 제어\n// ========================================\n\n/*\n@Service\npublic class OrderQueueService {\n    \n    private final Queue<Order> orderQueue = new LinkedList<>();\n    private final int MAX_QUEUE_SIZE = 100;\n    \n    // 주문 접수\n    public synchronized void submitOrder(Order order) \n            throws InterruptedException {\n        while (orderQueue.size() >= MAX_QUEUE_SIZE) {\n            wait();  // 큐가 가득차면 대기\n        }\n        orderQueue.add(order);\n        notifyAll();  // 처리 스레드 깨움\n    }\n    \n    // 주문 처리\n    public synchronized Order processOrder() \n            throws InterruptedException {\n        while (orderQueue.isEmpty()) {\n            wait();  // 큐가 비어있으면 대기\n        }\n        Order order = orderQueue.poll();\n        notifyAll();  // 접수 스레드 깨움\n        return order;\n    }\n}\n*/"
            },
            {
                "type": "tip",
                "title": "체크리스트 & 면접",
                "content": "## Monitor 체크리스트\n\n### wait/notify 사용 규칙\n- [ ] synchronized 블록 안에서만 호출\n- [ ] wait()는 반드시 while 루프 안에서 (Spurious Wakeup 대비)\n- [ ] notify()보다 notifyAll() 권장 (안전함)\n- [ ] Condition 객체로 분리하면 더 효율적\n\n### 모니터 vs 세마포어\n| 특성 | Monitor | Semaphore |\n|------|---------|----------|\n| 추상화 수준 | 고수준 | 저수준 |\n| 상호 배제 | 자동 | 수동 |\n| 조건 동기화 | 내장 (wait/notify) | 별도 구현 |\n| 사용 편의성 | 높음 | 낮음 |\n\n## 면접 예상 질문\n\n**Q1: Monitor란 무엇인가요?**\n> 상호 배제와 조건 동기화를 캡슐화한 고수준 동기화 구조입니다. Java의 synchronized, wait(), notify()가 모니터 기반입니다.\n\n**Q2: wait()와 sleep()의 차이는?**\n> wait()는 모니터 락을 해제하고 대기하지만, sleep()은 락을 유지한 채 대기합니다. wait()는 notify()로, sleep()은 시간 경과로 깨어납니다.\n\n**Q3: notify() vs notifyAll() 차이는?**\n> notify()는 Wait Set에서 1개만 깨우고, notifyAll()은 전부 깨웁니다. notifyAll()이 안전하지만 성능은 notify()가 좋습니다.\n\n**Q4: 왜 wait()는 while 안에서 호출해야 하나요?**\n> Spurious Wakeup(거짓 깨어남) 때문입니다. notify 없이도 깨어날 수 있어서 조건을 다시 확인해야 합니다. if문 사용 시 조건 불만족 상태로 진행될 수 있습니다."
            }
        ]
    }

def get_deadlock_content():
    return {
        "id": "03_동기화/deadlock",
        "title": "Deadlock",
        "category": "os",
        "subCategory": "03_동기화",
        "language": "Java",
        "description": "데드락(교착 상태)의 발생 조건과 예방, 회피, 탐지 및 회복 전략을 학습합니다.",
        "isPlaceholder": False,
        "sections": [
            {
                "type": "concept",
                "title": "데드락 완전 정복",
                "content": "# Deadlock (데드락, 교착 상태)\n\n## 한 줄 요약\n**두 개 이상의 스레드가 서로가 가진 자원을 기다리며 영원히 대기하는 상태**\n\n## 생활 비유: 좁은 골목 교착\n```\n[일방통행 좁은 골목]\n\n     차량 A -->        <-- 차량 B\n         |     |  |     |\n         +-----|--|-----+\n               |  |\n           교착 상태!\n\n- A는 B가 비켜줘야 전진 가능\n- B는 A가 비켜줘야 전진 가능\n- 둘 다 비키지 않으면 영원히 멈춤!\n```\n\n## 데드락 4대 필요조건 (모두 충족 시 발생)\n```\n1. 상호 배제 (Mutual Exclusion)\n   - 자원을 한 번에 하나의 스레드만 사용\n\n2. 점유와 대기 (Hold and Wait)\n   - 자원을 보유한 채 다른 자원을 기다림\n\n3. 비선점 (No Preemption)\n   - 다른 스레드의 자원을 강제로 뺏을 수 없음\n\n4. 순환 대기 (Circular Wait)\n   - 스레드들이 원형으로 서로의 자원을 대기\n   \n   T1 --wait--> R2 (held by T2)\n   ^                    |\n   |                    v\n   R1 (held by T1) <--wait-- T2\n```\n\n## 핵심 개념\n| 전략 | 설명 |\n|------|------|\n| Prevention | 4대 조건 중 하나 제거 |\n| Avoidance | 안전 상태 유지 (은행원 알고리즘) |\n| Detection | 발생 후 탐지 (자원 할당 그래프) |\n| Recovery | 프로세스 종료 또는 자원 선점 |"
            },
            {
                "type": "code",
                "title": "동작 원리",
                "language": "text",
                "code": "========================================\n    Deadlock 발생 시나리오\n========================================\n\n[자원]\n- Lock A (계좌 A 잠금)\n- Lock B (계좌 B 잠금)\n\n[시나리오: 계좌 이체]\n\n  Thread 1 (A->B 이체)       Thread 2 (B->A 이체)\n  ---------------------       ---------------------\n  lock(A)  // A 획득         \n                              lock(B)  // B 획득\n  lock(B)  // B 대기...       \n                              lock(A)  // A 대기...\n  \n  --> 교착 상태! (영원히 대기)\n\n\n========================================\n    자원 할당 그래프 (RAG)\n========================================\n\n[정상 상태]\n\n  T1 -----> R1 -----> T2\n  (요청)    (할당)\n\n[데드락 상태] - 사이클 존재!\n\n  T1 -----> R1 -----> T2\n  ^                    |\n  |                    v\n  +---- R2 <----------+\n  (T1이 R2 보유)  (T2가 R2 요청)\n\n사이클 = 데드락 (단일 인스턴스 자원일 때)\n\n\n========================================\n    은행원 알고리즘 (Banker's Algorithm)\n========================================\n\n[안전 상태 검사]\n\n총 자원: 10\n현재 할당:\n  P1: 5 (최대 7 필요)\n  P2: 2 (최대 5 필요)\n  P3: 2 (최대 3 필요)\n\n가용 자원: 10 - 5 - 2 - 2 = 1\n\n안전 순서 찾기:\n1. P3: 1 >= (3-2=1) -> P3 완료 -> 가용: 1+2=3\n2. P2: 3 >= (5-2=3) -> P2 완료 -> 가용: 3+2=5\n3. P1: 5 >= (7-5=2) -> P1 완료 -> 가용: 5+5=10\n\n안전 순서: <P3, P2, P1> 존재 -> 안전 상태!\n\n\n========================================\n    데드락 탐지 알고리즘\n========================================\n\n1. 모든 프로세스를 '미완료'로 표시\n2. 현재 가용 자원으로 실행 가능한 프로세스 찾기\n3. 찾으면:\n   - 해당 프로세스 '완료'로 표시\n   - 보유 자원을 가용 자원에 추가\n   - 2번으로 돌아감\n4. 못 찾으면:\n   - 남은 '미완료' 프로세스들 = 데드락!"
            },
            {
                "type": "code",
                "title": "실무 활용",
                "language": "java",
                "code": "// ========================================\n//   Java에서 Deadlock 재현\n// ========================================\n\npublic class DeadlockDemo {\n    \n    private static final Object lockA = new Object();\n    private static final Object lockB = new Object();\n    \n    public static void main(String[] args) {\n        \n        // Thread 1: A -> B 순서로 락 획득\n        Thread t1 = new Thread(() -> {\n            synchronized (lockA) {\n                System.out.println(\"Thread 1: lockA 획득\");\n                try { Thread.sleep(100); } catch (Exception e) {}\n                \n                System.out.println(\"Thread 1: lockB 대기...\");\n                synchronized (lockB) {\n                    System.out.println(\"Thread 1: lockB 획득\");\n                }\n            }\n        }, \"Thread-1\");\n        \n        // Thread 2: B -> A 순서로 락 획득 (역순!)\n        Thread t2 = new Thread(() -> {\n            synchronized (lockB) {\n                System.out.println(\"Thread 2: lockB 획득\");\n                try { Thread.sleep(100); } catch (Exception e) {}\n                \n                System.out.println(\"Thread 2: lockA 대기...\");\n                synchronized (lockA) {\n                    System.out.println(\"Thread 2: lockA 획득\");\n                }\n            }\n        }, \"Thread-2\");\n        \n        t1.start();\n        t2.start();\n        \n        // 결과: 데드락 발생! 프로그램 멈춤\n    }\n}\n\n// ========================================\n//   Deadlock 방지 전략들\n// ========================================\n\nimport java.util.concurrent.locks.*;\nimport java.util.concurrent.TimeUnit;\n\npublic class DeadlockPrevention {\n    \n    // 방법 1: 락 순서 일관성 유지\n    private static final Object lockA = new Object();\n    private static final Object lockB = new Object();\n    \n    public void transferSafe(Account from, Account to, int amount) {\n        // 항상 ID가 작은 계좌부터 잠금 (순서 일관성)\n        Object firstLock = from.getId() < to.getId() ? from : to;\n        Object secondLock = from.getId() < to.getId() ? to : from;\n        \n        synchronized (firstLock) {\n            synchronized (secondLock) {\n                from.withdraw(amount);\n                to.deposit(amount);\n            }\n        }\n    }\n    \n    // 방법 2: tryLock으로 타임아웃\n    private final ReentrantLock lock1 = new ReentrantLock();\n    private final ReentrantLock lock2 = new ReentrantLock();\n    \n    public boolean transferWithTimeout() {\n        try {\n            if (lock1.tryLock(1, TimeUnit.SECONDS)) {\n                try {\n                    if (lock2.tryLock(1, TimeUnit.SECONDS)) {\n                        try {\n                            // 작업 수행\n                            return true;\n                        } finally {\n                            lock2.unlock();\n                        }\n                    }\n                } finally {\n                    lock1.unlock();\n                }\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        return false;  // 락 획득 실패\n    }\n    \n    // 방법 3: 단일 락 사용\n    private final ReentrantLock globalLock = new ReentrantLock();\n    \n    public void transferSingleLock(Account from, Account to, int amount) {\n        globalLock.lock();\n        try {\n            from.withdraw(amount);\n            to.deposit(amount);\n        } finally {\n            globalLock.unlock();\n        }\n    }\n}\n\n// ========================================\n//   Spring에서 DB 데드락 처리\n// ========================================\n\n/*\n@Service\npublic class AccountService {\n    \n    @Autowired\n    private AccountRepository accountRepository;\n    \n    // 재시도 로직으로 데드락 처리\n    @Retryable(\n        value = {DeadlockLoserDataAccessException.class},\n        maxAttempts = 3,\n        backoff = @Backoff(delay = 100)\n    )\n    @Transactional\n    public void transfer(Long fromId, Long toId, BigDecimal amount) {\n        // 항상 ID 순서대로 잠금 (데드락 방지)\n        Long firstId = Math.min(fromId, toId);\n        Long secondId = Math.max(fromId, toId);\n        \n        Account first = accountRepository.findByIdWithLock(firstId);\n        Account second = accountRepository.findByIdWithLock(secondId);\n        \n        if (fromId.equals(firstId)) {\n            first.withdraw(amount);\n            second.deposit(amount);\n        } else {\n            second.withdraw(amount);\n            first.deposit(amount);\n        }\n    }\n}\n*/"
            },
            {
                "type": "tip",
                "title": "체크리스트 & 면접",
                "content": "## Deadlock 체크리스트\n\n### 데드락 4대 조건 (암기!)\n- [ ] 상호 배제 (Mutual Exclusion)\n- [ ] 점유와 대기 (Hold and Wait)\n- [ ] 비선점 (No Preemption)\n- [ ] 순환 대기 (Circular Wait)\n\n### 예방 전략 비교\n| 조건 제거 | 방법 | 단점 |\n|----------|------|------|\n| 상호 배제 | 불가능 | 자원 특성상 필수 |\n| 점유와 대기 | 한번에 모든 자원 요청 | 자원 낭비 |\n| 비선점 | 자원 선점 허용 | 구현 어려움 |\n| 순환 대기 | 자원 순서 부여 | 유연성 저하 |\n\n## 면접 예상 질문\n\n**Q1: 데드락이란?**\n> 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 영원히 진행하지 못하는 상태입니다.\n\n**Q2: 데드락 발생 4대 조건은?**\n> 상호 배제, 점유와 대기, 비선점, 순환 대기입니다. 이 4가지가 모두 만족되어야 데드락이 발생합니다.\n\n**Q3: 데드락을 어떻게 방지하나요?**\n> 1) 락 획득 순서 일관성 유지\n> 2) tryLock() 타임아웃 사용\n> 3) 한 번에 모든 자원 요청\n> 4) 단일 전역 락 사용\n\n**Q4: 실무에서 데드락 경험은?**\n> DB 트랜잭션에서 테이블 락 순서 불일치로 발생했고, 항상 PK 순서대로 잠그는 규칙과 @Retryable 재시도 로직으로 해결했다고 답변하세요."
            }
        ]
    }

def get_multi_thread_content():
    return {
        "id": "03_스레드/multi-thread",
        "title": "Multi Thread",
        "category": "os",
        "subCategory": "03_스레드",
        "language": "Java",
        "description": "멀티스레드 프로그래밍의 개념, 장단점, 그리고 Java에서의 구현 방법을 학습합니다.",
        "isPlaceholder": False,
        "sections": [
            {
                "type": "concept",
                "title": "멀티스레드 완전 정복",
                "content": "# Multi-Thread Programming (멀티스레드 프로그래밍)\n\n## 한 줄 요약\n**하나의 프로세스 내에서 여러 실행 흐름을 동시에 수행하여 병렬 처리를 구현하는 기법**\n\n## 생활 비유: 식당 주방\n```\n[단일 스레드 = 요리사 1명]\n주문 1 -> 조리 -> 서빙 -> 주문 2 -> 조리 -> 서빙\n(순차 처리, 느림)\n\n[멀티 스레드 = 요리사 여러 명]\n  요리사 A: 주문 1 조리 중\n  요리사 B: 주문 2 조리 중  <- 동시 진행!\n  요리사 C: 주문 3 조리 중\n  \n공유 자원: 냉장고, 가스레인지 (동기화 필요!)\n```\n\n## 멀티스레드 vs 멀티프로세스\n```\n[멀티프로세스]\n+----------+  +----------+  +----------+\n|Process 1 |  |Process 2 |  |Process 3 |\n|  Code    |  |  Code    |  |  Code    |\n|  Data    |  |  Data    |  |  Data    |\n|  Stack   |  |  Stack   |  |  Stack   |\n+----------+  +----------+  +----------+\n  독립된 메모리 공간 (IPC 필요)\n\n[멀티스레드]\n+----------------------------------+\n|            Process               |\n|  Code (공유)  |  Data (공유)     |\n|----------------------------------|  \n|  Stack 1  |  Stack 2  |  Stack 3 |\n|  (T1)     |  (T2)     |  (T3)    |\n+----------------------------------+\n  메모리 공유 (동기화 필요)\n```\n\n## 핵심 개념\n| 특성 | 설명 |\n|------|------|\n| 공유 자원 | Heap, Data 영역 공유 |\n| 독립 자원 | Stack, 레지스터 독립 |\n| 장점 | 메모리 효율, 빠른 통신 |\n| 단점 | 동기화 복잡성, 디버깅 어려움 |"
            },
            {
                "type": "code",
                "title": "동작 원리",
                "language": "text",
                "code": "========================================\n    스레드 메모리 구조\n========================================\n\n[프로세스 메모리 레이아웃]\n\n  +----------------------------------+\n  |            Stack (T3)            | <- 스레드 3 전용\n  +----------------------------------+\n  |            Stack (T2)            | <- 스레드 2 전용\n  +----------------------------------+\n  |            Stack (T1)            | <- 스레드 1 전용\n  +----------------------------------+\n  |                                  |\n  |            Heap (공유)           | <- 모든 스레드 공유\n  |                                  |\n  +----------------------------------+\n  |            Data (공유)           | <- 전역 변수\n  +----------------------------------+\n  |            Code (공유)           | <- 실행 코드\n  +----------------------------------+\n\n\n========================================\n    스레드 생명주기 (Life Cycle)\n========================================\n\n              start()\n  [NEW] -----------------> [RUNNABLE]\n                               |\n            +------------------+------------------+\n            |                  |                  |\n            v                  v                  v\n     [BLOCKED]          [WAITING]          [TIMED_WAITING]\n     (락 대기)          (무한 대기)         (시간 대기)\n            |                  |                  |\n            +------------------+------------------+\n                               |\n                               v\n                          [RUNNABLE]\n                               |\n                               v (run() 완료)\n                        [TERMINATED]\n\n\n========================================\n    스레드 스케줄링\n========================================\n\n[Time Slicing - 시분할]\n\n시간 -->  |--T1--|--T2--|--T3--|--T1--|--T2--|--T3--|\n              ^      ^      ^      ^\n           컨텍스트 스위칭 (오버헤드)\n\n[우선순위 기반]\n\n  T1 (Priority: 10) ==========> 자주 실행\n  T2 (Priority: 5)  ===>        가끔 실행\n  T3 (Priority: 1)  =>          드물게 실행\n\n주의: 우선순위는 힌트일 뿐, 보장되지 않음!"
            },
            {
                "type": "code",
                "title": "실무 활용",
                "language": "java",
                "code": "// ========================================\n//   Java 스레드 생성 방법\n// ========================================\n\n// 방법 1: Thread 클래스 상속\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Thread 실행: \" + getName());\n    }\n}\n\n// 방법 2: Runnable 인터페이스 구현 (권장)\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Runnable 실행: \" + \n            Thread.currentThread().getName());\n    }\n}\n\n// 방법 3: 람다 표현식 (가장 간결)\nRunnable task = () -> System.out.println(\"Lambda 실행\");\n\npublic class ThreadDemo {\n    public static void main(String[] args) {\n        // Thread 상속\n        new MyThread().start();\n        \n        // Runnable 구현\n        new Thread(new MyRunnable()).start();\n        \n        // 람다\n        new Thread(() -> System.out.println(\"익명 스레드\")).start();\n    }\n}\n\n// ========================================\n//   ExecutorService (스레드 풀) - 실무 필수!\n// ========================================\n\nimport java.util.concurrent.*;\n\npublic class ThreadPoolDemo {\n    \n    public static void main(String[] args) throws Exception {\n        \n        // 고정 크기 스레드 풀\n        ExecutorService executor = Executors.newFixedThreadPool(4);\n        \n        // 작업 제출 (Runnable)\n        for (int i = 0; i < 10; i++) {\n            final int taskId = i;\n            executor.submit(() -> {\n                System.out.println(\"Task \" + taskId + \n                    \" by \" + Thread.currentThread().getName());\n                try { Thread.sleep(1000); } catch (Exception e) {}\n            });\n        }\n        \n        // 결과가 필요한 작업 (Callable)\n        Future<Integer> future = executor.submit(() -> {\n            Thread.sleep(1000);\n            return 42;\n        });\n        System.out.println(\"결과: \" + future.get());  // blocking\n        \n        // 종료\n        executor.shutdown();\n        executor.awaitTermination(10, TimeUnit.SECONDS);\n    }\n}\n\n// ========================================\n//   Spring에서의 비동기 처리\n// ========================================\n\n/*\n@Configuration\n@EnableAsync\npublic class AsyncConfig {\n    \n    @Bean\n    public Executor taskExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(4);\n        executor.setMaxPoolSize(10);\n        executor.setQueueCapacity(100);\n        executor.setThreadNamePrefix(\"Async-\");\n        executor.initialize();\n        return executor;\n    }\n}\n\n@Service\npublic class NotificationService {\n    \n    // 비동기 메서드 (별도 스레드에서 실행)\n    @Async\n    public CompletableFuture<Void> sendEmailAsync(String email) {\n        // 이메일 전송 (시간이 오래 걸림)\n        sendEmail(email);\n        return CompletableFuture.completedFuture(null);\n    }\n    \n    @Async\n    public CompletableFuture<User> findUserAsync(Long id) {\n        User user = userRepository.findById(id);\n        return CompletableFuture.completedFuture(user);\n    }\n}\n\n@RestController\npublic class OrderController {\n    \n    @Autowired\n    private NotificationService notificationService;\n    \n    @PostMapping(\"/orders\")\n    public ResponseEntity<?> createOrder(@RequestBody Order order) {\n        // 주문 저장\n        Order saved = orderService.save(order);\n        \n        // 이메일 전송은 비동기로 (응답 지연 없음)\n        notificationService.sendEmailAsync(order.getEmail());\n        \n        return ResponseEntity.ok(saved);\n    }\n}\n*/"
            },
            {
                "type": "tip",
                "title": "체크리스트 & 면접",
                "content": "## 멀티스레드 체크리스트\n\n### 스레드 풀 설정 가이드\n| 작업 유형 | 권장 스레드 수 | 이유 |\n|----------|--------------|------|\n| CPU 바운드 | CPU 코어 수 | 컨텍스트 스위칭 최소화 |\n| I/O 바운드 | CPU 코어 수 x 2~10 | I/O 대기 시간 활용 |\n| 혼합 | 모니터링 후 조정 | 상황에 따라 다름 |\n\n### 주의사항\n- [ ] 공유 자원 접근 시 동기화 필수\n- [ ] 스레드 풀 사용 (직접 생성 지양)\n- [ ] 적절한 스레드 수 설정\n- [ ] 예외 처리 철저히\n\n## 면접 예상 질문\n\n**Q1: 프로세스와 스레드의 차이는?**\n> 프로세스는 독립된 메모리 공간을 가지고, 스레드는 프로세스 내에서 메모리를 공유합니다. 스레드가 생성/전환 비용이 적고 통신이 빠릅니다.\n\n**Q2: 멀티스레드의 장단점은?**\n> 장점: 메모리 효율, 빠른 통신, 빠른 컨텍스트 스위칭\n> 단점: 동기화 복잡성, 디버깅 어려움, 하나의 스레드 오류가 전체에 영향\n\n**Q3: 스레드 풀을 왜 사용하나요?**\n> 스레드 생성/소멸 비용 절감, 동시 스레드 수 제한으로 시스템 안정성 확보, 작업 큐잉으로 부하 관리가 가능합니다.\n\n**Q4: Thread와 Runnable 차이는?**\n> Thread는 클래스 상속이라 단일 상속만 가능합니다. Runnable은 인터페이스라 다중 구현 가능하고, 스레드 풀과 함께 사용하기 좋아 Runnable이 권장됩니다."
            }
        ]
    }

def get_user_kernel_thread_content():
    return {
        "id": "03_스레드/user-kernel-thread",
        "title": "User Kernel Thread",
        "category": "os",
        "subCategory": "03_스레드",
        "language": "C",
        "description": "사용자 수준 스레드와 커널 수준 스레드의 차이점과 다양한 매핑 모델을 학습합니다.",
        "isPlaceholder": False,
        "sections": [
            {
                "type": "concept",
                "title": "사용자/커널 스레드 완전 정복",
                "content": "# User-Level Thread vs Kernel-Level Thread\n\n## 한 줄 요약\n**사용자 스레드는 라이브러리가, 커널 스레드는 OS가 관리하며, 매핑 방식에 따라 성능이 달라짐**\n\n## 생활 비유: 회사 조직 구조\n```\n[사용자 스레드 = 팀 내부 업무 분담]\n  - 팀장(프로세스)이 자체적으로 업무 배분\n  - 회사(OS)는 팀 단위로만 관리\n  - 팀원 1명 병가 -> 팀 전체 업무 마비\n\n[커널 스레드 = 회사 직접 관리]\n  - 회사(OS)가 직원 개인별로 관리\n  - 직원 1명 병가 -> 다른 직원은 계속 일함\n  - 관리 비용 높음\n```\n\n## 두 가지 스레드 비교\n```\n+--------------------+----------------------+\n|   User-Level       |    Kernel-Level      |\n|    Thread          |      Thread          |\n+--------------------+----------------------+\n|   Application      |     Application      |\n|    (Library)       |                      |\n|   +-----------+    |                      |\n|   |  Thread   |    |                      |\n|   |  Library  |    |                      |\n|   +-----------+    |                      |\n+--------|-----------+---------|------------+\n         |                     |\n+--------v---------+  +--------v-----------+\n|      Kernel      |  |      Kernel        |\n|  (스레드 모름)   |  |  +-----+  +-----+  |\n|                  |  |  | KT1 |  | KT2 |  |\n+------------------+  |  +-----+  +-----+  |\n                      +--------------------+\n```\n\n## 핵심 개념\n| 특성 | 사용자 스레드 | 커널 스레드 |\n|------|-------------|-------------|\n| 관리 주체 | 스레드 라이브러리 | OS 커널 |\n| 생성 속도 | 빠름 | 느림 |\n| 스케줄링 | 프로세스 단위 | 스레드 단위 |\n| Blocking | 전체 프로세스 블록 | 해당 스레드만 블록 |"
            },
            {
                "type": "code",
                "title": "동작 원리",
                "language": "text",
                "code": "========================================\n    스레드 매핑 모델\n========================================\n\n[1. Many-to-One (N:1)]\n\n  User Threads:  T1  T2  T3  T4\n                  \\   |   |  /\n                   \\  |  |  /\n                    \\ | | /\n                     \\|||/\n  Kernel Thread:      K1\n\n  - 장점: 빠른 스레드 생성, 효율적\n  - 단점: 하나가 블록되면 전체 블록\n  - 예: 초기 Java (Green Thread)\n\n\n[2. One-to-One (1:1)]\n\n  User Threads:   T1    T2    T3    T4\n                   |     |     |     |\n                   |     |     |     |\n  Kernel Threads: K1    K2    K3    K4\n\n  - 장점: 진정한 병렬 처리, 독립적 블록\n  - 단점: 커널 스레드 생성 비용 높음\n  - 예: Linux (pthread), Windows\n\n\n[3. Many-to-Many (M:N)]\n\n  User Threads:  T1  T2  T3  T4  T5\n                  \\  |\\  /|  /| /\n                   \\ | \\/ | / |/\n                    \\|/\\  |/\n  Kernel Threads:   K1   K2   K3\n\n  - 장점: 유연성, 효율성과 병렬성 균형\n  - 단점: 구현 복잡\n  - 예: Solaris, Go (Goroutine)\n\n\n========================================\n    Blocking I/O 시나리오 비교\n========================================\n\n[Many-to-One (N:1) - 문제 상황]\n\n  T1: read() 호출 (I/O 대기)\n       |\n       v\n  K1: 블록됨\n       |\n       v\n  T2, T3, T4: 모두 실행 불가! (전체 마비)\n\n\n[One-to-One (1:1) - 해결]\n\n  T1: read() 호출    T2: 계속 실행    T3: 계속 실행\n       |                  |                 |\n       v                  v                 v\n  K1: 블록됨         K2: 실행 중       K3: 실행 중\n\n  -> T1만 블록, 나머지는 정상 실행!\n\n\n========================================\n    현대 시스템의 스레드 구현\n========================================\n\n[Linux - 1:1 모델]\n- pthread = 커널 스레드\n- clone() 시스템 콜로 생성\n- NPTL (Native POSIX Thread Library)\n\n[Go - M:N 모델 (Goroutine)]\n- Goroutine = 경량 사용자 스레드\n- Go 런타임이 커널 스레드에 매핑\n- 수백만 개 생성 가능\n\n[Java - 변화 중]\n- 전통: 1:1 (OS 스레드)\n- Project Loom: M:N (Virtual Thread)\n  - Java 21부터 정식 지원\n  - 경량 스레드로 수백만 개 생성 가능"
            },
            {
                "type": "code",
                "title": "실무 활용",
                "language": "java",
                "code": "// ========================================\n//   Java Virtual Thread (Project Loom)\n// ========================================\n\n// Java 21+ Virtual Thread (경량 스레드)\npublic class VirtualThreadDemo {\n    \n    public static void main(String[] args) throws Exception {\n        \n        // 기존 플랫폼 스레드 (1:1 - OS 스레드)\n        Thread platformThread = Thread.ofPlatform()\n            .name(\"platform-thread\")\n            .start(() -> {\n                System.out.println(\"Platform Thread: \" + \n                    Thread.currentThread());\n            });\n        \n        // 가상 스레드 (M:N - 경량 스레드)\n        Thread virtualThread = Thread.ofVirtual()\n            .name(\"virtual-thread\")\n            .start(() -> {\n                System.out.println(\"Virtual Thread: \" + \n                    Thread.currentThread());\n            });\n        \n        platformThread.join();\n        virtualThread.join();\n        \n        // 대량 가상 스레드 생성 (수백만 개 가능!)\n        long start = System.currentTimeMillis();\n        \n        try (var executor = java.util.concurrent.Executors\n                .newVirtualThreadPerTaskExecutor()) {\n            \n            for (int i = 0; i < 100_000; i++) {\n                executor.submit(() -> {\n                    Thread.sleep(1000);  // I/O 시뮬레이션\n                    return null;\n                });\n            }\n        }\n        \n        System.out.println(\"100,000 tasks completed in \" + \n            (System.currentTimeMillis() - start) + \"ms\");\n    }\n}\n\n// ========================================\n//   C - POSIX Thread (커널 스레드)\n// ========================================\n\n/*\n#include <pthread.h>\n#include <stdio.h>\n#include <unistd.h>\n\nvoid* thread_func(void* arg) {\n    int id = *(int*)arg;\n    printf(\"Thread %d started (TID: %lu)\\n\", id, pthread_self());\n    sleep(1);\n    printf(\"Thread %d finished\\n\", id);\n    return NULL;\n}\n\nint main() {\n    pthread_t threads[5];\n    int ids[5];\n    \n    // 커널 스레드 생성 (1:1 매핑)\n    for (int i = 0; i < 5; i++) {\n        ids[i] = i;\n        pthread_create(&threads[i], NULL, thread_func, &ids[i]);\n    }\n    \n    for (int i = 0; i < 5; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    \n    return 0;\n}\n*/\n\n// ========================================\n//   Spring Boot + Virtual Thread\n// ========================================\n\n/*\n// application.yml\nspring:\n  threads:\n    virtual:\n      enabled: true  # Virtual Thread 활성화 (Java 21+)\n\n@RestController\npublic class UserController {\n    \n    @GetMapping(\"/users/{id}\")\n    public User getUser(@PathVariable Long id) {\n        // Virtual Thread에서 실행\n        // Blocking I/O도 효율적으로 처리!\n        return userRepository.findById(id).orElseThrow();\n    }\n}\n\n// 성능 비교:\n// 플랫폼 스레드: 200 동시 요청 -> 200 OS 스레드 (메모리 ~200MB)\n// 가상 스레드: 200 동시 요청 -> 소수의 캐리어 스레드 (메모리 ~수MB)\n*/"
            },
            {
                "type": "tip",
                "title": "체크리스트 & 면접",
                "content": "## 스레드 모델 체크리스트\n\n### 매핑 모델 비교\n| 모델 | 장점 | 단점 | 예시 |\n|------|------|------|------|\n| N:1 | 빠름, 효율적 | 전체 블록 | Green Thread |\n| 1:1 | 병렬 처리 | 비용 높음 | pthread |\n| M:N | 균형 | 복잡함 | Goroutine |\n\n### 현대 트렌드\n- [ ] Go: Goroutine (M:N, 경량)\n- [ ] Java 21: Virtual Thread (M:N)\n- [ ] Kotlin: Coroutine (협력적 멀티태스킹)\n- [ ] Node.js: 이벤트 루프 (단일 스레드 + 비동기)\n\n## 면접 예상 질문\n\n**Q1: 사용자 스레드와 커널 스레드의 차이는?**\n> 사용자 스레드는 라이브러리가 관리하고 커널이 모릅니다. 커널 스레드는 OS가 직접 관리합니다. 사용자 스레드는 빠르지만 하나가 블록되면 전체가 멈출 수 있습니다.\n\n**Q2: N:1, 1:1, M:N 모델을 설명해주세요.**\n> N:1은 여러 사용자 스레드가 하나의 커널 스레드에 매핑됩니다. 1:1은 각 사용자 스레드가 커널 스레드에 1대1 매핑됩니다. M:N은 여러 사용자 스레드가 여러 커널 스레드에 유연하게 매핑됩니다.\n\n**Q3: Java Virtual Thread란?**\n> Java 21에서 도입된 경량 스레드로, M:N 모델입니다. 수백만 개 생성 가능하고, Blocking I/O 시에도 캐리어 스레드를 효율적으로 재사용합니다.\n\n**Q4: 왜 Go의 Goroutine이 효율적인가요?**\n> M:N 모델로 소수의 OS 스레드 위에 수백만 개의 경량 Goroutine을 실행합니다. Go 런타임이 I/O 블록 시 자동으로 다른 Goroutine을 스케줄링합니다."
            }
        ]
    }

def main():
    # JSON 파일 읽기
    json_path = r"c:\tools\codemaster-next-main\codemaster-next-main\codemaster-next-main\src\data\contents\os.json"

    with open(json_path, 'r', encoding='utf-8') as f:
        data = json.load(f)

    # 9개 토픽 업데이트
    topics = [
        ("02_프로세스스레드/context-switching", get_context_switching_content()),
        ("03_동기화/race-condition", get_race_condition_content()),
        ("03_동기화/mutex", get_mutex_content()),
        ("03_동기화/semaphore", get_semaphore_content()),
        ("03_동기화/monitor", get_monitor_content()),
        ("03_동기화/deadlock", get_deadlock_content()),
        ("03_스레드/multi-thread", get_multi_thread_content()),
        ("03_스레드/user-kernel-thread", get_user_kernel_thread_content()),
    ]

    for topic_id, content in topics:
        data[topic_id] = content
        print(f"Updated: {topic_id}")

    # JSON 파일 저장
    with open(json_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

    print(f"\nSuccessfully updated {len(topics)} topics in os.json")

if __name__ == "__main__":
    main()
