# -*- coding: utf-8 -*-
import json

OS_JSON_PATH = r"c:\tools\codemaster-next-main\codemaster-next-main\codemaster-next-main\src\data\contents\os.json"

TOPICS = {
    "06_메모리/memory-allocation": {
        "title": "Memory Allocation",
        "description": "메모리 할당 방식(연속/비연속)의 개념과 구현을 학습합니다.",
        "sections": [
            {
                "type": "concept",
                "title": "메모리 할당 - 창고 정리 비유",
                "content": "메모리 할당이란?\n\n메모리 할당은 프로세스가 실행될 때 필요한 메모리 공간을 배정하는 과정입니다.\n\n창고 정리 비유:\n창고(메모리)에 물건(프로세스)을 보관하는 방법을 생각해보세요.\n\n1. 연속 할당 (Contiguous Allocation)\n- 비유: 큰 물건을 한 구역에 통째로 보관\n- 물건 크기만큼의 연속된 공간이 필요\n- 장점: 접근이 빠르고 관리가 단순\n- 단점: 큰 연속 공간을 찾기 어려움\n\n2. 비연속 할당 (Non-contiguous Allocation)\n- 비유: 물건을 분해해서 여러 구역에 분산 보관\n- 페이징: 같은 크기의 상자에 나눠 담기\n- 세그멘테이션: 종류별로 다른 크기 상자에 담기\n- 장점: 메모리 활용도가 높음\n- 단점: 관리 오버헤드 발생\n\n연속 할당 기법:\n- First Fit: 처음 맞는 공간에 배치\n- Best Fit: 가장 딱 맞는 공간에 배치\n- Worst Fit: 가장 큰 공간에 배치"
            },
            {
                "type": "code",
                "title": "메모리 할당 알고리즘 시뮬레이션",
                "language": "Python",
                "code": "# 메모리 할당 알고리즘 시뮬레이션\nclass MemoryAllocator:\n    def __init__(self, total_size):\n        self.memory = [{'start': 0, 'size': total_size, 'process': None}]\n    \n    def first_fit(self, process_id, size):\n        \"\"\"First Fit: 첫 번째 적합한 공간에 할당\"\"\"\n        for i, block in enumerate(self.memory):\n            if block['process'] is None and block['size'] >= size:\n                return self._allocate(i, process_id, size)\n        return False\n    \n    def best_fit(self, process_id, size):\n        \"\"\"Best Fit: 가장 작은 적합한 공간에 할당\"\"\"\n        best_idx, best_size = -1, float('inf')\n        for i, block in enumerate(self.memory):\n            if block['process'] is None and block['size'] >= size:\n                if block['size'] < best_size:\n                    best_idx, best_size = i, block['size']\n        if best_idx != -1:\n            return self._allocate(best_idx, process_id, size)\n        return False\n    \n    def _allocate(self, idx, process_id, size):\n        block = self.memory[idx]\n        if block['size'] > size:\n            new_block = {'start': block['start'] + size,\n                        'size': block['size'] - size, 'process': None}\n            self.memory.insert(idx + 1, new_block)\n        block['size'], block['process'] = size, process_id\n        return True\n    \n    def display(self):\n        print(\"\\n[메모리 상태]\")\n        print(\"+\" + \"-\"*40 + \"+\")\n        for b in self.memory:\n            status = f\"P{b['process']}\" if b['process'] else \"FREE\"\n            print(f\"| {b['start']:4d} - {b['start']+b['size']-1:4d} | {status:6} | {b['size']:4d} KB |\")\n        print(\"+\" + \"-\"*40 + \"+\")\n\n# 실행 예제\nmem = MemoryAllocator(1000)\nmem.first_fit(1, 200)  # P1: 200KB\nmem.first_fit(2, 300)  # P2: 300KB\nmem.first_fit(3, 150)  # P3: 150KB\nmem.display()"
            },
            {
                "type": "code",
                "title": "OS별 메모리 설정",
                "language": "Bash",
                "code": "# ===== Linux 메모리 관리 설정 =====\n# 현재 메모리 상태 확인\nfree -h\ncat /proc/meminfo\n\n# 가상 메모리(스왑) 설정\nsudo swapon --show\nsudo fallocate -l 4G /swapfile\nsudo chmod 600 /swapfile\nsudo mkswap /swapfile\nsudo swapon /swapfile\n\n# 메모리 오버커밋 정책 설정\n# 0: 휴리스틱, 1: 항상 허용, 2: 제한\nsudo sysctl vm.overcommit_memory=0\n\n# ===== JVM 메모리 튜닝 =====\n# 힙 메모리 설정\njava -Xms512m -Xmx2g -jar app.jar\n\n# 메모리 영역별 설정\njava -XX:NewSize=256m \\       # Young Generation 초기 크기\n     -XX:MaxNewSize=512m \\    # Young Generation 최대 크기\n     -XX:MetaspaceSize=128m \\ # Metaspace 초기 크기\n     -jar app.jar\n\n# GC 로그로 메모리 할당 패턴 분석\njava -Xlog:gc*:file=gc.log:time -jar app.jar"
            },
            {
                "type": "tip",
                "title": "메모리 할당 비교표 및 면접 질문",
                "content": "할당 알고리즘 비교표:\n\n| 알고리즘    | 속도   | 메모리 효율 | 단편화     |\n|------------|--------|-------------|------------|\n| First Fit  | 빠름   | 보통        | 앞쪽 집중  |\n| Best Fit   | 느림   | 높음        | 작은 조각  |\n| Worst Fit  | 느림   | 낮음        | 적음       |\n| Next Fit   | 빠름   | 보통        | 분산       |\n\n연속 vs 비연속 할당:\n| 구분        | 연속 할당    | 비연속 할당   |\n|-------------|--------------|---------------|\n| 외부 단편화 | 발생         | 없음(페이징)  |\n| 내부 단편화 | 없음         | 발생(페이징)  |\n| 메모리 활용 | 낮음         | 높음          |\n| 관리 복잡도 | 단순         | 복잡          |\n\n면접 빈출 질문:\n\nQ1: First Fit과 Best Fit의 차이점은?\nA: First Fit은 첫 번째 적합 공간에 빠르게 할당하고, Best Fit은 가장 작은 적합 공간에 할당하여 메모리 효율은 높지만 검색 시간이 깁니다.\n\nQ2: 외부 단편화 해결 방법은?\nA: 압축(Compaction), 페이징, 세그멘테이션으로 해결합니다.\n\nQ3: 메모리 풀(Memory Pool)이란?\nA: 미리 할당해둔 메모리 블록을 재사용하는 기법으로, 할당/해제 오버헤드를 줄입니다."
            }
        ]
    },
    "06_메모리/fragmentation": {
        "title": "Fragmentation",
        "description": "내부 단편화와 외부 단편화의 개념과 해결 방법을 학습합니다.",
        "sections": [
            {
                "type": "concept",
                "title": "단편화 - 퍼즐 조각 비유",
                "content": "단편화(Fragmentation)란?\n\n메모리 공간이 조각나서 사용할 수 없게 되는 현상입니다.\n\n퍼즐 비유:\n\n1. 외부 단편화 (External Fragmentation)\n- 비유: 퍼즐 조각들 사이에 빈 공간이 생김\n- 전체 빈 공간은 충분하지만 연속되지 않아 사용 불가\n- 예: 100KB 필요한데, 50KB + 30KB + 40KB로 흩어져 있음\n- 해결: 압축(Compaction), 페이징\n\n2. 내부 단편화 (Internal Fragmentation)\n- 비유: 큰 상자에 작은 물건을 넣어 공간 낭비\n- 할당된 블록 내부에서 사용하지 않는 공간 발생\n- 예: 4KB 페이지에 3KB만 사용하면 1KB 낭비\n- 해결: 적절한 블록 크기 선택, 슬랩 할당자\n\n단편화 발생 시나리오:\n1. 프로세스 A(100KB) 할당\n2. 프로세스 B(200KB) 할당\n3. 프로세스 A 해제 -> 100KB 빈 공간\n4. 프로세스 C(150KB) 할당 불가! (100KB < 150KB)\n\n압축(Compaction):\n- 메모리의 모든 프로세스를 한쪽으로 이동\n- 외부 단편화 제거\n- 단점: 오버헤드가 크고 실행 중 이동이 어려움"
            },
            {
                "type": "code",
                "title": "단편화 시뮬레이션",
                "language": "Python",
                "code": "# 단편화 시뮬레이션 및 시각화\nclass FragmentationSimulator:\n    def __init__(self, size, page_size=4):\n        self.total_size = size\n        self.page_size = page_size\n        self.memory = [None] * size  # None = 빈 공간\n        self.processes = {}\n    \n    def allocate(self, pid, size):\n        \"\"\"연속 할당 시도\"\"\"\n        start = self._find_contiguous(size)\n        if start == -1:\n            return False, \"외부 단편화 발생!\"\n        \n        for i in range(start, start + size):\n            self.memory[i] = pid\n        self.processes[pid] = (start, size)\n        return True, f\"P{pid} 할당: {start}-{start+size-1}\"\n    \n    def _find_contiguous(self, size):\n        count, start = 0, 0\n        for i in range(self.total_size):\n            if self.memory[i] is None:\n                if count == 0: start = i\n                count += 1\n                if count >= size: return start\n            else:\n                count = 0\n        return -1\n    \n    def deallocate(self, pid):\n        if pid in self.processes:\n            start, size = self.processes[pid]\n            for i in range(start, start + size):\n                self.memory[i] = None\n            del self.processes[pid]\n    \n    def calc_fragmentation(self):\n        \"\"\"단편화 계산\"\"\"\n        free_blocks, current = [], 0\n        for i in range(self.total_size):\n            if self.memory[i] is None:\n                current += 1\n            elif current > 0:\n                free_blocks.append(current)\n                current = 0\n        if current > 0: free_blocks.append(current)\n        \n        total_free = sum(free_blocks)\n        largest_free = max(free_blocks) if free_blocks else 0\n        external_frag = total_free - largest_free\n        return {'total_free': total_free, 'largest_block': largest_free,\n                'external_frag': external_frag, 'fragments': len(free_blocks)}\n    \n    def visualize(self):\n        print(\"\\n[메모리 맵] (. = 빈 공간)\")\n        row = \"\"\n        for i, cell in enumerate(self.memory):\n            row += str(cell) if cell else \".\"\n            if (i + 1) % 20 == 0:\n                print(f\"{i-19:3d}-{i:3d}: [{row}]\")\n                row = \"\"\n        stats = self.calc_fragmentation()\n        print(f\"\\n외부 단편화: {stats['external_frag']}KB ({stats['fragments']}개 조각)\")\n\n# 실행\nsim = FragmentationSimulator(100)\nsim.allocate(1, 20)\nsim.allocate(2, 30)\nsim.allocate(3, 15)\nsim.deallocate(2)  # 중간에 구멍 생성\nsim.visualize()\nprint(sim.allocate(4, 35))  # 35KB 연속 공간 없음!"
            },
            {
                "type": "code",
                "title": "단편화 모니터링 및 해결",
                "language": "Bash",
                "code": "# ===== Linux 메모리 단편화 확인 =====\n# 메모리 단편화 상태 확인\ncat /proc/buddyinfo\n# 출력 예: Node 0, zone Normal 1 2 3 5 8 13 21 34 55 89 144\n# 각 숫자는 2^n 페이지 크기의 사용 가능한 블록 수\n\n# 단편화 지수 확인 (0에 가까울수록 좋음)\ncat /proc/pagetypeinfo\n\n# 메모리 압축 수행 (커널 4.6+)\nsudo bash -c \"echo 1 > /proc/sys/vm/compact_memory\"\n\n# ===== 단편화 방지 설정 =====\n# THP(Transparent Huge Pages) 설정\ncat /sys/kernel/mm/transparent_hugepage/enabled\n# [always] madvise never\n\n# 큰 연속 메모리 확보를 위한 설정\nsudo sysctl vm.min_free_kbytes=65536\n\n# ===== JVM 단편화 관리 =====\n# G1 GC 사용 (단편화 방지에 효과적)\njava -XX:+UseG1GC \\\n     -XX:G1HeapRegionSize=16m \\\n     -XX:MaxGCPauseMillis=200 \\\n     -jar app.jar\n\n# 힙 덤프로 메모리 분석\njmap -histo:live <pid> | head -20"
            },
            {
                "type": "tip",
                "title": "단편화 비교표 및 면접 질문",
                "content": "단편화 유형 비교:\n\n| 구분        | 내부 단편화           | 외부 단편화           |\n|-------------|----------------------|----------------------|\n| 발생 위치   | 할당된 블록 내부      | 할당된 블록 사이      |\n| 발생 원인   | 고정 크기 할당        | 가변 크기 할당        |\n| 발생 기법   | 페이징               | 세그멘테이션          |\n| 해결 방법   | 작은 페이지 크기      | 압축, 페이징          |\n\n단편화 해결 기법:\n| 기법        | 대상            | 장점              | 단점              |\n|-------------|-----------------|-------------------|-------------------|\n| 압축        | 외부 단편화     | 완전 해결         | 높은 오버헤드     |\n| 페이징      | 외부 단편화     | 자동 해결         | 내부 단편화 발생  |\n| 버디 시스템 | 둘 다           | 빠른 할당/해제    | 50% 내부 단편화   |\n| 슬랩 할당자 | 내부 단편화     | 캐시 효율적       | 구현 복잡         |\n\n면접 빈출 질문:\n\nQ1: 페이징에서 내부 단편화가 발생하는 이유는?\nA: 프로세스 크기가 페이지 크기의 배수가 아니면 마지막 페이지에 낭비 공간이 생깁니다.\n\nQ2: 압축의 단점은?\nA: 모든 프로세스 중지, 주소 재계산, I/O 대기 등 큰 오버헤드가 발생합니다.\n\nQ3: 버디 시스템이란?\nA: 메모리를 2의 거듭제곱 크기로 분할하여 관리하는 기법으로, 빠른 병합이 가능합니다."
            }
        ]
    },
    "06_메모리/page-fault": {
        "title": "Page Fault",
        "description": "페이지 폴트의 발생 원인과 처리 과정을 학습합니다.",
        "sections": [
            {
                "type": "concept",
                "title": "페이지 폴트 - 도서관 비유",
                "content": "페이지 폴트(Page Fault)란?\n\n프로세스가 접근하려는 페이지가 물리 메모리에 없을 때 발생하는 예외입니다.\n\n도서관 비유:\n책(페이지)을 빌리러 왔는데 서가(RAM)에 없고 창고(디스크)에 있는 상황\n\n1. 책을 찾으러 감 (메모리 접근)\n2. 서가에 없음! (페이지 폴트 발생)\n3. 사서에게 요청 (OS 인터럽트)\n4. 창고에서 가져옴 (디스크 I/O)\n5. 서가에 배치 (페이지 테이블 갱신)\n6. 다시 책을 읽음 (명령어 재실행)\n\n페이지 폴트 종류:\n\n1. Minor Page Fault (소프트 폴트)\n- 페이지가 이미 메모리에 있지만 매핑 안 됨\n- 디스크 I/O 없이 해결\n- 예: 공유 라이브러리 접근\n\n2. Major Page Fault (하드 폴트)\n- 페이지가 디스크에 있음\n- 디스크 I/O 필요 (느림)\n- 예: 스왑 영역에서 로드\n\n3. Invalid Page Fault\n- 잘못된 주소 접근\n- 세그멘테이션 폴트 발생\n\n페이지 폴트 비용:\n- 메모리 접근: ~100ns\n- 페이지 폴트: ~10ms\n- 약 100,000배 느림!"
            },
            {
                "type": "code",
                "title": "페이지 폴트 시뮬레이션",
                "language": "Python",
                "code": "# 페이지 폴트 처리 시뮬레이션\nimport time\n\nclass PageFaultSimulator:\n    def __init__(self, physical_frames, disk_pages):\n        self.frames = physical_frames  # 물리 메모리 프레임 수\n        self.memory = {}  # 프레임 -> 페이지 매핑\n        self.page_table = {}  # 페이지 -> 프레임 매핑 (valid bit)\n        self.disk = set(range(disk_pages))  # 디스크의 모든 페이지\n        self.stats = {'minor': 0, 'major': 0, 'hits': 0}\n        self.access_order = []  # LRU를 위한 접근 순서\n    \n    def access_page(self, page_num):\n        \"\"\"페이지 접근 시뮬레이션\"\"\"\n        print(f\"\\n[접근] 페이지 {page_num}\")\n        \n        # 1. 페이지 테이블 확인\n        if page_num in self.page_table:\n            # 페이지 히트!\n            self.stats['hits'] += 1\n            self._update_lru(page_num)\n            print(f\"  -> 히트! 프레임 {self.page_table[page_num]}에서 읽기\")\n            return 'HIT'\n        \n        # 2. 페이지 폴트 발생!\n        print(f\"  -> 페이지 폴트 발생!\")\n        \n        # 3. 빈 프레임 확인\n        if len(self.memory) < self.frames:\n            # Minor fault: 빈 프레임에 로드\n            frame = len(self.memory)\n            self._load_page(page_num, frame)\n            self.stats['minor'] += 1\n            print(f\"  -> Minor fault: 빈 프레임 {frame}에 로드\")\n            return 'MINOR'\n        \n        # 4. 페이지 교체 필요 (Major fault)\n        victim = self._select_victim_lru()\n        victim_frame = self.page_table[victim]\n        \n        # 희생 페이지 제거\n        del self.page_table[victim]\n        del self.memory[victim_frame]\n        print(f\"  -> Major fault: 페이지 {victim} 교체\")\n        \n        # 새 페이지 로드\n        self._load_page(page_num, victim_frame)\n        self.stats['major'] += 1\n        return 'MAJOR'\n    \n    def _load_page(self, page, frame):\n        self.memory[frame] = page\n        self.page_table[page] = frame\n        self._update_lru(page)\n    \n    def _update_lru(self, page):\n        if page in self.access_order:\n            self.access_order.remove(page)\n        self.access_order.append(page)\n    \n    def _select_victim_lru(self):\n        return self.access_order[0]\n    \n    def print_stats(self):\n        total = self.stats['hits'] + self.stats['minor'] + self.stats['major']\n        fault_rate = (self.stats['minor'] + self.stats['major']) / total * 100\n        print(f\"\\n[통계] 총 {total}회 접근\")\n        print(f\"  히트: {self.stats['hits']}, 폴트: {self.stats['minor']+self.stats['major']}\")\n        print(f\"  폴트율: {fault_rate:.1f}%\")\n\n# 실행\nsim = PageFaultSimulator(physical_frames=3, disk_pages=10)\nfor page in [1, 2, 3, 4, 1, 2, 5, 1, 2, 3]:\n    sim.access_page(page)\nsim.print_stats()"
            },
            {
                "type": "code",
                "title": "페이지 폴트 모니터링",
                "language": "Bash",
                "code": "# ===== Linux 페이지 폴트 모니터링 =====\n# 시스템 전체 페이지 폴트 확인\nsar -B 1 5\n# pgpgin/s: 초당 페이지 인\n# pgpgout/s: 초당 페이지 아웃\n# fault/s: 초당 페이지 폴트\n# majflt/s: 초당 Major 폴트\n\n# 프로세스별 페이지 폴트 확인\nps -o pid,min_flt,maj_flt,cmd -p <pid>\n\n# 실시간 모니터링\nwatch -n 1 \"cat /proc/<pid>/stat | awk '{print \\\"Minor:\\\", \\$10, \\\"Major:\\\", \\$12}'\"\n\n# perf로 페이지 폴트 프로파일링\nsudo perf stat -e page-faults,minor-faults,major-faults ./my_program\n\n# ===== 페이지 폴트 최적화 =====\n# 메모리 사전 로드 (페이지 폴트 방지)\nvmtouch -t /path/to/file  # 파일을 메모리에 로드\n\n# 스왑 사용 조절 (Major 폴트 감소)\nsudo sysctl vm.swappiness=10  # 기본값 60\n\n# ===== JVM 페이지 폴트 최적화 =====\n# 힙을 미리 터치하여 페이지 폴트 방지\njava -XX:+AlwaysPreTouch -Xms4g -Xmx4g -jar app.jar\n\n# 대용량 페이지 사용 (TLB 미스 및 폴트 감소)\njava -XX:+UseLargePages -Xms4g -Xmx4g -jar app.jar"
            },
            {
                "type": "tip",
                "title": "페이지 폴트 비교표 및 면접 질문",
                "content": "페이지 폴트 유형 비교:\n\n| 유형         | 원인                | 디스크 I/O | 처리 시간  |\n|--------------|--------------------|-----------|-----------|\n| Minor Fault  | 매핑만 필요         | 없음       | ~1us      |\n| Major Fault  | 디스크에서 로드     | 있음       | ~10ms     |\n| Invalid      | 잘못된 주소         | -          | SIGSEGV   |\n\n페이지 폴트 처리 단계:\n1. 트랩 발생 -> OS로 제어 전환\n2. 유효한 참조인지 확인\n3. 빈 프레임 찾기 (없으면 교체)\n4. 디스크에서 페이지 로드\n5. 페이지 테이블 갱신\n6. 명령어 재시작\n\n스래싱(Thrashing):\n- 페이지 폴트가 과도하게 발생하는 현상\n- 원인: 프로세스가 너무 많거나 메모리 부족\n- 해결: Working Set 모델, PFF(Page Fault Frequency)\n\n면접 빈출 질문:\n\nQ1: 페이지 폴트가 발생하면 어떤 일이 일어나나요?\nA: 트랩 발생 -> OS 개입 -> 페이지 테이블 확인 -> 디스크에서 로드 -> 테이블 갱신 -> 명령어 재실행\n\nQ2: 스래싱이란?\nA: 페이지 폴트가 너무 자주 발생하여 CPU가 실제 작업보다 페이지 교체에 더 많은 시간을 쓰는 현상입니다.\n\nQ3: Demand Paging이란?\nA: 필요할 때만 페이지를 로드하는 기법으로, 초기 로딩 시간 단축과 메모리 절약이 가능합니다."
            }
        ]
    },
    "06_메모리/page-replacement": {
        "title": "Page Replacement",
        "description": "FIFO, LRU, LFU, Optimal 페이지 교체 알고리즘을 학습합니다.",
        "sections": [
            {
                "type": "concept",
                "title": "페이지 교체 - 냉장고 정리 비유",
                "content": "페이지 교체 알고리즘이란?\n\n물리 메모리가 가득 찼을 때 어떤 페이지를 내보낼지 결정하는 알고리즘입니다.\n\n냉장고 정리 비유:\n냉장고(메모리)가 가득 찼을 때 새 음식(페이지)을 넣으려면?\n\n1. FIFO (First In First Out)\n- 가장 오래된 음식부터 버리기\n- 구현 간단, 성능 불안정\n- Belady's Anomaly 발생 가능\n\n2. LRU (Least Recently Used)\n- 가장 오래 안 먹은 음식 버리기\n- 최근 사용 기록 기반\n- 가장 널리 사용됨\n\n3. LFU (Least Frequently Used)\n- 가장 적게 먹은 음식 버리기\n- 사용 빈도 기반\n- 인기 없는 페이지 우선 제거\n\n4. Optimal (OPT)\n- 앞으로 가장 안 먹을 음식 버리기\n- 이론상 최적, 구현 불가능\n- 다른 알고리즘의 성능 기준\n\n알고리즘 선택 기준:\n- 단순함: FIFO\n- 일반 성능: LRU\n- 접근 패턴 예측 가능: LFU\n- 성능 비교 기준: Optimal"
            },
            {
                "type": "code",
                "title": "페이지 교체 알고리즘 시뮬레이션",
                "language": "Python",
                "code": "# 페이지 교체 알고리즘 비교 시뮬레이션\nfrom collections import OrderedDict, defaultdict\n\nclass PageReplacementSimulator:\n    def __init__(self, frames):\n        self.frames = frames\n    \n    def fifo(self, pages):\n        \"\"\"FIFO 알고리즘\"\"\"\n        memory, faults, queue = set(), 0, []\n        history = []\n        \n        for page in pages:\n            if page not in memory:\n                faults += 1\n                if len(memory) >= self.frames:\n                    victim = queue.pop(0)\n                    memory.remove(victim)\n                memory.add(page)\n                queue.append(page)\n            history.append((page, list(queue), page not in memory or len(queue) == 1))\n        \n        return faults, history\n    \n    def lru(self, pages):\n        \"\"\"LRU 알고리즘\"\"\"\n        memory = OrderedDict()\n        faults = 0\n        \n        for page in pages:\n            if page in memory:\n                memory.move_to_end(page)\n            else:\n                faults += 1\n                if len(memory) >= self.frames:\n                    memory.popitem(last=False)\n                memory[page] = True\n        \n        return faults\n    \n    def lfu(self, pages):\n        \"\"\"LFU 알고리즘\"\"\"\n        memory, freq, faults = set(), defaultdict(int), 0\n        \n        for page in pages:\n            if page in memory:\n                freq[page] += 1\n            else:\n                faults += 1\n                if len(memory) >= self.frames:\n                    victim = min(memory, key=lambda x: freq[x])\n                    memory.remove(victim)\n                memory.add(page)\n                freq[page] = 1\n        \n        return faults\n    \n    def optimal(self, pages):\n        \"\"\"Optimal 알고리즘\"\"\"\n        memory, faults = set(), 0\n        \n        for i, page in enumerate(pages):\n            if page not in memory:\n                faults += 1\n                if len(memory) >= self.frames:\n                    future = {p: pages[i+1:].index(p) if p in pages[i+1:] else float('inf') \n                              for p in memory}\n                    victim = max(future, key=future.get)\n                    memory.remove(victim)\n                memory.add(page)\n        \n        return faults\n    \n    def compare_all(self, pages):\n        \"\"\"모든 알고리즘 비교\"\"\"\n        print(f\"\\n페이지 참조열: {pages}\")\n        print(f\"프레임 수: {self.frames}\")\n        print(\"\\n\" + \"=\"*40)\n        print(f\"{'알고리즘':<12} {'페이지 폴트':>10} {'폴트율':>10}\")\n        print(\"=\"*40)\n        \n        for name, func in [('FIFO', self.fifo), ('LRU', self.lru),\n                           ('LFU', self.lfu), ('Optimal', self.optimal)]:\n            result = func(pages)\n            faults = result[0] if isinstance(result, tuple) else result\n            rate = faults / len(pages) * 100\n            print(f\"{name:<12} {faults:>10} {rate:>9.1f}%\")\n\n# Gantt 차트 출력\ndef print_gantt(pages, frames):\n    sim = PageReplacementSimulator(frames)\n    memory, queue = set(), []\n    \n    print(\"\\n[FIFO Gantt 차트]\")\n    print(\"+\" + \"----+\" * len(pages))\n    print(\"|\" + \"|\".join(f\" {p:2} \" for p in pages) + \"|\")\n    print(\"+\" + \"----+\" * len(pages))\n    \n    for frame_idx in range(frames):\n        row = \"|\"\n        current_queue = []\n        for page in pages:\n            if page not in set(current_queue):\n                if len(current_queue) >= frames:\n                    current_queue.pop(0)\n                current_queue.append(page)\n            else:\n                pass\n            \n            if frame_idx < len(current_queue):\n                row += f\" {current_queue[frame_idx]:2} |\"\n            else:\n                row += \"    |\"\n        print(row)\n    print(\"+\" + \"----+\" * len(pages))\n\n# 실행\npages = [7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1]\nsim = PageReplacementSimulator(frames=3)\nsim.compare_all(pages)\nprint_gantt([7, 0, 1, 2, 0, 3, 0, 4], 3)"
            },
            {
                "type": "code",
                "title": "OS 페이지 교체 설정",
                "language": "Bash",
                "code": "# ===== Linux 페이지 교체 정책 =====\n# 현재 페이지 교체 통계\nvmstat 1 5\n# si: swap in, so: swap out\n\n# 페이지 캐시 상태\ncat /proc/meminfo | grep -E \"Cached|Buffers|Active|Inactive\"\n\n# 스왑 경향성 조절 (0-100, 낮을수록 스왑 회피)\nsudo sysctl vm.swappiness=10\n\n# 더티 페이지 임계값 설정\nsudo sysctl vm.dirty_ratio=20\nsudo sysctl vm.dirty_background_ratio=5\n\n# ===== 페이지 교체 모니터링 =====\n# 페이지 교체 활동 실시간 확인\nwatch -n 1 \"cat /proc/vmstat | grep -E 'pgpg|pswp'\"\n\n# 프로세스별 메모리 접근 패턴 분석\nsudo perf record -e page-faults -p <pid> -- sleep 10\nsudo perf report\n\n# ===== JVM 메모리 교체 최적화 =====\n# 힙 크기 고정으로 페이지 교체 최소화\njava -Xms4g -Xmx4g -jar app.jar\n\n# 메모리 잠금 (스왑 방지)\njava -XX:+AlwaysPreTouch \\  \n     -XX:+UseLargePages \\   \n     -Xms4g -Xmx4g -jar app.jar"
            },
            {
                "type": "tip",
                "title": "페이지 교체 알고리즘 비교표",
                "content": "알고리즘 비교표:\n\n| 알고리즘 | 구현 복잡도 | 성능     | 오버헤드 | Belady |\n|----------|-------------|----------|----------|--------|\n| FIFO     | O(1)        | 낮음     | 낮음     | 발생   |\n| LRU      | O(1)~O(n)   | 좋음     | 중간     | 없음   |\n| LFU      | O(n)        | 좋음     | 높음     | 없음   |\n| Optimal  | 불가능      | 최적     | -        | 없음   |\n| Clock    | O(1)        | 좋음     | 낮음     | 없음   |\n\nBelady's Anomaly:\n- FIFO에서만 발생\n- 프레임 수가 늘어나도 페이지 폴트가 증가할 수 있음\n- 예: 1,2,3,4,1,2,5,1,2,3,4,5\n  - 3프레임: 9번 폴트\n  - 4프레임: 10번 폴트!\n\nClock (Second Chance) 알고리즘:\n- FIFO의 개선 버전\n- 참조 비트 사용\n- LRU 근사, 낮은 오버헤드\n\n면접 빈출 질문:\n\nQ1: LRU 구현 방법은?\nA: 1) 카운터: 접근시마다 타임스탬프 기록\n   2) 스택: 접근시 top으로 이동\n   3) 해시맵+이중연결리스트: O(1) 구현\n\nQ2: Optimal 알고리즘을 실제로 사용할 수 없는 이유는?\nA: 미래의 페이지 참조를 알 수 없기 때문입니다. 성능 비교 기준으로만 사용합니다.\n\nQ3: Working Set이란?\nA: 특정 시간 동안 프로세스가 참조하는 페이지들의 집합으로, 이 크기만큼 프레임을 할당하면 스래싱을 방지할 수 있습니다."
            }
        ]
    },
    "06_메모리/segmentation": {
        "title": "Segmentation",
        "description": "세그멘테이션의 개념과 페이징과의 차이점을 학습합니다.",
        "sections": [
            {
                "type": "concept",
                "title": "세그멘테이션 - 서류 정리 비유",
                "content": "세그멘테이션(Segmentation)이란?\n\n프로그램을 논리적 단위(세그먼트)로 나누어 메모리를 관리하는 기법입니다.\n\n서류 정리 비유:\n서류를 종류별로 다른 폴더에 정리하는 것과 같습니다.\n\n프로그램의 세그먼트 예시:\n- Code 세그먼트: 실행 코드\n- Data 세그먼트: 전역 변수\n- Stack 세그먼트: 지역 변수, 함수 호출\n- Heap 세그먼트: 동적 할당 메모리\n\n세그먼트 테이블:\n| 세그먼트 | Base(시작 주소) | Limit(크기) |\n|----------|-----------------|-------------|\n| Code     | 1000           | 400         |\n| Data     | 2000           | 300         |\n| Stack    | 3000           | 500         |\n\n주소 변환:\n논리 주소 = <세그먼트 번호, 오프셋>\n물리 주소 = Base + Offset (Offset < Limit 확인)\n\n장점:\n- 논리적 구조 반영\n- 세그먼트별 보호 가능 (읽기/쓰기/실행)\n- 공유 용이 (코드 세그먼트 공유)\n\n단점:\n- 외부 단편화 발생\n- 가변 크기로 관리 복잡"
            },
            {
                "type": "code",
                "title": "세그멘테이션 시뮬레이션",
                "language": "Python",
                "code": "# 세그멘테이션 메모리 관리 시뮬레이션\nclass Segment:\n    def __init__(self, name, base, limit, permissions):\n        self.name = name\n        self.base = base\n        self.limit = limit\n        self.permissions = permissions  # 'r', 'w', 'x'\n\nclass SegmentationUnit:\n    def __init__(self):\n        self.segment_table = {}\n        self.memory_map = []  # (start, end, segment_name)\n    \n    def create_segment(self, name, size, permissions):\n        \"\"\"세그먼트 생성 (First Fit)\"\"\"\n        base = self._find_free_space(size)\n        if base == -1:\n            return False, \"메모리 부족 또는 외부 단편화\"\n        \n        segment = Segment(name, base, size, permissions)\n        self.segment_table[name] = segment\n        self.memory_map.append((base, base + size, name))\n        self.memory_map.sort()\n        return True, f\"{name} 세그먼트 생성: base={base}, limit={size}\"\n    \n    def _find_free_space(self, size):\n        if not self.memory_map:\n            return 0\n        \n        # 처음 빈 공간 확인\n        if self.memory_map[0][0] >= size:\n            return 0\n        \n        # 세그먼트 사이 빈 공간 확인\n        for i in range(len(self.memory_map) - 1):\n            gap_start = self.memory_map[i][1]\n            gap_end = self.memory_map[i + 1][0]\n            if gap_end - gap_start >= size:\n                return gap_start\n        \n        # 마지막 뒤 공간\n        return self.memory_map[-1][1]\n    \n    def translate(self, segment_name, offset, access_type):\n        \"\"\"논리 주소 -> 물리 주소 변환\"\"\"\n        if segment_name not in self.segment_table:\n            return None, \"세그멘테이션 폴트: 존재하지 않는 세그먼트\"\n        \n        seg = self.segment_table[segment_name]\n        \n        # 범위 검사\n        if offset >= seg.limit:\n            return None, f\"세그멘테이션 폴트: 오프셋 {offset} > limit {seg.limit}\"\n        \n        # 권한 검사\n        if access_type not in seg.permissions:\n            return None, f\"보호 위반: {access_type} 권한 없음\"\n        \n        physical_addr = seg.base + offset\n        return physical_addr, f\"물리 주소: {physical_addr}\"\n    \n    def display(self):\n        print(\"\\n[세그먼트 테이블]\")\n        print(\"+\" + \"-\"*50 + \"+\")\n        print(f\"| {'세그먼트':<10} | {'Base':>8} | {'Limit':>8} | {'권한':>6} |\")\n        print(\"+\" + \"-\"*50 + \"+\")\n        for name, seg in self.segment_table.items():\n            print(f\"| {name:<10} | {seg.base:>8} | {seg.limit:>8} | {seg.permissions:>6} |\")\n        print(\"+\" + \"-\"*50 + \"+\")\n        \n        # 메모리 맵 시각화\n        print(\"\\n[메모리 맵]\")\n        for start, end, name in self.memory_map:\n            print(f\"{start:5d} +{'-'*20}+\")\n            print(f\"      | {name:^18} |\")\n        if self.memory_map:\n            print(f\"{self.memory_map[-1][1]:5d} +{'-'*20}+\")\n\n# 실행 예제\nmmu = SegmentationUnit()\nmmu.create_segment(\"CODE\", 400, \"rx\")\nmmu.create_segment(\"DATA\", 300, \"rw\")\nmmu.create_segment(\"STACK\", 500, \"rw\")\nmmu.create_segment(\"HEAP\", 200, \"rw\")\nmmu.display()\n\nprint(\"\\n[주소 변환 테스트]\")\nprint(mmu.translate(\"CODE\", 100, \"r\"))   # 성공\nprint(mmu.translate(\"CODE\", 100, \"w\"))   # 보호 위반\nprint(mmu.translate(\"DATA\", 500, \"r\"))   # 범위 초과"
            },
            {
                "type": "code",
                "title": "세그먼트 확인 및 설정",
                "language": "Bash",
                "code": "# ===== Linux 프로세스 세그먼트 확인 =====\n# 프로세스 메모리 맵 확인\ncat /proc/<pid>/maps\n# 출력 예:\n# 00400000-0040b000 r-xp ... /bin/cat  (code)\n# 0060a000-0060b000 r--p ... /bin/cat  (rodata)\n# 0060b000-0060c000 rw-p ... /bin/cat  (data)\n# 7ffff7a0d000-7ffff7bcd000 r-xp ... libc.so\n\n# 더 상세한 메모리 맵\npmap -x <pid>\n\n# 세그먼트별 크기 확인\nsize /bin/ls\n# text    data    bss     dec     hex\n# 124635  4792    4824    134251  20c6b\n\n# ===== 세그먼트 보호 설정 =====\n# 메모리 영역 권한 변경 (C 코드 예시)\n# mprotect(addr, length, PROT_READ | PROT_EXEC);\n\n# 실행 권한 확인\nreadelf -l /bin/ls | grep -A1 LOAD\n\n# ===== JVM 세그먼트 설정 =====\n# 스택 크기 설정\njava -Xss1m -jar app.jar\n\n# 코드 캐시 크기 설정\njava -XX:ReservedCodeCacheSize=256m -jar app.jar\n\n# 메타스페이스(구 PermGen) 설정\njava -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m -jar app.jar\n\n# 네이티브 메모리 추적\njava -XX:NativeMemoryTracking=summary -jar app.jar\njcmd <pid> VM.native_memory summary"
            },
            {
                "type": "tip",
                "title": "세그멘테이션 vs 페이징 비교",
                "content": "페이징 vs 세그멘테이션:\n\n| 구분        | 페이징              | 세그멘테이션         |\n|-------------|--------------------|--------------------|a\n| 단위 크기   | 고정 (4KB)         | 가변               |\n| 외부 단편화 | 없음               | 발생               |\n| 내부 단편화 | 발생               | 없음               |\n| 논리적 의미 | 없음               | 있음 (코드/데이터)  |\n| 공유        | 페이지 단위        | 세그먼트 단위       |\n| 보호        | 페이지 단위        | 세그먼트 단위       |\n\n세그먼트 + 페이징 (Segmented Paging):\n- 세그먼트를 다시 페이지로 분할\n- 외부 단편화 해결 + 논리적 구조 유지\n- Intel x86 아키텍처에서 사용\n\n논리 주소 변환:\n<세그먼트, 페이지, 오프셋>\n-> 세그먼트 테이블 -> 페이지 테이블 -> 물리 주소\n\n면접 빈출 질문:\n\nQ1: 세그멘테이션 폴트란?\nA: 유효하지 않은 세그먼트 접근 시 발생하는 오류로, 잘못된 메모리 주소 접근, 권한 위반, 스택 오버플로우 등이 원인입니다.\n\nQ2: 페이징이 세그멘테이션보다 많이 사용되는 이유는?\nA: 외부 단편화가 없고, 고정 크기로 관리가 단순하며, 하드웨어 지원이 효율적이기 때문입니다.\n\nQ3: 코드 세그먼트가 읽기 전용인 이유는?\nA: 실행 중 코드 수정을 방지하여 보안과 프로세스 간 코드 공유를 가능하게 합니다."
            }
        ]
    },
    "06_메모리/cache": {
        "title": "Cache",
        "description": "캐시 메모리의 원리와 CPU-RAM 사이의 역할을 학습합니다.",
        "sections": [
            {
                "type": "concept",
                "title": "캐시 메모리 - 책상 비유",
                "content": "캐시 메모리란?\n\nCPU와 주기억장치(RAM) 사이에서 속도 차이를 줄여주는 고속 메모리입니다.\n\n책상 비유:\n- CPU = 작업자\n- 캐시 = 책상 (자주 쓰는 자료)\n- RAM = 책장 (모든 자료)\n- 디스크 = 창고 (보관 자료)\n\n작업자는 책상에 있는 자료를 바로 사용하고,\n없으면 책장에서 가져와 책상에 올려둡니다.\n\n메모리 계층 구조:\n| 계층        | 용량      | 속도      | 가격/GB    |\n|-------------|-----------|-----------|------------|\n| 레지스터    | ~KB       | <1ns      | -          |\n| L1 캐시     | 32-64KB   | ~1ns      | 매우 높음  |\n| L2 캐시     | 256KB-1MB | ~3ns      | 높음       |\n| L3 캐시     | 4-32MB    | ~10ns     | 중간       |\n| RAM         | 8-64GB    | ~100ns    | 낮음       |\n| SSD         | 256GB-4TB | ~100us    | 매우 낮음  |\n\n캐시 동작 원리:\n1. 지역성 (Locality)\n   - 시간 지역성: 최근 사용한 데이터 재사용\n   - 공간 지역성: 인접 데이터 함께 사용\n\n2. 캐시 히트/미스\n   - 히트: 캐시에서 데이터 발견\n   - 미스: 캐시에 없어 RAM에서 로드"
            },
            {
                "type": "code",
                "title": "캐시 동작 시뮬레이션",
                "language": "Python",
                "code": "# 캐시 시뮬레이션 (Direct Mapped, Set Associative)\nimport time\n\nclass CacheSimulator:\n    def __init__(self, cache_size, block_size, associativity=1):\n        self.cache_size = cache_size\n        self.block_size = block_size\n        self.associativity = associativity  # 1=Direct, n=n-way set associative\n        self.num_sets = cache_size // (block_size * associativity)\n        \n        # 캐시 구조: sets[set_index] = [(tag, data, lru_counter), ...]\n        self.cache = [[] for _ in range(self.num_sets)]\n        self.lru_counter = 0\n        self.stats = {'hits': 0, 'misses': 0}\n    \n    def access(self, address):\n        \"\"\"메모리 주소 접근\"\"\"\n        # 주소 분해\n        block_addr = address // self.block_size\n        set_index = block_addr % self.num_sets\n        tag = block_addr // self.num_sets\n        \n        # 캐시 검색\n        cache_set = self.cache[set_index]\n        for i, (cached_tag, _, _) in enumerate(cache_set):\n            if cached_tag == tag:\n                # 캐시 히트!\n                self.stats['hits'] += 1\n                self.lru_counter += 1\n                cache_set[i] = (tag, f\"data_{address}\", self.lru_counter)\n                return 'HIT', 1  # 1 사이클\n        \n        # 캐시 미스!\n        self.stats['misses'] += 1\n        self.lru_counter += 1\n        new_entry = (tag, f\"data_{address}\", self.lru_counter)\n        \n        if len(cache_set) < self.associativity:\n            # 빈 공간에 추가\n            cache_set.append(new_entry)\n        else:\n            # LRU 교체\n            min_idx = min(range(len(cache_set)), key=lambda i: cache_set[i][2])\n            cache_set[min_idx] = new_entry\n        \n        return 'MISS', 100  # 100 사이클 (RAM 접근)\n    \n    def simulate_access_pattern(self, addresses):\n        \"\"\"접근 패턴 시뮬레이션\"\"\"\n        total_cycles = 0\n        print(\"\\n[캐시 접근 시뮬레이션]\")\n        print(f\"캐시 크기: {self.cache_size}B, 블록 크기: {self.block_size}B\")\n        print(f\"연관도: {self.associativity}-way, 세트 수: {self.num_sets}\\n\")\n        \n        for addr in addresses:\n            result, cycles = self.access(addr)\n            total_cycles += cycles\n            print(f\"주소 {addr:4d}: {result:4s} ({cycles:3d} cycles)\")\n        \n        hit_rate = self.stats['hits'] / (self.stats['hits'] + self.stats['misses']) * 100\n        print(f\"\\n히트율: {hit_rate:.1f}%\")\n        print(f\"총 사이클: {total_cycles}\")\n        return hit_rate\n\n# 캐시 친화적 vs 비친화적 코드 비교\ndef cache_friendly_sum(matrix):\n    \"\"\"행 우선 순회 (캐시 친화적)\"\"\"\n    total = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            total += matrix[i][j]\n    return total\n\ndef cache_unfriendly_sum(matrix):\n    \"\"\"열 우선 순회 (캐시 비친화적)\"\"\"\n    total = 0\n    for j in range(len(matrix[0])):\n        for i in range(len(matrix)):\n            total += matrix[i][j]\n    return total\n\n# 실행\ncache = CacheSimulator(cache_size=64, block_size=8, associativity=2)\naddresses = [0, 8, 0, 16, 8, 24, 0, 8, 16]  # 공간 지역성 패턴\ncache.simulate_access_pattern(addresses)"
            },
            {
                "type": "code",
                "title": "캐시 모니터링 및 최적화",
                "language": "Bash",
                "code": "# ===== Linux 캐시 정보 확인 =====\n# CPU 캐시 정보\nlscpu | grep -i cache\n# L1d cache: 32K (데이터 캐시)\n# L1i cache: 32K (명령어 캐시)\n# L2 cache: 256K\n# L3 cache: 6144K\n\n# 상세 캐시 정보\ngetconf -a | grep CACHE\n\n# 캐시 라인 크기 확인\ncat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size\n\n# ===== 캐시 성능 측정 =====\n# perf로 캐시 미스 측정\nsudo perf stat -e cache-references,cache-misses,L1-dcache-loads,L1-dcache-load-misses ./my_program\n\n# 캐시 미스율 상세 분석\nsudo perf stat -e \\\n  L1-dcache-load-misses,\\\n  L1-dcache-loads,\\\n  L1-icache-load-misses,\\\n  LLC-load-misses,\\\n  LLC-loads \\\n  ./my_program\n\n# ===== 페이지 캐시 관리 =====\n# 페이지 캐시 상태 확인\nfree -h\n\n# 페이지 캐시 삭제 (테스트용)\nsync; echo 3 | sudo tee /proc/sys/vm/drop_caches\n\n# ===== JVM 캐시 최적화 =====\n# 큰 배열 접근 시 캐시 워밍업\njava -XX:CompileThreshold=100 -jar app.jar\n\n# 캐시 라인 패딩 (False Sharing 방지)\n# @Contended 어노테이션 활성화\njava -XX:-RestrictContended -jar app.jar"
            },
            {
                "type": "tip",
                "title": "캐시 최적화 및 면접 질문",
                "content": "캐시 구조 비교:\n\n| 매핑 방식       | 구조         | 히트율 | 복잡도 |\n|-----------------|--------------|--------|--------|\n| Direct Mapped   | 1-way        | 낮음   | 단순   |\n| 2-way Set       | 2-way        | 중간   | 중간   |\n| 4-way Set       | 4-way        | 높음   | 복잡   |\n| Fully Assoc     | N-way        | 최고   | 매우복잡|\n\n캐시 최적화 기법:\n1. 데이터 정렬: 캐시 라인에 맞춰 정렬\n2. 루프 최적화: 행 우선 순회\n3. 데이터 압축: 캐시 효율 증가\n4. False Sharing 방지: 패딩 추가\n\nFalse Sharing:\n- 서로 다른 데이터가 같은 캐시 라인에 있을 때\n- 한 CPU가 수정하면 다른 CPU 캐시 무효화\n- 해결: 데이터를 다른 캐시 라인으로 분리\n\n면접 빈출 질문:\n\nQ1: 캐시가 빠른 이유는?\nA: SRAM 사용, CPU와 가까운 위치, 지역성 원리를 활용하기 때문입니다.\n\nQ2: Write-through와 Write-back의 차이는?\nA: Write-through는 캐시와 메모리에 동시 기록(일관성 보장), Write-back은 캐시에만 기록 후 나중에 메모리 갱신(성능 우수).\n\nQ3: 캐시 라인(Cache Line)이란?\nA: 캐시가 데이터를 읽고 쓰는 최소 단위로, 보통 64바이트입니다. 데이터 한 바이트를 읽어도 64바이트가 함께 로드됩니다."
            }
        ]
    },
    "06_스케줄링/scheduling-intro": {
        "title": "Scheduling Intro",
        "description": "CPU 스케줄링의 개요와 목표, 평가 기준을 학습합니다.",
        "sections": [
            {
                "type": "concept",
                "title": "스케줄링 개요 - 놀이공원 비유",
                "content": "CPU 스케줄링이란?\n\n여러 프로세스가 CPU를 사용하고자 할 때 어떤 프로세스에게 CPU를 할당할지 결정하는 것입니다.\n\n놀이공원 비유:\n- CPU = 놀이기구\n- 프로세스 = 손님\n- 스케줄러 = 직원(줄 관리)\n- 대기 시간 = 기다리는 시간\n\n스케줄링이 필요한 이유:\n1. CPU는 하나, 프로세스는 여러 개\n2. 공정하고 효율적인 자원 배분 필요\n3. 응답성과 처리량의 균형\n\n스케줄링 목표:\n| 목표         | 설명                          |\n|--------------|------------------------------|\n| CPU 이용률   | CPU를 최대한 바쁘게           |\n| 처리량       | 단위 시간당 완료 작업 수      |\n| 대기 시간    | Ready Queue에서 기다린 시간   |\n| 응답 시간    | 요청 후 첫 응답까지 시간      |\n| 반환 시간    | 제출 후 완료까지 총 시간      |\n\n스케줄링 단계:\n1. 장기 스케줄링: 어떤 프로세스를 Ready Queue에 넣을지\n2. 중기 스케줄링: 메모리에서 일시 제거할 프로세스\n3. 단기 스케줄링: Ready Queue에서 CPU 할당\n\n선점 vs 비선점:\n- 선점(Preemptive): 실행 중 뺏을 수 있음\n- 비선점(Non-preemptive): 완료까지 보장"
            },
            {
                "type": "code",
                "title": "스케줄링 시뮬레이션 기초",
                "language": "Python",
                "code": "# 스케줄링 시뮬레이터 기본 구조\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass Process:\n    pid: str\n    arrival_time: int\n    burst_time: int\n    priority: int = 0\n    remaining_time: int = 0\n    start_time: int = -1\n    completion_time: int = 0\n    \n    def __post_init__(self):\n        self.remaining_time = self.burst_time\n\nclass SchedulerSimulator:\n    def __init__(self, processes: List[Process]):\n        self.processes = [Process(**p.__dict__) for p in processes]\n        self.timeline = []  # Gantt 차트용\n    \n    def calculate_metrics(self):\n        \"\"\"스케줄링 성능 지표 계산\"\"\"\n        metrics = []\n        for p in self.processes:\n            turnaround = p.completion_time - p.arrival_time\n            waiting = turnaround - p.burst_time\n            response = p.start_time - p.arrival_time\n            metrics.append({\n                'pid': p.pid,\n                'turnaround': turnaround,\n                'waiting': waiting,\n                'response': response\n            })\n        return metrics\n    \n    def print_gantt_chart(self):\n        \"\"\"Gantt 차트 출력\"\"\"\n        if not self.timeline:\n            return\n        \n        print(\"\\n[Gantt Chart]\")\n        # 상단 경계\n        print(\"+\" + \"+\".join([\"-\" * 4 for _ in self.timeline]) + \"+\")\n        # 프로세스 ID\n        print(\"|\" + \"|\".join([f\" {t[0]:^2} \" for t in self.timeline]) + \"|\")\n        # 하단 경계\n        print(\"+\" + \"+\".join([\"-\" * 4 for _ in self.timeline]) + \"+\")\n        # 시간\n        times = [str(self.timeline[0][1])]\n        for t in self.timeline:\n            times.append(str(t[2]))\n        print(\" \" + \"   \".join(times[:len(self.timeline)+1]))\n    \n    def print_metrics(self):\n        \"\"\"성능 지표 출력\"\"\"\n        metrics = self.calculate_metrics()\n        print(\"\\n[성능 지표]\")\n        print(\"+\" + \"-\"*50 + \"+\")\n        print(f\"| {'PID':^5} | {'반환시간':^10} | {'대기시간':^10} | {'응답시간':^10} |\")\n        print(\"+\" + \"-\"*50 + \"+\")\n        \n        total_turnaround = total_waiting = total_response = 0\n        for m in metrics:\n            print(f\"| {m['pid']:^5} | {m['turnaround']:^10} | {m['waiting']:^10} | {m['response']:^10} |\")\n            total_turnaround += m['turnaround']\n            total_waiting += m['waiting']\n            total_response += m['response']\n        \n        n = len(metrics)\n        print(\"+\" + \"-\"*50 + \"+\")\n        print(f\"| {'평균':^5} | {total_turnaround/n:^10.2f} | {total_waiting/n:^10.2f} | {total_response/n:^10.2f} |\")\n        print(\"+\" + \"-\"*50 + \"+\")\n\n# 프로세스 정의\nprocesses = [\n    Process('P1', arrival_time=0, burst_time=8, priority=3),\n    Process('P2', arrival_time=1, burst_time=4, priority=1),\n    Process('P3', arrival_time=2, burst_time=9, priority=4),\n    Process('P4', arrival_time=3, burst_time=5, priority=2),\n]\n\nprint(\"[프로세스 목록]\")\nprint(f\"{'PID':^5} {'도착':^6} {'실행':^6} {'우선순위':^8}\")\nfor p in processes:\n    print(f\"{p.pid:^5} {p.arrival_time:^6} {p.burst_time:^6} {p.priority:^8}\")"
            },
            {
                "type": "code",
                "title": "OS별 스케줄러 확인 및 설정",
                "language": "Bash",
                "code": "# ===== Linux 스케줄러 확인 =====\n# 현재 스케줄러 정책 확인\nchrt -p <pid>\n# 출력: scheduling policy: SCHED_OTHER (일반)\n#       scheduling priority: 0\n\n# 사용 가능한 스케줄러\n# SCHED_OTHER: 일반 프로세스 (CFS)\n# SCHED_FIFO: 실시간 FIFO\n# SCHED_RR: 실시간 Round Robin\n# SCHED_BATCH: 배치 작업\n# SCHED_IDLE: 최저 우선순위\n\n# ===== 스케줄러 정책 변경 =====\n# 실시간 FIFO로 변경 (우선순위 50)\nsudo chrt -f -p 50 <pid>\n\n# 실시간 Round Robin으로 변경\nsudo chrt -r -p 30 <pid>\n\n# 프로세스 시작 시 정책 지정\nsudo chrt -f 50 ./my_program\n\n# ===== nice 값으로 우선순위 조절 =====\n# nice 값 확인 (-20 ~ 19, 낮을수록 높은 우선순위)\nps -o pid,ni,cmd -p <pid>\n\n# nice 값 변경\nrenice -n -5 -p <pid>  # 우선순위 높임\nsudo renice -n -20 -p <pid>  # 최고 우선순위\n\n# ===== 스케줄러 튜닝 =====\n# CFS 스케줄러 파라미터 확인\ncat /proc/sys/kernel/sched_latency_ns\ncat /proc/sys/kernel/sched_min_granularity_ns\n\n# JVM 스레드 우선순위 설정\njava -XX:ThreadPriorityPolicy=1 -jar app.jar\n# 0: 기본, 1: 우선순위 적용"
            },
            {
                "type": "tip",
                "title": "스케줄링 알고리즘 비교표",
                "content": "스케줄링 알고리즘 비교:\n\n| 알고리즘    | 선점 | 기아 | 응답시간 | 처리량 | 사용처        |\n|-------------|------|------|----------|--------|---------------|\n| FCFS        | X    | X    | 길다     | 낮음   | 배치 시스템   |\n| SJF         | X    | O    | 최적     | 높음   | 배치 시스템   |\n| SRTF        | O    | O    | 좋음     | 높음   | -             |\n| Round Robin | O    | X    | 좋음     | 중간   | 시분할 시스템 |\n| Priority    | 둘다 | O    | 다양     | 다양   | 범용          |\n| MLQ         | O    | O    | 좋음     | 높음   | 현대 OS       |\n| MLFQ        | O    | X    | 좋음     | 높음   | 현대 OS       |\n\n용어 정리:\n- 반환 시간(Turnaround): 완료 시간 - 도착 시간\n- 대기 시간(Waiting): 반환 시간 - 실행 시간\n- 응답 시간(Response): 첫 실행 - 도착 시간\n- 기아(Starvation): 무한 대기 현상\n\n면접 빈출 질문:\n\nQ1: 선점형과 비선점형 스케줄링의 차이는?\nA: 선점형은 실행 중인 프로세스를 중단시킬 수 있고(RR, SRTF), 비선점형은 자발적 양보까지 기다립니다(FCFS, SJF).\n\nQ2: 현대 OS에서 사용하는 스케줄링은?\nA: Linux는 CFS(Completely Fair Scheduler), Windows는 다단계 피드백 큐를 사용합니다.\n\nQ3: 기아 현상을 해결하는 방법은?\nA: 에이징(Aging) 기법으로 대기 시간에 따라 우선순위를 점진적으로 높입니다."
            }
        ]
    },
    "06_스케줄링/fcfs": {
        "title": "FCFS",
        "description": "FCFS(First Come First Served) 스케줄링 알고리즘을 학습합니다.",
        "sections": [
            {
                "type": "concept",
                "title": "FCFS - 은행 창구 비유",
                "content": "FCFS (First Come First Served)란?\n\n먼저 도착한 프로세스가 먼저 CPU를 사용하는 가장 단순한 스케줄링 알고리즘입니다.\n\n은행 창구 비유:\n은행에서 번호표를 뽑아 순서대로 처리하는 것과 같습니다.\n\n특징:\n- 비선점형 (Non-preemptive)\n- 도착 순서대로 처리\n- 구현이 매우 간단 (FIFO Queue)\n\n장점:\n1. 구현이 단순 (큐만 사용)\n2. 공정함 (먼저 온 순서대로)\n3. 기아 현상 없음\n\n단점:\n1. 호위 효과 (Convoy Effect)\n   - 긴 작업 뒤에 짧은 작업들이 기다림\n   - 평균 대기 시간 증가\n\n2. 평균 대기 시간이 길 수 있음\n\n예시:\n| 프로세스 | 도착 | 실행 |\n|----------|------|------|\n| P1       | 0    | 24   |\n| P2       | 0    | 3    |\n| P3       | 0    | 3    |\n\n순서: P1 -> P2 -> P3\n대기 시간: P1=0, P2=24, P3=27\n평균 대기 시간: (0+24+27)/3 = 17\n\n만약 순서가 P2 -> P3 -> P1이었다면?\n평균 대기 시간: (0+3+6)/3 = 3"
            },
            {
                "type": "code",
                "title": "FCFS 알고리즘 시뮬레이션",
                "language": "Python",
                "code": "# FCFS 스케줄링 시뮬레이션\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass Process:\n    pid: str\n    arrival_time: int\n    burst_time: int\n    start_time: int = -1\n    completion_time: int = 0\n\nclass FCFSScheduler:\n    def __init__(self, processes: List[Process]):\n        self.processes = sorted(processes, key=lambda p: (p.arrival_time, p.pid))\n        self.timeline = []\n    \n    def schedule(self):\n        \"\"\"FCFS 스케줄링 실행\"\"\"\n        current_time = 0\n        \n        for process in self.processes:\n            # 프로세스 도착 전이면 대기\n            if current_time < process.arrival_time:\n                current_time = process.arrival_time\n            \n            process.start_time = current_time\n            process.completion_time = current_time + process.burst_time\n            \n            self.timeline.append((process.pid, current_time, process.completion_time))\n            current_time = process.completion_time\n        \n        return self.processes\n    \n    def print_gantt_chart(self):\n        \"\"\"Gantt 차트 출력\"\"\"\n        print(\"\\n[FCFS Gantt Chart]\")\n        \n        # 타임라인 바\n        chart = \"\"\n        for pid, start, end in self.timeline:\n            width = (end - start) * 2\n            chart += \"|\" + f\"{pid}\".center(width, '-')\n        chart += \"|\"\n        print(chart)\n        \n        # 시간 표시\n        times = f\"{self.timeline[0][1]}\"\n        for _, start, end in self.timeline:\n            width = (end - start) * 2\n            times += \" \" * width + f\"{end}\"\n        print(times[:len(chart)+10])\n    \n    def print_results(self):\n        \"\"\"결과 출력\"\"\"\n        print(\"\\n[FCFS 스케줄링 결과]\")\n        print(\"+\" + \"-\"*60 + \"+\")\n        print(f\"| {'PID':^5} | {'도착':^6} | {'실행':^6} | {'시작':^6} | {'완료':^6} | {'반환':^6} | {'대기':^6} |\")\n        print(\"+\" + \"-\"*60 + \"+\")\n        \n        total_turnaround = total_waiting = 0\n        for p in self.processes:\n            turnaround = p.completion_time - p.arrival_time\n            waiting = turnaround - p.burst_time\n            total_turnaround += turnaround\n            total_waiting += waiting\n            print(f\"| {p.pid:^5} | {p.arrival_time:^6} | {p.burst_time:^6} | {p.start_time:^6} | {p.completion_time:^6} | {turnaround:^6} | {waiting:^6} |\")\n        \n        n = len(self.processes)\n        print(\"+\" + \"-\"*60 + \"+\")\n        print(f\"평균 반환 시간: {total_turnaround/n:.2f}\")\n        print(f\"평균 대기 시간: {total_waiting/n:.2f}\")\n\ndef demonstrate_convoy_effect():\n    \"\"\"호위 효과 시연\"\"\"\n    print(\"\\n\" + \"=\"*50)\n    print(\"[호위 효과(Convoy Effect) 시연]\")\n    print(\"=\"*50)\n    \n    # 긴 작업이 먼저 온 경우\n    processes1 = [\n        Process('P1', 0, 24),\n        Process('P2', 0, 3),\n        Process('P3', 0, 3),\n    ]\n    print(\"\\n시나리오 1: 긴 작업(P1=24)이 먼저 도착\")\n    scheduler1 = FCFSScheduler(processes1)\n    scheduler1.schedule()\n    scheduler1.print_gantt_chart()\n    scheduler1.print_results()\n    \n    # 짧은 작업이 먼저 온 경우\n    processes2 = [\n        Process('P2', 0, 3),\n        Process('P3', 0, 3),\n        Process('P1', 0, 24),\n    ]\n    print(\"\\n시나리오 2: 짧은 작업(P2=3, P3=3)이 먼저 도착\")\n    scheduler2 = FCFSScheduler(processes2)\n    scheduler2.schedule()\n    scheduler2.print_gantt_chart()\n    scheduler2.print_results()\n\n# 실행\nprocesses = [\n    Process('P1', 0, 8),\n    Process('P2', 1, 4),\n    Process('P3', 2, 9),\n    Process('P4', 3, 5),\n]\n\nscheduler = FCFSScheduler(processes)\nscheduler.schedule()\nscheduler.print_gantt_chart()\nscheduler.print_results()\n\ndemonstrate_convoy_effect()"
            },
            {
                "type": "code",
                "title": "FCFS 적용 사례",
                "language": "Bash",
                "code": "# ===== FCFS가 사용되는 시스템 =====\n# 1. 배치 처리 시스템\n# 작업 큐에 순서대로 실행\nat now + 1 hour <<< \"./job1.sh\"\nat now + 2 hours <<< \"./job2.sh\"\natq  # 큐 확인\n\n# 2. 프린터 스풀러\nlpq  # 인쇄 대기열 확인 (FCFS)\nlp document.pdf  # 인쇄 작업 추가\n\n# 3. 메시지 큐 (RabbitMQ, Kafka)\n# 기본적으로 FIFO 순서로 처리\n\n# ===== Linux에서 FIFO 스케줄링 설정 =====\n# 실시간 FIFO 정책으로 프로세스 실행\nsudo chrt -f 50 ./batch_job.sh\n\n# 현재 프로세스를 FIFO로 변경\nsudo chrt -f -p 50 $$\n\n# FIFO 스케줄링 확인\nchrt -p <pid>\n# scheduling policy: SCHED_FIFO\n\n# ===== Java에서 FCFS 큐 구현 =====\n# LinkedBlockingQueue - FIFO 순서 보장\njava -cp . -Xms512m <<'EOF'\nimport java.util.concurrent.*;\nBlockingQueue<Runnable> queue = new LinkedBlockingQueue<>();\nThreadPoolExecutor executor = new ThreadPoolExecutor(\n    1, 1, 0L, TimeUnit.MILLISECONDS, queue);\n// 작업은 제출 순서대로 실행됨\nEOF\n\n# ===== 배치 작업 스케줄링 =====\n# cron으로 순차 실행\ncrontab -e\n# 0 1 * * * /scripts/job1.sh && /scripts/job2.sh && /scripts/job3.sh"
            },
            {
                "type": "tip",
                "title": "FCFS 특성 및 면접 질문",
                "content": "FCFS 특성 정리:\n\n| 항목          | 내용                    |\n|---------------|------------------------|\n| 선점 여부     | 비선점(Non-preemptive)  |\n| 기아 현상     | 없음                    |\n| 호위 효과     | 발생                    |\n| 구현 복잡도   | O(n) - 매우 단순        |\n| 평균 대기시간 | 최적 아님               |\n| 사용 사례     | 배치 시스템, 프린터 큐  |\n\n호위 효과(Convoy Effect):\n- CPU 바운드 프로세스가 앞에 있으면\n- I/O 바운드 프로세스들이 오래 대기\n- CPU와 I/O 장치 이용률 저하\n- 해결: SJF, Round Robin 사용\n\nFCFS vs SJF:\n| 구분          | FCFS    | SJF      |\n|---------------|---------|----------|\n| 기준          | 도착순  | 실행시간 |\n| 평균 대기시간 | 길다    | 최소     |\n| 기아 현상     | 없음    | 있음     |\n| 예측 필요     | 불필요  | 필요     |\n\n면접 빈출 질문:\n\nQ1: FCFS의 가장 큰 문제점은?\nA: 호위 효과(Convoy Effect)입니다. 긴 작업이 앞에 있으면 짧은 작업들이 불필요하게 오래 기다립니다.\n\nQ2: FCFS에서 기아 현상이 발생하지 않는 이유는?\nA: 모든 프로세스가 도착 순서대로 처리되므로 무한 대기가 발생하지 않습니다.\n\nQ3: FCFS가 적합한 시스템은?\nA: 배치 처리 시스템, 프린터 스풀러 등 순서가 중요하고 응답 시간이 중요하지 않은 시스템입니다."
            }
        ]
    },
    "06_스케줄링/round-robin": {
        "title": "Round Robin",
        "description": "라운드 로빈 스케줄링과 시간 할당량(Time Quantum) 개념을 학습합니다.",
        "sections": [
            {
                "type": "concept",
                "title": "라운드 로빈 - 회전목마 비유",
                "content": "Round Robin이란?\n\n각 프로세스에게 동일한 시간(Time Quantum)을 할당하고 순환하며 실행하는 선점형 스케줄링입니다.\n\n회전목마 비유:\n놀이공원 회전목마처럼 모든 손님이 같은 시간만큼 타고 내립니다.\n\n동작 방식:\n1. Ready Queue에서 프로세스 선택\n2. Time Quantum만큼 실행\n3. 완료 안 되면 Queue 끝으로 이동\n4. 다음 프로세스 실행\n5. 반복\n\n특징:\n- 선점형 (Preemptive)\n- 공정한 CPU 시간 배분\n- 응답 시간 보장\n\nTime Quantum 선택:\n- 너무 크면: FCFS와 같아짐\n- 너무 작으면: 컨텍스트 스위칭 오버헤드\n- 적정 크기: 대부분의 CPU 버스트보다 약간 큼\n\n| Time Quantum | 특징                  |\n|--------------|----------------------|\n| 매우 작음    | 높은 오버헤드        |\n| 작음         | 좋은 응답 시간       |\n| 큼           | FCFS에 가까움        |\n| 최적         | 80%의 CPU 버스트보다 큼 |\n\n장점:\n- 공정한 시간 배분\n- 기아 현상 없음\n- 예측 가능한 응답 시간\n\n단점:\n- 컨텍스트 스위칭 오버헤드\n- Time Quantum 선택이 중요"
            },
            {
                "type": "code",
                "title": "Round Robin 시뮬레이션",
                "language": "Python",
                "code": "# Round Robin 스케줄링 시뮬레이션\nfrom collections import deque\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass Process:\n    pid: str\n    arrival_time: int\n    burst_time: int\n    remaining_time: int = 0\n    start_time: int = -1\n    completion_time: int = 0\n    \n    def __post_init__(self):\n        self.remaining_time = self.burst_time\n\nclass RoundRobinScheduler:\n    def __init__(self, processes: List[Process], time_quantum: int):\n        self.original = processes\n        self.processes = {p.pid: Process(**p.__dict__) for p in processes}\n        self.time_quantum = time_quantum\n        self.timeline = []\n    \n    def schedule(self):\n        \"\"\"Round Robin 스케줄링 실행\"\"\"\n        current_time = 0\n        ready_queue = deque()\n        completed = []\n        waiting = sorted(self.processes.values(), key=lambda p: p.arrival_time)\n        \n        while waiting or ready_queue:\n            # 도착한 프로세스를 Ready Queue에 추가\n            while waiting and waiting[0].arrival_time <= current_time:\n                ready_queue.append(waiting.pop(0))\n            \n            if not ready_queue:\n                current_time = waiting[0].arrival_time if waiting else current_time\n                continue\n            \n            # 프로세스 실행\n            process = ready_queue.popleft()\n            \n            if process.start_time == -1:\n                process.start_time = current_time\n            \n            # 실행 시간 계산\n            exec_time = min(self.time_quantum, process.remaining_time)\n            start = current_time\n            current_time += exec_time\n            process.remaining_time -= exec_time\n            \n            self.timeline.append((process.pid, start, current_time))\n            \n            # 도착한 프로세스 추가 (현재 실행 중 도착한 것들)\n            while waiting and waiting[0].arrival_time <= current_time:\n                ready_queue.append(waiting.pop(0))\n            \n            # 완료 여부 확인\n            if process.remaining_time == 0:\n                process.completion_time = current_time\n                completed.append(process)\n            else:\n                ready_queue.append(process)\n        \n        return completed\n    \n    def print_gantt_chart(self):\n        \"\"\"Gantt 차트 출력\"\"\"\n        print(f\"\\n[Round Robin Gantt Chart] (Time Quantum = {self.time_quantum})\")\n        \n        # 헤더\n        header = \"|\" + \"|\".join([f\"{t[0]:^3}\" for t in self.timeline]) + \"|\"\n        border = \"+\" + \"+\".join([\"-\"*3 for _ in self.timeline]) + \"+\"\n        \n        print(border)\n        print(header)\n        print(border)\n        \n        # 시간 표시\n        times = [f\"{self.timeline[0][1]}\"]\n        for t in self.timeline:\n            times.append(f\"{t[2]}\")\n        print(\" \" + \"   \".join(times[:min(len(times), 20)]))\n    \n    def print_results(self):\n        \"\"\"결과 출력\"\"\"\n        print(f\"\\n[Round Robin 결과] (TQ = {self.time_quantum})\")\n        print(\"+\" + \"-\"*50 + \"+\")\n        print(f\"| {'PID':^5} | {'실행':^6} | {'완료':^6} | {'반환':^8} | {'대기':^8} |\")\n        print(\"+\" + \"-\"*50 + \"+\")\n        \n        total_turnaround = total_waiting = 0\n        for pid, proc in sorted(self.processes.items()):\n            original = next(p for p in self.original if p.pid == pid)\n            turnaround = proc.completion_time - original.arrival_time\n            waiting = turnaround - original.burst_time\n            total_turnaround += turnaround\n            total_waiting += waiting\n            print(f\"| {pid:^5} | {original.burst_time:^6} | {proc.completion_time:^6} | {turnaround:^8} | {waiting:^8} |\")\n        \n        n = len(self.processes)\n        print(\"+\" + \"-\"*50 + \"+\")\n        print(f\"평균 반환 시간: {total_turnaround/n:.2f}\")\n        print(f\"평균 대기 시간: {total_waiting/n:.2f}\")\n\ndef compare_time_quantum():\n    \"\"\"Time Quantum에 따른 성능 비교\"\"\"\n    print(\"\\n\" + \"=\"*50)\n    print(\"[Time Quantum 비교]\")\n    print(\"=\"*50)\n    \n    processes = [\n        Process('P1', 0, 10),\n        Process('P2', 0, 4),\n        Process('P3', 0, 5),\n        Process('P4', 0, 3),\n    ]\n    \n    for tq in [2, 4, 6, 10]:\n        print(f\"\\n--- Time Quantum = {tq} ---\")\n        scheduler = RoundRobinScheduler(\n            [Process(**p.__dict__) for p in processes], tq)\n        scheduler.schedule()\n        scheduler.print_gantt_chart()\n        scheduler.print_results()\n\n# 실행\nprocesses = [\n    Process('P1', 0, 8),\n    Process('P2', 1, 4),\n    Process('P3', 2, 9),\n    Process('P4', 3, 5),\n]\n\nscheduler = RoundRobinScheduler(processes, time_quantum=3)\nscheduler.schedule()\nscheduler.print_gantt_chart()\nscheduler.print_results()\n\ncompare_time_quantum()"
            },
            {
                "type": "code",
                "title": "Round Robin 시스템 설정",
                "language": "Bash",
                "code": "# ===== Linux Round Robin 스케줄링 =====\n# 실시간 Round Robin으로 프로세스 실행\nsudo chrt -r 50 ./my_program\n# -r: SCHED_RR (Round Robin)\n# 50: 우선순위 (1-99, 높을수록 우선)\n\n# 현재 프로세스를 RR로 변경\nsudo chrt -r -p 50 <pid>\n\n# RR Time Quantum 확인 (기본값)\ncat /proc/sys/kernel/sched_rr_timeslice_ms\n# 일반적으로 100ms\n\n# ===== Round Robin 관련 설정 =====\n# CFS 스케줄러 타임슬라이스 설정\nsudo sysctl kernel.sched_rr_timeslice_ms=50\n\n# 스케줄링 지연 시간 설정\nsudo sysctl kernel.sched_latency_ns=6000000\n\n# ===== 프로세스 모니터링 =====\n# 실시간 프로세스 확인\nps -eo pid,cls,pri,ni,cmd | grep -E \"RR|FF\"\n\n# 컨텍스트 스위칭 확인\nvmstat 1 5\n# cs 열: 초당 컨텍스트 스위칭 횟수\n\n# 프로세스별 컨텍스트 스위칭\ncat /proc/<pid>/status | grep ctxt\n\n# ===== JVM Thread 스케줄링 =====\n# 스레드 우선순위 정책 설정\njava -XX:ThreadPriorityPolicy=1 \\\n     -XX:+UseThreadPriorities \\\n     -jar app.jar\n\n# 스레드 스케줄링 확인\njstack <pid> | grep -E \"prio|tid\""
            },
            {
                "type": "tip",
                "title": "Round Robin 최적화 및 면접 질문",
                "content": "Time Quantum 선택 가이드:\n\n| 시스템 유형      | 권장 TQ      | 이유                |\n|------------------|--------------|--------------------|\n| 대화형 시스템    | 10-100ms     | 빠른 응답          |\n| 배치 시스템      | 100-500ms    | 낮은 오버헤드      |\n| 실시간 시스템    | 1-10ms       | 정확한 타이밍      |\n\n컨텍스트 스위칭 오버헤드:\n- 레지스터 저장/복원: ~1us\n- 캐시 무효화: ~10us\n- TLB 플러시: ~100us\n- 총 오버헤드: 수십 ~ 수백 us\n\nTime Quantum vs 성능:\n| TQ    | 응답시간 | 처리량 | 오버헤드 |\n|-------|----------|--------|----------|\n| 1ms   | 매우좋음 | 낮음   | 매우높음 |\n| 10ms  | 좋음     | 중간   | 중간     |\n| 100ms | 보통     | 높음   | 낮음     |\n| 무한  | FCFS     | 최고   | 없음     |\n\n면접 빈출 질문:\n\nQ1: Time Quantum이 너무 작으면 어떤 문제가?\nA: 컨텍스트 스위칭이 너무 자주 발생하여 실제 작업보다 오버헤드가 커집니다.\n\nQ2: Time Quantum이 너무 크면?\nA: FCFS와 동일해져서 응답 시간이 길어지고 Round Robin의 장점이 사라집니다.\n\nQ3: Round Robin에서 기아 현상이 발생하지 않는 이유는?\nA: 모든 프로세스가 순환하며 CPU 시간을 할당받으므로 무한 대기가 발생하지 않습니다.\n\nQ4: n개의 프로세스가 있고 TQ가 q일 때, 최대 응답 시간은?\nA: (n-1) * q입니다. 자신의 차례가 오기 전에 최대 n-1개의 프로세스가 실행됩니다."
            }
        ]
    }
}

def main():
    # os.json 파일 읽기
    with open(OS_JSON_PATH, 'r', encoding='utf-8') as f:
        os_data = json.load(f)

    # 각 토픽 업데이트
    for topic_id, topic_content in TOPICS.items():
        if topic_id in os_data:
            os_data[topic_id]["title"] = topic_content["title"]
            os_data[topic_id]["description"] = topic_content["description"]
            os_data[topic_id]["sections"] = topic_content["sections"]
            os_data[topic_id]["isPlaceholder"] = False
            print(f"Updated: {topic_id}")
        else:
            print(f"Warning: {topic_id} not found in os.json")

    # os.json 파일 저장
    with open(OS_JSON_PATH, 'w', encoding='utf-8') as f:
        json.dump(os_data, f, ensure_ascii=False, indent=2)

    print(f"\nSuccessfully updated {len(TOPICS)} topics in os.json")

if __name__ == "__main__":
    main()
