{
  "id": "python-day17",
  "language": "python",
  "day": 17,
  "title": "그리디",
  "examScope": "pccp",
  "difficultyLevel": 4,
  "estimatedTime": "75분",
  "difficulty": "중급",
  "pcceWeight": "★★☆☆☆",
  "keywords": ["그리디", "탐욕법", "최적선택", "거스름돈", "회의실배정"],

  "sections": {
    "A_principle": {
      "title": "🎯 원리 이해",

      "analogy": {
        "title": "그리디 = 뷔페에서 비싼 것 먼저 먹기",
        "explanation": "뷔페에서 배가 찰 때까지 가장 비싼 음식부터 먹으면 '가성비'가 최대입니다. 그리디도 마찬가지로 매 순간 가장 좋은 선택을 합니다. 거스름돈 문제에서 큰 동전부터 쓰는 것이 대표적 예입니다.",
        "codeExample": "# 거스름돈: 큰 동전부터\nfor coin in [500, 100, 50, 10]:\n    count += money // coin  # 현재 최선\n    money %= coin"
      },

      "whyNeeded": {
        "realWorld": "매 순간 가장 좋아 보이는 선택. 거스름돈, 일정 관리 등.",
        "inExam": "PCCE에서 간단한 그리디 문제 출제. 거스름돈이 대표적."
      },

      "coreIdea": {
        "oneLiner": "그리디 = 매 단계에서 현재 최선의 선택을 함",
        "key": "전체 최적해를 보장하지는 않지만, 특정 조건에서는 보장됨"
      },

      "when": {
        "title": "그리디가 통하는 경우",
        "cases": [
          "탐욕적 선택이 전체 최적해로 이어질 때",
          "부분 문제의 최적해가 전체의 최적해일 때",
          "거스름돈 문제 (큰 단위부터)",
          "활동 선택 문제 (종료 시간 빠른 것부터)"
        ]
      },

      "commonMisunderstanding": {
        "wrong": {"belief": "그리디는 항상 최적해를 준다"},
        "correct": {"belief": "특정 조건에서만 최적해 보장. 반례가 없는지 확인 필요"}
      }
    },

    "B_examinerIntent": {
      "title": "🎯 출제자 의도 분석",

      "whatTheyTest": {
        "primary": "그리디 선택 기준을 올바르게 잡는가?",
        "secondary": "정렬 후 선택하는 패턴을 아는가?",
        "tertiary": "그리디가 적용 가능한 상황을 파악하는가?"
      },

      "questionPatterns": [
        {
          "type": "거스름돈",
          "frequency": "★★★★★",
          "example": "최소 동전 개수"
        },
        {
          "type": "활동 선택",
          "frequency": "★★★☆☆",
          "example": "겹치지 않는 최대 활동 수"
        },
        {
          "type": "분할 가능 배낭",
          "frequency": "★★☆☆☆",
          "example": "가치/무게 비율 높은 것부터"
        }
      ]
    },

    "C_codePhilosophy": {
      "title": "💻 코드 철학",

      "examples": [
        {
          "title": "예제 1: 거스름돈 (기본)",
          "problem": "500, 100, 50, 10원 동전으로 거슬러 줄 최소 개수",
          "code": "money = int(input())  # 1260\ncoins = [500, 100, 50, 10]\ncount = 0\n\nfor coin in coins:\n    count += money // coin  # 해당 동전 개수\n    money %= coin           # 남은 금액\n\nprint(count)  # 6 (500*2 + 100*2 + 50*1 + 10*1)",
          "keyInsight": "큰 동전부터 최대한 많이"
        },
        {
          "title": "예제 2: 회의실 배정",
          "problem": "회의 시간이 겹치지 않게 최대 몇 개 배정",
          "code": "# (시작, 종료) 회의 목록\nmeetings = [(1,4), (3,5), (0,6), (5,7), (3,8), (5,9)]\n\n# 종료 시간 기준 정렬\nmeetings.sort(key=lambda x: x[1])\n\ncount = 0\nend_time = 0\n\nfor start, end in meetings:\n    if start >= end_time:  # 이전 회의 끝난 후\n        count += 1\n        end_time = end\n\nprint(count)  # 4",
          "keyInsight": "종료 시간 빠른 것부터 선택"
        },
        {
          "title": "예제 3: 큰 수 만들기",
          "problem": "숫자를 k개 제거해서 가장 큰 수",
          "code": "number = '1924'\nk = 2\nstack = []\n\nfor digit in number:\n    while stack and k > 0 and stack[-1] < digit:\n        stack.pop()\n        k -= 1\n    stack.append(digit)\n\n# 남은 k개 제거 (뒤에서)\nresult = ''.join(stack[:len(stack)-k]) if k else ''.join(stack)\nprint(result)  # 94",
          "keyInsight": "앞자리가 클수록 유리"
        },
        {
          "title": "예제 4: 체육복",
          "problem": "여벌 있는 학생이 앞뒤 번호에게 빌려줌",
          "code": "n = 5\nlost = [2, 4]      # 도난당한 학생\nreserve = [1, 3, 5]  # 여벌 있는 학생\n\n# 여벌 있는데 도난당한 경우 처리\nactual_lost = [x for x in lost if x not in reserve]\nactual_reserve = [x for x in reserve if x not in lost]\n\nfor r in sorted(actual_reserve):\n    if r - 1 in actual_lost:\n        actual_lost.remove(r - 1)\n    elif r + 1 in actual_lost:\n        actual_lost.remove(r + 1)\n\nprint(n - len(actual_lost))",
          "keyInsight": "앞번호 먼저 빌려주기"
        }
      ]
    },

    "D_realExamPatterns": {
      "title": "📝 실전 기출 패턴",

      "patterns": [
        {
          "patternName": "패턴 1: 거스름돈",
          "frequency": "★★★★★",
          "exampleProblem": {
            "question": "1160원을 500,100,50,10원으로 최소 동전",
            "answer": "6개 (500*2+100*1+50*1+10*1)"
          }
        },
        {
          "patternName": "패턴 2: 정렬 후 선택",
          "frequency": "★★★★☆",
          "exampleProblem": {
            "question": "특정 기준으로 정렬 후 그리디 선택",
            "answer": "sort(key=...) 후 순회"
          }
        },
        {
          "patternName": "패턴 3: 최소/최대",
          "frequency": "★★★☆☆",
          "exampleProblem": {
            "question": "합이 최대가 되도록 선택",
            "answer": "큰 것부터 또는 작은 것부터"
          }
        }
      ]
    },

    "E_thinkingProcess": {
      "title": "🧠 사고 과정 시뮬레이션",

      "sampleProblem": {
        "question": "30명에게 사탕 나눠주기. 사탕 [1,2,3,4,5], 최대 몇 명에게?",
        "answer": "최소 개수부터 주면 최대 인원"
      },

      "steps": [
        {"phase": "1️⃣ 그리디 적합성", "time": "30초", "thinking": "적게 쓰면 많이 줄 수 있음 → 그리디 OK"},
        {"phase": "2️⃣ 선택 기준", "time": "30초", "thinking": "작은 것부터 선택 → 오름차순 정렬"},
        {"phase": "3️⃣ 종료 조건", "time": "30초", "thinking": "누적합이 total 초과하면 중단"},
        {"phase": "4️⃣ 코드 작성", "time": "1분 30초", "code": "candies.sort()\ncount, used = 0, 0\nfor c in candies:\n    if used + c <= total:\n        used += c\n        count += 1\n    else: break"},
        {"phase": "5️⃣ 반례 확인", "time": "30초", "thinking": "1+2+3+4+5=15 ≤ 30, 5명 모두 가능 ✓"}
      ],

      "whenStuck": {
        "그리디_불가_의심": "반례 찾아보기. 없으면 그리디 OK",
        "정렬_기준_혼란": "최대→내림차순, 최소→오름차순",
        "선택_조건_실수": "언제 선택하고 언제 패스하는지 명확히",
        "상태_업데이트_누락": "선택 후 상태(남은양, 끝시간 등) 업데이트"
      }
    },

    "F_languageSpecific": {
      "title": "🐍 Python 특화 팁",

      "usefulPatterns": [
        {"pattern": "정렬 후 순회", "code": "sorted(items, key=...)"},
        {"pattern": "몫과 나머지", "code": "count = money // coin; money %= coin"},
        {"pattern": "조건부 선택", "code": "if condition: select()"}
      ],

      "commonPitfalls": [
        {"pitfall": "그리디 적용 불가 상황", "note": "반례 확인 필수"},
        {"pitfall": "정렬 기준 실수", "note": "오름차순/내림차순 확인"},
        {"pitfall": "경계 조건", "note": "딱 맞거나 부족한 경우"}
      ]
    },

    "G_mistakePrevention": {
      "title": "⚠️ 실수 방지 체크리스트",

      "top5Mistakes": [
        {
          "rank": 1,
          "mistake": "그리디 적용 불가인데 적용",
          "frequency": "70%",
          "wrongCode": "# 동전: [1, 3, 4], 6원 → 4+1+1=3개",
          "correctCode": "# 실제 최적: 3+3=2개 → 그리디 불가",
          "result": "최적해 아님"
        },
        {
          "rank": 2,
          "mistake": "정렬 기준 실수",
          "frequency": "65%",
          "wrongCode": "meetings.sort()  # 시작 시간순",
          "correctCode": "meetings.sort(key=lambda x: x[1])  # 종료 시간순",
          "result": "선택 기준 오류"
        },
        {
          "rank": 3,
          "mistake": "선택 조건 실수",
          "frequency": "60%",
          "wrongCode": "if start > end_time:  # 등호 누락",
          "correctCode": "if start >= end_time:  # 딱 끝나면 시작 가능",
          "result": "선택 가능한데 안 함"
        },
        {
          "rank": 4,
          "mistake": "경계 조건 미처리",
          "frequency": "55%",
          "wrongCode": "count += money // coin  # 나머지 처리 안 함",
          "correctCode": "count += money // coin\nmoney %= coin",
          "result": "남은 금액 누적"
        },
        {
          "rank": 5,
          "mistake": "상태 업데이트 누락",
          "frequency": "50%",
          "wrongCode": "if start >= end_time: count += 1",
          "correctCode": "if start >= end_time:\n    count += 1\n    end_time = end",
          "result": "다음 선택 기준 안 바뀜"
        }
      ],

      "edgeCases": [
        {"case": "빈 입력", "handling": "탐색할 것 없으면 0 반환"},
        {"case": "정확히 맞는 경우", "handling": ">= 조건으로 처리"},
        {"case": "모두 선택 불가", "handling": "0 또는 불가능 반환"}
      ],

      "finalChecklist": [
        "✅ 그리디 적용 가능한지 반례 확인",
        "✅ 정렬 기준 (오름/내림) 정확히",
        "✅ 선택 후 상태 업데이트",
        "✅ 경계 조건 (딱 맞는 경우) 처리"
      ]
    },

    "H_aiUsageGuide": {
      "title": "🤖 AI 활용 가이드",

      "effectivePrompts": [
        {
          "situation": "그리디 적용 가능성",
          "badPrompt": "그리디로 풀 수 있어?",
          "goodPrompt": "이 문제에 그리디를 적용할 수 있는지, 반례가 있으면 알려줘. 반례 없으면 선택 기준도 알려줘",
          "whyGood": "적용 가능성과 기준을 함께 확인"
        },
        {
          "situation": "정렬 기준",
          "badPrompt": "어떻게 정렬해",
          "goodPrompt": "회의실 배정 문제에서 시작 시간순 vs 종료 시간순 정렬의 차이를 예제로 비교해줘",
          "whyGood": "두 방법 비교로 올바른 기준 이해"
        },
        {
          "situation": "반례 확인",
          "badPrompt": "이 풀이 맞아?",
          "goodPrompt": "이 그리디 풀이가 실패하는 반례 입력이 있는지 찾아줘",
          "whyGood": "반례 존재 여부 직접 확인"
        }
      ],

      "warningAboutCopyPaste": {
        "message": "그리디는 '왜' 최적인지 이해해야 합니다",
        "recommendation": "거스름돈, 회의실 배정 등 대표 문제의 증명 과정 이해하기"
      },

      "selfCheckQuestion": [
        "그리디 선택이 전체 최적해로 이어지는가?",
        "반례가 존재하지 않는가?",
        "정렬 기준 (오름/내림)이 맞는가?",
        "선택 후 상태 업데이트하는가?"
      ]
    }
  },

  "practice": {
    "problems": [
      {
        "id": "d17-p1",
        "type": "코드작성",
        "difficulty": "중",
        "question": "800원을 500,100,50,10원으로 최소 동전 개수",
        "output": "4",
        "answer": {"code": "money = 800\ncoins = [500, 100, 50, 10]\ncount = 0\nfor c in coins:\n    count += money // c\n    money %= c\nprint(count)"}
      },
      {
        "id": "d17-p2",
        "type": "코드작성",
        "difficulty": "중",
        "question": "숫자 리스트에서 k개 선택해 합 최대",
        "input": "[5, 1, 3, 7, 2], k=3",
        "output": "15",
        "answer": {"code": "nums = [5, 1, 3, 7, 2]\nk = 3\nnums.sort(reverse=True)\nprint(sum(nums[:k]))"}
      },
      {
        "id": "d17-p3",
        "type": "코드작성",
        "difficulty": "중",
        "question": "리스트에서 두 수의 차이 최소",
        "input": "[3, 8, 1, 5]",
        "output": "2",
        "answer": {"code": "nums = [3, 8, 1, 5]\nnums.sort()\nmin_diff = float('inf')\nfor i in range(len(nums)-1):\n    diff = nums[i+1] - nums[i]\n    if diff < min_diff:\n        min_diff = diff\nprint(min_diff)"}
      },
      {
        "id": "d17-p4",
        "type": "코드작성",
        "difficulty": "상",
        "question": "회의 배정: 겹치지 않게 최대 개수 (종료 시간순)",
        "input": "[(1,4), (3,5), (0,6), (5,7)]",
        "output": "3",
        "answer": {"code": "meetings = [(1,4), (3,5), (0,6), (5,7)]\nmeetings.sort(key=lambda x: x[1])\ncount = 0\nend = 0\nfor s, e in meetings:\n    if s >= end:\n        count += 1\n        end = e\nprint(count)"}
      },
      {
        "id": "d17-p5",
        "type": "코드작성",
        "difficulty": "상",
        "question": "카드 숫자 합: 두 카드씩 뽑아 합치기, 최소 비용",
        "input": "[10, 20, 30, 40]",
        "output": "190",
        "answer": {"code": "import heapq\ncards = [10, 20, 30, 40]\nheapq.heapify(cards)\ntotal = 0\nwhile len(cards) > 1:\n    a = heapq.heappop(cards)\n    b = heapq.heappop(cards)\n    s = a + b\n    total += s\n    heapq.heappush(cards, s)\nprint(total)"},
        "explanation": "작은 것부터 합치면 비용 최소"
      }
    ]
  },

  "summary": {
    "todayKey": "그리디 = 현재 최선의 선택. 단, 전체 최적 보장되는지 확인!",
    "examinerMindset": "그리디 선택 기준, 정렬 후 선택, 반례 확인",
    "mustRemember": ["현재 최선 선택", "정렬 후 순회", "반례 확인", "거스름돈 패턴"],
    "tomorrowPreview": {"topic": "Day 18: DP 기초", "connection": "그리디가 안 되면 DP로. 부분 문제 결과 저장"}
  }
}
