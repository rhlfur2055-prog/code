{
  "01_python-basics/01_variables": {
    "id": "01_python-basics/01_variables",
    "title": "01 Variables",
    "category": "ai-roadmap",
    "subCategory": "01_python-basics",
    "language": "Python",
    "description": "Python 변수의 개념, 선언, 타입, 명명 규칙을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "변수란 무엇인가",
        "content": "변수(Variable)는 데이터를 저장하는 메모리 공간의 이름입니다. Python에서 변수는 데이터를 담는 상자와 같으며, 프로그램 실행 중 값을 저장하고 재사용할 수 있게 합니다.\n\n**변수의 특징:**\n- Python은 동적 타이핑(Dynamic Typing)을 사용하여 변수 선언 시 타입을 명시하지 않아도 됩니다\n- 변수는 할당 연산자(=)를 사용하여 값을 저장합니다\n- 변수명은 대소문자를 구분하며, 영문자, 숫자, 언더스코어(_)로 구성됩니다\n- 숫자로 시작할 수 없으며, 예약어(if, for, class 등)는 사용할 수 없습니다\n\n**Python의 주요 데이터 타입:**\n- 정수형(int): 소수점이 없는 숫자\n- 실수형(float): 소수점이 있는 숫자\n- 문자열(str): 텍스트 데이터\n- 불린(bool): True/False 논리값\n- None: 값이 없음을 나타냄"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# 1. 기본 변수 선언과 할당\nname = \"Alice\"          # 문자열\nage = 25                # 정수\nheight = 165.5          # 실수\nis_student = True       # 불린\ndata = None             # None 타입\n\n# 2. 변수 타입 확인\nprint(type(name))       # <class 'str'>\nprint(type(age))        # <class 'int'>\nprint(type(height))     # <class 'float'>\nprint(type(is_student)) # <class 'bool'>\n\n# 3. 다중 할당\nx, y, z = 10, 20, 30\nprint(f\"x={x}, y={y}, z={z}\")  # x=10, y=20, z=30\n\n# 4. 같은 값 다중 할당\na = b = c = 100\nprint(a, b, c)          # 100 100 100\n\n# 5. 변수 값 교환\nx, y = 5, 10\nx, y = y, x             # Swap\nprint(f\"x={x}, y={y}\")  # x=10, y=5\n\n# 6. 타입 변환 (Type Casting)\nnum_str = \"123\"\nnum_int = int(num_str)  # 문자열 → 정수\nnum_float = float(num_str)  # 문자열 → 실수\nstr_num = str(456)      # 정수 → 문자열\n\nprint(f\"{num_int} ({type(num_int)})\")    # 123 (<class 'int'>)\nprint(f\"{num_float} ({type(num_float)})\")  # 123.0 (<class 'float'>)\nprint(f\"{str_num} ({type(str_num)})\")    # 456 (<class 'str'>)\n\n# 7. f-string을 사용한 변수 출력\nname = \"Bob\"\nage = 30\nprint(f\"{name}님의 나이는 {age}세입니다.\")  # Bob님의 나이는 30세입니다."
      },
      {
        "type": "use-case",
        "title": "실무 활용 사례",
        "content": "**1. 데이터 분석: 데이터 전처리**\n```python\nimport pandas as pd\n\n# 데이터프레임 로드\ndf = pd.read_csv('sales_data.csv')\n\n# 변수에 계산 결과 저장\ntotal_sales = df['sales'].sum()\naverage_sales = df['sales'].mean()\nmax_sales = df['sales'].max()\n\nprint(f\"총 매출: {total_sales:,}원\")\nprint(f\"평균 매출: {average_sales:,.2f}원\")\nprint(f\"최고 매출: {max_sales:,}원\")\n```\n\n**2. 웹 스크래핑: 설정값 관리**\n```python\nimport requests\nfrom bs4 import BeautifulSoup\n\n# API 요청 설정값을 변수로 관리\nbase_url = \"https://api.example.com\"\napi_key = \"your_api_key_here\"\nheaders = {\"Authorization\": f\"Bearer {api_key}\"}\ntimeout = 30\n\n# 요청 실행\nresponse = requests.get(base_url, headers=headers, timeout=timeout)\ndata = response.json()\n```\n\n**3. 머신러닝: 하이퍼파라미터 관리**\n```python\nfrom sklearn.ensemble import RandomForestClassifier\n\n# 모델 학습 파라미터를 변수로 관리\nn_estimators = 100\nmax_depth = 10\nrandom_state = 42\ntest_size = 0.2\n\nmodel = RandomForestClassifier(\n    n_estimators=n_estimators,\n    max_depth=max_depth,\n    random_state=random_state\n)\n```\n\n**4. 설정 파일 관리**\n```python\n# config.py\nDATABASE_URL = \"postgresql://localhost/mydb\"\nMAX_CONNECTIONS = 10\nDEBUG = True\nLOG_LEVEL = \"INFO\"\n\n# main.py\nimport config\n\nif config.DEBUG:\n    print(f\"데이터베이스 연결: {config.DATABASE_URL}\")\n```"
      },
      {
        "type": "best-practice",
        "title": "변수 명명 규칙과 모범 사례",
        "content": "**1. Snake Case 명명 규칙 (PEP 8)**\n```python\n# Good: snake_case 사용\nuser_name = \"Alice\"\ntotal_count = 100\nmax_retry_attempts = 3\n\n# Bad: camelCase는 Python에서 권장하지 않음\nuserName = \"Alice\"      # X\ntotalCount = 100        # X\n```\n\n**2. 의미 있는 변수명 사용**\n```python\n# Good: 명확하고 설명적인 이름\nstudent_count = 30\naverage_score = 85.5\nis_valid = True\n\n# Bad: 모호하거나 너무 짧은 이름\nn = 30                  # X (무엇의 개수인지 불명확)\navg = 85.5              # X (축약어 남발)\nf = True                # X (의미 파악 불가)\n```\n\n**3. 상수는 대문자와 언더스코어로 표기**\n```python\n# 상수 (변경되지 않는 값)\nMAX_SIZE = 1000\nPI = 3.14159\nDEFAULT_TIMEOUT = 30\nAPI_BASE_URL = \"https://api.example.com\"\n```\n\n**4. 타입 힌트 사용 (Python 3.5+)**\n```python\nfrom typing import List, Dict, Optional\n\n# 타입 힌트로 변수의 예상 타입 명시\nname: str = \"Alice\"\nage: int = 25\nscores: List[int] = [85, 90, 78]\nuser_data: Dict[str, str] = {\"name\": \"Bob\", \"email\": \"bob@example.com\"}\noptional_value: Optional[int] = None  # None일 수 있는 값\n```\n\n**5. Private 변수는 언더스코어로 시작**\n```python\nclass User:\n    def __init__(self, name: str, password: str):\n        self.name = name              # Public\n        self._age = 0                 # Protected (관례상)\n        self.__password = password    # Private (Name Mangling)\n```\n\n**6. 불필요한 변수 생성 지양**\n```python\n# Bad: 한 번만 사용되는 변수\ntemp_result = calculate_total(data)\nreturn temp_result\n\n# Good: 직접 반환\nreturn calculate_total(data)\n```"
      },
      {
        "type": "common-mistake",
        "title": "흔한 실수와 해결책",
        "content": "**1. 가변(Mutable) 타입 변수 할당 시 참조 문제**\n```python\n# 실수: 리스트는 참조가 복사됨\nlist1 = [1, 2, 3]\nlist2 = list1           # 같은 객체를 참조\nlist2.append(4)\nprint(list1)            # [1, 2, 3, 4] - list1도 변경됨!\n\n# 해결책: copy() 또는 슬라이싱 사용\nlist1 = [1, 2, 3]\nlist2 = list1.copy()    # 새로운 객체 생성\n# 또는\nlist2 = list1[:]        # 슬라이싱으로 복사\nlist2.append(4)\nprint(list1)            # [1, 2, 3] - list1은 변경되지 않음\n```\n\n**2. 변수명 철자 오류**\n```python\n# 실수: 변수명 오타\nuser_name = \"Alice\"\nprint(usre_name)        # NameError: name 'usre_name' is not defined\n\n# 해결책: IDE의 자동완성 기능 활용, 린터 사용\n```\n\n**3. 전역 변수와 지역 변수 혼동**\n```python\n# 실수: 전역 변수 수정하려고 했으나 지역 변수 생성\ncount = 0\n\ndef increment():\n    count = count + 1   # UnboundLocalError!\n\n# 해결책 1: global 키워드 사용\ncount = 0\n\ndef increment():\n    global count\n    count = count + 1\n\n# 해결책 2: 클래스 또는 딕셔너리 사용 (더 권장)\nclass Counter:\n    def __init__(self):\n        self.count = 0\n    \n    def increment(self):\n        self.count += 1\n```\n\n**4. 예약어를 변수명으로 사용**\n```python\n# 실수: Python 예약어 사용\nclass = \"Math\"          # SyntaxError!\nfor = 10                # SyntaxError!\n\n# 해결책: 다른 이름 사용\nclass_name = \"Math\"\nloop_count = 10\n```\n\n**5. 타입 변환 시 에러 처리 누락**\n```python\n# 실수: 변환할 수 없는 값에 대한 예외 처리 없음\nuser_input = \"abc\"\nage = int(user_input)   # ValueError: invalid literal for int()\n\n# 해결책: try-except 사용\nuser_input = \"abc\"\ntry:\n    age = int(user_input)\nexcept ValueError:\n    print(\"유효한 숫자를 입력해주세요.\")\n    age = 0\n```"
      },
      {
        "type": "tip",
        "title": "변수 사용 팁",
        "content": "**1. 변수 존재 여부 확인**\n```python\n# 변수가 정의되어 있는지 확인\nif 'my_var' in locals():  # 지역 변수\n    print(f\"my_var = {my_var}\")\n\nif 'MY_CONST' in globals():  # 전역 변수\n    print(f\"MY_CONST = {MY_CONST}\")\n```\n\n**2. 여러 변수를 한 번에 삭제**\n```python\nx, y, z = 1, 2, 3\ndel x, y, z  # 여러 변수 동시 삭제\n```\n\n**3. Walrus Operator (:=) 활용 (Python 3.8+)**\n```python\n# 할당과 동시에 조건 검사\nif (n := len(data)) > 10:\n    print(f\"데이터가 {n}개로 너무 많습니다.\")\n\n# 리스트 컴프리헨션에서 중복 계산 방지\nresults = [y for x in data if (y := expensive_function(x)) is not None]\n```\n\n**4. 언패킹(Unpacking)으로 깔끔한 코드**\n```python\n# 리스트/튜플 언패킹\nfirst, *middle, last = [1, 2, 3, 4, 5]\nprint(first)    # 1\nprint(middle)   # [2, 3, 4]\nprint(last)     # 5\n\n# 딕셔너리 언패킹\nuser = {\"name\": \"Alice\", \"age\": 25}\nprint({**user, \"city\": \"Seoul\"})  # 병합\n```\n\n**5. 환경 변수 활용**\n```python\nimport os\nfrom dotenv import load_dotenv\n\n# .env 파일에서 환경 변수 로드\nload_dotenv()\n\nAPI_KEY = os.getenv(\"API_KEY\", \"default_key\")\nDATABASE_URL = os.environ[\"DATABASE_URL\"]  # 필수값\n```\n\n**6. 변수 스왑을 활용한 알고리즘 최적화**\n```python\n# 리스트 정렬 시 스왑 활용 (버블 정렬 예시)\narr = [5, 2, 8, 1, 9]\nfor i in range(len(arr)):\n    for j in range(len(arr) - 1 - i):\n        if arr[j] > arr[j + 1]:\n            arr[j], arr[j + 1] = arr[j + 1], arr[j]  # Swap\nprint(arr)  # [1, 2, 5, 8, 9]\n```"
      },
      {
        "type": "practice",
        "title": "연습 문제",
        "content": "**문제 1: 기본 변수 연습**\n다음 변수들을 선언하고 출력하세요:\n- 당신의 이름 (문자열)\n- 나이 (정수)\n- 키 (실수, cm 단위)\n- 학생 여부 (불린)\n\n**문제 2: 변수 스왑**\n두 변수 `a = 10`, `b = 20`의 값을 서로 교환하세요. (임시 변수 없이)\n\n**문제 3: 타입 변환**\n사용자로부터 문자열로 입력받은 \"123\"을 정수로, \"45.67\"을 실수로 변환하고, 두 값을 더한 결과를 출력하세요.\n\n**문제 4: 다중 할당**\n한 줄의 코드로 `x, y, z`에 각각 100, 200, 300을 할당하세요.\n\n**문제 5: 환경 설정 변수**\n다음 정보를 상수로 정의하세요:\n- 최대 연결 수: 50\n- 타임아웃: 30초\n- API URL: \"https://api.example.com\"\n\n**문제 6: 실전 문제**\n온라인 쇼핑몰에서 다음 정보를 변수로 관리하세요:\n- 상품명, 가격, 수량, 할인율(%)을 변수에 저장\n- 최종 결제 금액 계산 (원가 * 수량 * (1 - 할인율/100))\n- f-string을 사용하여 결과 출력\n\n```python\n# 예시 출력:\n# 상품명: 노트북\n# 원가: 1,000,000원\n# 수량: 2개\n# 할인율: 10%\n# 최종 결제 금액: 1,800,000원\n```\n\n**보너스 문제:**\nWalrus Operator(:=)를 사용하여 리스트에서 길이가 5 이상인 문자열만 필터링하면서, 각 문자열의 길이도 함께 출력하세요.\n```python\nwords = [\"apple\", \"banana\", \"cat\", \"elephant\", \"dog\"]\n# 출력: banana(6), elephant(8)\n```"
      }
    ]
  },
  "01_python-basics/02_control_flow": {
    "id": "01_python-basics/02_control_flow",
    "title": "02 Control Flow",
    "category": "ai-roadmap",
    "subCategory": "01_python-basics",
    "language": "Python",
    "description": "Python 조건문(if), 반복문(for, while)을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "제어문(Control Flow)이란",
        "content": "제어문은 프로그램의 실행 흐름을 제어하는 구문입니다. Python의 제어문은 크게 **조건문(Conditional Statements)**과 **반복문(Loops)**으로 나뉩니다.\n\n**1. 조건문 (Conditional Statements)**\n- 특정 조건이 참(True)일 때만 코드 블록을 실행합니다\n- `if`, `elif`, `else` 키워드를 사용합니다\n- 조건식은 불린(Boolean) 값으로 평가됩니다\n\n**2. 반복문 (Loops)**\n- 코드 블록을 여러 번 반복 실행합니다\n- `for` 루프: 시퀀스(리스트, 문자열 등)를 순회할 때 사용\n- `while` 루프: 조건이 참인 동안 계속 실행\n\n**3. 제어 키워드**\n- `break`: 반복문을 즉시 종료\n- `continue`: 현재 반복을 건너뛰고 다음 반복으로 이동\n- `pass`: 아무것도 하지 않음 (자리 표시자)\n\n**들여쓰기 규칙:**\nPython은 들여쓰기(Indentation)로 코드 블록을 구분합니다. 일반적으로 스페이스 4개를 사용합니다."
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ===== 1. if 조건문 =====\nage = 20\n\nif age >= 18:\n    print(\"성인입니다.\")\n\n# if-else\nscore = 85\n\nif score >= 60:\n    print(\"합격입니다.\")\nelse:\n    print(\"불합격입니다.\")\n\n# if-elif-else\ngrade = 88\n\nif grade >= 90:\n    print(\"A 등급\")\nelif grade >= 80:\n    print(\"B 등급\")  # 실행됨\nelif grade >= 70:\n    print(\"C 등급\")\nelse:\n    print(\"D 등급\")\n\n# ===== 2. 비교 연산자와 논리 연산자 =====\nx, y = 10, 20\n\n# 비교 연산자: ==, !=, <, >, <=, >=\nif x < y:\n    print(f\"{x}는 {y}보다 작습니다.\")\n\n# 논리 연산자: and, or, not\ntemp = 25\nif temp >= 20 and temp <= 30:\n    print(\"적정 온도입니다.\")\n\nraining = False\nif not raining:\n    print(\"우산이 필요 없습니다.\")\n\n# ===== 3. for 루프 (시퀀스 순회) =====\n# 리스트 순회\nfruits = [\"사과\", \"바나나\", \"체리\"]\nfor fruit in fruits:\n    print(fruit)\n\n# range() 함수 사용\nfor i in range(5):  # 0, 1, 2, 3, 4\n    print(i)\n\nfor i in range(1, 6):  # 1, 2, 3, 4, 5\n    print(i)\n\nfor i in range(0, 10, 2):  # 0, 2, 4, 6, 8 (step=2)\n    print(i)\n\n# enumerate()로 인덱스와 값 함께 가져오기\ncolors = [\"빨강\", \"파랑\", \"초록\"]\nfor index, color in enumerate(colors):\n    print(f\"{index}: {color}\")\n\n# ===== 4. while 루프 =====\ncount = 0\nwhile count < 5:\n    print(f\"count = {count}\")\n    count += 1\n\n# 무한 루프 (조건 검사로 탈출)\nwhile True:\n    user_input = input(\"종료하려면 'q'를 입력하세요: \")\n    if user_input == 'q':\n        break\n    print(f\"입력값: {user_input}\")\n\n# ===== 5. break와 continue =====\n# break: 루프 즉시 종료\nfor i in range(10):\n    if i == 5:\n        break  # i가 5일 때 루프 종료\n    print(i)  # 0, 1, 2, 3, 4 출력\n\n# continue: 현재 반복 건너뛰기\nfor i in range(10):\n    if i % 2 == 0:  # 짝수이면\n        continue    # 건너뛰기\n    print(i)  # 1, 3, 5, 7, 9 출력 (홀수만)\n\n# ===== 6. 중첩 루프 =====\n# 구구단 2단부터 9단까지\nfor i in range(2, 10):\n    for j in range(1, 10):\n        print(f\"{i} x {j} = {i*j}\")\n    print()  # 단 구분\n\n# ===== 7. 리스트 컴프리헨션 (간결한 for 루프) =====\n# 기본 for 루프\nsquares = []\nfor i in range(10):\n    squares.append(i ** 2)\n\n# 리스트 컴프리헨션\nsquares = [i ** 2 for i in range(10)]\nprint(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n# 조건 포함\neven_squares = [i ** 2 for i in range(10) if i % 2 == 0]\nprint(even_squares)  # [0, 4, 16, 36, 64]\n\n# ===== 8. pass 키워드 =====\n# 아직 구현하지 않은 함수/클래스의 자리 표시\ndef my_function():\n    pass  # 나중에 구현 예정\n\nfor i in range(5):\n    if i == 3:\n        pass  # 아무것도 하지 않음\n    else:\n        print(i)"
      },
      {
        "type": "use-case",
        "title": "실무 활용 사례",
        "content": "**1. 데이터 검증 및 필터링**\n```python\nimport pandas as pd\n\n# CSV 데이터 로드\ndf = pd.read_csv('users.csv')\n\n# 나이가 18세 이상인 사용자만 필터링\nvalid_users = []\nfor index, row in df.iterrows():\n    if row['age'] >= 18:\n        valid_users.append(row)\n        print(f\"{row['name']}님은 성인입니다.\")\n    else:\n        print(f\"{row['name']}님은 미성년자입니다.\")\n\n# 조건에 맞는 데이터 카운팅\nadult_count = sum(1 for age in df['age'] if age >= 18)\nprint(f\"성인 사용자 수: {adult_count}명\")\n```\n\n**2. API 요청 재시도 로직**\n```python\nimport requests\nimport time\n\nurl = \"https://api.example.com/data\"\nmax_retries = 3\nretry_count = 0\n\nwhile retry_count < max_retries:\n    try:\n        response = requests.get(url, timeout=5)\n        if response.status_code == 200:\n            data = response.json()\n            print(\"데이터 수신 성공\")\n            break\n        else:\n            print(f\"에러 코드: {response.status_code}\")\n            retry_count += 1\n    except requests.exceptions.Timeout:\n        print(f\"타임아웃 발생. 재시도 {retry_count + 1}/{max_retries}\")\n        retry_count += 1\n        time.sleep(2)  # 2초 대기 후 재시도\nelse:\n    print(\"최대 재시도 횟수 초과\")\n```\n\n**3. 파일 처리 및 변환**\n```python\nimport os\nimport json\n\n# 디렉토리 내 모든 JSON 파일 처리\ndata_dir = './data'\nprocessed_files = []\n\nfor filename in os.listdir(data_dir):\n    if not filename.endswith('.json'):\n        continue  # JSON 파일이 아니면 건너뛰기\n    \n    filepath = os.path.join(data_dir, filename)\n    \n    with open(filepath, 'r', encoding='utf-8') as f:\n        data = json.load(f)\n        \n        # 데이터 검증\n        if 'id' not in data or 'name' not in data:\n            print(f\"{filename}: 필수 필드 누락\")\n            continue\n        \n        processed_files.append(filename)\n        print(f\"{filename} 처리 완료\")\n\nprint(f\"총 {len(processed_files)}개 파일 처리됨\")\n```\n\n**4. 머신러닝: 데이터 전처리**\n```python\nimport numpy as np\n\n# 이상치(Outlier) 제거\ndata = [10, 12, 15, 200, 18, 14, 300, 16]  # 200, 300이 이상치\nthreshold = 100\n\nclean_data = []\nfor value in data:\n    if value < threshold:\n        clean_data.append(value)\n    else:\n        print(f\"{value}는 이상치로 제거됨\")\n\nprint(f\"정제된 데이터: {clean_data}\")\n\n# 결측값 처리\nvalues = [1.0, 2.0, None, 4.0, None, 6.0]\nmean_value = np.nanmean([v for v in values if v is not None])\n\nfilled_values = []\nfor v in values:\n    if v is None:\n        filled_values.append(mean_value)  # 평균값으로 대체\n    else:\n        filled_values.append(v)\n\nprint(f\"결측값 처리 완료: {filled_values}\")\n```\n\n**5. 웹 스크래핑: 페이지네이션 처리**\n```python\nimport requests\nfrom bs4 import BeautifulSoup\n\nbase_url = \"https://example.com/page\"\nall_data = []\n\nfor page_num in range(1, 11):  # 1~10페이지\n    url = f\"{base_url}?page={page_num}\"\n    response = requests.get(url)\n    \n    if response.status_code != 200:\n        print(f\"페이지 {page_num} 로드 실패\")\n        continue\n    \n    soup = BeautifulSoup(response.text, 'html.parser')\n    items = soup.find_all('div', class_='item')\n    \n    if not items:  # 더 이상 데이터가 없으면 종료\n        print(f\"페이지 {page_num}에 데이터 없음. 크롤링 종료\")\n        break\n    \n    for item in items:\n        all_data.append(item.text.strip())\n    \n    print(f\"페이지 {page_num} 완료: {len(items)}개 항목\")\n\nprint(f\"총 {len(all_data)}개 데이터 수집 완료\")\n```"
      },
      {
        "type": "best-practice",
        "title": "제어문 작성 모범 사례",
        "content": "**1. Early Return으로 중첩 줄이기**\n```python\n# Bad: 중첩이 깊음\ndef process_user(user):\n    if user is not None:\n        if user['age'] >= 18:\n            if user['active']:\n                return f\"{user['name']} 처리 완료\"\n            else:\n                return \"비활성 사용자\"\n        else:\n            return \"미성년자\"\n    else:\n        return \"사용자 없음\"\n\n# Good: Early Return 사용\ndef process_user(user):\n    if user is None:\n        return \"사용자 없음\"\n    if user['age'] < 18:\n        return \"미성년자\"\n    if not user['active']:\n        return \"비활성 사용자\"\n    \n    return f\"{user['name']} 처리 완료\"\n```\n\n**2. 복잡한 조건은 변수로 추출**\n```python\n# Bad: 조건이 복잡하고 읽기 어려움\nif user['age'] >= 18 and user['verified'] and not user['banned'] and user['premium']:\n    grant_access()\n\n# Good: 의미 있는 변수명으로 가독성 향상\nis_adult = user['age'] >= 18\nis_verified = user['verified']\nis_not_banned = not user['banned']\nis_premium = user['premium']\n\nif is_adult and is_verified and is_not_banned and is_premium:\n    grant_access()\n```\n\n**3. 리스트 컴프리헨션 활용 (간결한 for 루프)**\n```python\n# Bad: 전통적인 for 루프\nsquares = []\nfor i in range(10):\n    if i % 2 == 0:\n        squares.append(i ** 2)\n\n# Good: 리스트 컴프리헨션\nsquares = [i ** 2 for i in range(10) if i % 2 == 0]\n```\n\n**4. enumerate() 사용 (인덱스가 필요한 경우)**\n```python\n# Bad: range(len())은 비효율적\nitems = ['a', 'b', 'c']\nfor i in range(len(items)):\n    print(f\"{i}: {items[i]}\")\n\n# Good: enumerate() 사용\nfor i, item in enumerate(items):\n    print(f\"{i}: {item}\")\n```\n\n**5. any()와 all() 활용**\n```python\n# Bad: 수동 반복문\nscores = [85, 90, 78, 92]\nhas_high_score = False\nfor score in scores:\n    if score >= 90:\n        has_high_score = True\n        break\n\n# Good: any() 사용\nhas_high_score = any(score >= 90 for score in scores)\n\n# 모든 점수가 60점 이상인지 확인\nall_passed = all(score >= 60 for score in scores)\n```\n\n**6. 삼항 연산자로 간단한 조건 처리**\n```python\n# Bad: 간단한 조건에 여러 줄 사용\nif age >= 18:\n    status = \"성인\"\nelse:\n    status = \"미성년자\"\n\n# Good: 삼항 연산자\nstatus = \"성인\" if age >= 18 else \"미성년자\"\n```\n\n**7. 딕셔너리로 if-elif 체인 대체**\n```python\n# Bad: 긴 if-elif 체인\ndef get_day_name(day_num):\n    if day_num == 1:\n        return \"월요일\"\n    elif day_num == 2:\n        return \"화요일\"\n    elif day_num == 3:\n        return \"수요일\"\n    # ...\n\n# Good: 딕셔너리 매핑\nDAY_NAMES = {\n    1: \"월요일\",\n    2: \"화요일\",\n    3: \"수요일\",\n    4: \"목요일\",\n    5: \"금요일\",\n    6: \"토요일\",\n    7: \"일요일\"\n}\n\ndef get_day_name(day_num):\n    return DAY_NAMES.get(day_num, \"잘못된 입력\")\n```"
      },
      {
        "type": "common-mistake",
        "title": "흔한 실수와 해결책",
        "content": "**1. 무한 루프 (Infinite Loop)**\n```python\n# 실수: 조건이 절대 False가 되지 않음\ncount = 0\nwhile count < 10:\n    print(count)\n    # count를 증가시키지 않음! 무한 루프!\n\n# 해결책: 조건 변수를 올바르게 업데이트\ncount = 0\nwhile count < 10:\n    print(count)\n    count += 1  # 증가 필수\n```\n\n**2. 가변 타입 기본값 문제**\n```python\n# 실수: 리스트를 기본값으로 사용\ndef add_item(item, items=[]):\n    items.append(item)\n    return items\n\nprint(add_item(1))  # [1]\nprint(add_item(2))  # [1, 2] - 예상치 못한 결과!\n\n# 해결책: None을 기본값으로 사용\ndef add_item(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n```\n\n**3. 반복문 안에서 리스트 수정**\n```python\n# 실수: 반복 중인 리스트를 수정하면 인덱스가 꼬임\nnumbers = [1, 2, 3, 4, 5]\nfor num in numbers:\n    if num % 2 == 0:\n        numbers.remove(num)  # 위험!\nprint(numbers)  # [1, 3, 5] 예상했지만 [1, 3, 4, 5] 출력!\n\n# 해결책 1: 리스트 컴프리헨션으로 새 리스트 생성\nnumbers = [num for num in numbers if num % 2 != 0]\n\n# 해결책 2: 복사본을 순회\nnumbers = [1, 2, 3, 4, 5]\nfor num in numbers[:]:\n    if num % 2 == 0:\n        numbers.remove(num)\n```\n\n**4. for 루프에서 range(len()) 남용**\n```python\n# 실수: 불필요하게 인덱스 사용\nfruits = [\"사과\", \"바나나\", \"체리\"]\nfor i in range(len(fruits)):\n    print(fruits[i])\n\n# 해결책: 직접 순회\nfor fruit in fruits:\n    print(fruit)\n\n# 인덱스가 필요한 경우: enumerate() 사용\nfor i, fruit in enumerate(fruits):\n    print(f\"{i}: {fruit}\")\n```\n\n**5. 비교 연산자 실수**\n```python\n# 실수: 대입(=)과 비교(==) 혼동\nx = 10\nif x = 5:  # SyntaxError!\n    print(\"x는 5입니다.\")\n\n# 해결책: 비교 연산자 사용\nif x == 5:\n    print(\"x는 5입니다.\")\n```\n\n**6. break와 continue 위치 실수**\n```python\n# 실수: continue 후 코드는 실행되지 않음\nfor i in range(5):\n    if i == 2:\n        continue\n        print(f\"이 코드는 실행되지 않음: {i}\")  # Dead code\n    print(i)\n\n# 해결책: 로직 순서 조정\nfor i in range(5):\n    if i == 2:\n        continue\n    print(i)  # 올바른 위치\n```\n\n**7. while True 사용 시 탈출 조건 누락**\n```python\n# 실수: 탈출 조건 없는 무한 루프\nwhile True:\n    data = fetch_data()\n    process(data)\n    # break가 없어서 무한 루프!\n\n# 해결책: 명확한 탈출 조건\nwhile True:\n    data = fetch_data()\n    if not data:  # 데이터가 없으면 종료\n        break\n    process(data)\n```"
      },
      {
        "type": "tip",
        "title": "제어문 고급 활용 팁",
        "content": "**1. else 절과 함께 사용하는 for/while**\n```python\n# for-else: 루프가 break 없이 정상 완료되면 else 실행\nfor i in range(5):\n    if i == 10:  # 조건이 맞지 않아 break 안됨\n        break\nelse:\n    print(\"루프가 정상 완료됨\")  # 이 코드 실행\n\n# 실무 예시: 검색 후 결과 없을 때 처리\nusers = [{\"name\": \"Alice\", \"id\": 1}, {\"name\": \"Bob\", \"id\": 2}]\nsearch_id = 3\n\nfor user in users:\n    if user[\"id\"] == search_id:\n        print(f\"사용자 발견: {user['name']}\")\n        break\nelse:\n    print(f\"ID {search_id}를 가진 사용자를 찾을 수 없습니다.\")\n```\n\n**2. zip()으로 여러 리스트 동시 순회**\n```python\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [25, 30, 35]\ncities = [\"Seoul\", \"Busan\", \"Incheon\"]\n\n# 세 리스트를 동시에 순회\nfor name, age, city in zip(names, ages, cities):\n    print(f\"{name}({age}세)는 {city}에 삽니다.\")\n```\n\n**3. itertools를 활용한 고급 반복**\n```python\nfrom itertools import cycle, islice, chain\n\n# cycle: 무한 반복\ncolors = cycle(['빨강', '파랑', '초록'])\nfor _ in range(7):\n    print(next(colors))  # 빨강, 파랑, 초록, 빨강, 파랑, 초록, 빨강\n\n# islice: 일부만 가져오기\ndata = range(100)\nfirst_10 = list(islice(data, 10))  # 처음 10개\nprint(first_10)\n\n# chain: 여러 시퀀스 연결\nlist1 = [1, 2, 3]\nlist2 = [4, 5, 6]\nfor item in chain(list1, list2):\n    print(item)  # 1, 2, 3, 4, 5, 6\n```\n\n**4. match-case (Python 3.10+)**\n```python\n# switch-case 문법 (Python 3.10 이상)\ndef http_status(status):\n    match status:\n        case 200:\n            return \"OK\"\n        case 404:\n            return \"Not Found\"\n        case 500:\n            return \"Internal Server Error\"\n        case _:  # default\n            return \"Unknown\"\n\nprint(http_status(200))  # \"OK\"\nprint(http_status(999))  # \"Unknown\"\n```\n\n**5. Generator Expression (메모리 효율적 반복)**\n```python\n# 리스트 컴프리헨션: 전체 리스트 메모리에 저장\nsquares_list = [i ** 2 for i in range(1000000)]  # 메모리 많이 사용\n\n# 제너레이터: 필요할 때만 계산 (메모리 효율적)\nsquares_gen = (i ** 2 for i in range(1000000))\n\n# 큰 파일 처리 시 유용\nsum_of_squares = sum(i ** 2 for i in range(1000000))\n```\n\n**6. defaultdict로 조건문 줄이기**\n```python\nfrom collections import defaultdict\n\n# Bad: 키 존재 여부 매번 확인\nword_count = {}\nfor word in [\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\"]:\n    if word in word_count:\n        word_count[word] += 1\n    else:\n        word_count[word] = 1\n\n# Good: defaultdict 사용\nword_count = defaultdict(int)\nfor word in [\"apple\", \"banana\", \"apple\", \"cherry\", \"banana\"]:\n    word_count[word] += 1  # 조건문 불필요\n\nprint(dict(word_count))  # {'apple': 2, 'banana': 2, 'cherry': 1}\n```"
      },
      {
        "type": "practice",
        "title": "연습 문제",
        "content": "**문제 1: 짝수/홀수 판별**\n사용자로부터 정수를 입력받아 짝수인지 홀수인지 출력하세요.\n\n**문제 2: 학점 계산기**\n점수(0-100)를 입력받아 다음 기준으로 학점을 출력하세요:\n- 90점 이상: A\n- 80-89점: B\n- 70-79점: C\n- 60-69점: D\n- 60점 미만: F\n\n**문제 3: 구구단 출력**\n2단부터 9단까지 구구단을 출력하세요. (중첩 for 루프 사용)\n\n**문제 4: 리스트 요소 필터링**\n다음 리스트에서 20 이상인 숫자만 필터링하여 새 리스트를 만드세요.\n```python\nnumbers = [10, 25, 30, 15, 40, 5, 35]\n# 결과: [25, 30, 40, 35]\n```\n\n**문제 5: 소수(Prime Number) 판별**\n주어진 숫자가 소수인지 판별하는 함수를 작성하세요.\n```python\ndef is_prime(n):\n    # 여기에 코드 작성\n    pass\n\nprint(is_prime(7))   # True\nprint(is_prime(10))  # False\n```\n\n**문제 6: 최댓값 찾기**\nmax() 함수를 사용하지 않고, 리스트에서 가장 큰 값을 찾으세요.\n```python\nnumbers = [42, 17, 89, 23, 56]\n# 결과: 89\n```\n\n**문제 7: 패턴 출력**\n다음과 같은 별 패턴을 출력하세요:\n```\n*\n**\n***\n****\n*****\n```\n\n**문제 8: 실전 문제 - 로그인 시스템**\n사용자에게 최대 3번의 로그인 기회를 주는 시스템을 만드세요.\n- 올바른 비밀번호: \"python123\"\n- 3번 실패 시 \"계정이 잠겼습니다\" 출력\n- 성공 시 \"로그인 성공\" 출력\n\n**보너스 문제: FizzBuzz**\n1부터 100까지 숫자를 출력하되:\n- 3의 배수는 \"Fizz\"\n- 5의 배수는 \"Buzz\"\n- 3과 5의 공배수는 \"FizzBuzz\"\n- 나머지는 숫자 그대로 출력\n```python\n# 출력 예시: 1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, ...\n```"
      }
    ]
  },
  "01_python-basics/03_functions": {
    "id": "01_python-basics/03_functions",
    "title": "03 Functions",
    "category": "ai-roadmap",
    "subCategory": "01_python-basics",
    "language": "Python",
    "description": "Python 함수 정의, 매개변수, 반환값, 람다 함수를 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "함수(Function)란",
        "content": "함수는 특정 작업을 수행하는 재사용 가능한 코드 블록입니다. 코드의 중복을 줄이고, 모듈화와 유지보수를 쉽게 만들어줍니다.\n\n**함수의 구성 요소:**\n- **함수 정의**: `def` 키워드로 함수를 선언\n- **매개변수(Parameters)**: 함수에 전달되는 입력값\n- **반환값(Return)**: 함수가 실행 후 돌려주는 결과\n- **함수 호출**: 함수명()으로 실행\n\n**함수의 장점:**\n- 코드 재사용성: 같은 코드를 반복 작성하지 않음\n- 가독성 향상: 복잡한 로직을 의미 있는 이름으로 추상화\n- 유지보수 용이: 한 곳만 수정하면 모든 호출 지점에 반영\n- 테스트 가능: 독립적인 단위로 테스트 가능\n\n**함수의 종류:**\n- 내장 함수(Built-in Functions): print(), len(), sum() 등\n- 사용자 정의 함수(User-defined Functions): 직접 작성하는 함수\n- 람다 함수(Lambda Functions): 익명 함수, 간단한 연산에 사용\n- 고차 함수(Higher-order Functions): 함수를 인자로 받거나 반환"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ===== 1. 기본 함수 정의와 호출 =====\ndef greet():\n    \"\"\"인사 메시지를 출력하는 함수\"\"\"\n    print(\"안녕하세요!\")\n\ngreet()  # 함수 호출\n\n# ===== 2. 매개변수가 있는 함수 =====\ndef greet_person(name):\n    \"\"\"이름을 받아 인사하는 함수\"\"\"\n    print(f\"안녕하세요, {name}님!\")\n\ngreet_person(\"Alice\")  # 안녕하세요, Alice님!\ngreet_person(\"Bob\")    # 안녕하세요, Bob님!\n\n# ===== 3. 반환값이 있는 함수 =====\ndef add(a, b):\n    \"\"\"두 숫자를 더한 결과를 반환\"\"\"\n    return a + b\n\nresult = add(10, 20)\nprint(result)  # 30\n\n# 여러 값 반환 (튜플로 반환)\ndef get_min_max(numbers):\n    return min(numbers), max(numbers)\n\nmin_val, max_val = get_min_max([5, 2, 9, 1, 7])\nprint(f\"최소: {min_val}, 최대: {max_val}\")  # 최소: 1, 최대: 9\n\n# ===== 4. 기본값(Default) 매개변수 =====\ndef power(base, exponent=2):\n    \"\"\"거듭제곱 계산 (기본값: 제곱)\"\"\"\n    return base ** exponent\n\nprint(power(5))       # 25 (5^2)\nprint(power(5, 3))    # 125 (5^3)\n\n# ===== 5. 키워드 인자(Keyword Arguments) =====\ndef introduce(name, age, city):\n    print(f\"{name}님은 {age}세이며 {city}에 삽니다.\")\n\n# 위치 인자\nintroduce(\"Alice\", 25, \"Seoul\")\n\n# 키워드 인자 (순서 무관)\nintroduce(age=30, city=\"Busan\", name=\"Bob\")\n\n# 혼합 사용 (위치 인자가 먼저)\nintroduce(\"Charlie\", age=35, city=\"Incheon\")\n\n# ===== 6. 가변 인자 (*args, **kwargs) =====\n# *args: 임의 개수의 위치 인자\ndef sum_all(*args):\n    \"\"\"모든 인자의 합을 계산\"\"\"\n    return sum(args)\n\nprint(sum_all(1, 2, 3))           # 6\nprint(sum_all(10, 20, 30, 40))    # 100\n\n# **kwargs: 임의 개수의 키워드 인자\ndef print_info(**kwargs):\n    \"\"\"모든 키워드 인자를 출력\"\"\"\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"Alice\", age=25, city=\"Seoul\")\n# 출력:\n# name: Alice\n# age: 25\n# city: Seoul\n\n# *args와 **kwargs 함께 사용\ndef complex_function(required, *args, **kwargs):\n    print(f\"필수 인자: {required}\")\n    print(f\"가변 위치 인자: {args}\")\n    print(f\"가변 키워드 인자: {kwargs}\")\n\ncomplex_function(\"필수값\", 1, 2, 3, name=\"Alice\", age=25)\n\n# ===== 7. 람다(Lambda) 함수 =====\n# 한 줄로 작성하는 익명 함수\nsquare = lambda x: x ** 2\nprint(square(5))  # 25\n\n# 여러 인자\nadd = lambda a, b: a + b\nprint(add(10, 20))  # 30\n\n# map(), filter(), sorted()와 함께 사용\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x ** 2, numbers))\nprint(squared)  # [1, 4, 9, 16, 25]\n\neven = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even)  # [2, 4]\n\nstudents = [(\"Alice\", 85), (\"Bob\", 92), (\"Charlie\", 78)]\nsorted_students = sorted(students, key=lambda x: x[1], reverse=True)\nprint(sorted_students)  # [('Bob', 92), ('Alice', 85), ('Charlie', 78)]\n\n# ===== 8. 함수 내부 함수 (Nested Function) =====\ndef outer_function(x):\n    def inner_function(y):\n        return x + y\n    return inner_function(10)\n\nprint(outer_function(5))  # 15\n\n# ===== 9. 재귀 함수 (Recursive Function) =====\ndef factorial(n):\n    \"\"\"팩토리얼 계산 (재귀)\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    return n * factorial(n - 1)\n\nprint(factorial(5))  # 120 (5! = 5*4*3*2*1)\n\n# 피보나치 수열 (재귀)\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint([fibonacci(i) for i in range(10)])  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n\n# ===== 10. 타입 힌트 (Type Hints) =====\ndef calculate_area(width: float, height: float) -> float:\n    \"\"\"직사각형 넓이 계산\"\"\"\n    return width * height\n\narea: float = calculate_area(10.5, 20.3)\nprint(area)  # 213.15\n\n# 복잡한 타입 힌트\nfrom typing import List, Dict, Optional\n\ndef process_users(users: List[Dict[str, str]]) -> Optional[str]:\n    \"\"\"사용자 목록 처리\"\"\"\n    if not users:\n        return None\n    return users[0]['name']\n\n# ===== 11. Docstring (문서화 문자열) =====\ndef calculate_bmi(weight: float, height: float) -> float:\n    \"\"\"\n    BMI(체질량지수)를 계산합니다.\n    \n    Args:\n        weight (float): 체중 (kg)\n        height (float): 키 (m)\n    \n    Returns:\n        float: BMI 값\n    \n    Example:\n        >>> calculate_bmi(70, 1.75)\n        22.86\n    \"\"\"\n    return weight / (height ** 2)\n\nprint(calculate_bmi(70, 1.75))  # 22.857142857142858"
      },
      {
        "type": "use-case",
        "title": "실무 활용 사례",
        "content": "**1. 데이터 전처리 함수**\n```python\nimport pandas as pd\nimport numpy as np\n\ndef clean_data(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    데이터 전처리: 결측값 제거, 이상치 처리\n    \"\"\"\n    # 결측값 제거\n    df = df.dropna()\n    \n    # 수치형 컬럼의 이상치 제거 (IQR 방법)\n    numeric_cols = df.select_dtypes(include=[np.number]).columns\n    \n    for col in numeric_cols:\n        Q1 = df[col].quantile(0.25)\n        Q3 = df[col].quantile(0.75)\n        IQR = Q3 - Q1\n        lower_bound = Q1 - 1.5 * IQR\n        upper_bound = Q3 + 1.5 * IQR\n        df = df[(df[col] >= lower_bound) & (df[col] <= upper_bound)]\n    \n    return df\n\n# 사용 예시\nraw_data = pd.read_csv('sales.csv')\ncleaned_data = clean_data(raw_data)\nprint(f\"원본 데이터: {len(raw_data)}행\")\nprint(f\"정제된 데이터: {len(cleaned_data)}행\")\n```\n\n**2. API 요청 래퍼 함수**\n```python\nimport requests\nfrom typing import Optional, Dict, Any\nimport time\n\ndef api_request_with_retry(\n    url: str,\n    method: str = 'GET',\n    max_retries: int = 3,\n    timeout: int = 30,\n    **kwargs\n) -> Optional[Dict[Any, Any]]:\n    \"\"\"\n    재시도 로직이 포함된 API 요청 함수\n    \"\"\"\n    for attempt in range(max_retries):\n        try:\n            if method.upper() == 'GET':\n                response = requests.get(url, timeout=timeout, **kwargs)\n            elif method.upper() == 'POST':\n                response = requests.post(url, timeout=timeout, **kwargs)\n            else:\n                raise ValueError(f\"지원하지 않는 메서드: {method}\")\n            \n            response.raise_for_status()\n            return response.json()\n        \n        except requests.exceptions.RequestException as e:\n            print(f\"시도 {attempt + 1}/{max_retries} 실패: {e}\")\n            if attempt < max_retries - 1:\n                time.sleep(2 ** attempt)  # Exponential backoff\n            else:\n                print(\"최대 재시도 횟수 초과\")\n                return None\n\n# 사용 예시\ndata = api_request_with_retry(\n    \"https://api.example.com/users\",\n    headers={\"Authorization\": \"Bearer token123\"}\n)\n```\n\n**3. 모델 평가 함수**\n```python\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\nimport numpy as np\n\ndef evaluate_model(y_true, y_pred, model_name: str = \"Model\"):\n    \"\"\"\n    분류 모델 성능 평가 함수\n    \"\"\"\n    metrics = {\n        'accuracy': accuracy_score(y_true, y_pred),\n        'precision': precision_score(y_true, y_pred, average='weighted'),\n        'recall': recall_score(y_true, y_pred, average='weighted'),\n        'f1_score': f1_score(y_true, y_pred, average='weighted')\n    }\n    \n    print(f\"===== {model_name} 평가 결과 =====\")\n    for metric_name, value in metrics.items():\n        print(f\"{metric_name}: {value:.4f}\")\n    \n    return metrics\n\n# 사용 예시\ny_true = [0, 1, 1, 0, 1, 1, 0, 0]\ny_pred = [0, 1, 1, 0, 0, 1, 0, 1]\nevaluate_model(y_true, y_pred, \"Random Forest\")\n```\n\n**4. 설정 파일 로더**\n```python\nimport json\nimport yaml\nfrom pathlib import Path\nfrom typing import Dict, Any\n\ndef load_config(file_path: str) -> Dict[Any, Any]:\n    \"\"\"\n    JSON 또는 YAML 설정 파일 로드\n    \"\"\"\n    path = Path(file_path)\n    \n    if not path.exists():\n        raise FileNotFoundError(f\"파일을 찾을 수 없습니다: {file_path}\")\n    \n    with open(path, 'r', encoding='utf-8') as f:\n        if path.suffix == '.json':\n            return json.load(f)\n        elif path.suffix in ['.yaml', '.yml']:\n            return yaml.safe_load(f)\n        else:\n            raise ValueError(f\"지원하지 않는 파일 형식: {path.suffix}\")\n\n# 사용 예시\nconfig = load_config('config.json')\nprint(f\"데이터베이스 URL: {config['database']['url']}\")\n```\n\n**5. 데코레이터 함수 (고급)**\n```python\nimport time\nimport functools\n\ndef timer(func):\n    \"\"\"함수 실행 시간 측정 데코레이터\"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} 실행 시간: {end_time - start_time:.4f}초\")\n        return result\n    return wrapper\n\n@timer\ndef slow_function():\n    time.sleep(2)\n    return \"완료\"\n\nresult = slow_function()\n# 출력: slow_function 실행 시간: 2.0023초\n```"
      },
      {
        "type": "best-practice",
        "title": "함수 작성 모범 사례",
        "content": "**1. 단일 책임 원칙 (Single Responsibility Principle)**\n```python\n# Bad: 하나의 함수가 너무 많은 일을 함\ndef process_user_data(user):\n    # 검증\n    if not user['email']:\n        raise ValueError(\"이메일 필수\")\n    # 변환\n    user['name'] = user['name'].upper()\n    # 저장\n    save_to_database(user)\n    # 이메일 발송\n    send_welcome_email(user['email'])\n\n# Good: 각 기능을 별도 함수로 분리\ndef validate_user(user):\n    if not user['email']:\n        raise ValueError(\"이메일 필수\")\n\ndef format_user_data(user):\n    user['name'] = user['name'].upper()\n    return user\n\ndef process_user(user):\n    validate_user(user)\n    formatted_user = format_user_data(user)\n    save_to_database(formatted_user)\n    send_welcome_email(formatted_user['email'])\n```\n\n**2. 명확하고 서술적인 함수명**\n```python\n# Bad: 모호한 이름\ndef proc(data):\n    pass\n\ndef get_data():\n    pass\n\n# Good: 명확한 이름\ndef calculate_average_score(scores):\n    pass\n\ndef fetch_user_from_database(user_id):\n    pass\n```\n\n**3. 함수는 짧게 유지 (10-20줄 이내 권장)**\n```python\n# Bad: 너무 긴 함수 (100줄+)\ndef massive_function():\n    # ... 100줄의 코드 ...\n    pass\n\n# Good: 작은 함수로 분리\ndef step1():\n    pass\n\ndef step2():\n    pass\n\ndef main_function():\n    step1()\n    step2()\n```\n\n**4. 타입 힌트와 Docstring 작성**\n```python\nfrom typing import List, Optional\n\ndef calculate_statistics(numbers: List[float]) -> dict:\n    \"\"\"\n    숫자 리스트의 통계값을 계산합니다.\n    \n    Args:\n        numbers (List[float]): 숫자 리스트\n    \n    Returns:\n        dict: 평균, 최소, 최대값을 포함한 딕셔너리\n    \n    Raises:\n        ValueError: 빈 리스트가 입력된 경우\n    \n    Example:\n        >>> calculate_statistics([1, 2, 3, 4, 5])\n        {'mean': 3.0, 'min': 1, 'max': 5}\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"빈 리스트는 처리할 수 없습니다.\")\n    \n    return {\n        'mean': sum(numbers) / len(numbers),\n        'min': min(numbers),\n        'max': max(numbers)\n    }\n```\n\n**5. 가변 객체를 기본값으로 사용하지 않기**\n```python\n# Bad: 리스트를 기본값으로 사용 (버그 발생)\ndef add_item(item, items=[]):\n    items.append(item)\n    return items\n\nprint(add_item(1))  # [1]\nprint(add_item(2))  # [1, 2] - 예상치 못한 결과!\n\n# Good: None을 기본값으로 사용\ndef add_item(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n```\n\n**6. 순수 함수(Pure Function) 지향**\n```python\n# Bad: 전역 변수 수정 (부작용 발생)\ntotal = 0\n\ndef add_to_total(value):\n    global total\n    total += value\n\n# Good: 순수 함수 (부작용 없음)\ndef add(a, b):\n    return a + b\n\ntotal = add(total, value)\n```\n\n**7. 조기 반환(Early Return) 활용**\n```python\n# Bad: 중첩된 조건문\ndef process_order(order):\n    if order is not None:\n        if order['status'] == 'pending':\n            if order['amount'] > 0:\n                return process_payment(order)\n            else:\n                return \"잘못된 금액\"\n        else:\n            return \"처리할 수 없는 상태\"\n    else:\n        return \"주문 없음\"\n\n# Good: 조기 반환으로 가독성 향상\ndef process_order(order):\n    if order is None:\n        return \"주문 없음\"\n    if order['status'] != 'pending':\n        return \"처리할 수 없는 상태\"\n    if order['amount'] <= 0:\n        return \"잘못된 금액\"\n    \n    return process_payment(order)\n```"
      },
      {
        "type": "common-mistake",
        "title": "흔한 실수와 해결책",
        "content": "**1. return 문 누락**\n```python\n# 실수: return 없이 결과 출력만 함\ndef add(a, b):\n    print(a + b)  # 반환이 아닌 출력\n\nresult = add(10, 20)  # None이 반환됨\nprint(result)  # None\n\n# 해결책: return 사용\ndef add(a, b):\n    return a + b\n\nresult = add(10, 20)\nprint(result)  # 30\n```\n\n**2. 함수 호출 시 괄호 누락**\n```python\n# 실수: 괄호 없이 호출하면 함수 객체만 반환\ndef greet():\n    return \"안녕하세요!\"\n\nmessage = greet  # 함수 객체\nprint(message)   # <function greet at 0x...>\n\n# 해결책: 괄호 추가\nmessage = greet()  # 함수 호출\nprint(message)     # \"안녕하세요!\"\n```\n\n**3. 위치 인자와 키워드 인자 순서 오류**\n```python\n# 실수: 키워드 인자 뒤에 위치 인자\ndef func(a, b, c):\n    pass\n\nfunc(1, c=3, 2)  # SyntaxError!\n\n# 해결책: 위치 인자가 먼저\nfunc(1, 2, c=3)  # 올바름\n```\n\n**4. 재귀 함수의 종료 조건 누락**\n```python\n# 실수: 종료 조건이 없어 무한 재귀\ndef countdown(n):\n    print(n)\n    countdown(n - 1)  # RecursionError!\n\n# 해결책: 종료 조건 추가\ndef countdown(n):\n    if n <= 0:  # 종료 조건\n        return\n    print(n)\n    countdown(n - 1)\n```\n\n**5. 람다 함수의 클로저 문제**\n```python\n# 실수: 람다가 변수를 늦게 바인딩\nfuncs = []\nfor i in range(5):\n    funcs.append(lambda: i)  # i는 루프 종료 후의 값(4)을 참조\n\nprint([f() for f in funcs])  # [4, 4, 4, 4, 4] - 예상과 다름!\n\n# 해결책 1: 기본 인자로 즉시 바인딩\nfuncs = []\nfor i in range(5):\n    funcs.append(lambda i=i: i)\n\nprint([f() for f in funcs])  # [0, 1, 2, 3, 4]\n\n# 해결책 2: 리스트 컴프리헨션 사용\nfuncs = [lambda i=i: i for i in range(5)]\nprint([f() for f in funcs])  # [0, 1, 2, 3, 4]\n```\n\n**6. 가변 인자 언패킹 실수**\n```python\n# 실수: 리스트를 그대로 전달\ndef sum_all(*args):\n    return sum(args)\n\nnumbers = [1, 2, 3, 4, 5]\nresult = sum_all(numbers)  # TypeError: 튜플([1,2,3,4,5],)가 됨\n\n# 해결책: * 연산자로 언패킹\nresult = sum_all(*numbers)  # 올바름\nprint(result)  # 15\n```\n\n**7. 함수 내부에서 외부 변수 수정 시도**\n```python\n# 실수: 함수 내부에서 외부 변수 수정 불가\ncount = 0\n\ndef increment():\n    count += 1  # UnboundLocalError!\n\n# 해결책 1: global 키워드 (권장하지 않음)\ncount = 0\n\ndef increment():\n    global count\n    count += 1\n\n# 해결책 2: 클래스 사용 (권장)\nclass Counter:\n    def __init__(self):\n        self.count = 0\n    \n    def increment(self):\n        self.count += 1\n```"
      },
      {
        "type": "tip",
        "title": "함수 고급 활용 팁",
        "content": "**1. functools.lru_cache로 성능 최적화**\n```python\nfrom functools import lru_cache\n\n# 메모이제이션: 이전 계산 결과 캐싱\n@lru_cache(maxsize=128)\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# 캐싱 없이: 매우 느림\n# 캐싱 사용: 빠름!\nprint(fibonacci(100))  # 즉시 계산\n```\n\n**2. functools.partial로 함수 고정**\n```python\nfrom functools import partial\n\ndef power(base, exponent):\n    return base ** exponent\n\n# exponent를 2로 고정\nsquare = partial(power, exponent=2)\nprint(square(5))  # 25\n\n# exponent를 3으로 고정\ncube = partial(power, exponent=3)\nprint(cube(5))  # 125\n```\n\n**3. *args와 **kwargs로 래퍼 함수 작성**\n```python\nimport time\n\ndef measure_time(func):\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f\"{func.__name__} 실행 시간: {end - start:.4f}초\")\n        return result\n    return wrapper\n\n@measure_time\ndef slow_function(n):\n    time.sleep(n)\n    return \"완료\"\n\nslow_function(2)  # slow_function 실행 시간: 2.0023초\n```\n\n**4. inspect 모듈로 함수 정보 확인**\n```python\nimport inspect\n\ndef example_function(a: int, b: str = \"default\") -> str:\n    \"\"\"예시 함수\"\"\"\n    return f\"{a}: {b}\"\n\n# 함수 시그니처 확인\nsig = inspect.signature(example_function)\nprint(sig)  # (a: int, b: str = 'default') -> str\n\n# 소스 코드 확인\nprint(inspect.getsource(example_function))\n```\n\n**5. operator 모듈로 간결한 람다 대체**\n```python\nimport operator\n\n# Bad: 람다 사용\nsorted_items = sorted(items, key=lambda x: x[1])\n\n# Good: operator.itemgetter 사용 (더 빠르고 명확)\nsorted_items = sorted(items, key=operator.itemgetter(1))\n\n# 딕셔너리에서 값 추출\ndata = [{'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 30}]\nsorted_data = sorted(data, key=operator.itemgetter('age'))\n```\n\n**6. 제너레이터 함수로 메모리 효율 향상**\n```python\n# 일반 함수: 전체 리스트 메모리에 저장\ndef get_numbers(n):\n    result = []\n    for i in range(n):\n        result.append(i ** 2)\n    return result\n\n# 제너레이터 함수: 필요할 때만 생성 (메모리 효율적)\ndef get_numbers_gen(n):\n    for i in range(n):\n        yield i ** 2\n\n# 사용\nfor num in get_numbers_gen(1000000):  # 메모리 절약\n    if num > 100:\n        break\n    print(num)\n```\n\n**7. ChainMap으로 여러 설정 병합**\n```python\nfrom collections import ChainMap\n\ndef get_config(**overrides):\n    defaults = {'host': 'localhost', 'port': 8000, 'debug': False}\n    env_vars = {'port': 9000}  # 환경 변수에서 로드\n    \n    # 우선순위: overrides > env_vars > defaults\n    config = ChainMap(overrides, env_vars, defaults)\n    return dict(config)\n\nconfig = get_config(debug=True)\nprint(config)  # {'host': 'localhost', 'port': 9000, 'debug': True}\n```"
      },
      {
        "type": "practice",
        "title": "연습 문제",
        "content": "**문제 1: 기본 함수**\n섭씨 온도를 화씨로 변환하는 함수 `celsius_to_fahrenheit(celsius)`를 작성하세요.\n공식: F = C × 9/5 + 32\n\n**문제 2: 매개변수와 반환값**\n세 개의 숫자를 받아 평균을 계산하는 함수 `calculate_average(a, b, c)`를 작성하세요.\n\n**문제 3: 기본값 매개변수**\n인사말을 출력하는 함수 `greet(name, greeting=\"안녕하세요\")`를 작성하세요.\n- 기본값으로 \"안녕하세요\"를 사용\n- 다른 인사말도 지정 가능\n\n**문제 4: 가변 인자**\n임의 개수의 숫자를 받아 최댓값을 반환하는 함수 `find_max(*numbers)`를 작성하세요. (max() 함수 사용 금지)\n\n**문제 5: 람다 함수**\n다음 리스트를 이름의 길이순으로 정렬하세요. (람다 함수 사용)\n```python\nnames = [\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"]\n# 결과: ['Bob', 'Eve', 'Alice', 'David', 'Charlie']\n```\n\n**문제 6: 재귀 함수**\n숫자 n의 팩토리얼을 계산하는 재귀 함수 `factorial(n)`을 작성하세요.\n예: factorial(5) = 5 × 4 × 3 × 2 × 1 = 120\n\n**문제 7: 여러 값 반환**\n리스트를 받아 (최솟값, 최댓값, 평균)을 튜플로 반환하는 함수 `get_stats(numbers)`를 작성하세요.\n\n**문제 8: 실전 문제 - 비밀번호 검증**\n비밀번호가 다음 조건을 만족하는지 검증하는 함수를 작성하세요:\n- 길이가 8자 이상\n- 대문자, 소문자, 숫자를 모두 포함\n- 조건 만족 시 True, 아니면 False 반환\n\n```python\ndef is_valid_password(password: str) -> bool:\n    # 여기에 코드 작성\n    pass\n\nprint(is_valid_password(\"Abc12345\"))  # True\nprint(is_valid_password(\"abc123\"))    # False (대문자 없음)\n```\n\n**보너스 문제: 데코레이터**\n함수 호출 횟수를 세는 데코레이터 `count_calls`를 작성하세요.\n```python\n@count_calls\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello()  # Hello! (호출 횟수: 1)\nsay_hello()  # Hello! (호출 횟수: 2)\nsay_hello()  # Hello! (호출 횟수: 3)\n```"
      }
    ]
  },
  "01_python-basics/04_classes": {
    "id": "01_python-basics/04_classes",
    "title": "04 Classes",
    "category": "ai-roadmap",
    "subCategory": "01_python-basics",
    "language": "Python",
    "description": "Python 클래스, 객체, 상속, 메서드, 캡슐화를 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "클래스(Class)와 객체 지향 프로그래밍",
        "content": "클래스는 관련된 데이터(속성)와 기능(메서드)을 하나로 묶는 객체 지향 프로그래밍의 핵심 개념입니다.\n\n**객체 지향 프로그래밍(OOP)의 4대 특징:**\n\n**1. 캡슐화(Encapsulation)**\n- 데이터와 메서드를 하나로 묶어 정보 은닉\n- Public, Protected, Private 접근 제어\n\n**2. 상속(Inheritance)**\n- 기존 클래스의 속성과 메서드를 물려받음\n- 코드 재사용성 향상\n\n**3. 다형성(Polymorphism)**\n- 같은 메서드 이름으로 다른 동작 구현\n- 메서드 오버라이딩\n\n**4. 추상화(Abstraction)**\n- 복잡한 내부 구현을 숨기고 필수 기능만 노출\n- Abstract Base Class 사용\n\n**기본 용어:**\n- **클래스(Class)**: 객체를 만들기 위한 설계도/틀\n- **객체(Object)**: 클래스로부터 생성된 실체(인스턴스)\n- **속성(Attribute)**: 객체가 가진 데이터/변수\n- **메서드(Method)**: 객체가 가진 함수/동작\n- **생성자(__init__)**: 객체 생성 시 자동 호출되는 초기화 메서드\n- **self**: 인스턴스 자신을 가리키는 참조"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ===== 1. 기본 클래스 정의와 객체 생성 =====\nclass Dog:\n    \"\"\"강아지 클래스\"\"\"\n    \n    # 생성자 (초기화 메서드)\n    def __init__(self, name, age):\n        self.name = name  # 인스턴스 속성\n        self.age = age\n    \n    # 인스턴스 메서드\n    def bark(self):\n        return f\"{self.name}가 짖습니다: 멍멍!\"\n    \n    def get_info(self):\n        return f\"이름: {self.name}, 나이: {self.age}살\"\n\n# 객체 생성\ndog1 = Dog(\"초코\", 3)\ndog2 = Dog(\"바둑이\", 5)\n\n# 메서드 호출\nprint(dog1.bark())       # 초코가 짖습니다: 멍멍!\nprint(dog2.get_info())   # 이름: 바둑이, 나이: 5살\n\n# 속성 접근\nprint(dog1.name)         # 초코\nprint(dog2.age)          # 5\n\n# ===== 2. 클래스 변수 vs 인스턴스 변수 =====\nclass Student:\n    # 클래스 변수 (모든 인스턴스가 공유)\n    school = \"파이썬 고등학교\"\n    student_count = 0\n    \n    def __init__(self, name, grade):\n        # 인스턴스 변수 (각 객체마다 고유)\n        self.name = name\n        self.grade = grade\n        Student.student_count += 1  # 클래스 변수 증가\n\nstudent1 = Student(\"Alice\", 10)\nstudent2 = Student(\"Bob\", 11)\n\nprint(student1.school)          # 파이썬 고등학교 (클래스 변수)\nprint(Student.student_count)    # 2 (총 학생 수)\n\n# ===== 3. 특수 메서드 (Magic Methods) =====\nclass Book:\n    def __init__(self, title, author, pages):\n        self.title = title\n        self.author = author\n        self.pages = pages\n    \n    # 문자열 표현 (__str__)\n    def __str__(self):\n        return f\"'{self.title}' by {self.author}\"\n    \n    # 개발자용 표현 (__repr__)\n    def __repr__(self):\n        return f\"Book('{self.title}', '{self.author}', {self.pages})\"\n    \n    # 비교 연산자 (__eq__, __lt__)\n    def __eq__(self, other):\n        return self.pages == other.pages\n    \n    def __lt__(self, other):\n        return self.pages < other.pages\n    \n    # 길이 반환 (__len__)\n    def __len__(self):\n        return self.pages\n\nbook1 = Book(\"Python 기초\", \"김철수\", 300)\nbook2 = Book(\"AI 입문\", \"이영희\", 250)\n\nprint(book1)                    # 'Python 기초' by 김철수\nprint(len(book1))               # 300\nprint(book1 > book2)            # True (페이지 수 비교)\n\n# ===== 4. 상속 (Inheritance) =====\nclass Animal:\n    \"\"\"부모 클래스\"\"\"\n    def __init__(self, name):\n        self.name = name\n    \n    def speak(self):\n        return \"동물 소리\"\n\nclass Cat(Animal):\n    \"\"\"자식 클래스: Animal을 상속\"\"\"\n    def speak(self):  # 메서드 오버라이딩\n        return f\"{self.name}: 야옹!\"\n\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name}: 멍멍!\"\n\ncat = Cat(\"나비\")\ndog = Dog(\"바둑이\")\n\nprint(cat.speak())  # 나비: 야옹!\nprint(dog.speak())  # 바둑이: 멍멍!\n\n# ===== 5. super()로 부모 클래스 메서드 호출 =====\nclass Vehicle:\n    def __init__(self, brand, model):\n        self.brand = brand\n        self.model = model\n    \n    def info(self):\n        return f\"{self.brand} {self.model}\"\n\nclass ElectricCar(Vehicle):\n    def __init__(self, brand, model, battery_capacity):\n        super().__init__(brand, model)  # 부모 생성자 호출\n        self.battery_capacity = battery_capacity\n    \n    def info(self):  # 메서드 확장\n        parent_info = super().info()\n        return f\"{parent_info} (배터리: {self.battery_capacity}kWh)\"\n\ncar = ElectricCar(\"Tesla\", \"Model 3\", 75)\nprint(car.info())  # Tesla Model 3 (배터리: 75kWh)\n\n# ===== 6. 프로퍼티 (Property) - Getter/Setter =====\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius  # Protected 변수 (관례상)\n    \n    @property\n    def radius(self):\n        \"\"\"Getter\"\"\"\n        return self._radius\n    \n    @radius.setter\n    def radius(self, value):\n        \"\"\"Setter\"\"\"\n        if value < 0:\n            raise ValueError(\"반지름은 음수일 수 없습니다.\")\n        self._radius = value\n    \n    @property\n    def area(self):\n        \"\"\"읽기 전용 프로퍼티\"\"\"\n        return 3.14159 * (self._radius ** 2)\n\ncircle = Circle(5)\nprint(circle.radius)     # 5 (Getter 호출)\nprint(circle.area)       # 78.53975\n\ncircle.radius = 10       # Setter 호출\nprint(circle.area)       # 314.159\n\n# circle.radius = -5     # ValueError 발생\n\n# ===== 7. 클래스 메서드와 정적 메서드 =====\nclass MathUtils:\n    PI = 3.14159\n    \n    @classmethod\n    def from_diameter(cls, diameter):\n        \"\"\"클래스 메서드: 대체 생성자\"\"\"\n        return cls(diameter / 2)\n    \n    @staticmethod\n    def is_even(n):\n        \"\"\"정적 메서드: 유틸리티 함수\"\"\"\n        return n % 2 == 0\n\nprint(MathUtils.is_even(10))   # True\nprint(MathUtils.is_even(7))    # False\n\n# ===== 8. Private 속성 (Name Mangling) =====\nclass BankAccount:\n    def __init__(self, owner, balance):\n        self.owner = owner              # Public\n        self._account_number = \"1234\"   # Protected (관례)\n        self.__balance = balance        # Private (Name Mangling)\n    \n    def deposit(self, amount):\n        if amount > 0:\n            self.__balance += amount\n    \n    def get_balance(self):\n        return self.__balance\n\naccount = BankAccount(\"Alice\", 1000)\nprint(account.owner)              # Alice (Public 접근 가능)\nprint(account._account_number)    # 1234 (Protected, 접근 가능하지만 권장 안 함)\n# print(account.__balance)        # AttributeError! (Private)\nprint(account.get_balance())      # 1000 (메서드로 접근)\n\n# ===== 9. 다중 상속 =====\nclass Flyer:\n    def fly(self):\n        return \"날고 있습니다.\"\n\nclass Swimmer:\n    def swim(self):\n        return \"수영하고 있습니다.\"\n\nclass Duck(Flyer, Swimmer):\n    def quack(self):\n        return \"꽥꽥!\"\n\nduck = Duck()\nprint(duck.fly())    # 날고 있습니다.\nprint(duck.swim())   # 수영하고 있습니다.\nprint(duck.quack())  # 꽥꽥!\n\n# ===== 10. 추상 클래스 (ABC) =====\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    \"\"\"추상 클래스: 인스턴스화 불가\"\"\"\n    \n    @abstractmethod\n    def area(self):\n        \"\"\"반드시 구현해야 하는 추상 메서드\"\"\"\n        pass\n    \n    @abstractmethod\n    def perimeter(self):\n        pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nrect = Rectangle(10, 5)\nprint(rect.area())       # 50\nprint(rect.perimeter())  # 30\n\n# shape = Shape()  # TypeError: 추상 클래스는 인스턴스화 불가!"
      },
      {
        "type": "use-case",
        "title": "실무 활용 사례",
        "content": "**1. 데이터 모델링: 사용자 관리 시스템**\n```python\nfrom datetime import datetime\nfrom typing import List, Optional\n\nclass User:\n    \"\"\"사용자 클래스\"\"\"\n    \n    def __init__(self, user_id: int, username: str, email: str):\n        self.user_id = user_id\n        self.username = username\n        self.email = email\n        self.created_at = datetime.now()\n        self.is_active = True\n    \n    def deactivate(self):\n        \"\"\"계정 비활성화\"\"\"\n        self.is_active = False\n    \n    def __repr__(self):\n        return f\"User({self.user_id}, '{self.username}')\"\n\nclass UserManager:\n    \"\"\"사용자 관리자 클래스\"\"\"\n    \n    def __init__(self):\n        self.users: List[User] = []\n        self._next_id = 1\n    \n    def create_user(self, username: str, email: str) -> User:\n        \"\"\"새 사용자 생성\"\"\"\n        user = User(self._next_id, username, email)\n        self.users.append(user)\n        self._next_id += 1\n        return user\n    \n    def find_by_username(self, username: str) -> Optional[User]:\n        \"\"\"사용자 이름으로 검색\"\"\"\n        for user in self.users:\n            if user.username == username:\n                return user\n        return None\n    \n    def get_active_users(self) -> List[User]:\n        \"\"\"활성 사용자 목록\"\"\"\n        return [user for user in self.users if user.is_active]\n\n# 사용 예시\nmanager = UserManager()\nuser1 = manager.create_user(\"alice\", \"alice@example.com\")\nuser2 = manager.create_user(\"bob\", \"bob@example.com\")\n\nuser1.deactivate()\nactive_users = manager.get_active_users()\nprint(f\"활성 사용자: {len(active_users)}명\")  # 1명\n```\n\n**2. 머신러닝: 모델 래퍼 클래스**\n```python\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nimport numpy as np\nimport joblib\n\nclass MLModel:\n    \"\"\"머신러닝 모델 래퍼 클래스\"\"\"\n    \n    def __init__(self, model_type='random_forest', **params):\n        if model_type == 'random_forest':\n            self.model = RandomForestClassifier(**params)\n        else:\n            raise ValueError(f\"지원하지 않는 모델: {model_type}\")\n        \n        self.is_trained = False\n        self.feature_names = None\n    \n    def train(self, X, y, feature_names=None):\n        \"\"\"모델 학습\"\"\"\n        self.model.fit(X, y)\n        self.is_trained = True\n        self.feature_names = feature_names\n        print(\"모델 학습 완료\")\n    \n    def predict(self, X):\n        \"\"\"예측 수행\"\"\"\n        if not self.is_trained:\n            raise RuntimeError(\"모델이 학습되지 않았습니다.\")\n        return self.model.predict(X)\n    \n    def save(self, filepath):\n        \"\"\"모델 저장\"\"\"\n        joblib.dump(self.model, filepath)\n        print(f\"모델 저장 완료: {filepath}\")\n    \n    @classmethod\n    def load(cls, filepath):\n        \"\"\"모델 로드\"\"\"\n        instance = cls()\n        instance.model = joblib.load(filepath)\n        instance.is_trained = True\n        print(f\"모델 로드 완료: {filepath}\")\n        return instance\n\n# 사용 예시\nX = np.random.rand(100, 5)\ny = np.random.randint(0, 2, 100)\n\nmodel = MLModel(model_type='random_forest', n_estimators=100)\nmodel.train(X, y)\npredictions = model.predict(X)\nmodel.save('model.pkl')\n```\n\n**3. API 클라이언트: HTTP 요청 관리**\n```python\nimport requests\nfrom typing import Dict, Any, Optional\nimport time\n\nclass APIClient:\n    \"\"\"RESTful API 클라이언트\"\"\"\n    \n    def __init__(self, base_url: str, api_key: Optional[str] = None):\n        self.base_url = base_url.rstrip('/')\n        self.session = requests.Session()\n        \n        if api_key:\n            self.session.headers.update({\n                'Authorization': f'Bearer {api_key}'\n            })\n    \n    def _request(self, method: str, endpoint: str, **kwargs) -> Dict[Any, Any]:\n        \"\"\"내부 요청 메서드 (재시도 로직 포함)\"\"\"\n        url = f\"{self.base_url}/{endpoint.lstrip('/')}\"\n        max_retries = 3\n        \n        for attempt in range(max_retries):\n            try:\n                response = self.session.request(method, url, **kwargs)\n                response.raise_for_status()\n                return response.json()\n            except requests.exceptions.RequestException as e:\n                if attempt == max_retries - 1:\n                    raise\n                time.sleep(2 ** attempt)  # Exponential backoff\n    \n    def get(self, endpoint: str, params: Optional[Dict] = None):\n        return self._request('GET', endpoint, params=params)\n    \n    def post(self, endpoint: str, data: Dict):\n        return self._request('POST', endpoint, json=data)\n    \n    def put(self, endpoint: str, data: Dict):\n        return self._request('PUT', endpoint, json=data)\n    \n    def delete(self, endpoint: str):\n        return self._request('DELETE', endpoint)\n\n# 사용 예시\nclient = APIClient(\n    base_url=\"https://api.example.com\",\n    api_key=\"your_api_key\"\n)\n\nusers = client.get('/users')\nnew_user = client.post('/users', data={'name': 'Alice', 'email': 'alice@example.com'})\n```\n\n**4. 데이터베이스 ORM 패턴**\n```python\nimport sqlite3\nfrom typing import List, Optional\n\nclass Database:\n    \"\"\"데이터베이스 연결 관리\"\"\"\n    \n    def __init__(self, db_path: str):\n        self.connection = sqlite3.connect(db_path)\n        self.cursor = self.connection.cursor()\n    \n    def execute(self, query: str, params=()):\n        self.cursor.execute(query, params)\n        self.connection.commit()\n    \n    def fetchall(self, query: str, params=()):\n        self.cursor.execute(query, params)\n        return self.cursor.fetchall()\n    \n    def close(self):\n        self.connection.close()\n\nclass Product:\n    \"\"\"상품 모델\"\"\"\n    \n    def __init__(self, product_id: int, name: str, price: float):\n        self.product_id = product_id\n        self.name = name\n        self.price = price\n    \n    @classmethod\n    def create_table(cls, db: Database):\n        \"\"\"테이블 생성\"\"\"\n        db.execute('''\n            CREATE TABLE IF NOT EXISTS products (\n                id INTEGER PRIMARY KEY,\n                name TEXT NOT NULL,\n                price REAL NOT NULL\n            )\n        ''')\n    \n    def save(self, db: Database):\n        \"\"\"DB에 저장\"\"\"\n        db.execute(\n            'INSERT INTO products (name, price) VALUES (?, ?)',\n            (self.name, self.price)\n        )\n    \n    @classmethod\n    def find_all(cls, db: Database) -> List['Product']:\n        \"\"\"모든 상품 조회\"\"\"\n        rows = db.fetchall('SELECT id, name, price FROM products')\n        return [cls(row[0], row[1], row[2]) for row in rows]\n```\n\n**5. 설정 관리 클래스 (Singleton 패턴)**\n```python\nclass Config:\n    \"\"\"싱글톤 설정 클래스\"\"\"\n    _instance = None\n    \n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n    \n    def __init__(self):\n        if not self._initialized:\n            self.database_url = \"postgresql://localhost/mydb\"\n            self.api_key = \"default_key\"\n            self.debug = False\n            self._initialized = True\n    \n    def update(self, **kwargs):\n        \"\"\"설정 업데이트\"\"\"\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\n# 어디서든 같은 인스턴스\nconfig1 = Config()\nconfig2 = Config()\n\nassert config1 is config2  # 같은 객체\nconfig1.update(debug=True)\nprint(config2.debug)  # True (같은 인스턴스라서)\n```"
      },
      {
        "type": "best-practice",
        "title": "클래스 설계 모범 사례",
        "content": "**1. SOLID 원칙 중 단일 책임 원칙 (Single Responsibility)**\n```python\n# Bad: 하나의 클래스가 너무 많은 책임\nclass User:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n    \n    def save_to_database(self):  # DB 저장\n        pass\n    \n    def send_email(self):  # 이메일 발송\n        pass\n    \n    def validate_email(self):  # 검증\n        pass\n\n# Good: 책임을 분리\nclass User:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\nclass UserRepository:\n    def save(self, user):\n        pass  # DB 저장 로직\n\nclass EmailService:\n    def send(self, user):\n        pass  # 이메일 발송 로직\n\nclass EmailValidator:\n    @staticmethod\n    def validate(email):\n        pass  # 검증 로직\n```\n\n**2. 작은 클래스, 작은 메서드 선호**\n```python\n# Good: 클래스는 작게, 메서드는 명확하게\nclass Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n```\n\n**3. __init__에서 복잡한 로직 피하기**\n```python\n# Bad: 생성자에서 복잡한 작업\nclass DataLoader:\n    def __init__(self, filepath):\n        self.data = self._load_file(filepath)  # 시간이 오래 걸리는 작업\n        self.processed = self._process_data(self.data)\n\n# Good: 명시적 메서드 호출\nclass DataLoader:\n    def __init__(self, filepath):\n        self.filepath = filepath\n        self.data = None\n        self.processed = None\n    \n    def load(self):\n        self.data = self._load_file(self.filepath)\n        return self\n    \n    def process(self):\n        self.processed = self._process_data(self.data)\n        return self\n\n# 사용\nloader = DataLoader('data.csv').load().process()\n```\n\n**4. 프로퍼티(@property) 활용**\n```python\n# Bad: 직접 접근\nclass Person:\n    def __init__(self, age):\n        self.age = age  # 음수 검증 없음\n\n# Good: 프로퍼티로 검증\nclass Person:\n    def __init__(self, age):\n        self._age = age\n    \n    @property\n    def age(self):\n        return self._age\n    \n    @age.setter\n    def age(self, value):\n        if value < 0:\n            raise ValueError(\"나이는 음수일 수 없습니다.\")\n        self._age = value\n```\n\n**5. 상속보다 컴포지션(Composition) 선호**\n```python\n# Bad: 과도한 상속\nclass Animal:\n    pass\n\nclass FlyingAnimal(Animal):\n    pass\n\nclass SwimmingAnimal(Animal):\n    pass\n\nclass FlyingSwimmingAnimal(FlyingAnimal, SwimmingAnimal):\n    pass  # 복잡한 상속 계층\n\n# Good: 컴포지션 사용\nclass Flyer:\n    def fly(self):\n        return \"날고 있습니다.\"\n\nclass Swimmer:\n    def swim(self):\n        return \"수영하고 있습니다.\"\n\nclass Duck:\n    def __init__(self):\n        self.flyer = Flyer()\n        self.swimmer = Swimmer()\n    \n    def fly(self):\n        return self.flyer.fly()\n    \n    def swim(self):\n        return self.swimmer.swim()\n```\n\n**6. dataclass 활용 (Python 3.7+)**\n```python\nfrom dataclasses import dataclass\n\n# Bad: 반복적인 보일러플레이트\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __repr__(self):\n        return f\"Point(x={self.x}, y={self.y})\"\n    \n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n# Good: dataclass로 간결하게\n@dataclass\nclass Point:\n    x: float\n    y: float\n    # __init__, __repr__, __eq__ 자동 생성!\n```\n\n**7. 타입 힌트 사용**\n```python\nfrom typing import List, Optional\n\nclass User:\n    def __init__(self, user_id: int, name: str, email: str):\n        self.user_id: int = user_id\n        self.name: str = name\n        self.email: str = email\n    \n    def get_friends(self) -> List['User']:\n        return []\n    \n    def find_by_id(self, user_id: int) -> Optional['User']:\n        return None\n```"
      },
      {
        "type": "common-mistake",
        "title": "흔한 실수와 해결책",
        "content": "**1. self 누락**\n```python\n# 실수: self 빠뜨림\nclass Dog:\n    def __init__(self, name):\n        name = name  # self 없음!\n    \n    def bark():\n        print(\"멍멍\")  # self 없음!\n\n# 해결책\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n    \n    def bark(self):\n        print(f\"{self.name}: 멍멍\")\n```\n\n**2. 가변 기본값 사용**\n```python\n# 실수: 리스트를 기본값으로 사용\nclass Team:\n    def __init__(self, members=[]):\n        self.members = members  # 버그!\n\nteam1 = Team()\nteam1.members.append(\"Alice\")\n\nteam2 = Team()\nprint(team2.members)  # ['Alice'] - 예상치 못한 결과!\n\n# 해결책: None 사용\nclass Team:\n    def __init__(self, members=None):\n        self.members = members if members is not None else []\n```\n\n**3. 클래스 변수와 인스턴스 변수 혼동**\n```python\n# 실수: 클래스 변수를 인스턴스 변수처럼 사용\nclass Counter:\n    count = 0  # 클래스 변수 (모든 인스턴스 공유)\n    \n    def increment(self):\n        self.count += 1  # 새 인스턴스 변수 생성! (의도와 다름)\n\n# 해결책 1: 명시적으로 클래스 변수 수정\nclass Counter:\n    count = 0\n    \n    def increment(self):\n        Counter.count += 1  # 또는 self.__class__.count += 1\n\n# 해결책 2: 인스턴스 변수로 변경\nclass Counter:\n    def __init__(self):\n        self.count = 0  # 인스턴스 변수\n    \n    def increment(self):\n        self.count += 1\n```\n\n**4. 순환 참조 (Circular Reference)**\n```python\n# 실수: 서로 참조하는 클래스\nclass Parent:\n    def __init__(self):\n        self.child = Child(self)  # 순환 참조 시작\n\nclass Child:\n    def __init__(self, parent):\n        self.parent = parent\n\n# 해결책: 약한 참조 사용\nimport weakref\n\nclass Child:\n    def __init__(self, parent):\n        self.parent = weakref.ref(parent)  # 약한 참조\n```\n\n**5. __init__에서 return 사용**\n```python\n# 실수: __init__에서 값 반환\nclass Person:\n    def __init__(self, name):\n        self.name = name\n        return name  # TypeError!\n\n# 해결책: __init__은 None을 반환해야 함\nclass Person:\n    def __init__(self, name):\n        self.name = name\n        # return 문 없음 (또는 return None)\n```\n\n**6. 메서드를 프로퍼티처럼 호출**\n```python\n# 실수: 괄호 누락\nclass Dog:\n    def bark(self):\n        return \"멍멍\"\n\ndog = Dog()\nprint(dog.bark)  # <bound method Dog.bark ...> (함수 객체)\n\n# 해결책: 괄호 추가\nprint(dog.bark())  # \"멍멍\"\n\n# 또는 프로퍼티로 만들기\nclass Dog:\n    @property\n    def bark(self):\n        return \"멍멍\"\n\ndog = Dog()\nprint(dog.bark)  # \"멍멍\" (괄호 없이 호출)\n```\n\n**7. 다이아몬드 상속 문제 (MRO)**\n```python\n# 실수: 다이아몬드 상속에서 MRO 이해 부족\nclass A:\n    def method(self):\n        print(\"A\")\n\nclass B(A):\n    def method(self):\n        print(\"B\")\n\nclass C(A):\n    def method(self):\n        print(\"C\")\n\nclass D(B, C):\n    pass\n\nd = D()\nd.method()  # \"B\" 출력 (MRO: D -> B -> C -> A)\n\n# MRO 확인\nprint(D.__mro__)\n# (<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>)\n```"
      },
      {
        "type": "tip",
        "title": "클래스 고급 활용 팁",
        "content": "**1. __slots__로 메모리 최적화**\n```python\n# 일반 클래스: 딕셔너리 사용 (메모리 많이 사용)\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n# __slots__ 사용: 메모리 절약\nclass Point:\n    __slots__ = ['x', 'y']\n    \n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n# 수백만 개 인스턴스 생성 시 메모리 사용량 크게 감소\n```\n\n**2. __call__로 인스턴스를 함수처럼 호출**\n```python\nclass Multiplier:\n    def __init__(self, factor):\n        self.factor = factor\n    \n    def __call__(self, x):\n        return x * self.factor\n\ndouble = Multiplier(2)\ntriple = Multiplier(3)\n\nprint(double(5))  # 10\nprint(triple(5))  # 15\n```\n\n**3. contextlib으로 컨텍스트 매니저**\n```python\nfrom contextlib import contextmanager\n\nclass DatabaseConnection:\n    def __enter__(self):\n        print(\"데이터베이스 연결\")\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print(\"데이터베이스 연결 종료\")\n    \n    def query(self, sql):\n        print(f\"쿼리 실행: {sql}\")\n\n# with 문과 함께 사용\nwith DatabaseConnection() as db:\n    db.query(\"SELECT * FROM users\")\n# 자동으로 __exit__ 호출됨\n```\n\n**4. __getattr__와 __setattr__로 동적 속성**\n```python\nclass DynamicClass:\n    def __getattr__(self, name):\n        \"\"\"존재하지 않는 속성 접근 시 호출\"\"\"\n        return f\"{name} 속성이 없습니다.\"\n    \n    def __setattr__(self, name, value):\n        \"\"\"속성 설정 시 호출\"\"\"\n        print(f\"{name} = {value} 설정\")\n        super().__setattr__(name, value)\n\nobj = DynamicClass()\nprint(obj.unknown)  # \"unknown 속성이 없습니다.\"\nobj.name = \"Alice\"  # \"name = Alice 설정\"\n```\n\n**5. 메타클래스(Metaclass) 활용**\n```python\nclass SingletonMeta(type):\n    \"\"\"싱글톤 메타클래스\"\"\"\n    _instances = {}\n    \n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass Database(metaclass=SingletonMeta):\n    def __init__(self):\n        print(\"데이터베이스 초기화\")\n\ndb1 = Database()  # \"데이터베이스 초기화\" 출력\ndb2 = Database()  # 출력 없음 (같은 인스턴스)\nassert db1 is db2  # True\n```\n\n**6. 디스크립터(Descriptor) 프로토콜**\n```python\nclass Validator:\n    def __init__(self, min_value, max_value):\n        self.min_value = min_value\n        self.max_value = max_value\n    \n    def __set_name__(self, owner, name):\n        self.name = name\n    \n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        return instance.__dict__.get(self.name)\n    \n    def __set__(self, instance, value):\n        if not (self.min_value <= value <= self.max_value):\n            raise ValueError(f\"{self.name}은 {self.min_value}~{self.max_value} 범위여야 합니다.\")\n        instance.__dict__[self.name] = value\n\nclass Person:\n    age = Validator(0, 150)\n    \n    def __init__(self, age):\n        self.age = age\n\nperson = Person(25)\nprint(person.age)  # 25\n# person.age = 200  # ValueError!\n```\n\n**7. Enum 클래스로 상수 관리**\n```python\nfrom enum import Enum, auto\n\nclass Status(Enum):\n    PENDING = auto()\n    APPROVED = auto()\n    REJECTED = auto()\n\norder_status = Status.PENDING\n\nif order_status == Status.PENDING:\n    print(\"주문 대기 중\")\n\nprint(Status.PENDING.name)   # \"PENDING\"\nprint(Status.PENDING.value)  # 1\n```"
      },
      {
        "type": "practice",
        "title": "연습 문제",
        "content": "**문제 1: 기본 클래스**\n`Car` 클래스를 만드세요:\n- 속성: brand, model, year\n- 메서드: `get_info()` - \"2020 Toyota Camry\" 형식으로 반환\n\n**문제 2: 계좌 관리**\n은행 계좌를 나타내는 `BankAccount` 클래스를 만드세요:\n- 속성: owner, balance (초기값 0)\n- 메서드: \n  - `deposit(amount)`: 입금\n  - `withdraw(amount)`: 출금 (잔액 부족 시 에러 메시지)\n  - `get_balance()`: 현재 잔액 반환\n\n**문제 3: 상속**\n`Animal` 부모 클래스와 `Dog`, `Cat` 자식 클래스를 만드세요:\n- `Animal`: `speak()` 메서드 (\"동물 소리\" 반환)\n- `Dog`: `speak()` 오버라이딩 (\"멍멍\" 반환)\n- `Cat`: `speak()` 오버라이딩 (\"야옹\" 반환)\n\n**문제 4: 프로퍼티**\n`Temperature` 클래스를 만드세요:\n- 섭씨 온도를 저장\n- `fahrenheit` 프로퍼티: 화씨로 자동 변환 (F = C × 9/5 + 32)\n- Getter와 Setter 모두 구현\n\n**문제 5: 클래스 메서드**\n`Date` 클래스를 만드세요:\n- 속성: year, month, day\n- 클래스 메서드 `from_string(date_string)`: \"2024-12-25\" 형식의 문자열로 Date 객체 생성\n\n**문제 6: 특수 메서드**\n`Vector` 클래스를 만드세요:\n- 속성: x, y\n- `__add__`: 벡터 덧셈\n- `__str__`: \"Vector(x, y)\" 형식으로 출력\n- `__len__`: 벡터의 크기 (√(x² + y²)) 반환\n\n**문제 7: 실전 문제 - 쇼핑 카트**\n온라인 쇼핑 시스템을 만드세요:\n```python\nclass Product:\n    # 상품 정보 (name, price)\n    pass\n\nclass ShoppingCart:\n    # 카트에 상품 추가/제거\n    # 총 금액 계산\n    pass\n\n# 사용 예시\ncart = ShoppingCart()\ncart.add_item(Product(\"노트북\", 1000000), quantity=1)\ncart.add_item(Product(\"마우스\", 30000), quantity=2)\nprint(cart.get_total())  # 1,060,000\n```\n\n**보너스 문제: 데코레이터 클래스**\n메서드 호출 횟수를 세는 데코레이터 클래스를 만드세요:\n```python\nclass CountCalls:\n    def __init__(self, func):\n        # 초기화\n        pass\n    \n    def __call__(self, *args, **kwargs):\n        # 호출 횟수 증가 및 함수 실행\n        pass\n\n@CountCalls\ndef greet(name):\n    print(f\"안녕하세요, {name}님!\")\n\ngreet(\"Alice\")  # 호출 횟수: 1\ngreet(\"Bob\")    # 호출 횟수: 2\n```"
      }
    ]
  },
  "01_python-basics/05_modules": {
    "id": "01_python-basics/05_modules",
    "title": "05 Modules",
    "category": "ai-roadmap",
    "subCategory": "01_python-basics",
    "language": "Python",
    "description": "Python 모듈, 패키지, import 문을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "모듈(Module)과 패키지(Package)",
        "content": "모듈은 Python 코드를 담고 있는 파일(.py)이며, 패키지는 여러 모듈을 묶은 디렉토리입니다. 코드를 재사용하고 체계적으로 관리할 수 있게 해줍니다.\n\n**모듈(Module)**\n- 단일 .py 파일\n- 함수, 클래스, 변수를 포함\n- `import` 문으로 불러와 사용\n- 예: `math.py`, `random.py`\n\n**패키지(Package)**\n- 모듈들을 담은 디렉토리\n- `__init__.py` 파일 포함 (Python 3.3+에서는 선택사항)\n- 계층 구조로 코드 조직화\n- 예: `numpy`, `pandas`, `requests`\n\n**import 방식:**\n1. `import 모듈`: 전체 모듈 가져오기\n2. `from 모듈 import 함수`: 특정 항목만 가져오기\n3. `import 모듈 as 별칭`: 별칭으로 가져오기\n4. `from 모듈 import *`: 모든 항목 가져오기 (비권장)\n\n**내장 모듈:**\nPython은 다양한 내장 모듈을 제공합니다:\n- `os`: 운영체제 기능\n- `sys`: 시스템 관련 기능\n- `math`: 수학 함수\n- `random`: 난수 생성\n- `datetime`: 날짜/시간 처리\n- `json`: JSON 데이터 처리\n- `re`: 정규 표현식\n\n**모듈 검색 경로:**\nPython은 다음 순서로 모듈을 찾습니다:\n1. 현재 디렉토리\n2. PYTHONPATH 환경 변수\n3. 표준 라이브러리 디렉토리\n4. site-packages (설치된 외부 패키지)"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ===== 1. 기본 import =====\nimport math\n\nprint(math.pi)           # 3.141592653589793\nprint(math.sqrt(16))     # 4.0\nprint(math.factorial(5)) # 120\n\n# ===== 2. from import (특정 항목만 가져오기) =====\nfrom math import pi, sqrt, pow\n\nprint(pi)           # 3.141592653589793\nprint(sqrt(25))     # 5.0\nprint(pow(2, 3))    # 8.0\n\n# ===== 3. import as (별칭 사용) =====\nimport numpy as np\nimport pandas as pd\n\narr = np.array([1, 2, 3, 4, 5])\ndf = pd.DataFrame({'A': [1, 2, 3]})\n\nprint(arr.mean())   # 3.0\nprint(df.head())\n\n# ===== 4. 여러 모듈 한 번에 import =====\nimport os, sys, json\n\nprint(os.getcwd())          # 현재 디렉토리\nprint(sys.version)          # Python 버전\ndata = json.dumps({'key': 'value'})\n\n# ===== 5. 사용자 정의 모듈 만들기 =====\n# my_module.py 파일 생성\n\"\"\"\n# my_module.py\ndef greet(name):\n    return f\"안녕하세요, {name}님!\"\n\ndef add(a, b):\n    return a + b\n\nPI = 3.14159\n\"\"\"\n\n# 다른 파일에서 import\nimport my_module\n\nprint(my_module.greet(\"Alice\"))  # 안녕하세요, Alice님!\nprint(my_module.add(10, 20))     # 30\nprint(my_module.PI)              # 3.14159\n\n# ===== 6. 패키지 구조 예시 =====\n\"\"\"\n프로젝트 구조:\nmy_project/\n├── main.py\n└── utils/\n    ├── __init__.py\n    ├── math_utils.py\n    └── string_utils.py\n\"\"\"\n\n# utils/math_utils.py\n\"\"\"\ndef square(x):\n    return x ** 2\n\ndef cube(x):\n    return x ** 3\n\"\"\"\n\n# utils/string_utils.py\n\"\"\"\ndef reverse(text):\n    return text[::-1]\n\ndef uppercase(text):\n    return text.upper()\n\"\"\"\n\n# utils/__init__.py\n\"\"\"\nfrom .math_utils import square, cube\nfrom .string_utils import reverse, uppercase\n\"\"\"\n\n# main.py에서 사용\nfrom utils import square, reverse\n# 또는\nimport utils.math_utils as math_utils\n\nprint(square(5))         # 25\nprint(reverse(\"hello\"))  # \"olleh\"\n\n# ===== 7. __name__ == \"__main__\" 패턴 =====\n# my_script.py\n\"\"\"\ndef main():\n    print(\"메인 함수 실행\")\n\nif __name__ == \"__main__\":\n    # 이 파일이 직접 실행될 때만 실행\n    main()\nelse:\n    # 다른 곳에서 import될 때는 실행 안 됨\n    pass\n\"\"\"\n\n# ===== 8. 동적 import (importlib) =====\nimport importlib\n\n# 문자열로 모듈 이름 지정\nmodule_name = \"math\"\nmath_module = importlib.import_module(module_name)\nprint(math_module.pi)  # 3.141592653589793\n\n# 모듈 리로드 (개발 중 유용)\nimportlib.reload(math_module)\n\n# ===== 9. 상대 경로 import =====\n\"\"\"\n패키지 구조:\nproject/\n├── main.py\n└── package/\n    ├── __init__.py\n    ├── module_a.py\n    └── subpackage/\n        ├── __init__.py\n        └── module_b.py\n\"\"\"\n\n# package/subpackage/module_b.py에서:\n\"\"\"\nfrom .. import module_a         # 상위 디렉토리의 module_a\nfrom ..module_a import func      # 상위 디렉토리 module_a의 func\nfrom . import another_module     # 같은 디렉토리의 another_module\n\"\"\"\n\n# ===== 10. sys.path 조작 =====\nimport sys\n\n# 현재 모듈 검색 경로 확인\nprint(sys.path)\n\n# 새 경로 추가\nsys.path.append('/path/to/my/modules')\n\n# 이제 해당 경로의 모듈을 import 가능\n# import my_custom_module\n\n# ===== 11. __all__ 변수로 export 제어 =====\n# my_module.py\n\"\"\"\n__all__ = ['public_func', 'PublicClass']\n\ndef public_func():\n    pass\n\ndef _private_func():\n    pass\n\nclass PublicClass:\n    pass\n\nclass _PrivateClass:\n    pass\n\"\"\"\n\n# 다른 파일에서\n\"\"\"\nfrom my_module import *\n# public_func와 PublicClass만 가져와짐\n# _private_func와 _PrivateClass는 안 가져와짐\n\"\"\"\n\n# ===== 12. 순환 import 해결 =====\n# Bad: 순환 참조\n\"\"\"\n# module_a.py\nimport module_b\n\ndef func_a():\n    module_b.func_b()\n\n# module_b.py\nimport module_a\n\ndef func_b():\n    module_a.func_a()  # 순환 참조!\n\"\"\"\n\n# Good: 지연 import\n\"\"\"\n# module_a.py\ndef func_a():\n    import module_b  # 함수 내부에서 import\n    module_b.func_b()\n\"\"\"\n\n# ===== 13. 조건부 import =====\ntry:\n    import numpy as np\n    HAS_NUMPY = True\nexcept ImportError:\n    HAS_NUMPY = False\n    print(\"NumPy가 설치되지 않았습니다.\")\n\nif HAS_NUMPY:\n    arr = np.array([1, 2, 3])\nelse:\n    arr = [1, 2, 3]  # 일반 리스트 사용\n\n# ===== 14. 주요 내장 모듈 예시 =====\n\n# os 모듈: 파일/디렉토리 작업\nimport os\n\nprint(os.getcwd())               # 현재 작업 디렉토리\nprint(os.listdir('.'))           # 현재 디렉토리 파일 목록\nif not os.path.exists('data'):\n    os.makedirs('data')          # 디렉토리 생성\n\n# datetime 모듈: 날짜/시간\nfrom datetime import datetime, timedelta\n\nnow = datetime.now()\nprint(now.strftime('%Y-%m-%d %H:%M:%S'))\n\ntomorrow = now + timedelta(days=1)\nprint(tomorrow)\n\n# random 모듈: 난수 생성\nimport random\n\nprint(random.randint(1, 10))           # 1~10 사이 정수\nprint(random.choice(['a', 'b', 'c']))  # 리스트에서 무작위 선택\nprint(random.random())                 # 0~1 사이 실수\n\n# json 모듈: JSON 처리\nimport json\n\ndata = {'name': 'Alice', 'age': 25}\njson_str = json.dumps(data, indent=2)  # Python → JSON\nprint(json_str)\n\nparsed = json.loads(json_str)          # JSON → Python\nprint(parsed['name'])  # Alice\n\n# re 모듈: 정규 표현식\nimport re\n\ntext = \"이메일: alice@example.com, bob@test.com\"\nemails = re.findall(r'[\\w.-]+@[\\w.-]+', text)\nprint(emails)  # ['alice@example.com', 'bob@test.com']\n\n# collections 모듈: 특수 컨테이너\nfrom collections import Counter, defaultdict, namedtuple\n\nwords = ['apple', 'banana', 'apple', 'cherry', 'banana']\ncount = Counter(words)\nprint(count)  # Counter({'apple': 2, 'banana': 2, 'cherry': 1})\n\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(10, 20)\nprint(p.x, p.y)  # 10 20"
      },
      {
        "type": "use-case",
        "title": "실무 활용 사례",
        "content": "**1. 유틸리티 모듈 구조화**\n```python\n# 프로젝트 구조:\n# project/\n# ├── main.py\n# └── utils/\n#     ├── __init__.py\n#     ├── file_utils.py\n#     ├── data_utils.py\n#     └── config.py\n\n# utils/file_utils.py\nimport os\nimport json\nfrom typing import Any, Dict\n\ndef load_json(filepath: str) -> Dict[str, Any]:\n    \"\"\"JSON 파일 로드\"\"\"\n    with open(filepath, 'r', encoding='utf-8') as f:\n        return json.load(f)\n\ndef save_json(data: Dict[str, Any], filepath: str):\n    \"\"\"JSON 파일 저장\"\"\"\n    with open(filepath, 'w', encoding='utf-8') as f:\n        json.dump(data, f, ensure_ascii=False, indent=2)\n\ndef ensure_dir(directory: str):\n    \"\"\"디렉토리 생성 (존재하지 않으면)\"\"\"\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n\n# utils/data_utils.py\nimport pandas as pd\nimport numpy as np\n\ndef clean_missing_values(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"결측값 처리\"\"\"\n    numeric_cols = df.select_dtypes(include=[np.number]).columns\n    df[numeric_cols] = df[numeric_cols].fillna(df[numeric_cols].mean())\n    \n    object_cols = df.select_dtypes(include=['object']).columns\n    df[object_cols] = df[object_cols].fillna('Unknown')\n    \n    return df\n\ndef normalize_data(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"데이터 정규화 (0-1 스케일)\"\"\"\n    numeric_cols = df.select_dtypes(include=[np.number]).columns\n    df[numeric_cols] = (df[numeric_cols] - df[numeric_cols].min()) / \\\n                       (df[numeric_cols].max() - df[numeric_cols].min())\n    return df\n\n# utils/config.py\nimport os\nfrom typing import Optional\n\nclass Config:\n    \"\"\"설정 관리 클래스\"\"\"\n    DATABASE_URL: str = os.getenv('DATABASE_URL', 'sqlite:///app.db')\n    API_KEY: Optional[str] = os.getenv('API_KEY')\n    DEBUG: bool = os.getenv('DEBUG', 'False').lower() == 'true'\n    MAX_WORKERS: int = int(os.getenv('MAX_WORKERS', '4'))\n\n# utils/__init__.py\nfrom .file_utils import load_json, save_json, ensure_dir\nfrom .data_utils import clean_missing_values, normalize_data\nfrom .config import Config\n\n__all__ = [\n    'load_json', 'save_json', 'ensure_dir',\n    'clean_missing_values', 'normalize_data',\n    'Config'\n]\n\n# main.py에서 사용\nfrom utils import load_json, save_json, Config\nfrom utils.data_utils import clean_missing_values\n\nconfig = Config()\ndata = load_json('data.json')\ndf = clean_missing_values(data)\n```\n\n**2. 데이터 과학 프로젝트 모듈 구조**\n```python\n# ml_project/\n# ├── main.py\n# ├── data/\n# │   ├── __init__.py\n# │   ├── loader.py\n# │   └── preprocessor.py\n# ├── models/\n# │   ├── __init__.py\n# │   ├── base_model.py\n# │   └── classifier.py\n# └── evaluation/\n#     ├── __init__.py\n#     └── metrics.py\n\n# data/loader.py\nimport pandas as pd\nfrom typing import Tuple\n\nclass DataLoader:\n    @staticmethod\n    def load_csv(filepath: str) -> pd.DataFrame:\n        return pd.read_csv(filepath)\n    \n    @staticmethod\n    def split_features_target(df: pd.DataFrame, target_col: str) -> Tuple:\n        X = df.drop(columns=[target_col])\n        y = df[target_col]\n        return X, y\n\n# data/preprocessor.py\nfrom sklearn.preprocessing import StandardScaler\nimport pandas as pd\n\nclass Preprocessor:\n    def __init__(self):\n        self.scaler = StandardScaler()\n    \n    def fit_transform(self, df: pd.DataFrame) -> pd.DataFrame:\n        numeric_cols = df.select_dtypes(include=['float64', 'int64']).columns\n        df[numeric_cols] = self.scaler.fit_transform(df[numeric_cols])\n        return df\n\n# models/classifier.py\nfrom sklearn.ensemble import RandomForestClassifier\nfrom typing import Any\nimport numpy as np\n\nclass Classifier:\n    def __init__(self, **params):\n        self.model = RandomForestClassifier(**params)\n        self.is_trained = False\n    \n    def train(self, X: np.ndarray, y: np.ndarray):\n        self.model.fit(X, y)\n        self.is_trained = True\n    \n    def predict(self, X: np.ndarray) -> np.ndarray:\n        if not self.is_trained:\n            raise RuntimeError(\"모델이 학습되지 않았습니다.\")\n        return self.model.predict(X)\n\n# evaluation/metrics.py\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\nimport numpy as np\n\ndef evaluate_model(y_true: np.ndarray, y_pred: np.ndarray) -> dict:\n    return {\n        'accuracy': accuracy_score(y_true, y_pred),\n        'precision': precision_score(y_true, y_pred, average='weighted'),\n        'recall': recall_score(y_true, y_pred, average='weighted'),\n        'f1_score': f1_score(y_true, y_pred, average='weighted')\n    }\n\n# main.py\nfrom data.loader import DataLoader\nfrom data.preprocessor import Preprocessor\nfrom models.classifier import Classifier\nfrom evaluation.metrics import evaluate_model\nfrom sklearn.model_selection import train_test_split\n\n# 파이프라인 실행\nloader = DataLoader()\ndf = loader.load_csv('data.csv')\nX, y = loader.split_features_target(df, 'target')\n\npreprocessor = Preprocessor()\nX = preprocessor.fit_transform(X)\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n\nmodel = Classifier(n_estimators=100)\nmodel.train(X_train, y_train)\n\ny_pred = model.predict(X_test)\nmetrics = evaluate_model(y_test, y_pred)\nprint(metrics)\n```\n\n**3. 웹 스크래핑 프로젝트**\n```python\n# scraper_project/\n# ├── main.py\n# ├── scrapers/\n# │   ├── __init__.py\n# │   ├── base_scraper.py\n# │   └── product_scraper.py\n# └── storage/\n#     ├── __init__.py\n#     └── database.py\n\n# scrapers/base_scraper.py\nimport requests\nfrom bs4 import BeautifulSoup\nfrom abc import ABC, abstractmethod\nimport time\n\nclass BaseScraper(ABC):\n    def __init__(self, base_url: str):\n        self.base_url = base_url\n        self.session = requests.Session()\n    \n    def fetch_page(self, url: str) -> str:\n        \"\"\"페이지 가져오기 (재시도 로직 포함)\"\"\"\n        for attempt in range(3):\n            try:\n                response = self.session.get(url, timeout=10)\n                response.raise_for_status()\n                return response.text\n            except requests.RequestException:\n                if attempt == 2:\n                    raise\n                time.sleep(2 ** attempt)\n    \n    @abstractmethod\n    def parse(self, html: str):\n        \"\"\"HTML 파싱 (서브클래스에서 구현)\"\"\"\n        pass\n\n# scrapers/product_scraper.py\nfrom .base_scraper import BaseScraper\nfrom bs4 import BeautifulSoup\nfrom typing import List, Dict\n\nclass ProductScraper(BaseScraper):\n    def parse(self, html: str) -> List[Dict]:\n        soup = BeautifulSoup(html, 'html.parser')\n        products = []\n        \n        for item in soup.find_all('div', class_='product'):\n            product = {\n                'name': item.find('h3').text.strip(),\n                'price': item.find('span', class_='price').text.strip(),\n                'rating': item.find('span', class_='rating').text.strip()\n            }\n            products.append(product)\n        \n        return products\n```\n\n**4. API 서비스 모듈화**\n```python\n# api_project/\n# ├── main.py\n# ├── api/\n# │   ├── __init__.py\n# │   ├── client.py\n# │   └── endpoints.py\n# └── models/\n#     ├── __init__.py\n#     └── response.py\n\n# api/client.py\nimport requests\nfrom typing import Optional, Dict, Any\n\nclass APIClient:\n    def __init__(self, base_url: str, api_key: Optional[str] = None):\n        self.base_url = base_url\n        self.session = requests.Session()\n        if api_key:\n            self.session.headers['Authorization'] = f'Bearer {api_key}'\n    \n    def request(self, method: str, endpoint: str, **kwargs) -> Dict[Any, Any]:\n        url = f\"{self.base_url}{endpoint}\"\n        response = self.session.request(method, url, **kwargs)\n        response.raise_for_status()\n        return response.json()\n\n# api/endpoints.py\nfrom .client import APIClient\nfrom typing import List, Dict\n\nclass UserEndpoint:\n    def __init__(self, client: APIClient):\n        self.client = client\n    \n    def get_all(self) -> List[Dict]:\n        return self.client.request('GET', '/users')\n    \n    def get_by_id(self, user_id: int) -> Dict:\n        return self.client.request('GET', f'/users/{user_id}')\n    \n    def create(self, data: Dict) -> Dict:\n        return self.client.request('POST', '/users', json=data)\n```"
      },
      {
        "type": "best-practice",
        "title": "모듈 사용 모범 사례",
        "content": "**1. import 문은 파일 상단에 작성**\n```python\n# Good: 파일 상단에 모든 import\nimport os\nimport sys\nfrom typing import List\n\nimport numpy as np\nimport pandas as pd\n\nfrom my_package import my_module\n\ndef my_function():\n    pass\n\n# Bad: 함수 사이에 import (예외: 지연 import 제외)\ndef func1():\n    pass\n\nimport random  # X\n\ndef func2():\n    pass\n```\n\n**2. import 순서 지키기 (PEP 8)**\n```python\n# 1. 표준 라이브러리\nimport os\nimport sys\nfrom datetime import datetime\n\n# 2. 서드파티 라이브러리\nimport numpy as np\nimport pandas as pd\nimport requests\n\n# 3. 로컬 모듈\nfrom my_package import my_module\nfrom .utils import helper_function\n```\n\n**3. from module import * 피하기**\n```python\n# Bad: 네임스페이스 오염\nfrom math import *\nfrom numpy import *\n\nresult = sqrt(16)  # math.sqrt인가 numpy.sqrt인가?\n\n# Good: 명시적 import\nfrom math import sqrt, pi\nimport numpy as np\n\nmath_result = sqrt(16)\nnumpy_result = np.sqrt(16)\n```\n\n**4. 명확한 별칭 사용**\n```python\n# Good: 업계 표준 별칭\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport tensorflow as tf\n\n# Bad: 모호한 별칭\nimport numpy as n\nimport pandas as p\nimport matplotlib.pyplot as plot\n```\n\n**5. __init__.py에서 공개 API 정의**\n```python\n# package/__init__.py\nfrom .module_a import func_a, ClassA\nfrom .module_b import func_b, ClassB\n\n__all__ = ['func_a', 'ClassA', 'func_b', 'ClassB']\n__version__ = '1.0.0'\n\n# 사용자는 간단하게 import 가능\n# from package import func_a, ClassA\n```\n\n**6. 순환 import 방지**\n```python\n# Bad: 순환 참조\n# module_a.py\nfrom module_b import func_b\n\ndef func_a():\n    func_b()\n\n# module_b.py\nfrom module_a import func_a  # 순환!\n\ndef func_b():\n    func_a()\n\n# Good: 리팩토링으로 해결\n# shared_module.py\ndef shared_func():\n    pass\n\n# module_a.py\nfrom shared_module import shared_func\n\n# module_b.py\nfrom shared_module import shared_func\n```\n\n**7. 조건부 import 활용**\n```python\n# 선택적 의존성 처리\ntry:\n    import matplotlib.pyplot as plt\n    HAS_MATPLOTLIB = True\nexcept ImportError:\n    HAS_MATPLOTLIB = False\n\ndef plot_data(data):\n    if not HAS_MATPLOTLIB:\n        raise RuntimeError(\"matplotlib가 필요합니다.\")\n    plt.plot(data)\n    plt.show()\n```\n\n**8. 지연 import (필요할 때만)**\n```python\ndef heavy_function():\n    # 함수 호출 시에만 import (모듈 로딩 시간 절약)\n    import tensorflow as tf\n    model = tf.keras.models.load_model('model.h5')\n    return model\n\n# 전역에서 import하면 프로그램 시작이 느려짐\n# import tensorflow as tf  # X (무거운 라이브러리)\n```"
      },
      {
        "type": "common-mistake",
        "title": "흔한 실수와 해결책",
        "content": "**1. 모듈 이름 충돌**\n```python\n# 실수: 표준 라이브러리와 같은 이름의 파일 생성\n# random.py (사용자 파일)\ndef my_function():\n    pass\n\n# 다른 파일에서\nimport random\nprint(random.randint(1, 10))  # ModuleNotFoundError!\n# 표준 라이브러리 random 대신 사용자 random.py를 import함\n\n# 해결책: 다른 이름 사용\n# my_random.py로 이름 변경\n```\n\n**2. 상대 경로 import 오류**\n```python\n# 실수: 잘못된 상대 경로\n# package/module_a.py\nfrom .module_b import func  # OK\n\n# 하지만 module_a.py를 직접 실행하면:\n# python module_a.py\n# ValueError: attempted relative import beyond top-level package\n\n# 해결책: 패키지로 실행\n# python -m package.module_a\n```\n\n**3. __init__.py 누락 (Python 3.3 이전)**\n```python\n# 실수: __init__.py가 없는 디렉토리\n# my_package/\n# └── module.py  (__init__.py 없음)\n\nimport my_package.module  # ImportError (Python 3.3 이전)\n\n# 해결책: __init__.py 파일 추가 (빈 파일도 OK)\n# my_package/\n# ├── __init__.py\n# └── module.py\n```\n\n**4. sys.path 잘못된 조작**\n```python\n# 실수: sys.path에 상대 경로 추가\nimport sys\nsys.path.append('../my_modules')  # 현재 디렉토리에 따라 다름\n\n# 해결책: 절대 경로 사용\nimport os\nimport sys\n\nproject_root = os.path.dirname(os.path.abspath(__file__))\nmodule_path = os.path.join(project_root, 'my_modules')\nsys.path.insert(0, module_path)\n```\n\n**5. import 문 위치 실수**\n```python\n# 실수: if 문 안에 import (매번 실행)\nfor i in range(1000):\n    import math  # 1000번 import! (비효율)\n    result = math.sqrt(i)\n\n# 해결책: 파일 상단에서 한 번만 import\nimport math\n\nfor i in range(1000):\n    result = math.sqrt(i)\n```\n\n**6. 모듈 vs 패키지 혼동**\n```python\n# 실수: 패키지를 모듈처럼 import\n# utils/ (디렉토리)\n# ├── __init__.py\n# └── helpers.py\n\nimport utils  # 패키지 import\nutils.helper_function()  # AttributeError!\n\n# 해결책 1: 명시적으로 모듈 import\nfrom utils import helpers\nhelpers.helper_function()\n\n# 해결책 2: __init__.py에서 노출\n# utils/__init__.py\nfrom .helpers import helper_function\n\nimport utils\nutils.helper_function()  # OK\n```\n\n**7. reload() 잘못 사용**\n```python\n# 실수: import 후 변경된 모듈 자동 반영 안 됨\nimport my_module\n\n# my_module.py 파일 수정\n\nimport my_module  # 다시 import해도 변경 사항 반영 안 됨!\n\n# 해결책: importlib.reload() 사용\nimport importlib\nimportlib.reload(my_module)  # 모듈 다시 로드\n```"
      },
      {
        "type": "tip",
        "title": "모듈 고급 활용 팁",
        "content": "**1. __all__로 공개 API 제어**\n```python\n# my_module.py\n__all__ = ['public_func', 'PublicClass']\n\ndef public_func():\n    pass\n\ndef _internal_func():\n    pass\n\nclass PublicClass:\n    pass\n\n# 다른 파일에서\nfrom my_module import *\n# public_func와 PublicClass만 import됨\n```\n\n**2. if __name__ == \"__main__\" 패턴**\n```python\n# script.py\ndef main():\n    print(\"메인 함수 실행\")\n\nif __name__ == \"__main__\":\n    # 직접 실행: python script.py\n    main()\nelse:\n    # import되었을 때: import script\n    pass  # 실행 안 됨\n```\n\n**3. pkgutil로 패키지 탐색**\n```python\nimport pkgutil\nimport my_package\n\n# 패키지 내 모든 모듈 찾기\nfor importer, modname, ispkg in pkgutil.iter_modules(my_package.__path__):\n    print(f\"모듈: {modname}, 패키지 여부: {ispkg}\")\n```\n\n**4. __import__()로 동적 import**\n```python\n# 문자열로 모듈 이름 지정\nmodule_name = \"math\"\nmath_module = __import__(module_name)\nprint(math_module.pi)  # 3.141592653589793\n\n# 패키지에서 특정 모듈 import\nmodule = __import__('numpy.random', fromlist=['random'])\nprint(module.randint(1, 10))\n```\n\n**5. 환경 변수로 모듈 경로 추가**\n```bash\n# Linux/Mac\nexport PYTHONPATH=\"/path/to/my/modules:$PYTHONPATH\"\n\n# Windows\nset PYTHONPATH=C:\\path\\to\\my\\modules;%PYTHONPATH%\n```\n\n**6. Namespace 패키지 (PEP 420)**\n```python\n# __init__.py 없이도 패키지 생성 가능 (Python 3.3+)\n# my_namespace/\n# ├── package_a/\n# │   └── module_a.py\n# └── package_b/\n#     └── module_b.py\n\n# 양쪽 모두 my_namespace 네임스페이스 공유\nfrom my_namespace.package_a import module_a\nfrom my_namespace.package_b import module_b\n```\n\n**7. lazy_import로 지연 로딩**\n```python\n# 모듈이 실제로 사용될 때까지 로딩 지연\nclass LazyLoader:\n    def __init__(self, module_name):\n        self.module_name = module_name\n        self._module = None\n    \n    def __getattr__(self, name):\n        if self._module is None:\n            import importlib\n            self._module = importlib.import_module(self.module_name)\n        return getattr(self._module, name)\n\n# 사용\ntf = LazyLoader('tensorflow')  # 아직 로드 안 됨\nmodel = tf.keras.Model()       # 여기서 로드됨\n```\n\n**8. inspect 모듈로 모듈 분석**\n```python\nimport inspect\nimport math\n\n# 모듈의 모든 함수 가져오기\nfunctions = inspect.getmembers(math, inspect.isfunction)\nfor name, func in functions:\n    print(f\"{name}: {inspect.signature(func)}\")\n\n# 모듈 소스 코드 위치\nprint(inspect.getfile(math))  # 모듈 파일 경로\n```"
      },
      {
        "type": "practice",
        "title": "연습 문제",
        "content": "**문제 1: 기본 모듈 사용**\n다음 작업을 수행하는 코드를 작성하세요:\n- `math` 모듈의 `sqrt`, `pow` 함수만 import\n- 16의 제곱근과 2의 3제곱 계산\n\n**문제 2: 사용자 정의 모듈**\n`calculator.py` 모듈을 만드세요:\n- 함수: `add(a, b)`, `subtract(a, b)`, `multiply(a, b)`, `divide(a, b)`\n- 다른 파일에서 import하여 사용\n\n**문제 3: 패키지 구조**\n다음 구조의 패키지를 만드세요:\n```\nmy_utils/\n├── __init__.py\n├── string_utils.py  (reverse, uppercase 함수)\n└── math_utils.py    (factorial, is_prime 함수)\n```\n\n**문제 4: 조건부 import**\nnumpy가 설치되어 있으면 사용하고, 없으면 일반 리스트를 사용하는 코드를 작성하세요.\n\n**문제 5: 내장 모듈 활용**\n`datetime` 모듈을 사용하여:\n- 현재 날짜와 시간 출력\n- 7일 후 날짜 계산\n- \"YYYY-MM-DD HH:MM:SS\" 형식으로 포맷팅\n\n**문제 6: json 모듈**\n다음 딕셔너리를 JSON 파일로 저장하고 다시 로드하세요:\n```python\ndata = {\n    \"name\": \"Alice\",\n    \"age\": 25,\n    \"city\": \"Seoul\"\n}\n```\n\n**문제 7: 실전 문제 - 설정 관리**\n`config.py` 모듈을 만들어 설정을 관리하세요:\n```python\n# config.py\nDATABASE_URL = \"sqlite:///app.db\"\nAPI_KEY = \"your_api_key\"\nDEBUG = True\n\ndef get_config():\n    # 모든 설정을 딕셔너리로 반환\n    pass\n```\n\n**보너스 문제: 동적 모듈 로딩**\n사용자가 입력한 모듈 이름을 동적으로 import하고, 해당 모듈의 모든 함수 목록을 출력하세요.\n```python\nimport importlib\nimport inspect\n\nmodule_name = input(\"모듈 이름: \")  # 예: \"math\"\n# 모듈을 동적으로 로드하고 함수 목록 출력\n```"
      }
    ]
  },
  "01_python-basics/intro": {
    "id": "01_python-basics/intro",
    "title": "Intro",
    "category": "ai-roadmap",
    "subCategory": "01_python-basics",
    "language": "Python",
    "description": "Python 프로그래밍 기초를 시작합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Python 기초 학습 로드맵",
        "content": "Python은 배우기 쉽고 강력한 프로그래밍 언어입니다. AI, 데이터 과학, 웹 개발, 자동화 등 다양한 분야에서 활용됩니다.\n\n**Python의 특징:**\n- **간결하고 읽기 쉬운 문법**: 영어와 유사하여 초보자도 쉽게 배울 수 있습니다\n- **풍부한 라이브러리**: NumPy, Pandas, TensorFlow 등 강력한 라이브러리 생태계\n- **멀티 패러다임**: 절차적, 객체지향, 함수형 프로그래밍 모두 지원\n- **크로스 플랫폼**: Windows, Mac, Linux 모두에서 실행 가능\n- **활발한 커뮤니티**: 방대한 문서와 활발한 개발자 커뮤니티\n\n**학습 로드맵:**\n\n**1단계: 기본 문법 (1-2주)**\n- 변수와 데이터 타입\n- 조건문과 반복문\n- 함수 정의와 사용\n- 클래스와 객체\n- 모듈과 패키지\n\n**2단계: 데이터 처리 (2-3주)**\n- NumPy: 배열 연산\n- Pandas: 데이터프레임 처리\n- Matplotlib: 데이터 시각화\n\n**3단계: 특화 분야 선택**\n- AI/머신러닝: PyTorch, TensorFlow, scikit-learn\n- 웹 개발: Django, Flask, FastAPI\n- 데이터 분석: Pandas, Jupyter Notebook\n- 자동화: Selenium, BeautifulSoup\n\n**왜 Python을 배워야 할까?**\n- AI/머신러닝의 사실상 표준 언어\n- 취업 시장에서 높은 수요\n- 빠른 프로토타이핑과 생산성\n- 초보자부터 전문가까지 폭넓은 활용\n\n**학습 팁:**\n- 매일 조금씩 코딩 연습\n- 작은 프로젝트로 실전 경험\n- 공식 문서 읽기 습관\n- 커뮤니티 참여 (Stack Overflow, GitHub)"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ===== Python 기초 맛보기 =====\n\n# 1. Hello World\nprint(\"Hello, Python!\")\n\n# 2. 변수와 데이터 타입\nname = \"Alice\"        # 문자열\nage = 25              # 정수\nheight = 165.5        # 실수\nis_student = True     # 불린\n\nprint(f\"{name}님은 {age}세이고, 키는 {height}cm입니다.\")\n\n# 3. 리스트 (배열)\nfruits = [\"사과\", \"바나나\", \"체리\"]\nprint(fruits[0])      # 사과\nfruits.append(\"포도\")\nprint(fruits)         # ['사과', '바나나', '체리', '포도']\n\n# 4. 딕셔너리 (키-값 쌍)\nuser = {\n    \"name\": \"Bob\",\n    \"age\": 30,\n    \"city\": \"Seoul\"\n}\nprint(user[\"name\"])   # Bob\n\n# 5. 조건문\nscore = 85\nif score >= 90:\n    grade = \"A\"\nelif score >= 80:\n    grade = \"B\"\nelse:\n    grade = \"C\"\nprint(f\"점수 {score}점은 {grade}등급입니다.\")\n\n# 6. 반복문\n# for 루프\nfor fruit in fruits:\n    print(f\"좋아하는 과일: {fruit}\")\n\n# while 루프\ncount = 0\nwhile count < 3:\n    print(f\"카운트: {count}\")\n    count += 1\n\n# 7. 함수\ndef greet(name):\n    \"\"\"인사 메시지 반환\"\"\"\n    return f\"안녕하세요, {name}님!\"\n\nmessage = greet(\"Charlie\")\nprint(message)  # 안녕하세요, Charlie님!\n\n# 8. 리스트 컴프리헨션 (간결한 리스트 생성)\nsquares = [x ** 2 for x in range(10)]\nprint(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n# 짝수만 필터링\neven_numbers = [x for x in range(20) if x % 2 == 0]\nprint(even_numbers)  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\n# 9. 클래스와 객체\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def bark(self):\n        return f\"{self.name}: 멍멍!\"\n\nmy_dog = Dog(\"초코\", 3)\nprint(my_dog.bark())     # 초코: 멍멍!\nprint(my_dog.age)        # 3\n\n# 10. 파일 읽기/쓰기\n# 파일 쓰기\nwith open('example.txt', 'w', encoding='utf-8') as f:\n    f.write(\"안녕하세요, Python!\\n\")\n    f.write(\"파일 쓰기 예제입니다.\")\n\n# 파일 읽기\nwith open('example.txt', 'r', encoding='utf-8') as f:\n    content = f.read()\n    print(content)\n\n# 11. 예외 처리\ntry:\n    result = 10 / 0  # ZeroDivisionError 발생\nexcept ZeroDivisionError:\n    print(\"0으로 나눌 수 없습니다.\")\nexcept Exception as e:\n    print(f\"에러 발생: {e}\")\nfinally:\n    print(\"항상 실행되는 코드\")\n\n# 12. 람다 함수 (익명 함수)\nsquare = lambda x: x ** 2\nprint(square(5))  # 25\n\n# map, filter와 함께 사용\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x ** 2, numbers))\nprint(squared)  # [1, 4, 9, 16, 25]\n\neven = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even)  # [2, 4]\n\n# 13. 모듈 import\nimport math\nimport random\nfrom datetime import datetime\n\nprint(math.pi)              # 3.141592653589793\nprint(math.sqrt(16))        # 4.0\nprint(random.randint(1, 10)) # 1~10 사이 랜덤 정수\nprint(datetime.now())       # 현재 날짜/시간\n\n# 14. 리스트 언패킹\nfirst, *middle, last = [1, 2, 3, 4, 5]\nprint(first)    # 1\nprint(middle)   # [2, 3, 4]\nprint(last)     # 5\n\n# 15. enumerate와 zip\nfruits = [\"사과\", \"바나나\", \"체리\"]\n\n# enumerate: 인덱스와 값 함께 가져오기\nfor index, fruit in enumerate(fruits):\n    print(f\"{index}: {fruit}\")\n\n# zip: 여러 리스트 동시 순회\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [25, 30, 35]\n\nfor name, age in zip(names, ages):\n    print(f\"{name}는 {age}세입니다.\")"
      },
      {
        "type": "use-case",
        "title": "Python의 실무 활용 분야",
        "content": "**1. 데이터 분석 및 과학**\n```python\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# CSV 데이터 로드\ndf = pd.read_csv('sales_data.csv')\n\n# 데이터 분석\ntotal_sales = df['sales'].sum()\naverage_sales = df['sales'].mean()\nmax_sales_product = df.loc[df['sales'].idxmax(), 'product']\n\n# 시각화\ndf.groupby('product')['sales'].sum().plot(kind='bar')\nplt.title('상품별 총 매출')\nplt.xlabel('상품')\nplt.ylabel('매출액')\nplt.show()\n\nprint(f\"총 매출: {total_sales:,}원\")\nprint(f\"평균 매출: {average_sales:,.2f}원\")\nprint(f\"최고 매출 상품: {max_sales_product}\")\n```\n\n**2. 머신러닝 / AI**\n```python\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import accuracy_score\nimport numpy as np\n\n# 데이터 준비\nX = np.random.rand(1000, 10)  # 1000개 샘플, 10개 특징\ny = np.random.randint(0, 2, 1000)  # 이진 분류\n\n# 학습/테스트 데이터 분할\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42\n)\n\n# 모델 학습\nmodel = RandomForestClassifier(n_estimators=100)\nmodel.fit(X_train, y_train)\n\n# 예측 및 평가\ny_pred = model.predict(X_test)\naccuracy = accuracy_score(y_test, y_pred)\nprint(f\"정확도: {accuracy:.2%}\")\n```\n\n**3. 웹 스크래핑**\n```python\nimport requests\nfrom bs4 import BeautifulSoup\nimport pandas as pd\n\n# 웹 페이지 가져오기\nurl = \"https://example.com/products\"\nresponse = requests.get(url)\nsoup = BeautifulSoup(response.text, 'html.parser')\n\n# 데이터 추출\nproducts = []\nfor item in soup.find_all('div', class_='product'):\n    name = item.find('h3').text.strip()\n    price = item.find('span', class_='price').text.strip()\n    products.append({'name': name, 'price': price})\n\n# DataFrame으로 변환\ndf = pd.DataFrame(products)\ndf.to_csv('scraped_products.csv', index=False)\nprint(f\"{len(products)}개 상품 수집 완료\")\n```\n\n**4. 자동화 스크립트**\n```python\nimport os\nimport shutil\nfrom datetime import datetime\n\n# 파일 정리 자동화\ndef organize_files(directory):\n    \"\"\"파일을 확장자별로 정리\"\"\"\n    for filename in os.listdir(directory):\n        if os.path.isfile(os.path.join(directory, filename)):\n            # 확장자 추출\n            ext = filename.split('.')[-1]\n            \n            # 확장자별 폴더 생성\n            ext_folder = os.path.join(directory, ext.upper())\n            os.makedirs(ext_folder, exist_ok=True)\n            \n            # 파일 이동\n            src = os.path.join(directory, filename)\n            dst = os.path.join(ext_folder, filename)\n            shutil.move(src, dst)\n            print(f\"{filename} → {ext.upper()}/\")\n\norganize_files('./downloads')\nprint(\"파일 정리 완료!\")\n```\n\n**5. REST API 개발 (FastAPI)**\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass User(BaseModel):\n    name: str\n    email: str\n    age: int\n\nusers = []\n\n@app.post(\"/users/\")\ndef create_user(user: User):\n    users.append(user)\n    return {\"message\": \"사용자 생성 완료\", \"user\": user}\n\n@app.get(\"/users/\")\ndef get_users():\n    return {\"users\": users}\n\n@app.get(\"/\")\ndef root():\n    return {\"message\": \"Hello, FastAPI!\"}\n\n# 실행: uvicorn main:app --reload\n```\n\n**6. 데이터베이스 연동**\n```python\nimport sqlite3\nimport pandas as pd\n\n# 데이터베이스 연결\nconn = sqlite3.connect('company.db')\ncursor = conn.cursor()\n\n# 테이블 생성\ncursor.execute('''\n    CREATE TABLE IF NOT EXISTS employees (\n        id INTEGER PRIMARY KEY,\n        name TEXT NOT NULL,\n        department TEXT,\n        salary REAL\n    )\n''')\n\n# 데이터 삽입\nemployees = [\n    ('Alice', 'IT', 70000),\n    ('Bob', 'Sales', 60000),\n    ('Charlie', 'IT', 75000)\n]\n\ncursor.executemany(\n    'INSERT INTO employees (name, department, salary) VALUES (?, ?, ?)',\n    employees\n)\n\n# 데이터 조회\ndf = pd.read_sql_query('SELECT * FROM employees', conn)\nprint(df)\n\n# 평균 연봉\navg_salary = df['salary'].mean()\nprint(f\"평균 연봉: ${avg_salary:,.2f}\")\n\nconn.commit()\nconn.close()\n```\n\n**7. 이미지 처리 (OpenCV)**\n```python\nimport cv2\nimport numpy as np\n\n# 이미지 읽기\nimg = cv2.imread('image.jpg')\n\n# 그레이스케일 변환\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n# 크기 조정\nresized = cv2.resize(img, (800, 600))\n\n# 엣지 검출\nedges = cv2.Canny(gray, 100, 200)\n\n# 이미지 저장\ncv2.imwrite('edges.jpg', edges)\n\nprint(\"이미지 처리 완료\")\n```"
      },
      {
        "type": "best-practice",
        "title": "Python 학습 모범 사례",
        "content": "**1. PEP 8 스타일 가이드 따르기**\n```python\n# Good: 명확한 변수명, snake_case 사용\nuser_name = \"Alice\"\ntotal_count = 100\nis_active = True\n\n# Bad: 모호한 이름, camelCase\nuserName = \"Alice\"  # Python에서는 비권장\nn = 100             # 너무 짧음\nx = True            # 의미 불명확\n\n# 함수명도 snake_case\ndef calculate_average(numbers):\n    return sum(numbers) / len(numbers)\n\n# 클래스명은 PascalCase\nclass UserAccount:\n    pass\n```\n\n**2. Docstring으로 문서화**\n```python\ndef calculate_bmi(weight, height):\n    \"\"\"\n    BMI(체질량지수)를 계산합니다.\n    \n    Args:\n        weight (float): 체중 (kg)\n        height (float): 키 (m)\n    \n    Returns:\n        float: BMI 값\n    \n    Example:\n        >>> calculate_bmi(70, 1.75)\n        22.86\n    \"\"\"\n    return weight / (height ** 2)\n```\n\n**3. 리스트 컴프리헨션 활용**\n```python\n# Bad: 전통적인 for 루프\nsquares = []\nfor i in range(10):\n    squares.append(i ** 2)\n\n# Good: 리스트 컴프리헨션 (더 간결하고 빠름)\nsquares = [i ** 2 for i in range(10)]\n\n# 조건 포함\neven_squares = [i ** 2 for i in range(10) if i % 2 == 0]\n```\n\n**4. with 문으로 자원 관리**\n```python\n# Bad: 수동으로 파일 닫기\nf = open('file.txt', 'r')\ncontent = f.read()\nf.close()  # 에러 발생 시 실행 안 될 수 있음\n\n# Good: with 문 사용 (자동으로 닫힘)\nwith open('file.txt', 'r', encoding='utf-8') as f:\n    content = f.read()\n# 블록 종료 시 자동으로 파일 닫힘\n```\n\n**5. 타입 힌트 사용**\n```python\nfrom typing import List, Dict, Optional\n\ndef greet(name: str, age: int) -> str:\n    return f\"{name}님은 {age}세입니다.\"\n\ndef process_data(data: List[int]) -> Dict[str, float]:\n    return {\n        'mean': sum(data) / len(data),\n        'max': max(data)\n    }\n```\n\n**6. 가상 환경 사용**\n```bash\n# 가상 환경 생성\npython -m venv venv\n\n# 활성화 (Linux/Mac)\nsource venv/bin/activate\n\n# 활성화 (Windows)\nvenv\\Scripts\\activate\n\n# 패키지 설치\npip install requests pandas numpy\n\n# requirements.txt 생성\npip freeze > requirements.txt\n\n# 다른 환경에서 설치\npip install -r requirements.txt\n```\n\n**7. 예외 처리 명시적으로**\n```python\n# Bad: 모든 예외 잡기\ntry:\n    result = risky_operation()\nexcept:\n    pass  # 어떤 에러인지 모름\n\n# Good: 구체적인 예외 처리\ntry:\n    result = risky_operation()\nexcept ValueError as e:\n    print(f\"잘못된 값: {e}\")\nexcept FileNotFoundError as e:\n    print(f\"파일 없음: {e}\")\nexcept Exception as e:\n    print(f\"예상치 못한 에러: {e}\")\n```"
      },
      {
        "type": "common-mistake",
        "title": "초보자가 자주 하는 실수",
        "content": "**1. 들여쓰기 오류**\n```python\n# 실수: 들여쓰기 불일치\ndef my_function():\n    print(\"첫 번째 줄\")  # 4칸\n  print(\"두 번째 줄\")    # 2칸 - IndentationError!\n\n# 해결책: 일관되게 4칸 스페이스 사용\ndef my_function():\n    print(\"첫 번째 줄\")\n    print(\"두 번째 줄\")\n```\n\n**2. 가변 타입 기본값**\n```python\n# 실수: 리스트를 기본값으로 사용\ndef add_item(item, items=[]):\n    items.append(item)\n    return items\n\nprint(add_item(1))  # [1]\nprint(add_item(2))  # [1, 2] - 예상과 다름!\n\n# 해결책: None 사용\ndef add_item(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n```\n\n**3. == vs is 혼동**\n```python\n# == : 값 비교\n# is : 객체 동일성 비교\n\na = [1, 2, 3]\nb = [1, 2, 3]\nc = a\n\nprint(a == b)   # True (값이 같음)\nprint(a is b)   # False (다른 객체)\nprint(a is c)   # True (같은 객체)\n\n# None 비교는 is 사용\nif value is None:  # Good\n    pass\n\nif value == None:  # Bad\n    pass\n```\n\n**4. 정수 나눗셈 실수**\n```python\n# Python 2 vs Python 3 차이\nresult = 5 / 2\nprint(result)  # Python 3: 2.5 (실수 나눗셈)\n\n# 정수 나눗셈은 //\nresult = 5 // 2\nprint(result)  # 2 (몫만)\n```\n\n**5. 전역 변수 수정**\n```python\n# 실수: 함수 내에서 전역 변수 수정 시도\ncount = 0\n\ndef increment():\n    count += 1  # UnboundLocalError!\n\n# 해결책: global 키워드\ncount = 0\n\ndef increment():\n    global count\n    count += 1\n```\n\n**6. import * 남용**\n```python\n# Bad: 네임스페이스 오염\nfrom math import *\nfrom numpy import *\n\n# 어느 모듈의 함수인지 불명확\nresult = sqrt(16)\n\n# Good: 명시적 import\nimport math\nimport numpy as np\n\nresult1 = math.sqrt(16)\nresult2 = np.sqrt(16)\n```\n\n**7. 문자열 연결 비효율**\n```python\n# Bad: + 연산자로 반복 연결 (느림)\nresult = \"\"\nfor i in range(1000):\n    result += str(i)  # 매번 새 문자열 생성\n\n# Good: join() 사용 (빠름)\nresult = \"\".join(str(i) for i in range(1000))\n```"
      },
      {
        "type": "tip",
        "title": "Python 학습 팁",
        "content": "**1. 인터랙티브 셸 활용**\n```python\n# Python 셸 실행\n$ python\n>>> print(\"Hello\")\nHello\n\n# IPython (더 강력한 셸)\n$ ipython\nIn [1]: 2 + 2\nOut[1]: 4\n\n# 빠른 테스트와 실험에 유용\n```\n\n**2. dir()과 help()로 탐색**\n```python\n# 객체의 속성과 메서드 확인\nimport math\nprint(dir(math))  # math 모듈의 모든 함수 목록\n\n# 함수 설명 보기\nhelp(math.sqrt)\n\n# 간단한 docstring 확인\nprint(math.sqrt.__doc__)\n```\n\n**3. 주피터 노트북 활용**\n```bash\n# 설치\npip install jupyter\n\n# 실행\njupyter notebook\n\n# 데이터 분석과 학습에 최적\n```\n\n**4. 온라인 리소스 활용**\n- **공식 문서**: https://docs.python.org\n- **튜토리얼**: https://www.python.org/about/gettingstarted/\n- **연습 사이트**:\n  - LeetCode (알고리즘)\n  - HackerRank (코딩 챌린지)\n  - Codecademy (인터랙티브 학습)\n\n**5. GitHub에서 코드 읽기**\n```python\n# 유명 프로젝트 소스 코드 분석\n# - requests: HTTP 라이브러리\n# - flask: 웹 프레임워크\n# - scikit-learn: 머신러닝\n\n# 다른 사람의 코드를 읽으며 배우기\n```\n\n**6. 작은 프로젝트로 실전 연습**\n- 할 일 관리 앱\n- 간단한 계산기\n- 웹 스크래퍼\n- 데이터 시각화 대시보드\n- 자동화 스크립트\n\n**7. 커뮤니티 참여**\n- Stack Overflow에서 질문/답변\n- Reddit r/learnpython\n- Python Discord 서버\n- 로컬 Python 미트업 참석"
      },
      {
        "type": "practice",
        "title": "Python 기초 종합 연습",
        "content": "**미니 프로젝트: 학생 성적 관리 시스템**\n\n다음 기능을 구현하세요:\n\n**1. Student 클래스 만들기**\n```python\nclass Student:\n    def __init__(self, name, student_id):\n        # 이름, 학번, 성적 리스트 초기화\n        pass\n    \n    def add_score(self, subject, score):\n        # 과목별 점수 추가\n        pass\n    \n    def get_average(self):\n        # 평균 점수 계산\n        pass\n    \n    def __str__(self):\n        # 학생 정보 문자열로 반환\n        pass\n```\n\n**2. 성적 관리 함수**\n```python\ndef calculate_grade(score):\n    \"\"\"\n    점수에 따른 등급 반환\n    90점 이상: A\n    80-89: B\n    70-79: C\n    60-69: D\n    60점 미만: F\n    \"\"\"\n    pass\n\ndef find_top_student(students):\n    \"\"\"평균 점수가 가장 높은 학생 찾기\"\"\"\n    pass\n\ndef save_to_file(students, filename):\n    \"\"\"학생 정보를 파일로 저장\"\"\"\n    pass\n```\n\n**3. 메인 프로그램**\n```python\ndef main():\n    students = []\n    \n    # 학생 3명 생성\n    students.append(Student(\"Alice\", \"2024001\"))\n    students.append(Student(\"Bob\", \"2024002\"))\n    students.append(Student(\"Charlie\", \"2024003\"))\n    \n    # 성적 입력\n    students[0].add_score(\"수학\", 95)\n    students[0].add_score(\"영어\", 88)\n    students[0].add_score(\"과학\", 92)\n    \n    # 평균 계산 및 출력\n    for student in students:\n        avg = student.get_average()\n        grade = calculate_grade(avg)\n        print(f\"{student.name}: 평균 {avg:.2f}점, 등급 {grade}\")\n    \n    # 최우수 학생 찾기\n    top = find_top_student(students)\n    print(f\"최우수 학생: {top.name}\")\n    \n    # 파일로 저장\n    save_to_file(students, \"students.txt\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**도전 과제:**\n1. 과목별 평균 점수 계산\n2. 성적 데이터를 CSV 파일로 저장/불러오기\n3. 학생 검색 기능 (이름 또는 학번)\n4. 성적 통계 (최고점, 최저점, 표준편차)\n5. 간단한 CLI 인터페이스 만들기\n\n**보너스:**\nPandas를 사용하여 성적 데이터를 DataFrame으로 관리하고, Matplotlib으로 시각화하세요."
      }
    ]
  },
  "02_python-data/01_numpy_basics": {
    "id": "02_python-data/01_numpy_basics",
    "title": "01 Numpy Basics",
    "category": "ai-roadmap",
    "subCategory": "02_python-data",
    "language": "Python",
    "description": "NumPy 배열 생성, 기본 연산, 인덱싱을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "NumPy란 무엇인가",
        "content": "NumPy(Numerical Python)는 Python에서 과학 계산을 위한 핵심 라이브러리입니다. 다차원 배열 객체와 이를 다루는 다양한 함수를 제공합니다.\n\n**NumPy의 특징:**\n- **고성능 다차원 배열**: ndarray 객체로 효율적인 데이터 처리\n- **빠른 연산**: C언어로 작성되어 Python 리스트보다 10-100배 빠름\n- **벡터화 연산**: 반복문 없이 배열 전체에 연산 적용\n- **브로드캐스팅**: 다른 크기의 배열 간 연산 지원\n- **선형대수, 통계, 난수 생성**: 풍부한 수학 함수 제공\n\n**NumPy가 필요한 이유:**\n- 데이터 과학, 머신러닝의 기초\n- Pandas, Matplotlib, scikit-learn 등의 기반\n- 대용량 데이터의 효율적 처리\n- 메모리 효율성\n\n**ndarray의 특징:**\n- **동일한 타입**: 모든 요소가 같은 데이터 타입\n- **고정된 크기**: 생성 후 크기 변경 불가 (reshape 제외)\n- **다차원**: 1D(벡터), 2D(행렬), 3D 이상 지원\n\n**주요 속성:**\n- `shape`: 배열의 차원 (행, 열)\n- `dtype`: 요소의 데이터 타입\n- `ndim`: 차원의 수\n- `size`: 전체 요소 개수\n\n**설치:**\n```bash\npip install numpy\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "import numpy as np\n\n# ===== 1. 배열 생성 =====\n# 리스트로부터 배열 생성\narr1 = np.array([1, 2, 3, 4, 5])\nprint(arr1)  # [1 2 3 4 5]\n\n# 2D 배열 (행렬)\narr2d = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr2d)\n# [[1 2 3]\n#  [4 5 6]]\n\n# 타입 지정\narr_float = np.array([1, 2, 3], dtype=float)\nprint(arr_float)  # [1. 2. 3.]\n\n# ===== 2. 특수 배열 생성 =====\n# 0으로 채운 배열\nzeros = np.zeros((3, 4))  # 3행 4열\nprint(zeros)\n\n# 1로 채운 배열\nones = np.ones((2, 3))\nprint(ones)\n\n# 특정 값으로 채운 배열\nfull = np.full((2, 2), 7)\nprint(full)  # [[7 7], [7 7]]\n\n# 단위 행렬 (Identity Matrix)\nidentity = np.eye(3)\nprint(identity)\n# [[1. 0. 0.]\n#  [0. 1. 0.]\n#  [0. 0. 1.]]\n\n# 범위 배열 (Python range와 유사)\narange_arr = np.arange(0, 10, 2)  # 시작, 끝, 간격\nprint(arange_arr)  # [0 2 4 6 8]\n\n# 균등 간격 배열\nlinspace_arr = np.linspace(0, 1, 5)  # 시작, 끝, 개수\nprint(linspace_arr)  # [0.   0.25 0.5  0.75 1.  ]\n\n# 난수 배열\nrandom_arr = np.random.rand(3, 3)  # 0~1 사이 난수\nprint(random_arr)\n\nrandom_int = np.random.randint(1, 100, size=(2, 3))  # 1~99 정수\nprint(random_int)\n\n# ===== 3. 배열 속성 =====\narr = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(f\"shape: {arr.shape}\")      # (2, 3) - 2행 3열\nprint(f\"dtype: {arr.dtype}\")      # int64\nprint(f\"ndim: {arr.ndim}\")        # 2 (2차원)\nprint(f\"size: {arr.size}\")        # 6 (전체 요소 수)\nprint(f\"itemsize: {arr.itemsize}\") # 8 (각 요소 바이트 크기)\n\n# ===== 4. 인덱싱과 슬라이싱 =====\narr = np.array([10, 20, 30, 40, 50])\n\n# 인덱싱\nprint(arr[0])     # 10\nprint(arr[-1])    # 50\n\n# 슬라이싱\nprint(arr[1:4])   # [20 30 40]\nprint(arr[:3])    # [10 20 30]\nprint(arr[::2])   # [10 30 50] (2개씩 건너뛰기)\n\n# 2D 배열 인덱싱\narr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\nprint(arr2d[0, 0])     # 1 (1행 1열)\nprint(arr2d[1, 2])     # 6 (2행 3열)\nprint(arr2d[0])        # [1 2 3] (첫 번째 행)\nprint(arr2d[:, 0])     # [1 4 7] (첫 번째 열)\nprint(arr2d[0:2, 1:3]) # [[2 3], [5 6]] (부분 행렬)\n\n# 불린 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nmask = arr > 25\nprint(mask)            # [False False  True  True  True]\nprint(arr[mask])       # [30 40 50]\nprint(arr[arr > 25])   # [30 40 50] (한 줄로)\n\n# 팬시 인덱싱 (배열로 인덱싱)\narr = np.array([10, 20, 30, 40, 50])\nindices = [0, 2, 4]\nprint(arr[indices])    # [10 30 50]\n\n# ===== 5. 배열 형태 변경 =====\narr = np.arange(12)  # [0, 1, 2, ..., 11]\n\n# reshape: 형태 변경\nreshaped = arr.reshape(3, 4)\nprint(reshaped)\n# [[ 0  1  2  3]\n#  [ 4  5  6  7]\n#  [ 8  9 10 11]]\n\n# flatten: 1차원으로 평탄화\nflattened = reshaped.flatten()\nprint(flattened)  # [ 0  1  2  3  4  5  6  7  8  9 10 11]\n\n# transpose: 전치 (행과 열 바꾸기)\ntransposed = reshaped.T\nprint(transposed)\n# [[ 0  4  8]\n#  [ 1  5  9]\n#  [ 2  6 10]\n#  [ 3  7 11]]\n\n# ===== 6. 배열 결합 =====\narr1 = np.array([[1, 2], [3, 4]])\narr2 = np.array([[5, 6], [7, 8]])\n\n# 수직 결합 (행 방향)\nvstack = np.vstack((arr1, arr2))\nprint(vstack)\n# [[1 2]\n#  [3 4]\n#  [5 6]\n#  [7 8]]\n\n# 수평 결합 (열 방향)\nhstack = np.hstack((arr1, arr2))\nprint(hstack)\n# [[1 2 5 6]\n#  [3 4 7 8]]\n\n# concatenate (axis 지정)\nconcat_axis0 = np.concatenate((arr1, arr2), axis=0)  # vstack과 동일\nconcat_axis1 = np.concatenate((arr1, arr2), axis=1)  # hstack과 동일\n\n# ===== 7. 기본 연산 =====\narr = np.array([1, 2, 3, 4, 5])\n\n# 스칼라 연산 (브로드캐스팅)\nprint(arr + 10)      # [11 12 13 14 15]\nprint(arr * 2)       # [ 2  4  6  8 10]\nprint(arr ** 2)      # [ 1  4  9 16 25]\n\n# 배열 간 연산\narr1 = np.array([1, 2, 3])\narr2 = np.array([10, 20, 30])\n\nprint(arr1 + arr2)   # [11 22 33]\nprint(arr1 * arr2)   # [10 40 90]\n\n# 집계 함수\narr = np.array([1, 2, 3, 4, 5])\n\nprint(arr.sum())     # 15\nprint(arr.mean())    # 3.0\nprint(arr.std())     # 1.4142135623730951 (표준편차)\nprint(arr.min())     # 1\nprint(arr.max())     # 5\nprint(arr.argmin())  # 0 (최솟값의 인덱스)\nprint(arr.argmax())  # 4 (최댓값의 인덱스)\n\n# 2D 배열에서 axis 지정\narr2d = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(arr2d.sum())           # 21 (전체 합)\nprint(arr2d.sum(axis=0))     # [ 5  7  9] (열 방향 합)\nprint(arr2d.sum(axis=1))     # [ 6 15] (행 방향 합)\n\n# ===== 8. 유용한 함수 =====\narr = np.array([1, 2, 3, 4, 5])\n\n# 제곱근\nprint(np.sqrt(arr))  # [1. 1.41421356 1.73205081 2. 2.23606798]\n\n# 지수\nprint(np.exp(arr))   # [  2.71828183   7.3890561   20.08553692  54.59815003 148.4131591 ]\n\n# 로그\nprint(np.log(arr))   # [0. 0.69314718 1.09861229 1.38629436 1.60943791]\n\n# 절댓값\narr = np.array([-1, -2, 3, -4])\nprint(np.abs(arr))   # [1 2 3 4]\n\n# 반올림\narr = np.array([1.234, 2.567, 3.891])\nprint(np.round(arr, 2))  # [1.23 2.57 3.89]"
      },
      {
        "type": "use-case",
        "title": "실무 활용 사례",
        "content": "**1. 이미지 처리**\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom PIL import Image\n\n# 이미지 로드 (NumPy 배열로 변환)\nimg = Image.open('photo.jpg')\nimg_array = np.array(img)\n\nprint(f\"이미지 shape: {img_array.shape}\")  # (height, width, channels)\n\n# 그레이스케일 변환\ngray = np.mean(img_array, axis=2).astype(np.uint8)\n\n# 이미지 밝기 조절\nbrightened = np.clip(img_array * 1.5, 0, 255).astype(np.uint8)\n\n# 이미지 회전 (90도)\nrotated = np.rot90(img_array)\n\n# 이미지 자르기\ncropped = img_array[100:400, 100:400]  # [y1:y2, x1:x2]\n\nplt.imshow(gray, cmap='gray')\nplt.show()\n```\n\n**2. 시계열 데이터 처리**\n```python\nimport numpy as np\nimport pandas as pd\n\n# 주식 가격 데이터 생성 (시뮬레이션)\ndays = 100\nprices = 100 + np.cumsum(np.random.randn(days)) * 2\n\n# 이동 평균 계산\ndef moving_average(data, window_size):\n    return np.convolve(data, np.ones(window_size)/window_size, mode='valid')\n\nma_5 = moving_average(prices, 5)\nma_20 = moving_average(prices, 20)\n\n# 일일 수익률 계산\nreturns = np.diff(prices) / prices[:-1] * 100\n\nprint(f\"평균 수익률: {returns.mean():.2f}%\")\nprint(f\"수익률 표준편차: {returns.std():.2f}%\")\nprint(f\"최대 수익률: {returns.max():.2f}%\")\nprint(f\"최소 수익률: {returns.min():.2f}%\")\n```\n\n**3. 머신러닝 데이터 전처리**\n```python\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\n\n# 가상 데이터 생성\nX = np.random.rand(1000, 10)  # 1000개 샘플, 10개 특징\ny = np.random.randint(0, 2, 1000)  # 이진 분류 레이블\n\n# 데이터 정규화 (Min-Max Scaling)\nX_normalized = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0))\n\n# 표준화 (Standardization)\nX_standardized = (X - X.mean(axis=0)) / X.std(axis=0)\n\n# 결측값 처리 (평균으로 대체)\nX_with_missing = X.copy()\nX_with_missing[X_with_missing < 0.1] = np.nan  # 일부를 NaN으로\n\nX_filled = np.where(np.isnan(X_with_missing),\n                     np.nanmean(X_with_missing, axis=0),\n                     X_with_missing)\n\n# 학습/테스트 데이터 분할\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42\n)\n\nprint(f\"학습 데이터 shape: {X_train.shape}\")\nprint(f\"테스트 데이터 shape: {X_test.shape}\")\n```\n\n**4. 통계 분석**\n```python\nimport numpy as np\n\n# 학생 100명의 시험 점수 (3과목)\nscores = np.random.randint(0, 101, size=(100, 3))\n\n# 기술 통계\nprint(f\"평균 점수: {scores.mean(axis=0)}\")\nprint(f\"중앙값: {np.median(scores, axis=0)}\")\nprint(f\"표준편차: {scores.std(axis=0)}\")\nprint(f\"분산: {scores.var(axis=0)}\")\n\n# 백분위수\nprint(f\"25th percentile: {np.percentile(scores, 25, axis=0)}\")\nprint(f\"75th percentile: {np.percentile(scores, 75, axis=0)}\")\n\n# 상관계수 행렬\ncorr_matrix = np.corrcoef(scores.T)\nprint(\"과목 간 상관계수:\")\nprint(corr_matrix)\n\n# 이상치 탐지 (IQR 방법)\nQ1 = np.percentile(scores, 25, axis=0)\nQ3 = np.percentile(scores, 75, axis=0)\nIQR = Q3 - Q1\n\nlower_bound = Q1 - 1.5 * IQR\nupper_bound = Q3 + 1.5 * IQR\n\noutliers_mask = (scores < lower_bound) | (scores > upper_bound)\noutliers_count = outliers_mask.sum(axis=0)\nprint(f\"과목별 이상치 개수: {outliers_count}\")\n```\n\n**5. 행렬 연산 (선형대수)**\n```python\nimport numpy as np\n\n# 행렬 곱셈\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\n\nC = np.dot(A, B)  # 또는 A @ B\nprint(\"행렬 곱:\")\nprint(C)\n# [[19 22]\n#  [43 50]]\n\n# 역행렬\nA_inv = np.linalg.inv(A)\nprint(\"역행렬:\")\nprint(A_inv)\n\n# 행렬식\ndet = np.linalg.det(A)\nprint(f\"행렬식: {det}\")  # -2.0\n\n# 고유값과 고유벡터\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(f\"고유값: {eigenvalues}\")\nprint(f\"고유벡터:\\n{eigenvectors}\")\n\n# 선형 방정식 풀이 (Ax = b)\nA = np.array([[3, 1], [1, 2]])\nb = np.array([9, 8])\n\nx = np.linalg.solve(A, b)\nprint(f\"해: {x}\")  # [2. 3.]\n```\n\n**6. 과학 계산**\n```python\nimport numpy as np\n\n# 물리학: 포물선 운동\ndef projectile_motion(v0, angle, time_steps):\n    \"\"\"\n    초기 속도 v0, 각도 angle로 발사된 물체의 궤적\n    \"\"\"\n    angle_rad = np.radians(angle)\n    g = 9.8  # 중력 가속도\n    \n    t = np.linspace(0, 2 * v0 * np.sin(angle_rad) / g, time_steps)\n    x = v0 * np.cos(angle_rad) * t\n    y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2\n    \n    return x, y\n\nx, y = projectile_motion(v0=20, angle=45, time_steps=100)\n\n# 최대 높이\nmax_height = y.max()\nprint(f\"최대 높이: {max_height:.2f}m\")\n\n# 비행 거리\nrange_distance = x[np.where(y >= 0)][-1]\nprint(f\"비행 거리: {range_distance:.2f}m\")\n```"
      },
      {
        "type": "best-practice",
        "title": "NumPy 사용 모범 사례",
        "content": "**1. 벡터화 연산 사용 (반복문 피하기)**\n```python\nimport numpy as np\n\n# Bad: Python 반복문 (느림)\ndata = list(range(1000000))\nresult = []\nfor x in data:\n    result.append(x ** 2)\n\n# Good: NumPy 벡터화 (빠름)\ndata = np.arange(1000000)\nresult = data ** 2  # 10-100배 빠름!\n```\n\n**2. 적절한 dtype 선택**\n```python\n# Bad: 기본 float64 (메모리 낭비)\narr = np.array([1, 2, 3, 4, 5])  # int64\n\n# Good: 필요한 크기만 사용\narr_int8 = np.array([1, 2, 3, 4, 5], dtype=np.int8)    # 1바이트\narr_int32 = np.array([1, 2, 3, 4, 5], dtype=np.int32)  # 4바이트\narr_float32 = np.array([1.0, 2.0], dtype=np.float32)   # 4바이트\n\n# 메모리 사용량 확인\nprint(arr.nbytes)        # 40 바이트\nprint(arr_int8.nbytes)   # 5 바이트 (8배 절약)\n```\n\n**3. 메모리 효율적인 연산**\n```python\n# Bad: 새 배열 계속 생성\narr = np.arange(1000000)\nresult = arr + 1\nresult = result * 2\nresult = result ** 2\n\n# Good: in-place 연산 (메모리 절약)\narr = np.arange(1000000)\narr += 1\narr *= 2\narr **= 2\n```\n\n**4. 브로드캐스팅 활용**\n```python\n# Bad: 명시적 반복\nmatrix = np.random.rand(100, 10)\nmean = matrix.mean(axis=0)\ncentered = np.zeros_like(matrix)\nfor i in range(matrix.shape[0]):\n    centered[i] = matrix[i] - mean\n\n# Good: 브로드캐스팅\ncentered = matrix - matrix.mean(axis=0)\n```\n\n**5. 배열 복사 vs 뷰**\n```python\n# 뷰 (view): 메모리 공유\narr = np.array([1, 2, 3, 4, 5])\nview = arr[1:4]  # 뷰 생성\nview[0] = 999\nprint(arr)  # [1 999 3 4 5] - 원본도 변경됨!\n\n# 복사 (copy): 독립적인 배열\narr = np.array([1, 2, 3, 4, 5])\ncopy = arr[1:4].copy()\ncopy[0] = 999\nprint(arr)  # [1 2 3 4 5] - 원본 변경 안 됨\n```\n\n**6. 불린 인덱싱으로 필터링**\n```python\n# Bad: 반복문으로 필터링\narr = np.random.randint(0, 100, 1000)\nfiltered = []\nfor x in arr:\n    if x > 50:\n        filtered.append(x)\nfiltered = np.array(filtered)\n\n# Good: 불린 인덱싱\nfiltered = arr[arr > 50]\n```\n\n**7. axis 파라미터 이해**\n```python\narr = np.array([[1, 2, 3], [4, 5, 6]])\n\n# axis=0: 열 방향 (아래로)\nprint(arr.sum(axis=0))  # [5 7 9]\n\n# axis=1: 행 방향 (옆으로)\nprint(arr.sum(axis=1))  # [6 15]\n\n# axis=None: 전체\nprint(arr.sum())  # 21\n```"
      },
      {
        "type": "common-mistake",
        "title": "흔한 실수와 해결책",
        "content": "**1. 배열 복사 vs 뷰 혼동**\n```python\n# 실수: 뷰를 복사라고 착각\narr = np.array([1, 2, 3, 4, 5])\nslice_arr = arr[1:4]  # 뷰!\nslice_arr[0] = 999\nprint(arr)  # [1 999 3 4 5] - 원본 변경됨\n\n# 해결책: 명시적 복사\nslice_arr = arr[1:4].copy()\nslice_arr[0] = 999\nprint(arr)  # [1 2 3 4 5] - 원본 유지\n```\n\n**2. reshape 시 요소 개수 불일치**\n```python\n# 실수: 요소 개수 안 맞음\narr = np.arange(10)  # 10개\nreshaped = arr.reshape(3, 3)  # ValueError! (9개 필요)\n\n# 해결책 1: 올바른 shape\nreshaped = arr.reshape(2, 5)  # OK (10개)\n\n# 해결책 2: -1 사용 (자동 계산)\nreshaped = arr.reshape(2, -1)  # (2, 5) 자동 계산\n```\n\n**3. axis 파라미터 헷갈림**\n```python\n# 2D 배열\narr = np.array([[1, 2, 3], [4, 5, 6]])\n\n# 실수: axis 의미 혼동\nprint(arr.sum(axis=0))  # [5 7 9] - 열 방향\nprint(arr.sum(axis=1))  # [6 15] - 행 방향\n\n# 기억법: axis=0은 첫 번째 차원(행)을 따라 연산\n# 즉, 행들을 합치므로 결과는 열 방향\n```\n\n**4. 브로드캐스팅 규칙 위반**\n```python\n# 실수: 호환되지 않는 shape\narr1 = np.array([[1, 2, 3], [4, 5, 6]])  # (2, 3)\narr2 = np.array([1, 2])                   # (2,)\n\nresult = arr1 + arr2  # ValueError!\n\n# 해결책: shape 맞추기\narr2 = np.array([[1], [2]])  # (2, 1)\nresult = arr1 + arr2  # OK\n# [[2 3 4]\n#  [6 7 8]]\n```\n\n**5. dtype 자동 변환 간과**\n```python\n# 실수: 정수 배열에 실수 할당\narr = np.array([1, 2, 3], dtype=int)\narr[0] = 1.9\nprint(arr)  # [1 2 3] - 1.9가 1로 변환됨!\n\n# 해결책: dtype 확인 또는 변경\narr = arr.astype(float)\narr[0] = 1.9\nprint(arr)  # [1.9 2.  3. ]\n```\n\n**6. 원본 배열 의도치 않게 수정**\n```python\n# 실수: 함수에서 배열 직접 수정\ndef normalize(arr):\n    arr -= arr.mean()  # 원본 수정!\n    arr /= arr.std()\n    return arr\n\ndata = np.array([1, 2, 3, 4, 5])\nresult = normalize(data)\nprint(data)  # 원본도 변경됨!\n\n# 해결책: 복사본 사용\ndef normalize(arr):\n    arr = arr.copy()\n    arr -= arr.mean()\n    arr /= arr.std()\n    return arr\n```\n\n**7. NaN 처리 함수 미사용**\n```python\n# 실수: NaN이 포함된 배열에 일반 함수 사용\narr = np.array([1, 2, np.nan, 4, 5])\nprint(arr.mean())  # nan\n\n# 해결책: NaN 무시 함수 사용\nprint(np.nanmean(arr))  # 3.0\nprint(np.nansum(arr))   # 12.0\nprint(np.nanstd(arr))   # 1.5811388300841898\n```"
      },
      {
        "type": "tip",
        "title": "NumPy 고급 활용 팁",
        "content": "**1. np.where()로 조건부 연산**\n```python\narr = np.array([1, 5, 10, 15, 20])\n\n# 10 이상이면 'High', 아니면 'Low'\nresult = np.where(arr >= 10, 'High', 'Low')\nprint(result)  # ['Low' 'Low' 'High' 'High' 'High']\n\n# 조건에 따른 값 치환\nresult = np.where(arr >= 10, arr, 0)\nprint(result)  # [ 0  0 10 15 20]\n```\n\n**2. einsum으로 복잡한 연산**\n```python\n# 행렬 곱셈\nA = np.random.rand(3, 4)\nB = np.random.rand(4, 5)\nC = np.einsum('ij,jk->ik', A, B)  # np.dot(A, B)와 동일\n\n# 대각 합\nmatrix = np.random.rand(5, 5)\ntrace = np.einsum('ii->', matrix)  # np.trace(matrix)와 동일\n```\n\n**3. meshgrid로 좌표 생성**\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(-5, 5, 100)\ny = np.linspace(-5, 5, 100)\nX, Y = np.meshgrid(x, y)\n\n# 2D 함수 계산\nZ = np.sin(np.sqrt(X**2 + Y**2))\n\nplt.contourf(X, Y, Z)\nplt.colorbar()\nplt.show()\n```\n\n**4. np.argwhere()로 조건 만족 인덱스**\n```python\narr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n# 5보다 큰 요소의 인덱스\nindices = np.argwhere(arr > 5)\nprint(indices)\n# [[1 2]\n#  [2 0]\n#  [2 1]\n#  [2 2]]\n```\n\n**5. np.clip()로 값 제한**\n```python\narr = np.array([1, 5, 10, 15, 20])\n\n# 5~15 범위로 제한\nclipped = np.clip(arr, 5, 15)\nprint(clipped)  # [ 5  5 10 15 15]\n```\n\n**6. np.allclose()로 부동소수점 비교**\n```python\n# 부동소수점 오차 고려한 비교\na = np.array([1.0, 2.0, 3.0])\nb = np.array([1.0000001, 2.0000001, 3.0000001])\n\nprint(a == b)  # [False False False]\nprint(np.allclose(a, b))  # True (기본 오차 범위 내)\n```\n\n**7. np.save/load로 배열 저장**\n```python\n# 배열 저장\narr = np.random.rand(1000, 1000)\nnp.save('array.npy', arr)\n\n# 배열 로드\nloaded_arr = np.load('array.npy')\n\n# 여러 배열 저장\nnp.savez('arrays.npz', a=arr1, b=arr2, c=arr3)\n\n# 로드\ndata = np.load('arrays.npz')\narr1 = data['a']\narr2 = data['b']\n```\n\n**8. np.random.choice()로 샘플링**\n```python\n# 가중치 있는 랜덤 샘플링\nvalues = ['A', 'B', 'C', 'D']\nweights = [0.1, 0.3, 0.4, 0.2]\n\nsample = np.random.choice(values, size=100, p=weights)\nprint(np.unique(sample, return_counts=True))\n```"
      },
      {
        "type": "practice",
        "title": "연습 문제",
        "content": "**문제 1: 배열 생성**\n- 0부터 99까지의 숫자를 담은 배열 생성\n- 10x10 형태로 reshape\n\n**문제 2: 인덱싱**\n다음 배열에서:\n```python\narr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n```\n- 첫 번째 행 추출\n- 마지막 열 추출\n- 중앙값 (5) 추출\n\n**문제 3: 불린 인덱싱**\n1부터 100까지 숫자 배열에서:\n- 짝수만 필터링\n- 50보다 큰 수만 필터링\n\n**문제 4: 통계 계산**\n100개의 랜덤 정수 배열(1-100)을 생성하고:\n- 평균, 중앙값, 표준편차 계산\n- 최댓값, 최솟값 찾기\n\n**문제 5: 배열 연산**\n두 개의 5x5 랜덤 배열을 생성하고:\n- 요소별 덧셈, 곱셈\n- 행렬 곱셈 (dot product)\n\n**문제 6: reshape와 transpose**\n1부터 12까지 배열을:\n- 3x4로 reshape\n- 전치 (transpose)\n- 다시 1차원으로 flatten\n\n**문제 7: 실전 문제 - 정규화**\n다음 배열을 Min-Max 정규화하세요 (0-1 범위):\n```python\ndata = np.array([10, 20, 30, 40, 50])\n# 결과: [0.0, 0.25, 0.5, 0.75, 1.0]\n```\n공식: (x - min) / (max - min)\n\n**문제 8: 이동 평균**\n다음 배열의 3일 이동 평균을 계산하세요:\n```python\nprices = np.array([100, 102, 98, 105, 107, 110, 108])\n# 3일 이동 평균 계산\n```\n\n**보너스 문제: 행렬 회전**\n3x3 행렬을 90도 시계 방향으로 회전하세요 (np.rot90 사용 금지):\n```python\nmatrix = np.array([[1, 2, 3],\n                   [4, 5, 6],\n                   [7, 8, 9]])\n# 결과:\n# [[7 4 1]\n#  [8 5 2]\n#  [9 6 3]]\n```"
      }
    ]
  },
  "02_python-data/02_numpy_operations": {
    "id": "02_python-data/02_numpy_operations",
    "title": "02 Numpy Operations",
    "category": "ai-roadmap",
    "subCategory": "02_python-data",
    "language": "Python",
    "description": "NumPy 고급 연산, 브로드캐스팅, 선형대수를 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "NumPy 고급 연산",
        "content": "NumPy는 단순 배열 연산을 넘어 과학 계산을 위한 강력한 기능을 제공합니다.\n\n**브로드캐스팅(Broadcasting)**\n다른 크기의 배열 간 연산을 자동으로 확장하여 수행하는 기능입니다.\n\n**브로드캐스팅 규칙:**\n1. 차원 수가 다르면, 작은 배열의 shape 앞쪽에 1을 추가\n2. 각 차원에서 크기가 같거나 한쪽이 1이면 브로드캐스팅 가능\n3. 크기가 다르고 둘 다 1이 아니면 에러\n\n예: (3, 4) + (4,) → (3, 4) + (1, 4) → (3, 4)\n\n**유니버설 함수(ufunc)**\n배열의 각 요소에 빠르게 적용되는 함수:\n- 산술 연산: add, subtract, multiply, divide\n- 비교 연산: equal, greater, less\n- 삼각 함수: sin, cos, tan\n- 지수/로그: exp, log, log10\n\n**집계 함수**\n배열 전체 또는 특정 축에 대한 통계:\n- sum, mean, std, var\n- min, max, argmin, argmax\n- percentile, median, quantile\n\n**선형대수(Linear Algebra)**\nNumPy는 행렬 연산과 선형대수 기능을 제공:\n- 행렬 곱셈: dot, matmul (@)\n- 역행렬: linalg.inv\n- 고유값/고유벡터: linalg.eig\n- 특이값 분해: linalg.svd\n- 선형 방정식: linalg.solve"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "import numpy as np\n\n# ===== 1. 브로드캐스팅 =====\n# 스칼라와 배열\narr = np.array([1, 2, 3, 4, 5])\nresult = arr + 10  # 10이 모든 요소에 더해짐\nprint(result)  # [11 12 13 14 15]\n\n# 1D 배열과 2D 배열\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nvector = np.array([10, 20, 30])\n\nresult = matrix + vector  # vector가 각 행에 더해짐\nprint(result)\n# [[11 22 33]\n#  [14 25 36]\n#  [17 28 39]]\n\n# 열 방향 브로드캐스팅\ncolumn_vector = np.array([[10], [20], [30]])  # (3, 1)\nresult = matrix + column_vector\nprint(result)\n# [[11 12 13]\n#  [24 25 26]\n#  [37 38 39]]\n\n# ===== 2. 유니버설 함수 (ufunc) =====\n# 산술 연산\narr1 = np.array([1, 2, 3, 4])\narr2 = np.array([10, 20, 30, 40])\n\nprint(np.add(arr1, arr2))       # [11 22 33 44]\nprint(np.subtract(arr2, arr1))  # [ 9 18 27 36]\nprint(np.multiply(arr1, arr2))  # [ 10  40  90 160]\nprint(np.divide(arr2, arr1))    # [10. 10. 10. 10.]\nprint(np.power(arr1, 2))        # [ 1  4  9 16]\n\n# 삼각 함수\nangles = np.array([0, np.pi/6, np.pi/4, np.pi/3, np.pi/2])\nprint(np.sin(angles))\nprint(np.cos(angles))\nprint(np.tan(angles))\n\n# 지수와 로그\narr = np.array([1, 2, 3, 4])\nprint(np.exp(arr))     # [  2.71828183   7.3890561   20.08553692  54.59815003]\nprint(np.log(arr))     # [0.         0.69314718 1.09861229 1.38629436]\nprint(np.log10(arr))   # [0.         0.30103    0.47712125 0.60205999]\n\n# 반올림 함수\narr = np.array([1.234, 2.567, 3.891, 4.123])\nprint(np.round(arr, 2))    # [1.23 2.57 3.89 4.12]\nprint(np.floor(arr))       # [1. 2. 3. 4.]\nprint(np.ceil(arr))        # [2. 3. 4. 5.]\nprint(np.trunc(arr))       # [1. 2. 3. 4.]\n\n# ===== 3. 비교 연산 =====\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([5, 4, 3, 2, 1])\n\nprint(arr1 == arr2)  # [False False  True False False]\nprint(arr1 > arr2)   # [False False False  True  True]\nprint(arr1 < 3)      # [ True  True False False False]\n\n# 논리 연산\nprint(np.logical_and(arr1 > 2, arr1 < 5))  # [False False  True  True False]\nprint(np.logical_or(arr1 < 2, arr1 > 4))   # [ True False False False  True]\nprint(np.logical_not(arr1 > 3))            # [ True  True  True False False]\n\n# ===== 4. 집계 함수 =====\narr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\nprint(f\"합계: {np.sum(arr)}\")           # 55\nprint(f\"평균: {np.mean(arr)}\")          # 5.5\nprint(f\"중앙값: {np.median(arr)}\")      # 5.5\nprint(f\"표준편차: {np.std(arr)}\")       # 2.8722813232690143\nprint(f\"분산: {np.var(arr)}\")           # 8.25\nprint(f\"최솟값: {np.min(arr)}\")         # 1\nprint(f\"최댓값: {np.max(arr)}\")         # 10\n\n# 누적 합, 누적 곱\nprint(np.cumsum(arr))   # [ 1  3  6 10 15 21 28 36 45 55]\nprint(np.cumprod(arr[:5]))  # [  1   2   6  24 120]\n\n# 백분위수\nprint(np.percentile(arr, 25))  # 3.25 (25th percentile)\nprint(np.percentile(arr, 75))  # 7.75 (75th percentile)\n\n# 2D 배열에서 axis 지정\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\nprint(matrix.sum())          # 45 (전체)\nprint(matrix.sum(axis=0))    # [12 15 18] (열별)\nprint(matrix.sum(axis=1))    # [ 6 15 24] (행별)\n\nprint(matrix.mean(axis=0))   # [4. 5. 6.]\nprint(matrix.max(axis=1))    # [3 6 9]\n\n# ===== 5. 행렬 연산 =====\n# 행렬 곱셈 (dot product)\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\n\nC = np.dot(A, B)  # 또는 A @ B\nprint(C)\n# [[19 22]\n#  [43 50]]\n\n# 요소별 곱셈 vs 행렬 곱셈\nprint(\"요소별 곱셈:\")\nprint(A * B)  # [[5 12], [21 32]]\n\nprint(\"행렬 곱셈:\")\nprint(A @ B)  # [[19 22], [43 50]]\n\n# 전치 행렬\nprint(A.T)\n# [[1 3]\n#  [2 4]]\n\n# 대각 행렬\ndiag = np.diag([1, 2, 3])\nprint(diag)\n# [[1 0 0]\n#  [0 2 0]\n#  [0 0 3]]\n\n# 대각선 추출\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(np.diag(matrix))  # [1 5 9]\n\n# 행렬식 (determinant)\ndet = np.linalg.det(A)\nprint(f\"행렬식: {det}\")  # -2.0\n\n# 역행렬\nA_inv = np.linalg.inv(A)\nprint(\"역행렬:\")\nprint(A_inv)\n# [[-2.   1. ]\n#  [ 1.5 -0.5]]\n\n# 역행렬 검증: A @ A_inv = I\nidentity = A @ A_inv\nprint(np.round(identity))  # 단위 행렬\n\n# ===== 6. 고유값과 고유벡터 =====\nA = np.array([[4, 2], [1, 3]])\n\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(f\"고유값: {eigenvalues}\")\nprint(f\"고유벡터:\\n{eigenvectors}\")\n\n# ===== 7. 선형 방정식 풀이 =====\n# Ax = b 형태의 방정식\n# 예: 3x + y = 9, x + 2y = 8\nA = np.array([[3, 1], [1, 2]])\nb = np.array([9, 8])\n\nx = np.linalg.solve(A, b)\nprint(f\"해: x={x[0]}, y={x[1]}\")  # x=2, y=3\n\n# 검증\nprint(np.allclose(A @ x, b))  # True\n\n# ===== 8. 특이값 분해 (SVD) =====\nA = np.array([[1, 2], [3, 4], [5, 6]])\n\nU, s, Vt = np.linalg.svd(A)\nprint(f\"U shape: {U.shape}\")    # (3, 3)\nprint(f\"s shape: {s.shape}\")    # (2,)\nprint(f\"Vt shape: {Vt.shape}\")  # (2, 2)\n\n# ===== 9. 정렬과 탐색 =====\narr = np.array([5, 2, 8, 1, 9, 3])\n\n# 정렬\nsorted_arr = np.sort(arr)\nprint(sorted_arr)  # [1 2 3 5 8 9]\n\n# 정렬 인덱스\nindices = np.argsort(arr)\nprint(indices)     # [3 1 5 0 2 4]\nprint(arr[indices])  # [1 2 3 5 8 9]\n\n# 2D 배열 정렬\nmatrix = np.array([[5, 2, 8], [1, 9, 3]])\nprint(np.sort(matrix, axis=1))  # 각 행 정렬\n# [[2 5 8]\n#  [1 3 9]]\n\n# 유일값 찾기\narr = np.array([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])\nunique = np.unique(arr)\nprint(unique)  # [1 2 3 4]\n\n# 개수와 함께\nunique, counts = np.unique(arr, return_counts=True)\nprint(dict(zip(unique, counts)))  # {1: 1, 2: 2, 3: 3, 4: 4}\n\n# ===== 10. 조건부 연산 =====\n# np.where: 조건에 따른 값 선택\narr = np.array([1, 5, 10, 15, 20])\nresult = np.where(arr > 10, 'High', 'Low')\nprint(result)  # ['Low' 'Low' 'Low' 'High' 'High']\n\n# 조건에 따른 값 치환\nresult = np.where(arr > 10, arr * 2, arr)\nprint(result)  # [ 1  5 10 30 40]\n\n# np.select: 여러 조건\nconditions = [\n    arr < 10,\n    (arr >= 10) & (arr < 20),\n    arr >= 20\n]\nchoices = ['Low', 'Medium', 'High']\nresult = np.select(conditions, choices)\nprint(result)  # ['Low' 'Low' 'Medium' 'Medium' 'High']\n\n# ===== 11. 랜덤 샘플링 =====\n# 균등 분포\nuniform = np.random.uniform(0, 1, 5)\nprint(uniform)\n\n# 정규 분포 (평균 0, 표준편차 1)\nnormal = np.random.randn(5)\nprint(normal)\n\n# 정규 분포 (평균과 표준편차 지정)\nnormal_custom = np.random.normal(loc=100, scale=15, size=5)\nprint(normal_custom)\n\n# 랜덤 정수\nrand_int = np.random.randint(1, 100, size=10)\nprint(rand_int)\n\n# 랜덤 선택\nvalues = np.array(['A', 'B', 'C', 'D'])\nsamples = np.random.choice(values, size=10)\nprint(samples)\n\n# 가중치 있는 샘플링\nweighted = np.random.choice(['A', 'B', 'C'], size=100, p=[0.5, 0.3, 0.2])\nunique, counts = np.unique(weighted, return_counts=True)\nprint(dict(zip(unique, counts)))\n\n# 랜덤 셔플\narr = np.arange(10)\nnp.random.shuffle(arr)\nprint(arr)\n\n# 시드 설정 (재현 가능)\nnp.random.seed(42)\nprint(np.random.rand(5))  # 항상 같은 값"
      },
      {
        "type": "use-case",
        "title": "실무 활용 사례",
        "content": "**1. 포트폴리오 최적화 (금융)**\n```python\nimport numpy as np\n\n# 4개 자산의 수익률 (일별, 252거래일)\nreturns = np.random.randn(252, 4) * 0.01  # 1% 표준편차\n\n# 평균 수익률\nmean_returns = returns.mean(axis=0)\nprint(f\"평균 수익률: {mean_returns}\")\n\n# 공분산 행렬\ncov_matrix = np.cov(returns.T)\nprint(f\"공분산 행렬:\\n{cov_matrix}\")\n\n# 포트폴리오 가중치 (4개 자산에 균등 배분)\nweights = np.array([0.25, 0.25, 0.25, 0.25])\n\n# 포트폴리오 수익률\nportfolio_return = np.dot(weights, mean_returns) * 252  # 연간화\nprint(f\"포트폴리오 연간 수익률: {portfolio_return:.2%}\")\n\n# 포트폴리오 리스크 (표준편차)\nportfolio_variance = weights @ cov_matrix @ weights\nportfolio_std = np.sqrt(portfolio_variance) * np.sqrt(252)  # 연간화\nprint(f\"포트폴리오 연간 리스크: {portfolio_std:.2%}\")\n\n# 샤프 비율 (무위험 수익률 2% 가정)\nrisk_free_rate = 0.02\nsharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_std\nprint(f\"샤프 비율: {sharpe_ratio:.2f}\")\n```\n\n**2. 이미지 필터링 (컴퓨터 비전)**\n```python\nimport numpy as np\nfrom scipy.signal import convolve2d\nimport matplotlib.pyplot as plt\n\n# 가우시안 블러 필터\ndef gaussian_kernel(size=5, sigma=1.0):\n    \"\"\"가우시안 커널 생성\"\"\"\n    kernel = np.zeros((size, size))\n    center = size // 2\n    \n    for i in range(size):\n        for j in range(size):\n            x, y = i - center, j - center\n            kernel[i, j] = np.exp(-(x**2 + y**2) / (2 * sigma**2))\n    \n    return kernel / kernel.sum()\n\n# 엣지 검출 필터 (Sobel)\nsobel_x = np.array([[-1, 0, 1],\n                     [-2, 0, 2],\n                     [-1, 0, 1]])\n\nsobel_y = np.array([[-1, -2, -1],\n                     [ 0,  0,  0],\n                     [ 1,  2,  1]])\n\n# 이미지 로드 (가정)\nimage = np.random.rand(256, 256) * 255\n\n# 가우시안 블러 적용\nblurred = convolve2d(image, gaussian_kernel(5, 1.0), mode='same')\n\n# 엣지 검출\nedges_x = convolve2d(image, sobel_x, mode='same')\nedges_y = convolve2d(image, sobel_y, mode='same')\nedges = np.hypot(edges_x, edges_y)\n\nprint(f\"원본 이미지 크기: {image.shape}\")\nprint(f\"블러 적용 후: {blurred.shape}\")\nprint(f\"엣지 검출 후: {edges.shape}\")\n```\n\n**3. 시계열 분석 (예측)**\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 시계열 데이터 생성 (추세 + 계절성 + 노이즈)\ndays = 365\nt = np.arange(days)\n\ntrend = 0.1 * t  # 상승 추세\nseasonality = 10 * np.sin(2 * np.pi * t / 365)  # 연간 계절성\nnoise = np.random.randn(days) * 2\n\ndata = 100 + trend + seasonality + noise\n\n# 이동 평균 (Moving Average)\ndef moving_average(data, window):\n    return np.convolve(data, np.ones(window)/window, mode='valid')\n\nma_7 = moving_average(data, 7)\nma_30 = moving_average(data, 30)\n\n# 지수 이동 평균 (Exponential Moving Average)\ndef exponential_moving_average(data, alpha=0.3):\n    ema = np.zeros_like(data)\n    ema[0] = data[0]\n    for i in range(1, len(data)):\n        ema[i] = alpha * data[i] + (1 - alpha) * ema[i-1]\n    return ema\n\nema = exponential_moving_average(data, alpha=0.1)\n\n# 추세 제거 (Detrending)\ndetrended = data - np.polyval(np.polyfit(t, data, 1), t)\n\n# 자기상관 (Autocorrelation)\ndef autocorr(data, lag):\n    mean = data.mean()\n    c0 = np.sum((data - mean) ** 2)\n    c_lag = np.sum((data[:-lag] - mean) * (data[lag:] - mean))\n    return c_lag / c0\n\nlags = range(1, 31)\nautocorr_values = [autocorr(data, lag) for lag in lags]\n\nprint(f\"7일 이동 평균 길이: {len(ma_7)}\")\nprint(f\"30일 이동 평균 길이: {len(ma_30)}\")\nprint(f\"1일 자기상관: {autocorr_values[0]:.3f}\")\n```\n\n**4. 선형 회귀 (머신러닝)**\n```python\nimport numpy as np\n\n# 데이터 생성 (y = 3x + 2 + noise)\nnp.random.seed(42)\nX = np.linspace(0, 10, 100).reshape(-1, 1)\ny = 3 * X.squeeze() + 2 + np.random.randn(100) * 2\n\n# 정규 방정식으로 계수 추정\n# β = (X^T X)^(-1) X^T y\n\n# X에 절편 항 추가\nX_b = np.c_[np.ones((100, 1)), X]  # [1, x]\n\n# 계수 계산\nbeta = np.linalg.inv(X_b.T @ X_b) @ X_b.T @ y\nintercept, slope = beta\n\nprint(f\"절편: {intercept:.2f}\")\nprint(f\"기울기: {slope:.2f}\")\n\n# 예측\ny_pred = X_b @ beta\n\n# 평가 지표\nmse = np.mean((y - y_pred) ** 2)\nrmse = np.sqrt(mse)\nr2 = 1 - (np.sum((y - y_pred) ** 2) / np.sum((y - y.mean()) ** 2))\n\nprint(f\"MSE: {mse:.2f}\")\nprint(f\"RMSE: {rmse:.2f}\")\nprint(f\"R²: {r2:.3f}\")\n```\n\n**5. 주성분 분석 (PCA)**\n```python\nimport numpy as np\n\n# 고차원 데이터 생성\nnp.random.seed(42)\nX = np.random.randn(100, 10)  # 100 샘플, 10 특징\n\n# 1. 데이터 표준화\nX_mean = X.mean(axis=0)\nX_std = X.std(axis=0)\nX_normalized = (X - X_mean) / X_std\n\n# 2. 공분산 행렬 계산\ncov_matrix = np.cov(X_normalized.T)\n\n# 3. 고유값과 고유벡터 계산\neigenvalues, eigenvectors = np.linalg.eig(cov_matrix)\n\n# 4. 고유값 기준으로 정렬\nidx = eigenvalues.argsort()[::-1]\neigenvalues = eigenvalues[idx]\neigenvectors = eigenvectors[:, idx]\n\n# 5. 설명 분산 비율\nexplained_variance_ratio = eigenvalues / eigenvalues.sum()\ncumulative_variance = np.cumsum(explained_variance_ratio)\n\nprint(f\"각 주성분의 설명 분산 비율: {explained_variance_ratio[:5]}\")\nprint(f\"상위 3개 주성분 누적 분산: {cumulative_variance[2]:.2%}\")\n\n# 6. 차원 축소 (상위 3개 주성분)\nn_components = 3\nW = eigenvectors[:, :n_components]\nX_reduced = X_normalized @ W\n\nprint(f\"원본 데이터 shape: {X.shape}\")\nprint(f\"축소된 데이터 shape: {X_reduced.shape}\")\n```\n\n**6. k-Means 클러스터링**\n```python\nimport numpy as np\n\ndef kmeans(X, k, max_iters=100):\n    \"\"\"k-Means 클러스터링 구현\"\"\"\n    # 랜덤 초기 중심점\n    n_samples = X.shape[0]\n    random_indices = np.random.choice(n_samples, k, replace=False)\n    centroids = X[random_indices]\n    \n    for _ in range(max_iters):\n        # 각 점을 가장 가까운 중심점에 할당\n        distances = np.sqrt(((X - centroids[:, np.newaxis])**2).sum(axis=2))\n        labels = np.argmin(distances, axis=0)\n        \n        # 새 중심점 계산\n        new_centroids = np.array([X[labels == i].mean(axis=0) for i in range(k)])\n        \n        # 수렴 확인\n        if np.allclose(centroids, new_centroids):\n            break\n        \n        centroids = new_centroids\n    \n    return labels, centroids\n\n# 데이터 생성\nnp.random.seed(42)\nX = np.vstack([\n    np.random.randn(100, 2) + [0, 0],\n    np.random.randn(100, 2) + [5, 5],\n    np.random.randn(100, 2) + [0, 5]\n])\n\n# k-Means 실행\nlabels, centroids = kmeans(X, k=3)\n\nprint(f\"클러스터 레이블: {np.unique(labels)}\")\nprint(f\"중심점:\\n{centroids}\")\nprint(f\"클러스터 0 크기: {(labels == 0).sum()}\")\nprint(f\"클러스터 1 크기: {(labels == 1).sum()}\")\nprint(f\"클러스터 2 크기: {(labels == 2).sum()}\")\n```"
      },
      {
        "type": "best-practice",
        "title": "NumPy 연산 모범 사례",
        "content": "**1. 벡터화 연산으로 성능 향상**\n```python\nimport numpy as np\nimport time\n\n# Bad: Python 반복문\nstart = time.time()\ndata = list(range(1000000))\nresult = []\nfor x in data:\n    result.append(x ** 2 + 2 * x + 1)\nend = time.time()\nprint(f\"Python 반복문: {end - start:.3f}초\")\n\n# Good: NumPy 벡터화\nstart = time.time()\ndata = np.arange(1000000)\nresult = data ** 2 + 2 * data + 1\nend = time.time()\nprint(f\"NumPy 벡터화: {end - start:.3f}초\")  # 10-100배 빠름!\n```\n\n**2. 브로드캐스팅으로 메모리 절약**\n```python\n# Bad: 명시적 반복\nmatrix = np.random.rand(1000, 100)\nrow_means = matrix.mean(axis=1)\ncentered = np.zeros_like(matrix)\nfor i in range(matrix.shape[0]):\n    centered[i] = matrix[i] - row_means[i]\n\n# Good: 브로드캐스팅\ncentered = matrix - matrix.mean(axis=1)[:, np.newaxis]\n```\n\n**3. axis 파라미터 활용**\n```python\ndata = np.random.rand(1000, 50)\n\n# 열별 평균\ncolumn_means = data.mean(axis=0)  # (50,)\n\n# 행별 평균\nrow_means = data.mean(axis=1)  # (1000,)\n\n# 전체 평균\ntotal_mean = data.mean()  # 스칼라\n```\n\n**4. 메모리 효율적인 연산**\n```python\n# Bad: 중간 배열 여러 개 생성\ndata = np.random.rand(10000, 100)\ntemp1 = data ** 2\ntemp2 = temp1 * 2\nresult = temp2 + 1\n\n# Good: 한 번에 계산 (중간 배열 최소화)\nresult = (data ** 2) * 2 + 1\n\n# Better: in-place 연산 (메모리 재사용)\ndata **= 2\ndata *= 2\ndata += 1\n```\n\n**5. 적절한 데이터 타입 선택**\n```python\n# Bad: 기본 float64 (메모리 낭비)\nlarge_array = np.random.rand(10000, 10000)  # 800MB\n\n# Good: 필요한 정밀도만 사용\nlarge_array = np.random.rand(10000, 10000).astype(np.float32)  # 400MB\n\n# 정수 데이터는 더 작은 타입\nint_array = np.arange(1000000, dtype=np.int32)  # 4MB (int64면 8MB)\n```\n\n**6. NaN 처리**\n```python\ndata = np.array([1, 2, np.nan, 4, np.nan, 6])\n\n# Bad: 일반 함수 (NaN 무시 안 함)\nprint(data.mean())  # nan\n\n# Good: NaN 무시 함수\nprint(np.nanmean(data))  # 3.25\nprint(np.nansum(data))   # 13.0\nprint(np.nanstd(data))   # 2.2174\n```\n\n**7. 조건부 연산 최적화**\n```python\ndata = np.random.rand(1000000)\n\n# Bad: 반복문\nresult = np.zeros_like(data)\nfor i, x in enumerate(data):\n    if x > 0.5:\n        result[i] = x * 2\n    else:\n        result[i] = x / 2\n\n# Good: np.where\nresult = np.where(data > 0.5, data * 2, data / 2)\n```"
      },
      {
        "type": "common-mistake",
        "title": "흔한 실수와 해결책",
        "content": "**1. 브로드캐스팅 shape 불일치**\n```python\n# 실수: shape 맞지 않음\nmatrix = np.random.rand(3, 4)  # (3, 4)\nvector = np.random.rand(3)     # (3,)\n\n# result = matrix + vector  # ValueError!\n\n# 해결책 1: reshape\nvector_col = vector.reshape(-1, 1)  # (3, 1)\nresult = matrix + vector_col  # OK\n\n# 해결책 2: newaxis\nresult = matrix + vector[:, np.newaxis]  # OK\n```\n\n**2. 행렬 곱셈 연산자 혼동**\n```python\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\n\n# 실수: 요소별 곱셈\nprint(A * B)  # [[5 12], [21 32]]\n\n# 올바른 행렬 곱셈\nprint(A @ B)   # [[19 22], [43 50]]\nprint(np.dot(A, B))  # [[19 22], [43 50]]\n```\n\n**3. 정수 나눗셈 타입 변환**\n```python\n# 실수: 정수 나눗셈 결과가 정수\narr = np.array([1, 2, 3, 4, 5])\nmean = arr.sum() / len(arr)  # OK (Python int)\n\narr_int = np.array([1, 2, 3, 4, 5], dtype=int)\nmean = arr_int.sum() / arr_int.size  # OK\n\n# 안전한 방법: float로 변환\nmean = arr_int.astype(float).mean()\n```\n\n**4. 배열 복사 vs 뷰**\n```python\n# 실수: 뷰를 수정하면 원본도 변경\noriginal = np.array([1, 2, 3, 4, 5])\nsliced = original[1:4]  # 뷰\nsliced[0] = 999\nprint(original)  # [1 999 3 4 5] - 원본 변경!\n\n# 해결책: 명시적 복사\nsliced = original[1:4].copy()\nsliced[0] = 999\nprint(original)  # [1 2 3 4 5] - 원본 유지\n```\n\n**5. NaN 비교 실수**\n```python\n# 실수: NaN은 자기 자신과도 같지 않음\nnan_val = np.nan\nprint(nan_val == nan_val)  # False!\n\n# 해결책: isnan 사용\nprint(np.isnan(nan_val))  # True\n\narr = np.array([1, 2, np.nan, 4])\nprint(np.isnan(arr))  # [False False  True False]\n```\n\n**6. 역행렬 존재 여부 미확인**\n```python\n# 실수: 특이 행렬(singular matrix)의 역행렬\nA = np.array([[1, 2], [2, 4]])  # 행렬식 = 0\n\ntry:\n    A_inv = np.linalg.inv(A)  # LinAlgError!\nexcept np.linalg.LinAlgError:\n    print(\"역행렬이 존재하지 않습니다.\")\n\n# 해결책: 행렬식 확인\nif np.linalg.det(A) != 0:\n    A_inv = np.linalg.inv(A)\nelse:\n    print(\"역행렬이 존재하지 않습니다.\")\n```\n\n**7. 메모리 부족 (대용량 배열)**\n```python\n# 실수: 너무 큰 배열 생성\ntry:\n    huge_array = np.zeros((100000, 100000))  # 80GB!\nexcept MemoryError:\n    print(\"메모리 부족\")\n\n# 해결책 1: 데이터 타입 축소\nhuge_array = np.zeros((100000, 100000), dtype=np.float32)  # 40GB\n\n# 해결책 2: 필요한 부분만 생성\n# 또는 메모리 맵 사용\n# huge_array = np.memmap('temp.dat', dtype='float32', mode='w+', shape=(100000, 100000))\n```"
      },
      {
        "type": "tip",
        "title": "NumPy 고급 팁",
        "content": "**1. Einstein Summation (einsum)**\n```python\n# 복잡한 텐서 연산을 간결하게\nA = np.random.rand(3, 4)\nB = np.random.rand(4, 5)\n\n# 행렬 곱셈\nC = np.einsum('ij,jk->ik', A, B)  # A @ B와 동일\n\n# 배치 행렬 곱셈\nA_batch = np.random.rand(10, 3, 4)\nB_batch = np.random.rand(10, 4, 5)\nC_batch = np.einsum('bij,bjk->bik', A_batch, B_batch)\n\n# 대각 합 (trace)\nmatrix = np.random.rand(5, 5)\ntrace = np.einsum('ii->', matrix)\n```\n\n**2. 고급 인덱싱 조합**\n```python\nmatrix = np.arange(20).reshape(4, 5)\n\n# 특정 행과 열 선택\nrows = [0, 2]\ncols = [1, 3, 4]\nresult = matrix[np.ix_(rows, cols)]\nprint(result)\n```\n\n**3. 구조화 배열 (Structured Array)**\n```python\n# 다양한 타입의 데이터를 하나의 배열에\ndtype = [('name', 'U20'), ('age', 'i4'), ('salary', 'f4')]\nemployees = np.array([\n    ('Alice', 25, 50000),\n    ('Bob', 30, 60000),\n    ('Charlie', 35, 70000)\n], dtype=dtype)\n\nprint(employees['name'])   # ['Alice' 'Bob' 'Charlie']\nprint(employees['age'])    # [25 30 35]\nprint(employees[employees['salary'] > 55000])  # 조건 필터링\n```\n\n**4. 메모리 맵 파일 (대용량 데이터)**\n```python\n# 메모리에 다 올리지 않고 디스크에서 직접 접근\nlarge_data = np.memmap('large_file.dat', \n                        dtype='float32', \n                        mode='w+', \n                        shape=(100000, 10000))\n\n# 일부분만 수정\nlarge_data[0:1000, :] = np.random.rand(1000, 10000)\n\n# 자동으로 디스크에 저장됨\nlarge_data.flush()\n```\n\n**5. 윈도우 함수 (Rolling Window)**\n```python\ndef rolling_window(arr, window_size):\n    \"\"\"효율적인 rolling window 생성\"\"\"\n    shape = (arr.size - window_size + 1, window_size)\n    strides = (arr.strides[0], arr.strides[0])\n    return np.lib.stride_tricks.as_strided(arr, shape=shape, strides=strides)\n\ndata = np.arange(10)\nwindows = rolling_window(data, 3)\nprint(windows)\n# [[0 1 2]\n#  [1 2 3]\n#  [2 3 4]\n#  ...\n#  [7 8 9]]\n\n# 이동 평균 계산\nmoving_avg = windows.mean(axis=1)\n```\n\n**6. 다차원 히스토그램**\n```python\n# 2D 히스토그램\ndata_x = np.random.randn(1000)\ndata_y = np.random.randn(1000)\n\nhist, xedges, yedges = np.histogram2d(data_x, data_y, bins=20)\nprint(f\"Histogram shape: {hist.shape}\")\n```\n\n**7. 다항식 피팅**\n```python\n# 데이터에 다항식 피팅\nx = np.linspace(0, 10, 100)\ny = 3 * x**2 + 2 * x + 1 + np.random.randn(100) * 10\n\n# 2차 다항식 피팅\ncoeffs = np.polyfit(x, y, 2)\nprint(f\"계수: {coeffs}\")  # [3, 2, 1]에 가까움\n\n# 예측\ny_pred = np.polyval(coeffs, x)\n\n# R² 계산\nss_res = np.sum((y - y_pred) ** 2)\nss_tot = np.sum((y - y.mean()) ** 2)\nr_squared = 1 - (ss_res / ss_tot)\nprint(f\"R²: {r_squared:.3f}\")\n```\n\n**8. 푸리에 변환 (FFT)**\n```python\n# 신호 생성\nt = np.linspace(0, 1, 1000)\nsignal = np.sin(2 * np.pi * 50 * t) + np.sin(2 * np.pi * 120 * t)\n\n# 푸리에 변환\nfft = np.fft.fft(signal)\nfreqs = np.fft.fftfreq(len(signal), t[1] - t[0])\n\n# 주파수 성분 확인\nprint(f\"주요 주파수: {freqs[np.abs(fft).argsort()[-3:]]}\")\n```"
      },
      {
        "type": "practice",
        "title": "연습 문제",
        "content": "**문제 1: 브로드캐스팅**\n3x4 행렬에서 각 열의 평균을 빼서 중심화하세요.\n```python\nmatrix = np.random.rand(3, 4)\n# 각 열의 평균을 빼기\n```\n\n**문제 2: 행렬 연산**\n두 행렬 A (2x3)와 B (3x2)의 행렬 곱셈을 수행하세요.\n\n**문제 3: 조건부 연산**\n배열의 값이 0보다 크면 제곱, 작거나 같으면 0으로 만드세요.\n```python\narr = np.array([-2, -1, 0, 1, 2, 3])\n# 결과: [0, 0, 0, 1, 4, 9]\n```\n\n**문제 4: 정렬**\n2D 배열을 두 번째 열 기준으로 정렬하세요.\n```python\ndata = np.array([[3, 2, 1],\n                 [6, 5, 4],\n                 [9, 8, 7]])\n# 두 번째 열 (2, 5, 8) 기준 정렬\n```\n\n**문제 5: 통계**\n100개 학생의 5과목 점수 행렬에서:\n- 학생별 평균 (행 방향)\n- 과목별 평균 (열 방향)\n- 전체 평균\n\n**문제 6: 선형 방정식**\n다음 연립 방정식을 풀으세요:\n- 2x + y = 5\n- x + 3y = 11\n\n**문제 7: 이동 평균**\n주식 가격 데이터의 7일 이동 평균을 계산하세요.\n```python\nprices = np.random.rand(30) * 100 + 100\n# 7일 이동 평균\n```\n\n**문제 8: 실전 문제 - 표준화**\n데이터를 z-score로 표준화하세요 (평균 0, 표준편차 1).\n```python\ndata = np.random.rand(100, 5) * 100\n# 각 열을 표준화\n# z = (x - mean) / std\n```\n\n**보너스 문제: PCA 구현**\nNumPy만 사용하여 2차원으로 차원 축소하는 PCA를 구현하세요.\n```python\nX = np.random.rand(100, 10)  # 100 샘플, 10 특징\n# 2개 주성분으로 축소\n# X_reduced shape: (100, 2)\n```"
      }
    ]
  },
  "02_python-data/03_pandas_dataframe": {
    "id": "02_python-data/03_pandas_dataframe",
    "title": "03 Pandas Dataframe",
    "category": "ai-roadmap",
    "subCategory": "02_python-data",
    "language": "Python",
    "description": "Pandas DataFrame 생성, 조회, 필터링, CSV 읽기/쓰기를 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Pandas와 DataFrame",
        "content": "Pandas는 데이터 분석을 위한 Python 라이브러리로, 표 형태의 데이터를 쉽게 다룰 수 있게 해줍니다.\n\n**Pandas의 핵심 자료구조:**\n\n**1. Series (1차원)**\n- 인덱스를 가진 1차원 배열\n- 단일 열의 데이터\n- 딕셔너리처럼 키-값 쌍으로 접근 가능\n\n**2. DataFrame (2차원)**\n- 여러 Series의 모음\n- 행과 열로 구성된 표 형태\n- 각 열은 다른 데이터 타입 가능\n- 엑셀 스프레드시트와 유사\n\n**DataFrame의 특징:**\n- **인덱스(Index)**: 각 행을 식별하는 레이블\n- **컬럼(Columns)**: 각 열의 이름\n- **값(Values)**: 실제 데이터\n- **타입 혼합**: 숫자, 문자열, 날짜 등 혼합 가능\n\n**주요 기능:**\n- 데이터 로드/저장: CSV, Excel, SQL, JSON\n- 데이터 조회: loc, iloc, 조건 필터링\n- 데이터 변환: 정렬, 그룹화, 피벗\n- 결측값 처리: dropna, fillna\n- 데이터 병합: merge, concat, join\n\n**설치:**\n```bash\npip install pandas\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "import pandas as pd\nimport numpy as np\n\n# ===== 1. Series 생성 =====\n# 리스트로부터\ns1 = pd.Series([10, 20, 30, 40, 50])\nprint(s1)\n\n# 인덱스 지정\ns2 = pd.Series([10, 20, 30], index=['a', 'b', 'c'])\nprint(s2)\n\n# 딕셔너리로부터\ndata_dict = {'apple': 100, 'banana': 200, 'cherry': 300}\ns3 = pd.Series(data_dict)\nprint(s3)\n\n# ===== 2. DataFrame 생성 =====\n# 딕셔너리로부터 (가장 일반적)\ndata = {\n    'name': ['Alice', 'Bob', 'Charlie', 'David'],\n    'age': [25, 30, 35, 40],\n    'city': ['Seoul', 'Busan', 'Incheon', 'Daegu'],\n    'salary': [50000, 60000, 70000, 80000]\n}\ndf = pd.DataFrame(data)\nprint(df)\n\n# ===== 3. DataFrame 기본 정보 =====\nprint(df.shape)      # (4, 4) - 4행 4열\nprint(df.columns)    # Index(['name', 'age', 'city', 'salary'])\nprint(df.index)      # RangeIndex(start=0, stop=4, step=1)\nprint(df.dtypes)     # 각 열의 데이터 타입\nprint(df.head(3))    # 처음 3개\nprint(df.tail(2))    # 마지막 2개\nprint(df.describe()) # 통계 요약\n\n# ===== 4. 데이터 선택 (열) =====\nprint(df['name'])    # 단일 열\nprint(df[['name', 'age']])  # 여러 열\n\n# 열 추가\ndf['bonus'] = df['salary'] * 0.1\n\n# 열 삭제\ndf_dropped = df.drop('bonus', axis=1)\n\n# ===== 5. 데이터 선택 (행) =====\nprint(df.iloc[0])    # 첫 번째 행\nprint(df.loc[0])     # 인덱스 0인 행\n\n# ===== 6. 조건 필터링 =====\nprint(df[df['age'] > 30])\nprint(df[(df['age'] > 25) & (df['salary'] >= 60000)])\n\n# ===== 7. 정렬 =====\nprint(df.sort_values('age'))\nprint(df.sort_values('salary', ascending=False))\n\n# ===== 8. 결측값 처리 =====\ndf_missing = pd.DataFrame({\n    'A': [1, 2, np.nan, 4],\n    'B': [10, np.nan, 30, 40]\n})\nprint(df_missing.isnull().sum())\nprint(df_missing.dropna())\nprint(df_missing.fillna(0))\n\n# ===== 9. CSV 파일 =====\ndf.to_csv('data.csv', index=False)\ndf_loaded = pd.read_csv('data.csv')"
      },
      {
        "type": "use-case",
        "title": "실무 활용 사례",
        "content": "**1. 고객 데이터 분석**\n```python\nimport pandas as pd\n\ncustomers = pd.DataFrame({\n    'customer_id': [1, 2, 3, 4, 5],\n    'name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],\n    'age': [25, 35, 45, 30, 28],\n    'total_purchase': [50000, 120000, 80000, 150000, 95000]\n})\n\nprint(f\"평균 구매액: {customers['total_purchase'].mean():,.0f}원\")\nvip = customers[customers['total_purchase'] >= 100000]\nprint(f\"VIP 고객: {len(vip)}명\")\n```\n\n**2. 매출 데이터 분석**\n```python\nsales = pd.DataFrame({\n    'date': pd.date_range('2024-01-01', periods=30),\n    'revenue': np.random.randint(100000, 500000, 30),\n    'category': np.random.choice(['전자제품', '의류'], 30)\n})\n\nmonthly = sales.groupby(sales['date'].dt.month)['revenue'].sum()\nprint(monthly)\n```"
      },
      {
        "type": "best-practice",
        "title": "Pandas 사용 모범 사례",
        "content": "**1. 벡터화 연산 사용**\n```python\n# Bad: apply 사용 (느림)\ndf['C'] = df.apply(lambda row: row['A'] + row['B'], axis=1)\n\n# Good: 벡터화\ndf['C'] = df['A'] + df['B']\n```\n\n**2. 체인 메서드**\n```python\nresult = (df\n    .query('age > 25')\n    .sort_values('salary')\n    [['name', 'salary']]\n    .head(10)\n)\n```\n\n**3. 적절한 데이터 타입**\n```python\n# category 타입으로 메모리 절약\ndf['category'] = df['category'].astype('category')\n```"
      },
      {
        "type": "common-mistake",
        "title": "흔한 실수와 해결책",
        "content": "**1. SettingWithCopyWarning**\n```python\n# 실수\ndf_filtered = df[df['age'] > 25]\ndf_filtered['new_col'] = 1  # Warning!\n\n# 해결책\ndf_filtered = df[df['age'] > 25].copy()\n```\n\n**2. 체인 인덱싱**\n```python\n# 실수\ndf[df['age'] > 25]['salary'] = 100000  # 작동 안 함\n\n# 해결책\ndf.loc[df['age'] > 25, 'salary'] = 100000\n```"
      },
      {
        "type": "tip",
        "title": "Pandas 고급 팁",
        "content": "**1. query() 사용**\n```python\n# 가독성 좋은 필터링\nfiltered = df.query('age > 25 and salary >= 50000')\n```\n\n**2. pipe()로 함수 체이닝**\n```python\ndef remove_outliers(df):\n    return df[df['value'] < df['value'].quantile(0.95)]\n\ndf_processed = df.pipe(remove_outliers)\n```\n\n**3. explode()로 리스트 펼치기**\n```python\ndf = pd.DataFrame({'name': ['Alice'], 'hobbies': [['reading', 'swimming']]})\ndf_exploded = df.explode('hobbies')\n```"
      },
      {
        "type": "practice",
        "title": "연습 문제",
        "content": "**문제 1: DataFrame 생성**\n이름, 나이, 도시 정보로 DataFrame을 만드세요.\n\n**문제 2: 필터링**\n나이가 30세 이상인 사람들만 필터링하세요.\n\n**문제 3: 집계**\n부서별 평균 급여를 계산하세요.\n\n**문제 4: 결측값**\n결측값을 열 평균으로 채우세요.\n\n**문제 5: CSV**\nDataFrame을 CSV로 저장하고 다시 불러오세요."
      }
    ]
  },
  "02_python-data/04_pandas_analysis": {
    "id": "02_python-data/04_pandas_analysis",
    "title": "04 Pandas Analysis",
    "category": "ai-roadmap",
    "subCategory": "02_python-data",
    "language": "Python",
    "description": "Pandas 그룹화, 집계, 피벗, 병합 등 고급 데이터 분석을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Pandas 데이터 분석 기법",
        "content": "Pandas는 SQL과 유사한 강력한 데이터 분석 기능을 제공합니다.\n\n**주요 분석 기법:**\n\n**1. GroupBy (그룹화)**\n- SQL의 GROUP BY와 유사\n- 데이터를 그룹으로 나누고 집계\n- split-apply-combine 패턴\n\n**2. Aggregation (집계)**\n- sum, mean, count, min, max\n- 여러 집계 함수 동시 적용\n- 사용자 정의 집계 함수\n\n**3. Pivot Table (피벗 테이블)**\n- 엑셀 피벗 테이블과 유사\n- 데이터를 다차원으로 요약\n- 행과 열로 데이터 재구성\n\n**4. Merge & Join (병합)**\n- SQL JOIN과 유사\n- 여러 DataFrame 결합\n- inner, outer, left, right join\n\n**5. Time Series (시계열)**\n- 날짜/시간 데이터 처리\n- 리샘플링, 롤링 윈도우\n- 시간대 변환"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "import pandas as pd\nimport numpy as np\n\n# ===== 1. GroupBy 기본 =====\ndf = pd.DataFrame({\n    'department': ['IT', 'IT', 'HR', 'HR', 'Sales'],\n    'name': ['Alice', 'Bob', 'Charlie', 'David', 'Eve'],\n    'salary': [70000, 75000, 60000, 65000, 80000]\n})\n\n# 부서별 평균 급여\nprint(df.groupby('department')['salary'].mean())\n\n# 부서별 여러 집계\nprint(df.groupby('department')['salary'].agg(['mean', 'sum', 'count']))\n\n# ===== 2. Pivot Table =====\nsales = pd.DataFrame({\n    'date': pd.date_range('2024-01-01', periods=12, freq='M'),\n    'region': ['North', 'South'] * 6,\n    'product': ['A', 'B'] * 6,\n    'revenue': np.random.randint(10000, 50000, 12)\n})\n\npivot = pd.pivot_table(\n    sales,\n    values='revenue',\n    index='region',\n    columns='product',\n    aggfunc='sum'\n)\nprint(pivot)\n\n# ===== 3. Merge (병합) =====\ndf1 = pd.DataFrame({'key': ['A', 'B', 'C'], 'value1': [1, 2, 3]})\ndf2 = pd.DataFrame({'key': ['A', 'B', 'D'], 'value2': [4, 5, 6]})\n\n# Inner join\nmerged = pd.merge(df1, df2, on='key', how='inner')\nprint(merged)\n\n# Left join\nmerged = pd.merge(df1, df2, on='key', how='left')\nprint(merged)\n\n# ===== 4. 시계열 데이터 =====\ndf = pd.DataFrame({\n    'date': pd.date_range('2024-01-01', periods=365),\n    'value': np.random.randn(365).cumsum()\n})\ndf.set_index('date', inplace=True)\n\n# 월별 리샘플링\nmonthly = df.resample('M').mean()\nprint(monthly)\n\n# 7일 이동 평균\ndf['ma_7'] = df['value'].rolling(window=7).mean()\nprint(df.head(10))"
      },
      {
        "type": "use-case",
        "title": "실무 활용 사례",
        "content": "**1. 매출 분석 대시보드**\n```python\nimport pandas as pd\n\nsales = pd.read_csv('sales_data.csv', parse_dates=['date'])\n\n# 일별/월별/연도별 집계\ndaily = sales.groupby('date')['revenue'].sum()\nmonthly = sales.resample('M', on='date')['revenue'].sum()\n\n# 제품별 매출\nproduct_sales = sales.groupby('product')['revenue'].agg([\n    ('총매출', 'sum'),\n    ('평균가격', 'mean'),\n    ('판매건수', 'count')\n])\n\n# 상위 10개 제품\ntop_products = product_sales.nlargest(10, '총매출')\nprint(top_products)\n```\n\n**2. 고객 세그먼테이션**\n```python\n# RFM 분석 (Recency, Frequency, Monetary)\ncustomers = pd.DataFrame({\n    'customer_id': [1, 2, 3],\n    'last_purchase_days': [5, 45, 120],\n    'purchase_count': [10, 5, 2],\n    'total_spend': [500000, 200000, 50000]\n})\n\n# 세그먼트 분류\ndef segment(row):\n    if row['purchase_count'] >= 5 and row['total_spend'] >= 300000:\n        return 'VIP'\n    elif row['last_purchase_days'] > 90:\n        return 'Churn Risk'\n    else:\n        return 'Regular'\n\ncustomers['segment'] = customers.apply(segment, axis=1)\nprint(customers.groupby('segment').size())\n```"
      },
      {
        "type": "best-practice",
        "title": "데이터 분석 모범 사례",
        "content": "**1. 효율적인 GroupBy**\n```python\n# Bad: 여러 번 groupby\nmean_val = df.groupby('category')['value'].mean()\nsum_val = df.groupby('category')['value'].sum()\n\n# Good: 한 번에 집계\nstats = df.groupby('category')['value'].agg(['mean', 'sum', 'std'])\n```\n\n**2. 메모리 효율적인 데이터 타입**\n```python\n# 카테고리 변수는 category 타입으로\ndf['category'] = df['category'].astype('category')\n\n# 날짜는 datetime으로\ndf['date'] = pd.to_datetime(df['date'])\n```"
      },
      {
        "type": "common-mistake",
        "title": "흔한 실수와 해결책",
        "content": "**1. 날짜 타입 미처리**\n```python\n# 실수: 문자열로 읽힘\ndf = pd.read_csv('data.csv')\n\n# 해결책: 파싱\ndf = pd.read_csv('data.csv', parse_dates=['date'])\n```\n\n**2. 인덱스 불일치**\n```python\n# merge 전 인덱스 리셋\ndf1 = df1.reset_index(drop=True)\ndf2 = df2.reset_index(drop=True)\n```"
      },
      {
        "type": "tip",
        "title": "고급 분석 팁",
        "content": "**1. 누적 계산**\n```python\n# 누적 합\ndf['cumsum'] = df['value'].cumsum()\n\n# 전월 대비 증가율\ndf['pct_change'] = df['value'].pct_change() * 100\n```\n\n**2. 다중 인덱스**\n```python\n# 다중 그룹화\nmulti_group = df.groupby(['year', 'month']).sum()\nprint(multi_group)\n```"
      },
      {
        "type": "practice",
        "title": "연습 문제",
        "content": "**문제 1: 부서별 평균 급여**\n부서별로 평균 급여를 계산하세요.\n\n**문제 2: 피벗 테이블**\n지역별, 제품별 매출을 피벗 테이블로 만드세요.\n\n**문제 3: 병합**\n두 DataFrame을 inner join으로 병합하세요.\n\n**문제 4: 시계열**\n일별 데이터를 월별로 리샘플링하고 평균을 구하세요."
      }
    ]
  },
  "02_python-data/05_matplotlib": {
    "id": "02_python-data/05_matplotlib",
    "title": "05 Matplotlib",
    "category": "ai-roadmap",
    "subCategory": "02_python-data",
    "language": "Python",
    "description": "Matplotlib으로 데이터 시각화 (선 그래프, 막대 그래프, 산점도 등)를 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Matplotlib 데이터 시각화",
        "content": "Matplotlib은 Python의 대표적인 데이터 시각화 라이브러리입니다.\n\n**주요 차트 유형:**\n- 선 그래프 (Line Plot): 시계열 데이터, 추세 표시\n- 막대 그래프 (Bar Chart): 카테고리별 비교\n- 산점도 (Scatter Plot): 변수 간 관계\n- 히스토그램 (Histogram): 분포 확인\n- 파이 차트 (Pie Chart): 구성비\n- 박스 플롯 (Box Plot): 통계 요약\n\n**설치:**\n```bash\npip install matplotlib\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# ===== 1. 기본 선 그래프 =====\nx = [1, 2, 3, 4, 5]\ny = [2, 4, 6, 8, 10]\n\nplt.plot(x, y)\nplt.xlabel('X축')\nplt.ylabel('Y축')\nplt.title('기본 선 그래프')\nplt.show()\n\n# ===== 2. 여러 선 그래프 =====\nx = np.linspace(0, 10, 100)\ny1 = np.sin(x)\ny2 = np.cos(x)\n\nplt.plot(x, y1, label='sin(x)', color='blue', linestyle='-')\nplt.plot(x, y2, label='cos(x)', color='red', linestyle='--')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.title('삼각함수')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n# ===== 3. 막대 그래프 =====\ncategories = ['A', 'B', 'C', 'D']\nvalues = [25, 40, 30, 55]\n\nplt.bar(categories, values, color='skyblue')\nplt.xlabel('카테고리')\nplt.ylabel('값')\nplt.title('막대 그래프')\nplt.show()\n\n# ===== 4. 산점도 =====\nx = np.random.rand(50)\ny = np.random.rand(50)\ncolors = np.random.rand(50)\nsizes = 1000 * np.random.rand(50)\n\nplt.scatter(x, y, c=colors, s=sizes, alpha=0.5)\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.title('산점도')\nplt.colorbar()\nplt.show()\n\n# ===== 5. 히스토그램 =====\ndata = np.random.randn(1000)\n\nplt.hist(data, bins=30, color='green', alpha=0.7)\nplt.xlabel('값')\nplt.ylabel('빈도')\nplt.title('히스토그램')\nplt.show()\n\n# ===== 6. 파이 차트 =====\nsizes = [25, 35, 20, 20]\nlabels = ['A', 'B', 'C', 'D']\nexplode = [0.1, 0, 0, 0]  # A를 강조\n\nplt.pie(sizes, labels=labels, explode=explode, autopct='%1.1f%%')\nplt.title('파이 차트')\nplt.axis('equal')\nplt.show()\n\n# ===== 7. 서브플롯 =====\nfig, axes = plt.subplots(2, 2, figsize=(10, 8))\n\naxes[0, 0].plot([1, 2, 3], [1, 4, 9])\naxes[0, 0].set_title('Plot 1')\n\naxes[0, 1].bar(['A', 'B'], [10, 20])\naxes[0, 1].set_title('Plot 2')\n\naxes[1, 0].scatter(np.random.rand(10), np.random.rand(10))\naxes[1, 0].set_title('Plot 3')\n\naxes[1, 1].hist(np.random.randn(100), bins=20)\naxes[1, 1].set_title('Plot 4')\n\nplt.tight_layout()\nplt.show()"
      },
      {
        "type": "use-case",
        "title": "실무 시각화 사례",
        "content": "**1. 매출 추이**\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf = pd.DataFrame({\n    'month': pd.date_range('2024-01', periods=12, freq='M'),\n    'revenue': [100, 120, 140, 130, 150, 180, 200, 210, 190, 220, 240, 250]\n})\n\nplt.plot(df['month'], df['revenue'], marker='o')\nplt.title('월별 매출 추이')\nplt.xlabel('월')\nplt.ylabel('매출 (만원)')\nplt.xticks(rotation=45)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n```\n\n**2. 제품별 비교**\n```python\nproducts = ['제품A', '제품B', '제품C', '제품D']\nsales = [350, 280, 420, 310]\n\nplt.barh(products, sales, color=['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A'])\nplt.xlabel('판매량')\nplt.title('제품별 판매량')\nplt.tight_layout()\nplt.show()\n```"
      },
      {
        "type": "best-practice",
        "title": "시각화 모범 사례",
        "content": "**1. 적절한 차트 선택**\n- 시계열: 선 그래프\n- 비교: 막대 그래프\n- 분포: 히스토그램\n- 관계: 산점도\n\n**2. 색상 사용**\n```python\n# 색맹 친화적 색상\ncolors = ['#0173B2', '#DE8F05', '#029E73']\n```\n\n**3. 레이블과 제목**\n```python\nplt.xlabel('X축 (단위)', fontsize=12)\nplt.ylabel('Y축 (단위)', fontsize=12)\nplt.title('명확한 제목', fontsize=14, fontweight='bold')\n```"
      },
      {
        "type": "common-mistake",
        "title": "흔한 실수",
        "content": "**1. plt.show() 누락**\n```python\n# Jupyter가 아닌 환경에서는 show() 필수\nplt.plot([1, 2, 3])\nplt.show()  # 필수!\n```\n\n**2. 한글 깨짐**\n```python\nimport matplotlib.pyplot as plt\nimport matplotlib.font_manager as fm\n\nplt.rcParams['font.family'] = 'Malgun Gothic'  # Windows\nplt.rcParams['axes.unicode_minus'] = False  # 마이너스 기호\n```"
      },
      {
        "type": "tip",
        "title": "고급 시각화 팁",
        "content": "**1. 스타일 적용**\n```python\nplt.style.use('seaborn-v0_8-darkgrid')\n# 또는\nplt.style.use('ggplot')\n```\n\n**2. 이미지 저장**\n```python\nplt.savefig('chart.png', dpi=300, bbox_inches='tight')\n```\n\n**3. 애니메이션**\n```python\nfrom matplotlib.animation import FuncAnimation\n\nfig, ax = plt.subplots()\nline, = ax.plot([], [])\n\ndef update(frame):\n    line.set_data(range(frame), range(frame))\n    return line,\n\nanim = FuncAnimation(fig, update, frames=100, interval=50)\n```"
      },
      {
        "type": "practice",
        "title": "연습 문제",
        "content": "**문제 1: 선 그래프**\n1-10까지 숫자와 그 제곱을 선 그래프로 그리세요.\n\n**문제 2: 막대 그래프**\n과일별 판매량을 막대 그래프로 표시하세요.\n```python\nfruits = ['사과', '바나나', '오렌지', '포도']\nsales = [150, 200, 120, 180]\n```\n\n**문제 3: 산점도**\n키와 몸무게의 관계를 산점도로 그리세요.\n\n**문제 4: 서브플롯**\n2x2 서브플롯에 선, 막대, 산점도, 히스토그램을 그리세요."
      }
    ]
  },
  "02_python-data/numpy": {
    "id": "02_python-data/numpy",
    "title": "Numpy",
    "category": "ai-roadmap",
    "subCategory": "02_python-data",
    "language": "Python",
    "description": "NumPy 소개 및 데이터 처리의 중요성을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "NumPy 소개",
        "content": "NumPy(Numerical Python)는 Python 과학 계산의 핵심 라이브러리입니다.\n\n**NumPy가 중요한 이유:**\n- 빠른 배열 연산 (C언어 수준 성능)\n- 메모리 효율적 데이터 구조\n- 다른 라이브러리의 기반 (Pandas, scikit-learn, TensorFlow)\n- 선형대수, 통계, 난수 생성 기능\n\n**주요 학습 내용:**\n1. NumPy Basics: 배열 생성, 인덱싱, 연산\n2. NumPy Operations: 브로드캐스팅, 선형대수, 집계\n\n**다음 단계:**\n- Pandas: 표 형태 데이터 처리\n- Matplotlib: 데이터 시각화\n- OpenCV: 이미지 처리 (NumPy 배열 활용)"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "import numpy as np\n\n# NumPy 기본 예시\narr = np.array([1, 2, 3, 4, 5])\nprint(f\"배열: {arr}\")\nprint(f\"타입: {arr.dtype}\")\nprint(f\"Shape: {arr.shape}\")\n\n# 2D 배열\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\nprint(f\"\\n행렬:\\n{matrix}\")\nprint(f\"Shape: {matrix.shape}\")\n\n# 기본 연산\nprint(f\"\\n배열 + 10: {arr + 10}\")\nprint(f\"배열 * 2: {arr * 2}\")\nprint(f\"배열 제곱: {arr ** 2}\")\n\n# 통계\nprint(f\"\\n평균: {arr.mean()}\")\nprint(f\"합계: {arr.sum()}\")\nprint(f\"최댓값: {arr.max()}\")\n\n# 난수 생성\nrandom_arr = np.random.rand(5)\nprint(f\"\\n난수 배열: {random_arr}\")"
      },
      {
        "type": "use-case",
        "title": "NumPy 활용 분야",
        "content": "**1. 데이터 분석**\n- Pandas DataFrame의 기반\n- 대용량 수치 데이터 처리\n- 통계 분석\n\n**2. 머신러닝**\n- 특징 행렬(Feature Matrix) 표현\n- 학습 데이터 전처리\n- 행렬 연산으로 모델 계산\n\n**3. 이미지 처리**\n- 이미지를 NumPy 배열로 표현\n- 픽셀 단위 조작\n- 필터링, 변환\n\n**4. 과학 계산**\n- 선형대수\n- 신호 처리\n- 시뮬레이션"
      },
      {
        "type": "best-practice",
        "title": "NumPy 학습 가이드",
        "content": "**학습 순서:**\n\n**1단계: 기본 (1-2일)**\n- 배열 생성 및 속성\n- 인덱싱과 슬라이싱\n- 기본 연산\n\n**2단계: 중급 (3-5일)**\n- 브로드캐스팅\n- 집계 함수\n- 배열 형태 변경\n\n**3단계: 고급 (1주)**\n- 선형대수\n- 유니버설 함수\n- 고급 인덱싱\n\n**실습 팁:**\n- 매일 코딩 연습\n- 실제 데이터셋으로 실습\n- Pandas, Matplotlib과 함께 활용"
      },
      {
        "type": "common-mistake",
        "title": "초보자 주의사항",
        "content": "**1. 배열 vs 리스트**\nNumPy 배열은 Python 리스트와 다릅니다:\n- 모든 요소가 같은 타입\n- 크기 고정\n- 훨씬 빠른 연산\n\n**2. 복사 vs 뷰**\n슬라이싱은 뷰를 반환합니다:\n```python\narr = np.array([1, 2, 3])\nslice_arr = arr[1:3]  # 뷰\nslice_arr[0] = 999  # 원본도 변경됨!\n\n# 복사본 생성\ncopy_arr = arr[1:3].copy()\n```\n\n**3. 차원 이해**\n- 1D: 벡터 (shape: (n,))\n- 2D: 행렬 (shape: (m, n))\n- 3D 이상: 텐서"
      },
      {
        "type": "tip",
        "title": "효율적인 학습 팁",
        "content": "**1. Jupyter Notebook 활용**\n대화형 환경에서 즉시 결과 확인\n\n**2. 공식 문서 참고**\nhttps://numpy.org/doc/stable/\n\n**3. 실전 프로젝트**\n- CSV 데이터 분석\n- 이미지 처리\n- 통계 분석\n\n**4. 타 라이브러리와 결합**\n- NumPy + Pandas: 데이터 분석\n- NumPy + Matplotlib: 시각화\n- NumPy + scikit-learn: 머신러닝"
      },
      {
        "type": "practice",
        "title": "다음 단계",
        "content": "**완료한 학습:**\n✅ NumPy Basics: 배열 생성, 인덱싱\n✅ NumPy Operations: 브로드캐스팅, 선형대수\n\n**계속 학습:**\n1. **Pandas DataFrame**: 표 형태 데이터 처리\n2. **Pandas Analysis**: 그룹화, 피벗, 병합\n3. **Matplotlib**: 데이터 시각화\n\n**추천 실습:**\n- Kaggle 데이터셋으로 분석 프로젝트\n- NumPy로 간단한 알고리즘 구현\n- 이미지 필터링 프로젝트\n\n**다음 섹션:**\n- Python OpenCV: 이미지 처리\n- Python Web Scraping: 데이터 수집\n- Python AI Libraries: 머신러닝"
      }
    ]
  },
  "03_python-opencv/01_image_read": {
    "id": "03_python-opencv/01_image_read",
    "title": "01 Image Read",
    "category": "ai-roadmap",
    "subCategory": "03_python-opencv",
    "language": "Python",
    "description": "OpenCV로 이미지를 읽고 저장하는 방법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "이미지 읽기와 저장의 핵심 개념",
        "content": "OpenCV(Open Source Computer Vision Library)는 컴퓨터 비전 작업을 위한 강력한 라이브러리입니다. 이미지는 픽셀(화소)들의 2차원 또는 3차원 배열로 표현되며, 각 픽셀은 색상 정보를 담고 있습니다. OpenCV는 이미지를 NumPy 배열로 다루며, 이를 통해 효율적인 수치 연산이 가능합니다. 왜 OpenCV를 사용할까요? 이미지 처리는 단순히 파일을 여는 것이 아니라 픽셀 단위의 수학적 연산이 필요하기 때문입니다. 예를 들어, 얼굴 인식 시스템은 수천 개의 이미지를 초당 처리해야 하고, 의료 영상 분석은 MRI 이미지의 각 픽셀을 정밀하게 분석해야 합니다. OpenCV는 BGR(Blue-Green-Red) 색상 순서를 사용하는데, 이는 역사적인 이유로 카메라 하드웨어의 표준 방식이었기 때문입니다. 일반적인 RGB 순서와 다르므로 주의가 필요합니다. 이미지 읽기는 파일 시스템에서 이미지 데이터를 메모리로 로드하고 이를 조작 가능한 배열 형태로 변환하는 과정입니다."
      },
      {
        "type": "code",
        "language": "Python",
        "title": "이미지 읽기와 저장 완전 가이드",
        "code": "import cv2\nimport numpy as np\nimport os\n\n# 1. 기본 이미지 읽기\n# imread() 함수로 이미지를 NumPy 배열로 읽어옵니다\nimage = cv2.imread('sample.jpg')\n\n# 이미지가 제대로 로드되었는지 확인 (매우 중요!)\nif image is None:\n    print(\"오류: 이미지를 읽을 수 없습니다. 경로를 확인하세요.\")\nelse:\n    print(f\"이미지 shape: {image.shape}\")  # (높이, 너비, 채널수)\n    print(f\"데이터 타입: {image.dtype}\")   # uint8 (0-255)\n    print(f\"이미지 크기: {image.size} 픽셀\") # 전체 픽셀 수\n\n# 2. 다양한 읽기 모드\n# 컬러 이미지로 읽기 (기본값, BGR 순서)\ncolor_image = cv2.imread('sample.jpg', cv2.IMREAD_COLOR)\n\n# 그레이스케일로 읽기 (흑백, 채널 1개)\ngray_image = cv2.imread('sample.jpg', cv2.IMREAD_GRAYSCALE)\n\n# 알파 채널 포함 읽기 (투명도 정보 포함, BGRA)\nalpha_image = cv2.imread('sample.png', cv2.IMREAD_UNCHANGED)\n\n# 3. 절대 경로와 상대 경로 처리\n# 상대 경로: 현재 작업 디렉토리 기준\nrel_path_image = cv2.imread('./images/photo.jpg')\n\n# 절대 경로: 전체 경로 지정 (권장)\nabs_path = os.path.abspath('images/photo.jpg')\nabs_path_image = cv2.imread(abs_path)\n\n# 4. 이미지 저장\n# imwrite()로 다양한 형식으로 저장 가능\nsuccess = cv2.imwrite('output.jpg', image)\nif success:\n    print(\"이미지 저장 성공!\")\n\n# JPEG 품질 조절 (0-100, 높을수록 고품질)\ncv2.imwrite('high_quality.jpg', image, [cv2.IMWRITE_JPEG_QUALITY, 95])\n\n# PNG 압축 레벨 조절 (0-9, 높을수록 작은 파일)\ncv2.imwrite('compressed.png', image, [cv2.IMWRITE_PNG_COMPRESSION, 9])\n\n# 5. 실전 예제: 안전한 이미지 읽기 함수\ndef safe_read_image(file_path, mode=cv2.IMREAD_COLOR):\n    \"\"\"이미지를 안전하게 읽는 함수\"\"\"\n    # 파일 존재 확인\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"파일을 찾을 수 없음: {file_path}\")\n    \n    # 이미지 읽기\n    img = cv2.imread(file_path, mode)\n    \n    # 읽기 실패 확인\n    if img is None:\n        raise ValueError(f\"이미지 읽기 실패: {file_path}\")\n    \n    return img\n\n# 사용 예시\ntry:\n    my_image = safe_read_image('photo.jpg')\n    print(f\"이미지 로드 성공: {my_image.shape}\")\nexcept Exception as e:\n    print(f\"오류 발생: {e}\")"
      },
      {
        "type": "use-case",
        "title": "실무 활용 사례",
        "content": "**1. CCTV 보안 시스템**: 편의점이나 은행의 CCTV 시스템은 초당 30프레임의 영상을 실시간으로 읽어들이고, 의심스러운 행동이나 얼굴을 감지합니다. cv2.imread()로 저장된 프레임을 불러와 분석하고, 이상 탐지 시 해당 프레임을 고해상도로 저장합니다. 예를 들어, 야간에 침입자가 감지되면 해당 이미지를 PNG 형식으로 무손실 저장하여 증거로 활용합니다.\n\n**2. 의료 영상 분석**: 병원에서는 X-ray, CT, MRI 이미지를 OpenCV로 읽어 분석합니다. 폐렴 진단 AI는 수천 장의 흉부 X-ray 이미지를 그레이스케일로 읽어 병변을 탐지합니다. DICOM 형식의 의료 영상을 16비트 그레이스케일로 읽어 미세한 조직 변화까지 감지할 수 있습니다. 진단 결과는 원본 이미지에 주석을 추가하여 고품질 JPEG로 저장됩니다.\n\n**3. 제조업 품질 관리**: 삼성전자나 현대자동차 같은 제조업체는 생산 라인에서 제품 이미지를 실시간으로 촬영하고 분석합니다. 스마트폰 화면의 미세한 흠집, 자동차 도장의 불량을 검출하기 위해 초고해상도 이미지를 읽어 픽셀 단위로 검사합니다. 불량품 이미지는 자동으로 분류되어 저장되며, 이를 통해 품질 관리 데이터베이스를 구축합니다.\n\n**4. 얼굴 인식 출입 시스템**: 스마트 오피스의 출입 시스템은 카메라로 촬영한 얼굴 이미지를 실시간으로 읽어 등록된 직원 데이터베이스와 비교합니다. 조명이 어두운 환경에서도 정확한 인식을 위해 이미지를 여러 모드로 읽고 전처리합니다. 출입 기록은 타임스탬프와 함께 이미지로 저장되어 보안 로그로 활용됩니다."
      },
      {
        "type": "best-practice",
        "title": "좋은 코드 vs 나쁜 코드",
        "content": "**나쁜 예 ❌ - 에러 처리 없음**\n```python\nimage = cv2.imread('photo.jpg')\nheight, width = image.shape[:2]  # image가 None이면 즉시 에러!\nprint(f\"크기: {width}x{height}\")\n```\n문제점: 파일이 없거나 손상되면 프로그램이 즉시 중단됩니다. 실무에서는 치명적인 버그가 됩니다.\n\n**좋은 예 ✅ - 완벽한 에러 처리**\n```python\nimport os\n\ndef load_image_safely(path):\n    # 1단계: 파일 존재 확인\n    if not os.path.exists(path):\n        print(f\"오류: '{path}' 파일이 존재하지 않습니다.\")\n        return None\n    \n    # 2단계: 이미지 읽기\n    image = cv2.imread(path)\n    \n    # 3단계: 읽기 결과 검증\n    if image is None:\n        print(f\"오류: '{path}' 이미지 형식이 지원되지 않습니다.\")\n        return None\n    \n    return image\n\nimage = load_image_safely('photo.jpg')\nif image is not None:\n    height, width = image.shape[:2]\n    print(f\"크기: {width}x{height}\")\n```\n장점: 모든 예외 상황을 처리하여 안정적으로 동작합니다.\n\n**나쁜 예 ❌ - 하드코딩된 경로**\n```python\nimage = cv2.imread('C:\\\\Users\\\\John\\\\photo.jpg')\n```\n문제점: 다른 컴퓨터에서는 동작하지 않습니다. 경로가 변경되면 코드를 수정해야 합니다.\n\n**좋은 예 ✅ - 유연한 경로 관리**\n```python\nimport os\n\n# 프로젝트 루트 디렉토리 기준 상대 경로\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\nimage_path = os.path.join(BASE_DIR, 'images', 'photo.jpg')\nimage = cv2.imread(image_path)\n```\n장점: 어떤 환경에서도 동작하며 유지보수가 쉽습니다."
      },
      {
        "type": "common-mistake",
        "title": "흔한 실수와 해결법",
        "content": "**실수 1: None 체크를 하지 않음**\n```python\n# 잘못된 코드\nimg = cv2.imread('nonexistent.jpg')\nprint(img.shape)  # AttributeError: 'NoneType' has no attribute 'shape'\n\n# 올바른 코드\nimg = cv2.imread('nonexistent.jpg')\nif img is not None:\n    print(img.shape)\nelse:\n    print(\"이미지를 불러올 수 없습니다.\")\n```\n**왜 이런 실수를 할까?** imread()는 실패 시 예외를 발생시키지 않고 None을 반환하기 때문에 초보자들이 자주 놓칩니다. 항상 None 체크를 습관화하세요.\n\n**실수 2: BGR과 RGB 혼동**\n```python\n# 잘못된 코드 - 색상이 이상하게 보임\nimport matplotlib.pyplot as plt\nimg = cv2.imread('photo.jpg')  # BGR로 읽음\nplt.imshow(img)  # matplotlib는 RGB를 기대함\nplt.show()  # 빨강과 파랑이 바뀌어 보임!\n\n# 올바른 코드\nimg_bgr = cv2.imread('photo.jpg')\nimg_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)\nplt.imshow(img_rgb)\nplt.show()\n```\n**왜 중요한가?** OpenCV는 BGR을 사용하지만 대부분의 라이브러리(PIL, matplotlib)는 RGB를 사용합니다. 변환 없이 사용하면 색상이 왜곡됩니다.\n\n**실수 3: 한글 경로 처리 오류**\n```python\n# 잘못된 코드 - 한글 경로에서 None 반환\nimg = cv2.imread('C:/사진/이미지.jpg')  # 한글 경로 인식 못함\n\n# 올바른 코드 - numpy를 이용한 우회 방법\nimport numpy as np\nfrom PIL import Image\n\n# 방법 1: PIL을 거쳐서 읽기\nimg_pil = Image.open('C:/사진/이미지.jpg')\nimg = cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR)\n\n# 방법 2: numpy로 직접 읽기\nimg_array = np.fromfile('C:/사진/이미지.jpg', np.uint8)\nimg = cv2.imdecode(img_array, cv2.IMREAD_COLOR)\n```\n**왜 발생하나?** OpenCV의 C++ 백엔드가 유니코드 경로를 제대로 처리하지 못하기 때문입니다. 한글, 일본어, 중국어 경로 사용 시 반드시 우회 방법을 사용하세요.\n\n**실수 4: 이미지 저장 실패 무시**\n```python\n# 잘못된 코드\ncv2.imwrite('/root/protected/image.jpg', img)  # 권한 없는 경로\n# 저장 실패해도 아무 알림 없음!\n\n# 올바른 코드\nsuccess = cv2.imwrite('output.jpg', img)\nif not success:\n    print(\"오류: 이미지 저장 실패! 경로와 권한을 확인하세요.\")\nelse:\n    print(\"이미지 저장 완료\")\n```\n**핵심 교훈**: imwrite()의 반환값을 항상 확인하여 저장 성공 여부를 검증하세요."
      },
      {
        "type": "practice",
        "title": "실습 문제",
        "content": "**기초 문제**\n1. 'test.jpg' 이미지를 읽어서 높이, 너비, 채널 수를 출력하는 코드를 작성하세요.\n2. 컬러 이미지를 그레이스케일로 읽어서 'gray.jpg'로 저장하세요.\n3. 이미지가 존재하지 않을 때 \"파일을 찾을 수 없습니다\"를 출력하는 안전한 읽기 함수를 만드세요.\n\n**중급 문제**\n4. 현재 디렉토리의 모든 JPG 이미지를 읽어 PNG 형식으로 변환하여 저장하는 프로그램을 작성하세요.\n5. 이미지를 읽어 픽셀 값의 평균, 최댓값, 최솟값을 계산하여 출력하세요.\n6. 5MB 이상의 이미지를 읽을 때는 JPEG 품질 70으로 압축하여 저장하는 함수를 만드세요.\n\n**고급 문제**\n7. 여러 이미지 파일을 입력받아 동시에 읽고, 읽기에 실패한 파일 목록을 반환하는 함수를 작성하세요.\n8. 한글 경로의 이미지를 안전하게 읽고 저장하는 범용 함수를 구현하세요.\n9. 이미지를 읽을 때 메타데이터(촬영 날짜, 카메라 정보)를 함께 추출하여 딕셔너리로 반환하는 함수를 만드세요. (힌트: PIL 라이브러리 활용)\n10. 대용량 이미지 폴더(1000장 이상)를 효율적으로 읽어 썸네일(가로 200px)을 생성하고, 원본 대비 저장 공간 절약률을 계산하는 프로그램을 작성하세요."
      },
      {
        "type": "tip",
        "title": "실무 팁",
        "content": "💡 **성능 최적화**: 같은 이미지를 반복해서 읽는다면 메모리에 캐싱하세요. 디스크 I/O는 매우 느립니다.\n\n💡 **형식 선택 가이드**: JPEG는 손실 압축으로 파일 크기가 작지만 품질이 저하됩니다. PNG는 무손실이지만 파일이 큽니다. 사진은 JPEG, 다이어그램이나 텍스트는 PNG가 적합합니다.\n\n💡 **대용량 이미지 처리**: 수십 MB의 고해상도 이미지는 cv2.resize()로 축소한 후 처리하면 속도가 10배 이상 빨라집니다. 필요한 경우에만 원본 크기로 작업하세요.\n\n💡 **경로 문제 디버깅**: os.getcwd()로 현재 작업 디렉토리를 확인하고, os.path.abspath()로 절대 경로를 출력하여 경로 문제를 빠르게 해결하세요.\n\n💡 **메모리 관리**: 큰 이미지를 다룰 때는 사용 후 del image로 명시적으로 메모리를 해제하세요. Python의 가비지 컬렉터가 즉시 동작하지 않을 수 있습니다."
      }
    ]
  },
  "03_python-opencv/02_image_transform": {
    "id": "03_python-opencv/02_image_transform",
    "title": "02 Image Transform",
    "category": "ai-roadmap",
    "subCategory": "03_python-opencv",
    "language": "Python",
    "description": "OpenCV로 이미지를 변형(리사이징, 회전, 크롭, 뒤집기)하는 방법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "이미지 변형의 핵심 개념",
        "content": "이미지 변형(Image Transformation)은 이미지의 크기, 각도, 위치를 변경하는 핵심 기술입니다. 왜 이미지 변형이 필요할까요? 딥러닝 모델은 고정된 입력 크기를 요구하기 때문에 다양한 크기의 이미지를 표준화해야 합니다. 또한 얼굴 인식 시스템은 기울어진 얼굴을 바로잡아야 정확도가 향상됩니다. 이미지 변형에는 크게 두 가지 유형이 있습니다. 기하학적 변형(Geometric Transformation)은 픽셀의 위치를 변경하지만 색상 값은 유지하며, 보간법(Interpolation)을 통해 새로운 픽셀 값을 계산합니다. cv2.resize()는 이미지 크기를 조절하고, cv2.rotate()는 90도 단위 회전, cv2.warpAffine()은 임의 각도 회전과 이동을 수행합니다. 리사이징 시 보간법은 매우 중요합니다. INTER_NEAREST는 가장 빠르지만 품질이 낮고, INTER_LINEAR는 균형잡힌 선택, INTER_CUBIC은 고품질이지만 느립니다. 실무에서는 이미지 확대 시 INTER_CUBIC, 축소 시 INTER_AREA를 주로 사용합니다. 종횡비(aspect ratio)를 유지하지 않으면 이미지가 왜곡되므로 주의가 필요합니다."
      },
      {
        "type": "code",
        "language": "Python",
        "title": "이미지 변형 완전 가이드",
        "code": "import cv2\nimport numpy as np\n\n# 이미지 읽기\nimage = cv2.imread('sample.jpg')\nheight, width = image.shape[:2]\nprint(f\"원본 크기: {width}x{height}\")\n\n# 1. 이미지 리사이징 (크기 조절)\n# 방법 1: 절대 크기 지정\nresized_absolute = cv2.resize(image, (800, 600))  # (너비, 높이)\n\n# 방법 2: 비율로 지정 (종횡비 유지)\nscale_percent = 50  # 50%로 축소\nnew_width = int(width * scale_percent / 100)\nnew_height = int(height * scale_percent / 100)\nresized_ratio = cv2.resize(image, (new_width, new_height))\n\n# 방법 3: 종횡비 유지하며 최대 너비 맞추기\nmax_width = 1000\nif width > max_width:\n    ratio = max_width / width\n    new_size = (max_width, int(height * ratio))\n    resized_fit = cv2.resize(image, new_size, interpolation=cv2.INTER_AREA)\nelse:\n    resized_fit = image\n\n# 보간법 비교\nenlarged_nearest = cv2.resize(image, (width*2, height*2), interpolation=cv2.INTER_NEAREST)  # 빠름, 저품질\nenlarged_linear = cv2.resize(image, (width*2, height*2), interpolation=cv2.INTER_LINEAR)    # 기본값\nenlarged_cubic = cv2.resize(image, (width*2, height*2), interpolation=cv2.INTER_CUBIC)      # 고품질\nshrunken_area = cv2.resize(image, (width//2, height//2), interpolation=cv2.INTER_AREA)      # 축소 최적화\n\n# 2. 이미지 회전\n# 방법 1: 90도 단위 빠른 회전\nrotated_90_cw = cv2.rotate(image, cv2.ROTATE_90_CLOCKWISE)        # 시계방향 90도\nrotated_90_ccw = cv2.rotate(image, cv2.ROTATE_90_COUNTERCLOCKWISE) # 반시계방향 90도\nrotated_180 = cv2.rotate(image, cv2.ROTATE_180)                    # 180도\n\n# 방법 2: 임의 각도 회전 (중심 기준)\nangle = 45  # 반시계방향 45도\ncenter = (width // 2, height // 2)  # 회전 중심점\n\n# 회전 행렬 생성 (scale=1.0은 크기 유지)\nrotation_matrix = cv2.getRotationMatrix2D(center, angle, scale=1.0)\n\n# 회전 적용 (잘림 없이 전체 이미지 보존)\ncos = np.abs(rotation_matrix[0, 0])\nsin = np.abs(rotation_matrix[0, 1])\nnew_width = int((height * sin) + (width * cos))\nnew_height = int((height * cos) + (width * sin))\nrotation_matrix[0, 2] += (new_width / 2) - center[0]\nrotation_matrix[1, 2] += (new_height / 2) - center[1]\n\nrotated_custom = cv2.warpAffine(image, rotation_matrix, (new_width, new_height))\n\n# 3. 이미지 크롭 (잘라내기)\n# NumPy 슬라이싱 사용: image[y1:y2, x1:x2]\nx, y, w, h = 100, 100, 300, 200  # 시작점(x,y)과 크기(w,h)\ncropped = image[y:y+h, x:x+w]\n\n# 중앙 크롭 (정사각형)\ncrop_size = 500\nstart_x = (width - crop_size) // 2\nstart_y = (height - crop_size) // 2\ncenter_cropped = image[start_y:start_y+crop_size, start_x:start_x+crop_size]\n\n# 4. 이미지 뒤집기 (Flip)\nflipped_horizontal = cv2.flip(image, 1)   # 좌우 반전\nflipped_vertical = cv2.flip(image, 0)     # 상하 반전\nflipped_both = cv2.flip(image, -1)        # 좌우+상하 반전\n\n# 5. 실전 예제: 썸네일 생성 함수\ndef create_thumbnail(img, max_size=200, maintain_ratio=True):\n    \"\"\"이미지를 썸네일로 변환 (종횡비 유지)\"\"\"\n    h, w = img.shape[:2]\n    \n    if maintain_ratio:\n        # 긴 쪽을 max_size에 맞춤\n        if w > h:\n            new_w = max_size\n            new_h = int(h * (max_size / w))\n        else:\n            new_h = max_size\n            new_w = int(w * (max_size / h))\n    else:\n        new_w = new_h = max_size\n    \n    # 축소이므로 INTER_AREA 사용\n    thumbnail = cv2.resize(img, (new_w, new_h), interpolation=cv2.INTER_AREA)\n    return thumbnail\n\n# 사용 예시\nthumb = create_thumbnail(image, max_size=150)\nprint(f\"썸네일 크기: {thumb.shape[1]}x{thumb.shape[0]}\")"
      },
      {
        "type": "use-case",
        "title": "실무 활용 사례",
        "content": "**1. 인스타그램 이미지 처리**: 인스타그램에 사진을 업로드하면 자동으로 여러 크기의 썸네일이 생성됩니다. 피드용(1080x1080), 프로필용(150x150), 스토리용(1080x1920) 등 다양한 비율로 리사이징됩니다. cv2.resize()를 사용해 원본 이미지를 각 포맷에 맞게 변환하고, INTER_AREA 보간법으로 선명도를 유지합니다. 사용자가 이미지를 회전하거나 크롭하는 편집 기능도 모두 OpenCV 변형 함수로 구현됩니다.\n\n**2. 문서 스캔 앱 (CamScanner)**: 스마트폰으로 문서를 촬영하면 기울어진 각도를 자동 보정합니다. cv2.warpAffine()으로 문서를 정면으로 회전시키고, 원근 변환(cv2.warpPerspective)으로 왜곡을 제거합니다. 그 후 A4 비율(210:297)로 크롭하고 리사이징하여 표준 문서 형식으로 변환합니다. 이를 통해 비스듬하게 찍은 사진도 스캔한 것처럼 깔끔하게 보정됩니다.\n\n**3. 얼굴 인식 시스템 전처리**: 출입 통제 시스템이나 스마트폰 잠금해제는 다양한 각도에서 촬영된 얼굴을 인식해야 합니다. 먼저 얼굴 영역을 detection하고 눈 좌표를 기준으로 얼굴을 회전시켜 정면으로 맞춥니다. 그 후 224x224 크기로 리사이징하여 딥러닝 모델에 입력합니다. 이 전처리 과정 없이는 인식 정확도가 30% 이상 떨어집니다.\n\n**4. 의료 영상 정규화**: MRI나 CT 이미지는 촬영 장비마다 해상도가 다릅니다. 딥러닝 기반 질병 진단 모델에 입력하기 전에 모든 이미지를 512x512로 표준화합니다. INTER_CUBIC 보간법을 사용해 의료 영상의 미세한 조직 정보를 최대한 보존하며, 회전 변형으로 데이터 증강(augmentation)을 수행해 학습 데이터를 10배 이상 확장합니다."
      },
      {
        "type": "best-practice",
        "title": "좋은 코드 vs 나쁜 코드",
        "content": "**나쁜 예 ❌ - 종횡비 무시한 리사이징**\n```python\nresized = cv2.resize(image, (500, 500))  # 강제로 정사각형으로 만듦\n# 문제: 원본이 16:9 비율이면 이미지가 찌그러짐\n```\n\n**좋은 예 ✅ - 종횡비 유지 리사이징**\n```python\ndef resize_keep_aspect_ratio(img, target_width):\n    h, w = img.shape[:2]\n    ratio = target_width / w\n    target_height = int(h * ratio)\n    return cv2.resize(img, (target_width, target_height))\n\nresized = resize_keep_aspect_ratio(image, 500)\n# 비율이 유지되어 자연스러움\n```\n\n**나쁜 예 ❌ - 회전 시 이미지 잘림**\n```python\ncenter = (width//2, height//2)\nM = cv2.getRotationMatrix2D(center, 45, 1.0)\nrotated = cv2.warpAffine(image, M, (width, height))\n# 문제: 모서리가 잘려나감\n```\n\n**좋은 예 ✅ - 잘림 없는 회전**\n```python\ndef rotate_no_crop(img, angle):\n    h, w = img.shape[:2]\n    center = (w//2, h//2)\n    M = cv2.getRotationMatrix2D(center, angle, 1.0)\n    \n    # 회전 후 필요한 캔버스 크기 계산\n    cos = np.abs(M[0, 0])\n    sin = np.abs(M[0, 1])\n    new_w = int((h * sin) + (w * cos))\n    new_h = int((h * cos) + (w * sin))\n    \n    # 이동 보정\n    M[0, 2] += (new_w / 2) - center[0]\n    M[1, 2] += (new_h / 2) - center[1]\n    \n    return cv2.warpAffine(img, M, (new_w, new_h))\n\nrotated = rotate_no_crop(image, 45)\n# 전체 이미지가 보존됨\n```\n\n**나쁜 예 ❌ - 잘못된 보간법 선택**\n```python\n# 이미지를 2배 확대\nenlarged = cv2.resize(image, (width*2, height*2), interpolation=cv2.INTER_NEAREST)\n# 문제: 픽셀이 깨져보임 (계단 현상)\n```\n\n**좋은 예 ✅ - 상황별 최적 보간법**\n```python\n# 확대 시: INTER_CUBIC (고품질)\nenlarged = cv2.resize(image, (width*2, height*2), interpolation=cv2.INTER_CUBIC)\n\n# 축소 시: INTER_AREA (선명도 유지)\nshrunken = cv2.resize(image, (width//2, height//2), interpolation=cv2.INTER_AREA)\n```"
      },
      {
        "type": "common-mistake",
        "title": "흔한 실수와 해결법",
        "content": "**실수 1: resize()의 (너비, 높이) 순서 혼동**\n```python\n# 잘못된 코드\nheight, width = image.shape[:2]\nresized = cv2.resize(image, (height, width))  # 순서가 바뀜!\n\n# 올바른 코드\nresized = cv2.resize(image, (width, height))  # (너비, 높이) 순서\n```\n**왜 혼동할까?** image.shape는 (높이, 너비, 채널)이지만 resize()는 (너비, 높이)를 받습니다. 항상 (가로, 세로) 순서임을 기억하세요.\n\n**실수 2: 크롭 후 빈 이미지**\n```python\n# 잘못된 코드\nx, y, w, h = 100, 100, 5000, 3000  # 이미지 범위를 벗어남\ncropped = image[y:y+h, x:x+w]  # 빈 배열 또는 에러\n\n# 올바른 코드\nimg_h, img_w = image.shape[:2]\nx = max(0, min(x, img_w - 1))\ny = max(0, min(y, img_h - 1))\nw = min(w, img_w - x)\nh = min(h, img_h - y)\ncropped = image[y:y+h, x:x+w]\n```\n**핵심 교훈**: 크롭 범위가 이미지 경계를 벗어나지 않도록 항상 검증하세요.\n\n**실수 3: 회전 각도 방향 오해**\n```python\n# OpenCV는 반시계방향이 양수\nrotated = cv2.getRotationMatrix2D(center, 45, 1.0)  # 반시계 45도\n\n# 시계방향으로 회전하려면 음수 사용\nrotated_cw = cv2.getRotationMatrix2D(center, -45, 1.0)  # 시계 45도\n```\n**주의점**: 수학적 관례를 따라 반시계방향이 양수입니다. 직관과 반대일 수 있으니 주의하세요.\n\n**실수 4: 리사이징 후 데이터 타입 변경**\n```python\n# 잘못된 코드\nresized = cv2.resize(image, (800, 600))\nprocessed = resized * 2  # 오버플로우 발생!\n\n# 올바른 코드\nresized = cv2.resize(image, (800, 600))\nresized_float = resized.astype(np.float32)  # float으로 변환\nprocessed = np.clip(resized_float * 2, 0, 255).astype(np.uint8)\n```\n**왜 발생하나?** uint8 타입은 0-255 범위만 표현 가능합니다. 연산 전 float으로 변환하고 후처리 시 클리핑하세요."
      },
      {
        "type": "practice",
        "title": "실습 문제",
        "content": "**기초 문제**\n1. 이미지를 원본의 50% 크기로 축소하는 코드를 작성하세요.\n2. 이미지를 시계방향으로 90도 회전하여 저장하세요.\n3. 이미지의 중앙 200x200 영역을 크롭하여 저장하세요.\n\n**중급 문제**\n4. 이미지의 긴 쪽이 1000px을 넘지 않도록 종횡비를 유지하며 리사이징하는 함수를 작성하세요.\n5. 이미지를 반시계방향으로 30도 회전하되, 이미지가 잘리지 않도록 캔버스 크기를 자동 조절하세요.\n6. 이미지를 좌우 반전한 후 상하 반전하는 과정을 하나의 함수로 구현하세요.\n\n**고급 문제**\n7. 폴더의 모든 이미지를 읽어 정사각형 썸네일(300x300)로 만들되, 종횡비를 유지하고 부족한 부분은 검은색 패딩으로 채우는 프로그램을 작성하세요.\n8. 이미지를 15도씩 회전하며 24장의 이미지를 생성하여 데이터 증강을 수행하는 함수를 만드세요.\n9. 얼굴 사진에서 두 눈의 좌표를 입력받아 얼굴을 수평으로 맞추는 자동 회전 보정 함수를 구현하세요. (힌트: 두 눈 사이의 각도 계산)\n10. 이미지 피라미드를 생성하는 함수를 작성하세요. 원본 이미지를 시작으로 50%씩 축소하여 최소 크기가 64x64 이하가 될 때까지 리스트에 저장하세요."
      },
      {
        "type": "tip",
        "title": "실무 팁",
        "content": "💡 **성능 최적화**: 대량의 이미지를 리사이징할 때는 멀티프로세싱을 활용하세요. cv2.resize()는 GIL(Global Interpreter Lock)의 영향을 적게 받아 병렬 처리 시 4-8배 속도 향상이 가능합니다.\n\n💡 **품질 vs 속도**: 실시간 처리(30fps 이상)가 필요하면 INTER_NEAREST나 INTER_LINEAR를 사용하세요. 오프라인 배치 처리는 INTER_CUBIC이 적합합니다.\n\n💡 **메모리 효율**: 회전이나 리사이징 시 원본 이미지를 덮어쓰지 말고 새 변수에 할당하세요. 실수로 원본을 손상시킬 수 있습니다.\n\n💡 **비율 계산 꿀팁**: 목표 크기를 먼저 정하고 ratio = target / original 공식을 사용하면 비율 계산이 간단합니다.\n\n💡 **데이터 증강**: 머신러닝 학습 데이터가 부족하면 회전, 뒤집기, 크롭을 조합해 데이터를 5-10배 증강할 수 있습니다. 단, 너무 과도한 변형은 오히려 성능을 저하시킬 수 있으니 적절한 범위(회전 ±15도, 크롭 80-100%)를 유지하세요."
      }
    ]
  },
  "03_python-opencv/03_color_space": {
    "id": "03_python-opencv/03_color_space",
    "title": "03 Color Space",
    "category": "ai-roadmap",
    "subCategory": "03_python-opencv",
    "language": "Python",
    "description": "OpenCV로 다양한 색상 공간(RGB, HSV, Grayscale 등)을 변환하는 방법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "색상 공간의 핵심 개념",
        "content": "색상 공간(Color Space)은 색을 표현하는 수학적 모델입니다. 왜 다양한 색상 공간이 필요할까요? 각 색상 공간은 특정 작업에 최적화되어 있기 때문입니다. RGB는 디스플레이 표현에 적합하고, HSV는 색상 기반 객체 추적에 유용하며, LAB는 인간 시각과 유사한 색상 거리 계산이 가능합니다. OpenCV의 기본 색상 공간은 BGR(Blue-Green-Red)입니다. 역사적으로 카메라 센서가 BGR 순서를 사용했기 때문입니다. HSV(Hue-Saturation-Value)는 색상, 채도, 명도로 구성되어 조명 변화에 강건하므로 피부색 감지, 교통 신호 인식에 널리 사용됩니다. Hue는 0-180도 범위로 색상 자체를 나타내고(빨강 0도, 초록 60도, 파랑 120도), Saturation은 0-255로 색의 순도, Value는 0-255로 밝기를 의미합니다. Grayscale 변환은 컬러 정보를 제거하고 밝기만 남기는데, 연산량을 1/3로 줄여 실시간 처리 속도를 크게 향상시킵니다. cv2.cvtColor() 함수는 100가지 이상의 색상 변환을 지원하며, 내부적으로 최적화된 행렬 연산을 수행합니다."
      },
      {
        "type": "code",
        "language": "Python",
        "title": "색상 공간 변환 완전 가이드",
        "code": "import cv2\nimport numpy as np\n\n# 이미지 읽기 (OpenCV는 BGR로 읽음)\nimage = cv2.imread('sample.jpg')\nprint(f\"원본 shape: {image.shape}\")  # (높이, 너비, 3)\n\n# 1. BGR ↔ RGB 변환\n# OpenCV는 BGR, matplotlib/PIL은 RGB 사용\nimage_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\nprint(f\"RGB shape: {image_rgb.shape}\")\n\n# RGB → BGR 역변환\nimage_bgr = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2BGR)\n\n# 2. 그레이스케일 변환\n# 가중 평균 방식: Gray = 0.299*R + 0.587*G + 0.114*B\ngray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\nprint(f\"Grayscale shape: {gray.shape}\")  # (높이, 너비) - 채널 없음\n\n# 그레이스케일 → BGR (채널만 복사, 컬러는 아님)\ngray_bgr = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)\nprint(f\"Gray to BGR shape: {gray_bgr.shape}\")  # (높이, 너비, 3)\n\n# 3. HSV 변환 (색상 기반 필터링에 최적)\nhsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\nprint(f\"HSV shape: {hsv.shape}\")\n\n# HSV 채널 분리\nh, s, v = cv2.split(hsv)  # Hue(색상), Saturation(채도), Value(명도)\nprint(f\"Hue 범위: {h.min()}-{h.max()}\")  # 0-180\nprint(f\"Saturation 범위: {s.min()}-{s.max()}\")  # 0-255\nprint(f\"Value 범위: {v.min()}-{v.max()}\")  # 0-255\n\n# 4. 색상 범위 기반 객체 검출 (예: 빨간색 객체)\n# 빨간색은 HSV에서 0-10, 170-180 범위\nlower_red1 = np.array([0, 100, 100])\nupper_red1 = np.array([10, 255, 255])\nmask1 = cv2.inRange(hsv, lower_red1, upper_red1)\n\nlower_red2 = np.array([170, 100, 100])\nupper_red2 = np.array([180, 255, 255])\nmask2 = cv2.inRange(hsv, lower_red2, upper_red2)\n\n# 두 마스크 합치기\nred_mask = mask1 + mask2\nred_result = cv2.bitwise_and(image, image, mask=red_mask)\n\n# 5. LAB 색상 공간 (인간 시각과 유사)\nlab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\nl, a, b = cv2.split(lab)\nprint(f\"LAB L 범위: {l.min()}-{l.max()}\")  # 밝기: 0-255\nprint(f\"LAB A 범위: {a.min()}-{a.max()}\")  # 녹색-빨강: 0-255\nprint(f\"LAB B 범위: {b.min()}-{b.max()}\")  # 파랑-노랑: 0-255\n\n# 6. YCrCb 변환 (JPEG 압축에 사용)\nycrcb = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)\ny, cr, cb = cv2.split(ycrcb)\n\n# 7. 실전 예제: 피부색 검출\ndef detect_skin(img):\n    \"\"\"HSV와 YCrCb 조합으로 피부색 영역 검출\"\"\"\n    # HSV 기반 피부색 범위\n    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n    lower_hsv = np.array([0, 20, 70], dtype=np.uint8)\n    upper_hsv = np.array([20, 255, 255], dtype=np.uint8)\n    mask_hsv = cv2.inRange(hsv, lower_hsv, upper_hsv)\n    \n    # YCrCb 기반 피부색 범위\n    ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)\n    lower_ycrcb = np.array([0, 135, 85], dtype=np.uint8)\n    upper_ycrcb = np.array([255, 180, 135], dtype=np.uint8)\n    mask_ycrcb = cv2.inRange(ycrcb, lower_ycrcb, upper_ycrcb)\n    \n    # 두 마스크 결합 (AND 연산)\n    skin_mask = cv2.bitwise_and(mask_hsv, mask_ycrcb)\n    \n    # 노이즈 제거 (모폴로지 연산)\n    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))\n    skin_mask = cv2.morphologyEx(skin_mask, cv2.MORPH_CLOSE, kernel)\n    skin_mask = cv2.morphologyEx(skin_mask, cv2.MORPH_OPEN, kernel)\n    \n    # 결과 적용\n    skin = cv2.bitwise_and(img, img, mask=skin_mask)\n    return skin, skin_mask\n\n# 사용 예시\nskin_detected, mask = detect_skin(image)\nprint(f\"피부 영역 픽셀 수: {np.sum(mask > 0)}\")"
      },
      {
        "type": "use-case",
        "title": "실무 활용 사례",
        "content": "**1. 자율주행 차선 인식**: 자율주행 자동차는 도로의 노란색/흰색 차선을 실시간으로 감지해야 합니다. BGR 이미지를 HSV로 변환한 후, 흰색(H:0-180, S:0-30, V:200-255)과 노란색(H:20-30, S:100-255, V:100-255) 범위를 inRange()로 필터링합니다. 그림자나 조명 변화에도 차선을 안정적으로 추적할 수 있어 테슬라, 현대 같은 자동차 제조사가 사용하는 핵심 기술입니다.\n\n**2. 의료 영상 분석 - 혈관 검출**: 망막 이미지에서 혈관을 추출할 때 LAB 색상 공간을 사용합니다. LAB의 L 채널(밝기)만 추출하면 혈관의 명암 대비가 선명해집니다. 이를 CLAHE(Contrast Limited Adaptive Histogram Equalization)로 강화하여 당뇨병성 망막병증, 녹내장 진단에 활용합니다. RGB보다 40% 더 정확한 혈관 분할이 가능합니다.\n\n**3. 증강현실(AR) 마커 추적**: 포켓몬고 같은 AR 앱은 특정 색상의 마커를 인식하여 가상 객체를 배치합니다. 마커의 색상을 HSV로 변환하고 Hue 값만 비교하여 조명이 변해도 일관되게 추적합니다. 예를 들어 파란색 마커(H:100-130)를 설정하면 실내/실외 어디서든 90% 이상 정확도로 인식됩니다.\n\n**4. 제조업 불량 검사 - 색상 품질 관리**: 페인트 도장 라인에서 제품 색상이 기준 범위 내인지 검사합니다. 표준 샘플을 LAB 공간으로 변환하고 Delta E(색상 거리)를 계산합니다. Delta E < 2.3이면 육안으로 구별 불가능한 수준입니다. RGB는 인간 시각과 차이가 있지만 LAB는 시각적 색차를 정확히 수치화하여 품질 관리의 정확도를 2배 향상시킵니다."
      },
      {
        "type": "best-practice",
        "title": "좋은 코드 vs 나쁜 코드",
        "content": "**나쁜 예 ❌ - 직접 채널 교환**\n```python\n# BGR을 RGB로 변환하려고 수동으로 채널을 바꿈\nb, g, r = cv2.split(image)\nimage_rgb = cv2.merge([r, g, b])\n# 문제: 느리고 메모리 낭비, cvtColor()보다 3배 느림\n```\n\n**좋은 예 ✅ - cvtColor() 사용**\n```python\n# 최적화된 함수 사용\nimage_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n# 내부 최적화로 빠르고 메모리 효율적\n```\n\n**나쁜 예 ❌ - 하드코딩된 색상 범위**\n```python\n# 빨간색 검출을 RGB로 시도\nmask = (image[:,:,2] > 150) & (image[:,:,1] < 100) & (image[:,:,0] < 100)\n# 문제: 조명 변화에 취약, 임계값 조정이 어려움\n```\n\n**좋은 예 ✅ - HSV 기반 색상 범위**\n```python\n# HSV로 변환 후 색상 범위 지정\nhsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\nlower_red = np.array([0, 100, 100])\nupper_red = np.array([10, 255, 255])\nmask = cv2.inRange(hsv, lower_red, upper_red)\n# 조명 변화에 강건하고 직관적\n```\n\n**나쁜 예 ❌ - 잘못된 그레이스케일 변환**\n```python\n# 단순 평균으로 변환\ngray = np.mean(image, axis=2).astype(np.uint8)\n# 문제: 인간 시각 가중치 무시 (녹색이 더 밝게 보임)\n```\n\n**좋은 예 ✅ - 가중 평균 그레이스케일**\n```python\n# OpenCV의 표준 가중치 사용\ngray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n# 0.299*R + 0.587*G + 0.114*B (인간 시각 모델)\n```\n\n**나쁜 예 ❌ - 범위 체크 없는 변환**\n```python\nhsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\nhsv[:,:,2] = hsv[:,:,2] + 50  # 명도 증가\nresult = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)\n# 문제: 255를 초과하면 오버플로우\n```\n\n**좋은 예 ✅ - 안전한 값 조절**\n```python\nhsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\nhsv[:,:,2] = np.clip(hsv[:,:,2] + 50, 0, 255)\nresult = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)\n# clip으로 범위 보장\n```"
      },
      {
        "type": "common-mistake",
        "title": "흔한 실수와 해결법",
        "content": "**실수 1: Hue 값의 범위 오해**\n```python\n# 잘못된 코드 - 일반 HSV는 H:0-360이지만\nlower = np.array([90, 100, 100])  # OpenCV는 0-180!\nupper = np.array([180, 255, 255])\nmask = cv2.inRange(hsv, lower, upper)  # 범위 오류\n\n# 올바른 코드\nlower = np.array([45, 100, 100])  # 360도를 180으로 나눔\nupper = np.array([90, 255, 255])\nmask = cv2.inRange(hsv, lower, upper)\n```\n**왜 0-180인가?** OpenCV는 8비트(0-255)에 저장하기 위해 Hue를 절반으로 압축했습니다. 다른 라이브러리는 0-360을 사용하므로 주의하세요.\n\n**실수 2: 그레이스케일 이미지에 cvtColor 재적용**\n```python\n# 잘못된 코드\ngray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  # shape: (H, W)\nhsv = cv2.cvtColor(gray, cv2.COLOR_BGR2HSV)  # 에러!\n# 문제: gray는 2D 배열이라 BGR 변환 불가\n\n# 올바른 코드 - 원본 이미지를 변환\nhsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n# 또는 그레이스케일을 BGR로 먼저 변환\ngray_bgr = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)\nhsv = cv2.cvtColor(gray_bgr, cv2.COLOR_BGR2HSV)\n```\n**핵심 교훈**: 색상 공간 변환 전에 이미지의 채널 수를 확인하세요.\n\n**실수 3: 빨간색 HSV 범위의 불연속성**\n```python\n# 잘못된 코드 - 빨간색을 한 번에 검출\nlower_red = np.array([0, 100, 100])\nupper_red = np.array([180, 255, 255])  # 빨강 외 모든 색 포함!\nmask = cv2.inRange(hsv, lower_red, upper_red)\n\n# 올바른 코드 - 빨간색은 0과 180 근처에 분포\nmask1 = cv2.inRange(hsv, np.array([0, 100, 100]), np.array([10, 255, 255]))\nmask2 = cv2.inRange(hsv, np.array([170, 100, 100]), np.array([180, 255, 255]))\nmask = cv2.bitwise_or(mask1, mask2)\n```\n**왜 두 번 검출?** Hue는 원형 색상환이라 빨간색(0도=360도)이 경계에 걸쳐있습니다.\n\n**실수 4: matplotlib에 BGR 직접 표시**\n```python\nimport matplotlib.pyplot as plt\n\n# 잘못된 코드\nimg = cv2.imread('photo.jpg')  # BGR\nplt.imshow(img)  # 색상이 이상하게 보임!\nplt.show()\n\n# 올바른 코드\nimg_bgr = cv2.imread('photo.jpg')\nimg_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)\nplt.imshow(img_rgb)\nplt.show()\n```\n**주의**: OpenCV는 BGR, Matplotlib/PIL은 RGB를 기본값으로 사용합니다. 항상 변환하세요."
      },
      {
        "type": "practice",
        "title": "실습 문제",
        "content": "**기초 문제**\n1. 컬러 이미지를 그레이스케일로 변환하고 다시 BGR로 변환하여 저장하세요.\n2. HSV 이미지에서 H, S, V 채널을 각각 분리하여 3개의 파일로 저장하세요.\n3. 이미지에서 파란색 영역만 추출하는 마스크를 생성하세요. (H: 100-130)\n\n**중급 문제**\n4. 이미지의 명도(V 채널)를 50% 증가시키되, 255를 넘지 않도록 처리하세요.\n5. 녹색 교통 신호등을 검출하는 함수를 작성하세요. (H: 40-80, S: 100-255, V: 100-255)\n6. LAB 색상 공간에서 L 채널만 조절하여 이미지를 밝게 만드는 함수를 구현하세요.\n\n**고급 문제**\n7. 두 이미지의 색상 히스토그램을 HSV 공간에서 비교하여 유사도를 0-100% 점수로 반환하는 함수를 작성하세요.\n8. 웹캠에서 실시간으로 특정 색상 객체를 추적하고 그 중심 좌표를 화면에 표시하는 프로그램을 만드세요.\n9. 피부색 검출 알고리즘을 구현하되, HSV와 YCrCb 두 색상 공간을 조합하여 정확도를 높이세요.\n10. 색맹 시뮬레이션 함수를 작성하세요. RGB 이미지를 받아 적록색맹(Deuteranopia)이 보는 것처럼 색상을 변환하세요. (힌트: 특정 색상 채널을 제거하거나 혼합)"
      },
      {
        "type": "tip",
        "title": "실무 팁",
        "content": "💡 **색상 검출 디버깅**: 올바른 HSV 범위를 찾기 어렵다면 cv2.createTrackbar()로 슬라이더를 만들어 실시간으로 범위를 조절하세요. 최적값을 빠르게 찾을 수 있습니다.\n\n💡 **조명 변화 대응**: 실외 환경처럼 조명이 불안정하면 HSV의 V 채널 대신 LAB의 L 채널을 사용하세요. LAB는 조명 변화에 더 강건합니다.\n\n💡 **성능 최적화**: 실시간 처리 시 색상 변환을 최소화하세요. HSV가 필요하면 한 번만 변환하고 재사용하세요. 반복 변환은 FPS를 30% 저하시킵니다.\n\n💡 **색상 공간 선택 가이드**: 색상 기반 필터링은 HSV, 피부 검출은 YCrCb, 색상 거리 측정은 LAB, 화질 개선은 YUV를 사용하세요.\n\n💡 **빨간색 검출 꿀팁**: 빨간색은 HSV에서 0과 180 근처에 분포합니다. 두 범위를 각각 검출한 후 bitwise_or()로 합치는 것을 잊지 마세요. 이를 놓치면 빨간색의 절반만 검출됩니다."
      }
    ]
  },
  "03_python-opencv/04_drawing": {
    "id": "03_python-opencv/04_drawing",
    "title": "04 Drawing",
    "category": "ai-roadmap",
    "subCategory": "03_python-opencv",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "03_python-opencv/05_video": {
    "id": "03_python-opencv/05_video",
    "title": "05 Video",
    "category": "ai-roadmap",
    "subCategory": "03_python-opencv",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "03_python-opencv/intro": {
    "id": "03_python-opencv/intro",
    "title": "Intro",
    "category": "ai-roadmap",
    "subCategory": "03_python-opencv",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "04_python-webscraping/01_requests_basics": {
    "id": "04_python-webscraping/01_requests_basics",
    "title": "01 Requests Basics",
    "category": "ai-roadmap",
    "subCategory": "04_python-webscraping",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "04_python-webscraping/02_beautifulsoup": {
    "id": "04_python-webscraping/02_beautifulsoup",
    "title": "02 Beautifulsoup",
    "category": "ai-roadmap",
    "subCategory": "04_python-webscraping",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "04_python-webscraping/03_selenium": {
    "id": "04_python-webscraping/03_selenium",
    "title": "03 Selenium",
    "category": "ai-roadmap",
    "subCategory": "04_python-webscraping",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "04_python-webscraping/04_scrapy": {
    "id": "04_python-webscraping/04_scrapy",
    "title": "04 Scrapy",
    "category": "ai-roadmap",
    "subCategory": "04_python-webscraping",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "04_python-webscraping/05_ai_data_collect": {
    "id": "04_python-webscraping/05_ai_data_collect",
    "title": "05 Ai Data Collect",
    "category": "ai-roadmap",
    "subCategory": "04_python-webscraping",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "04_python-webscraping/intro": {
    "id": "04_python-webscraping/intro",
    "title": "Intro",
    "category": "ai-roadmap",
    "subCategory": "04_python-webscraping",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "05_python-ai-libs/01_pytorch_tensor": {
    "id": "05_python-ai-libs/01_pytorch_tensor",
    "title": "01 Pytorch Tensor",
    "category": "ai-roadmap",
    "subCategory": "05_python-ai-libs",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "05_python-ai-libs/02_pytorch_model": {
    "id": "05_python-ai-libs/02_pytorch_model",
    "title": "02 Pytorch Model",
    "category": "ai-roadmap",
    "subCategory": "05_python-ai-libs",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "05_python-ai-libs/03_transformers": {
    "id": "05_python-ai-libs/03_transformers",
    "title": "03 Transformers",
    "category": "ai-roadmap",
    "subCategory": "05_python-ai-libs",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "05_python-ai-libs/04_ultralytics": {
    "id": "05_python-ai-libs/04_ultralytics",
    "title": "04 Ultralytics",
    "category": "ai-roadmap",
    "subCategory": "05_python-ai-libs",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "05_python-ai-libs/05_diffusers": {
    "id": "05_python-ai-libs/05_diffusers",
    "title": "05 Diffusers",
    "category": "ai-roadmap",
    "subCategory": "05_python-ai-libs",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "05_python-ai-libs/pytorch": {
    "id": "05_python-ai-libs/pytorch",
    "title": "Pytorch",
    "category": "ai-roadmap",
    "subCategory": "05_python-ai-libs",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "06_java-basics/intro": {
    "id": "06_java-basics/intro",
    "title": "Intro",
    "category": "ai-roadmap",
    "subCategory": "06_java-basics",
    "language": "Java",
    "description": "Java 클래스와 메인 메서드 구조입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "07_spring-boot-basics/intro": {
    "id": "07_spring-boot-basics/intro",
    "title": "Intro",
    "category": "ai-roadmap",
    "subCategory": "07_spring-boot-basics",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Intro",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "08_spring-ai-api/intro": {
    "id": "08_spring-ai-api/intro",
    "title": "Intro",
    "category": "ai-roadmap",
    "subCategory": "08_spring-ai-api",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Intro",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "09_rest-api-json/intro": {
    "id": "09_rest-api-json/intro",
    "title": "Intro",
    "category": "ai-roadmap",
    "subCategory": "09_rest-api-json",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "10_async-programming/intro": {
    "id": "10_async-programming/intro",
    "title": "Intro",
    "category": "ai-roadmap",
    "subCategory": "10_async-programming",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "11_database-ai/intro": {
    "id": "11_database-ai/intro",
    "title": "Intro",
    "category": "ai-roadmap",
    "subCategory": "11_database-ai",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "12_fullstack-ai/intro": {
    "id": "12_fullstack-ai/intro",
    "title": "Intro",
    "category": "ai-roadmap",
    "subCategory": "12_fullstack-ai",
    "language": "Python",
    "description": "Python 변수, 제어문 기초입니다.",
    "isPlaceholder": true,
    "sections": []
  },
  "index": {
    "id": "index",
    "title": "🚀 AI 활용 종합 학습 로드맵",
    "category": "ai-roadmap",
    "subCategory": null,
    "language": "Text",
    "description": "",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🚀 AI 활용 종합 학습 로드맵",
        "content": ""
      },
      {
        "type": "code",
        "language": "Text",
        "code": ""
      }
    ]
  }
}