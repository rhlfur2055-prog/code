{
  "01_기초/kernel": {
    "id": "01_기초/kernel",
    "title": "커널",
    "category": "os",
    "subCategory": "01_기초",
    "language": "C",
    "description": "하드웨어와 소프트웨어를 연결하는 커널의 역할을 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🎯 커널 완전 정복",
        "content": "**한 줄 요약**: 커널(Kernel)은 OS의 핵심으로, 하드웨어와 소프트웨어 사이에서 자원을 관리하고 중재하는 역할을 합니다.\n\n**초등학생도 이해할 비유 - 공항 관제탑**\n\n공항을 상상해보세요:\n- 활주로(CPU) - 비행기가 이착륙하는 곳\n- 주기장(메모리) - 비행기가 대기하는 곳\n- 비행기(프로그램) - 목적지로 가려는 운송 수단\n- 관제탑(커널) - 모든 것을 조율하는 중앙 통제실\n\n**관제탑(커널)의 역할:**\n1. 이착륙 순서 결정 - CPU 스케줄링\n2. 주기장 배정 - 메모리 할당\n3. 비행기 간 충돌 방지 - 프로세스 격리\n4. 긴급 상황 처리 - 인터럽트 처리\n\n**왜 알아야 하는가?**\n- 시스템 성능 병목 이해\n- 커널 파라미터 튜닝 필요시\n- 컨테이너(Docker) 원리 이해\n- 시스템 프로그래밍의 기초"
      },
      {
        "type": "code",
        "title": "💻 동작 원리",
        "language": "text",
        "code": "커널의 주요 구성 요소:\n\n┌─────────────────────────────────────────────────────┐\n│                     커널 (Kernel)                   │\n├─────────────────────────────────────────────────────┤\n│  ┌─────────────────────────────────────────────┐   │\n│  │          프로세스 관리 (Scheduler)           │   │\n│  │  - 프로세스 생성/종료                        │   │\n│  │  - CPU 시간 분배                             │   │\n│  │  - 컨텍스트 스위칭                           │   │\n│  └─────────────────────────────────────────────┘   │\n│  ┌─────────────────────────────────────────────┐   │\n│  │          메모리 관리 (Memory Manager)        │   │\n│  │  - 가상 메모리                               │   │\n│  │  - 페이징/스와핑                             │   │\n│  │  - 메모리 보호                               │   │\n│  └─────────────────────────────────────────────┘   │\n│  ┌─────────────────────────────────────────────┐   │\n│  │          파일 시스템 (VFS)                   │   │\n│  │  - 파일 읽기/쓰기                            │   │\n│  │  - 디렉토리 관리                             │   │\n│  │  - 권한 관리                                 │   │\n│  └─────────────────────────────────────────────┘   │\n│  ┌─────────────────────────────────────────────┐   │\n│  │          디바이스 드라이버                    │   │\n│  │  - 하드웨어 추상화                           │   │\n│  │  - I/O 요청 처리                             │   │\n│  └─────────────────────────────────────────────┘   │\n│  ┌─────────────────────────────────────────────┐   │\n│  │          네트워크 스택                        │   │\n│  │  - TCP/IP 프로토콜                           │   │\n│  │  - 소켓 관리                                 │   │\n│  └─────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────┘\n\n사용자 모드 vs 커널 모드:\n\n  User Mode          System Call         Kernel Mode\n ┌──────────┐            │              ┌──────────┐\n │ 응용     │ ──────────►│──────────────► 하드웨어 │\n │ 프로그램 │            │  권한 상승    │ 직접접근 │\n └──────────┘            │              └──────────┘\n   Ring 3                              Ring 0"
      },
      {
        "type": "code",
        "title": "🔧 실무 활용",
        "language": "bash",
        "code": "# Linux 커널 정보 확인\n$ uname -a\nLinux server 5.15.0-generic x86_64 GNU/Linux\n\n# 커널 파라미터 확인\n$ sysctl -a | head -10\nkernel.hostname = myserver\nkernel.pid_max = 4194304\nvm.swappiness = 60\n\n# 커널 파라미터 튜닝 (성능 최적화)\n$ sudo sysctl -w net.core.somaxconn=65535  # 소켓 대기열\n$ sudo sysctl -w vm.swappiness=10          # 스왑 사용 줄이기\n$ sudo sysctl -w net.ipv4.tcp_max_syn_backlog=65535\n\n# /etc/sysctl.conf에 영구 설정\nnet.core.somaxconn = 65535\nvm.swappiness = 10\nnet.ipv4.tcp_fin_timeout = 30\n\n# Java 애플리케이션에서 커널 튜닝이 필요한 경우\n# Spring Boot에서 대용량 트래픽 처리시\n\n// application.yml\nserver:\n  tomcat:\n    accept-count: 1000      # OS 레벨 backlog\n    max-connections: 10000  # 최대 연결 수\n    threads:\n      max: 200\n      min-spare: 10\n\n# Docker에서 커널 공유 확인\n$ docker run -it ubuntu uname -r\n5.15.0-generic  # 호스트와 동일한 커널 사용!"
      },
      {
        "type": "tip",
        "title": "💡 체크리스트 & 면접",
        "content": "**핵심 개념 정리표**\n| 구성요소 | 역할 | 관련 명령어 |\n|----------|------|-------------|\n| 프로세스 관리 | CPU 스케줄링, 생성/종료 | ps, top, kill |\n| 메모리 관리 | 가상 메모리, 페이징 | free, vmstat |\n| 파일 시스템 | 파일 I/O, 권한 | ls, chmod |\n| 디바이스 드라이버 | 하드웨어 제어 | lsmod, modprobe |\n| 네트워크 스택 | TCP/IP 처리 | netstat, ss |\n\n**User Mode vs Kernel Mode**\n| 구분 | User Mode | Kernel Mode |\n|------|-----------|-------------|\n| 권한 | 제한적 (Ring 3) | 전체 (Ring 0) |\n| 메모리 | 가상 주소만 | 물리 주소 접근 |\n| 하드웨어 | 접근 불가 | 직접 제어 |\n| 전환 | 시스템 콜로 | 인터럽트 발생시 |\n\n**면접 질문**\n\n[주니어]\nQ: 커널의 주요 역할 4가지를 설명해주세요.\nA: 1) 프로세스 관리 - CPU 시간 분배와 스케줄링, 2) 메모리 관리 - 가상 메모리와 페이징, 3) 파일 시스템 - 파일 I/O와 권한 관리, 4) 디바이스 관리 - 하드웨어 드라이버 제어입니다.\n\n[시니어]\nQ: 컨테이너가 VM보다 가벼운 이유를 커널 관점에서 설명해주세요.\nA: VM은 각각 독립된 Guest OS와 커널을 가져 무겁지만, 컨테이너는 호스트 OS의 커널을 공유합니다. 컨테이너는 namespace로 프로세스를 격리하고, cgroups로 자원을 제한하여 커널 레벨에서 가벼운 격리를 구현합니다. 따라서 부팅 시간이 빠르고 메모리 효율이 높습니다."
      }
    ]
  },
  "01_기초/os-intro": {
    "id": "01_기초/os-intro",
    "title": "운영체제란?",
    "category": "os",
    "subCategory": "01_기초",
    "language": "C",
    "description": "운영체제의 개념과 역할을 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🎯 운영체제 완전 정복",
        "content": "**한 줄 요약**: 운영체제(OS)는 하드웨어와 소프트웨어 사이에서 자원을 관리하고 사용자에게 편리한 환경을 제공하는 시스템 소프트웨어입니다.\n\n**초등학생도 이해할 비유 - 레스토랑 총괄 매니저**\n\n레스토랑을 상상해보세요:\n- 주방(CPU) - 요리를 만드는 곳\n- 냉장고(메모리) - 재료를 보관하는 곳\n- 손님(사용자 프로그램) - 음식을 주문하는 사람\n- 웨이터(입출력 장치) - 주문을 전달하고 음식을 가져다주는 역할\n\n**총괄 매니저(운영체제)의 역할:**\n1. 주방 시간 배분 - 어떤 요리를 먼저 만들지 결정\n2. 재료 관리 - 냉장고 공간을 효율적으로 사용\n3. 웨이터 조율 - 누가 어느 테이블을 담당할지 배정\n4. 손님 관리 - 대기 순서, 예약 관리\n\n**왜 알아야 하는가?**\n- 프로그램이 어떻게 실행되는지 이해\n- 성능 최적화의 기본 원리 파악\n- 시스템 레벨 문제 해결 능력 향상\n- 면접 단골 질문 (프로세스, 메모리, 스케줄링)"
      },
      {
        "type": "code",
        "title": "💻 동작 원리",
        "language": "text",
        "code": "┌─────────────────────────────────────────────────┐\n│                  사용자 영역                      │\n│  ┌──────────┐  ┌──────────┐  ┌──────────┐       │\n│  │  Chrome  │  │   Word   │  │  게임    │       │\n│  └──────────┘  └──────────┘  └──────────┘       │\n├─────────────────────────────────────────────────┤\n│                 시스템 콜 인터페이스              │\n├─────────────────────────────────────────────────┤\n│              운영체제 (커널)                     │\n│  ┌─────────┐ ┌─────────┐ ┌─────────┐           │\n│  │프로세스 │ │ 메모리  │ │파일시스템│           │\n│  │  관리   │ │  관리   │ │  관리   │           │\n│  └─────────┘ └─────────┘ └─────────┘           │\n├─────────────────────────────────────────────────┤\n│                하드웨어                          │\n│    CPU      메모리      디스크      네트워크     │\n└─────────────────────────────────────────────────┘\n\n운영체제의 핵심 기능:\n1. 프로세스 관리: CPU 시간 분배, 프로세스 생성/종료\n2. 메모리 관리: RAM 할당/해제, 가상 메모리\n3. 파일 시스템: 파일 저장, 디렉토리 관리\n4. I/O 관리: 키보드, 마우스, 디스크 제어\n5. 보안: 사용자 인증, 접근 권한 관리"
      },
      {
        "type": "code",
        "title": "🔧 실무 활용",
        "language": "java",
        "code": "// Java에서 OS 정보 확인하기\npublic class OSInfo {\n    public static void main(String[] args) {\n        // 운영체제 정보\n        System.out.println(\"OS: \" + System.getProperty(\"os.name\"));\n        System.out.println(\"Version: \" + System.getProperty(\"os.version\"));\n        System.out.println(\"Architecture: \" + System.getProperty(\"os.arch\"));\n        \n        // 런타임 정보 (JVM이 OS로부터 할당받은 자원)\n        Runtime runtime = Runtime.getRuntime();\n        System.out.println(\"Available Processors: \" + runtime.availableProcessors());\n        System.out.println(\"Max Memory: \" + runtime.maxMemory() / 1024 / 1024 + \"MB\");\n        System.out.println(\"Total Memory: \" + runtime.totalMemory() / 1024 / 1024 + \"MB\");\n        System.out.println(\"Free Memory: \" + runtime.freeMemory() / 1024 / 1024 + \"MB\");\n    }\n}\n\n// Spring Boot에서 OS 레벨 모니터링\n@Component\npublic class SystemMonitor {\n    \n    private final OperatingSystemMXBean osBean = \n        ManagementFactory.getOperatingSystemMXBean();\n    \n    @Scheduled(fixedRate = 60000) // 1분마다 체크\n    public void monitorSystem() {\n        double cpuLoad = osBean.getSystemLoadAverage();\n        if (cpuLoad > 0.8) {\n            log.warn(\"High CPU usage: {}%\", cpuLoad * 100);\n            // 알림 발송 또는 스케일 아웃 트리거\n        }\n    }\n}"
      },
      {
        "type": "tip",
        "title": "💡 체크리스트 & 면접",
        "content": "**핵심 개념 정리표**\n| 구분 | 내용 |\n|------|------|\n| 정의 | 하드웨어를 관리하고 응용 프로그램에 서비스를 제공하는 시스템 소프트웨어 |\n| 핵심 역할 | 자원 관리, 사용자 인터페이스 제공 |\n| 주요 기능 | 프로세스/메모리/파일/I-O 관리 |\n| 대표 예시 | Windows, Linux, macOS, Android, iOS |\n\n**면접 질문**\n\n[주니어]\nQ: 운영체제의 역할은 무엇인가요?\nA: 하드웨어 자원(CPU, 메모리, 디스크)을 효율적으로 관리하고, 응용 프로그램이 하드웨어를 쉽게 사용할 수 있도록 추상화된 인터페이스를 제공합니다. 또한 여러 프로그램이 동시에 실행될 때 충돌 없이 자원을 공유할 수 있게 합니다.\n\n[시니어]\nQ: 커널 모드와 사용자 모드를 분리하는 이유는?\nA: 보안과 안정성을 위해서입니다. 사용자 프로그램이 직접 하드웨어에 접근하면 시스템 전체가 불안정해질 수 있습니다. 커널 모드에서만 하드웨어 접근이 가능하게 하고, 사용자 프로그램은 시스템 콜을 통해 간접적으로 요청함으로써 OS가 요청을 검증하고 안전하게 처리할 수 있습니다."
      }
    ]
  },
  "01_기초/os-structure": {
    "id": "01_기초/os-structure",
    "title": "OS 구조",
    "category": "os",
    "subCategory": "01_기초",
    "language": "C",
    "description": "커널, 쉘, 사용자 영역으로 구성된 OS 구조를 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🎯 OS 구조 완전 정복",
        "content": "**한 줄 요약**: OS는 커널(핵심), 쉘(명령 해석기), 사용자 영역(응용 프로그램)의 계층 구조로 이루어져 있습니다.\n\n**초등학생도 이해할 비유 - 회사 조직도**\n\n회사를 상상해보세요:\n- 사장실(커널) - 회사의 핵심 의사결정, 모든 자원 관리\n- 비서실(쉘) - 외부 요청을 사장에게 전달, 결과 통보\n- 각 부서(사용자 영역) - 실제 업무 수행, 비서실 통해 사장에게 보고\n\n**계층별 역할:**\n1. 커널(Kernel) - OS의 핵심, 하드웨어 직접 제어\n2. 쉘(Shell) - 사용자 명령을 커널에 전달하는 인터페이스\n3. 사용자 영역 - 응용 프로그램이 실행되는 공간\n\n**왜 계층 구조인가?**\n- 보안: 일반 프로그램이 하드웨어 직접 접근 차단\n- 안정성: 한 프로그램 오류가 전체 시스템에 영향 X\n- 유지보수: 각 계층 독립적 수정 가능"
      },
      {
        "type": "code",
        "title": "💻 동작 원리",
        "language": "text",
        "code": "OS 구조 다이어그램:\n\n┌─────────────────────────────────────────────────────┐\n│              사용자 영역 (User Space)               │\n│  ┌─────────────────────────────────────────────┐   │\n│  │    응용 프로그램 (Chrome, VSCode, 게임)      │   │\n│  └─────────────────────────────────────────────┘   │\n│  ┌─────────────────────────────────────────────┐   │\n│  │    쉘 (Shell) - bash, zsh, PowerShell       │   │\n│  │    GUI 쉘 - Windows Explorer, GNOME         │   │\n│  └─────────────────────────────────────────────┘   │\n├─────────────────────────────────────────────────────┤\n│              시스템 콜 인터페이스                    │\n│         (User Mode ↔ Kernel Mode 경계)             │\n├─────────────────────────────────────────────────────┤\n│              커널 영역 (Kernel Space)               │\n│  ┌──────────┐ ┌──────────┐ ┌──────────┐            │\n│  │ 프로세스 │ │  메모리  │ │   파일   │            │\n│  │   관리   │ │   관리   │ │  시스템  │            │\n│  └──────────┘ └──────────┘ └──────────┘            │\n│  ┌──────────┐ ┌──────────┐                         │\n│  │  디바이스│ │  네트워크│                         │\n│  │  드라이버│ │   스택   │                         │\n│  └──────────┘ └──────────┘                         │\n├─────────────────────────────────────────────────────┤\n│                   하드웨어                          │\n│        CPU / RAM / Disk / NIC / GPU                │\n└─────────────────────────────────────────────────────┘\n\n커널 유형:\n1. 모놀리식 커널: 모든 기능이 커널에 (Linux)\n2. 마이크로 커널: 최소 기능만 커널에 (Minix)\n3. 하이브리드 커널: 두 방식 혼합 (Windows NT)"
      },
      {
        "type": "code",
        "title": "🔧 실무 활용",
        "language": "bash",
        "code": "# Linux에서 쉘 확인 및 사용\n$ echo $SHELL\n/bin/bash\n\n# 현재 커널 버전 확인\n$ uname -r\n5.15.0-generic\n\n# 시스템 콜 추적 (strace)\n$ strace -c ls\n% time     calls  syscall\n------ --------- ----------------\n 45.00        12  write\n 30.00         5  read\n 15.00         3  openat\n 10.00         2  close\n\n# Java에서 쉘 명령 실행\npublic class ShellExecutor {\n    public static String executeCommand(String command) {\n        try {\n            ProcessBuilder pb = new ProcessBuilder();\n            // OS에 따라 쉘 선택\n            if (System.getProperty(\"os.name\").toLowerCase().contains(\"win\")) {\n                pb.command(\"cmd\", \"/c\", command);\n            } else {\n                pb.command(\"sh\", \"-c\", command);\n            }\n            \n            Process process = pb.start();\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(process.getInputStream()));\n            \n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            return output.toString();\n        } catch (IOException e) {\n            return \"Error: \" + e.getMessage();\n        }\n    }\n}"
      },
      {
        "type": "tip",
        "title": "💡 체크리스트 & 면접",
        "content": "**핵심 개념 정리표**\n| 계층 | 역할 | 예시 |\n|------|------|------|\n| 사용자 영역 | 응용 프로그램 실행 | Chrome, VSCode |\n| 쉘 | 명령 해석, 커널과 통신 | bash, PowerShell |\n| 커널 | 자원 관리, 하드웨어 제어 | 프로세스/메모리 관리 |\n\n**커널 유형 비교**\n| 유형 | 장점 | 단점 | 예시 |\n|------|------|------|------|\n| 모놀리식 | 성능 우수 | 유지보수 어려움 | Linux |\n| 마이크로 | 안정성, 유연성 | 성능 오버헤드 | Minix |\n| 하이브리드 | 균형 | 복잡성 | Windows |\n\n**면접 질문**\n\n[주니어]\nQ: 커널과 쉘의 차이점은?\nA: 커널은 OS의 핵심으로 하드웨어를 직접 제어하고 자원을 관리합니다. 쉘은 사용자와 커널 사이의 인터페이스로, 사용자의 명령을 해석하여 커널에 전달하고 결과를 보여줍니다.\n\n[시니어]\nQ: 모놀리식 커널과 마이크로 커널의 트레이드오프는?\nA: 모놀리식은 모든 서비스가 커널 공간에서 실행되어 성능이 좋지만, 하나의 버그가 전체 시스템을 망칠 수 있습니다. 마이크로는 최소 기능만 커널에 두고 나머지는 사용자 공간에서 실행해 안정성이 높지만, IPC 오버헤드로 성능이 떨어집니다. Linux는 모놀리식이지만 모듈을 통해 유연성을 확보했습니다."
      }
    ]
  },
  "01_기초/system-call": {
    "id": "01_기초/system-call",
    "title": "시스템 콜",
    "category": "os",
    "subCategory": "01_기초",
    "language": "C",
    "description": "사용자 프로그램이 커널에 서비스를 요청하는 시스템 콜을 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🎯 시스템 콜 완전 정복",
        "content": "**한 줄 요약**: 시스템 콜(System Call)은 사용자 프로그램이 커널의 서비스(파일 I/O, 프로세스 생성 등)를 요청하는 유일한 방법입니다.\n\n**초등학생도 이해할 비유 - 은행 창구**\n\n은행을 상상해보세요:\n- 고객(사용자 프로그램) - 돈을 입출금하고 싶은 사람\n- 금고(하드웨어 자원) - 실제 돈이 보관된 곳\n- 은행 직원(커널) - 금고에 접근할 수 있는 유일한 사람\n- 창구(시스템 콜) - 고객이 직원에게 요청하는 공식 통로\n\n**고객이 직접 금고에 들어갈 수 없는 이유:**\n1. 보안 - 아무나 금고에 접근하면 위험\n2. 관리 - 기록 없이 돈이 오가면 혼란\n3. 안정성 - 규칙 없이 접근하면 사고 발생\n\n**주요 시스템 콜 종류:**\n- 프로세스: fork(), exec(), exit(), wait()\n- 파일: open(), read(), write(), close()\n- 메모리: mmap(), brk()\n- 통신: socket(), send(), recv()"
      },
      {
        "type": "code",
        "title": "💻 동작 원리",
        "language": "text",
        "code": "시스템 콜 동작 과정:\n\n  User Mode                              Kernel Mode\n ┌──────────────┐                     ┌──────────────┐\n │ printf(\"Hi\") │                     │              │\n │      │       │                     │              │\n │      ▼       │                     │              │\n │ write() 호출 │ ──── Trap ────────► │  시스템 콜   │\n │              │     (인터럽트)      │   핸들러     │\n │              │                     │      │       │\n │              │                     │      ▼       │\n │              │                     │  sys_write() │\n │              │                     │      │       │\n │              │                     │      ▼       │\n │              │ ◄─── Return ─────── │  하드웨어    │\n │   결과 수신  │                     │   I/O 수행   │\n └──────────────┘                     └──────────────┘\n\n상세 흐름:\n1. 사용자 프로그램이 라이브러리 함수 호출 (printf)\n2. 라이브러리가 시스템 콜 번호를 레지스터에 저장\n3. 소프트웨어 인터럽트(trap) 발생 → 커널 모드 전환\n4. 커널의 시스템 콜 핸들러가 번호 확인\n5. 해당 커널 함수 실행 (sys_write)\n6. 결과를 레지스터에 저장\n7. 사용자 모드로 복귀\n\n시스템 콜 번호 예시 (Linux x86_64):\n┌────────┬────────────┬──────────────────┐\n│ 번호   │ 시스템콜   │ 설명             │\n├────────┼────────────┼──────────────────┤\n│ 0      │ read       │ 파일 읽기        │\n│ 1      │ write      │ 파일 쓰기        │\n│ 2      │ open       │ 파일 열기        │\n│ 3      │ close      │ 파일 닫기        │\n│ 57     │ fork       │ 프로세스 생성    │\n│ 59     │ execve     │ 프로그램 실행    │\n│ 60     │ exit       │ 프로세스 종료    │\n└────────┴────────────┴──────────────────┘"
      },
      {
        "type": "code",
        "title": "🔧 실무 활용",
        "language": "c",
        "code": "// C언어에서 시스템 콜 직접 사용\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n\nint main() {\n    // 파일 시스템 콜\n    int fd = open(\"test.txt\", O_RDONLY);  // 시스템 콜\n    char buffer[100];\n    read(fd, buffer, 100);                 // 시스템 콜\n    close(fd);                             // 시스템 콜\n    \n    // 프로세스 시스템 콜\n    pid_t pid = fork();                    // 시스템 콜\n    if (pid == 0) {\n        // 자식 프로세스\n        execl(\"/bin/ls\", \"ls\", \"-la\", NULL);  // 시스템 콜\n    } else {\n        // 부모 프로세스\n        wait(NULL);                        // 시스템 콜\n    }\n    return 0;\n}\n\n// Java에서 시스템 콜 (JNI 또는 라이브러리 통해 간접 호출)\nimport java.io.*;\n\npublic class SystemCallExample {\n    public static void main(String[] args) throws Exception {\n        // FileInputStream 내부에서 open(), read() 시스템 콜 발생\n        FileInputStream fis = new FileInputStream(\"test.txt\");\n        byte[] buffer = new byte[100];\n        fis.read(buffer);  // 내부적으로 read() 시스템 콜\n        fis.close();       // 내부적으로 close() 시스템 콜\n        \n        // ProcessBuilder로 fork+exec 시스템 콜\n        ProcessBuilder pb = new ProcessBuilder(\"ls\", \"-la\");\n        Process p = pb.start();  // 내부적으로 fork(), exec()\n        p.waitFor();             // 내부적으로 wait()\n    }\n}\n\n// strace로 시스템 콜 추적\n// $ strace -f java SystemCallExample\n// openat(AT_FDCWD, \"test.txt\", O_RDONLY) = 3\n// read(3, \"hello world\", 100) = 11\n// close(3) = 0"
      },
      {
        "type": "tip",
        "title": "💡 체크리스트 & 면접",
        "content": "**주요 시스템 콜 분류**\n| 분류 | 시스템 콜 | 설명 |\n|------|----------|------|\n| 프로세스 | fork() | 프로세스 복제 생성 |\n| 프로세스 | exec() | 새 프로그램 실행 |\n| 프로세스 | exit() | 프로세스 종료 |\n| 파일 | open() | 파일 열기 |\n| 파일 | read()/write() | 파일 읽기/쓰기 |\n| 메모리 | mmap() | 메모리 매핑 |\n| 통신 | socket() | 소켓 생성 |\n\n**시스템 콜 vs 라이브러리 함수**\n| 구분 | 시스템 콜 | 라이브러리 함수 |\n|------|----------|----------------|\n| 실행 위치 | 커널 모드 | 사용자 모드 |\n| 오버헤드 | 큼 (모드 전환) | 작음 |\n| 예시 | read(), write() | printf(), malloc() |\n| 번호 | 고유 번호 있음 | 없음 |\n\n**면접 질문**\n\n[주니어]\nQ: 시스템 콜이 필요한 이유는?\nA: 사용자 프로그램은 보안상 하드웨어에 직접 접근할 수 없습니다. 파일 읽기, 네트워크 통신 등 하드웨어 자원이 필요할 때 시스템 콜을 통해 커널에 요청해야 합니다. 커널은 요청을 검증하고 안전하게 처리한 후 결과를 반환합니다.\n\n[시니어]\nQ: 시스템 콜의 오버헤드를 줄이는 방법은?\nA: 1) 버퍼링 - 여러 번의 I/O를 모아서 한 번의 시스템 콜로 처리 (BufferedReader), 2) mmap - 파일을 메모리에 매핑하여 read/write 콜 감소, 3) io_uring - Linux 5.1+에서 비동기 I/O로 시스템 콜 배치 처리, 4) vDSO - 자주 사용되는 콜(gettimeofday)을 사용자 공간에서 처리."
      }
    ]
  },
  "02_프로세스/ipc": {
    "id": "02_프로세스/ipc",
    "title": "IPC (프로세스 간 통신)",
    "category": "os",
    "subCategory": "02_프로세스",
    "language": "C",
    "description": "프로세스 간 데이터를 주고받는 IPC 메커니즘을 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🎯 IPC 완전 정복",
        "content": "**한 줄 요약**: IPC(Inter-Process Communication)는 독립된 프로세스들이 데이터를 주고받는 방법으로, 파이프, 메시지 큐, 공유 메모리, 소켓 등이 있습니다.\n\n**초등학생도 이해할 비유 - 교실 간 소통**\n\n학교 교실들을 상상해보세요:\n- 각 교실(프로세스) - 독립된 공간, 서로 직접 못 들어감\n- 쪽지 전달(파이프) - 한 방향으로 쪽지 전달\n- 게시판(메시지 큐) - 메시지를 올리고 가져감\n- 공유 사물함(공유 메모리) - 같이 쓰는 공간\n- 전화(소켓) - 멀리 있어도 통신 가능\n\n**IPC가 필요한 이유:**\n1. 프로세스는 각자 독립된 메모리 공간\n2. 직접 다른 프로세스 메모리 접근 불가\n3. 협력이 필요한 작업 수행\n4. 데이터 공유 및 동기화\n\n**주요 IPC 방식:**\n- 파이프(Pipe) - 단방향, 부모-자식 간\n- 메시지 큐 - 비동기, 메시지 단위\n- 공유 메모리 - 가장 빠름, 동기화 필요\n- 소켓 - 네트워크 통신 가능"
      },
      {
        "type": "code",
        "title": "💻 동작 원리",
        "language": "text",
        "code": "IPC 방식 비교:\n\n1. 파이프 (Pipe)\n   ┌───────────┐    단방향    ┌───────────┐\n   │ Process A │ ───────────► │ Process B │\n   │  (부모)   │   fd[1]→fd[0] │  (자식)   │\n   └───────────┘              └───────────┘\n\n2. 명명된 파이프 (Named Pipe / FIFO)\n   ┌───────────┐              ┌───────────┐\n   │ Process A │ ──┐      ┌── │ Process B │\n   └───────────┘   │      │   └───────────┘\n                   ▼      ▼\n              ┌──────────────┐\n              │  /tmp/myfifo │  ← 파일시스템에 존재\n              └──────────────┘\n\n3. 메시지 큐 (Message Queue)\n   ┌───────────┐              ┌───────────┐\n   │ Process A │ ──┐      ┌── │ Process B │\n   └───────────┘   │      │   └───────────┘\n                   ▼      ▼\n              ┌──────────────┐\n              │ Message Queue│\n              │ [msg1][msg2] │  ← 커널이 관리\n              └──────────────┘\n\n4. 공유 메모리 (Shared Memory)\n   ┌───────────┐              ┌───────────┐\n   │ Process A │              │ Process B │\n   │           │              │           │\n   │  ┌─────┐  │              │  ┌─────┐  │\n   │  │ ptr │──┼──────────────┼──│ ptr │  │\n   │  └─────┘  │              │  └─────┘  │\n   └───────────┘              └───────────┘\n           │                        │\n           └────────┬───────────────┘\n                    ▼\n              ┌──────────────┐\n              │ Shared Memory│  ← 물리 메모리\n              │   Segment    │\n              └──────────────┘\n\n5. 소켓 (Socket)\n   ┌───────────┐              ┌───────────┐\n   │ Process A │ ◄──────────► │ Process B │\n   │ (Client)  │   TCP/UDP    │ (Server)  │\n   └───────────┘   네트워크    └───────────┘"
      },
      {
        "type": "code",
        "title": "🔧 실무 활용",
        "language": "c",
        "code": "// 1. 파이프 (Pipe) - C언어\n#include <unistd.h>\nint main() {\n    int fd[2];\n    pipe(fd);  // fd[0]: 읽기, fd[1]: 쓰기\n    \n    if (fork() == 0) {\n        // 자식: 읽기\n        close(fd[1]);\n        char buf[100];\n        read(fd[0], buf, sizeof(buf));\n        printf(\"Received: %s\\n\", buf);\n    } else {\n        // 부모: 쓰기\n        close(fd[0]);\n        write(fd[1], \"Hello!\", 7);\n    }\n    return 0;\n}\n\n// 2. Java에서 IPC - 소켓 방식\n// Server\nServerSocket server = new ServerSocket(8080);\nSocket client = server.accept();\nBufferedReader in = new BufferedReader(\n    new InputStreamReader(client.getInputStream()));\nString message = in.readLine();\n\n// Client\nSocket socket = new Socket(\"localhost\", 8080);\nPrintWriter out = new PrintWriter(socket.getOutputStream(), true);\nout.println(\"Hello Server!\");\n\n// 3. Spring에서 IPC - Redis Pub/Sub\n@Service\npublic class MessageService {\n    @Autowired\n    private StringRedisTemplate redisTemplate;\n    \n    // 메시지 발행 (Publisher)\n    public void publish(String channel, String message) {\n        redisTemplate.convertAndSend(channel, message);\n    }\n}\n\n@Component\npublic class MessageSubscriber implements MessageListener {\n    // 메시지 수신 (Subscriber)\n    @Override\n    public void onMessage(Message message, byte[] pattern) {\n        String body = new String(message.getBody());\n        log.info(\"Received: {}\", body);\n    }\n}\n\n// 4. 실무에서 많이 사용하는 IPC\n// - 마이크로서비스: REST API, gRPC, Message Queue (Kafka, RabbitMQ)\n// - 같은 서버: Unix Socket, Shared Memory\n// - 컨테이너 간: Docker Network, Kubernetes Service"
      },
      {
        "type": "tip",
        "title": "💡 체크리스트 & 면접",
        "content": "**IPC 방식 비교표**\n| 방식 | 속도 | 방향 | 범위 | 용도 |\n|------|------|------|------|------|\n| 파이프 | 중간 | 단방향 | 부모-자식 | 간단한 데이터 전달 |\n| 명명된 파이프 | 중간 | 단/양방향 | 같은 시스템 | 무관계 프로세스 통신 |\n| 메시지 큐 | 중간 | 양방향 | 같은 시스템 | 비동기 메시지 |\n| 공유 메모리 | 매우 빠름 | 양방향 | 같은 시스템 | 대용량 데이터 |\n| 소켓 | 느림 | 양방향 | 네트워크 | 분산 시스템 |\n\n**실무에서의 IPC 선택**\n| 상황 | 추천 방식 |\n|------|----------|\n| 마이크로서비스 | REST, gRPC, Kafka |\n| 실시간 이벤트 | WebSocket, Redis Pub/Sub |\n| 대용량 데이터 공유 | 공유 메모리, mmap |\n| 부모-자식 프로세스 | 파이프 |\n\n**면접 질문**\n\n[주니어]\nQ: IPC 방식의 종류와 각각의 특징은?\nA: 파이프는 단방향으로 부모-자식 간 통신에 사용됩니다. 메시지 큐는 비동기로 메시지를 주고받습니다. 공유 메모리는 가장 빠르지만 동기화가 필요합니다. 소켓은 네트워크를 통해 다른 시스템과도 통신할 수 있습니다.\n\n[시니어]\nQ: 마이크로서비스에서 동기 vs 비동기 통신의 트레이드오프는?\nA: 동기(REST, gRPC)는 구현이 단순하고 즉시 응답을 받지만, 서비스 간 강결합과 장애 전파 위험이 있습니다. 비동기(Kafka, RabbitMQ)는 느슨한 결합과 장애 격리가 가능하지만, 최종 일관성 모델이라 복잡도가 높습니다. 보통 조회는 동기, 명령은 비동기(CQRS)로 혼합 사용합니다."
      }
    ]
  },
  "02_프로세스/pcb": {
    "id": "02_프로세스/pcb",
    "title": "PCB (Process Control Block)",
    "category": "os",
    "subCategory": "02_프로세스",
    "language": "C",
    "description": "프로세스의 모든 정보를 담고 있는 PCB를 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🎯 PCB 완전 정복",
        "content": "**한 줄 요약**: PCB(Process Control Block)는 각 프로세스의 정보(상태, 레지스터, 메모리 등)를 저장하는 커널의 자료구조입니다.\n\n**초등학생도 이해할 비유 - 학생 생활기록부**\n\n학교를 상상해보세요:\n- 학생(프로세스) - 각각 고유한 특성을 가진 존재\n- 생활기록부(PCB) - 학생의 모든 정보가 기록된 문서\n- 담임선생님(OS) - 생활기록부를 관리하는 사람\n\n**생활기록부(PCB)에 기록된 정보:**\n1. 학번(PID) - 학생 고유 식별 번호\n2. 현재 상태 - 수업중/쉬는시간/급식중\n3. 시간표(프로그램 카운터) - 지금 어떤 수업인지\n4. 성적(레지스터) - 현재까지의 학습 상태\n5. 교실 배치(메모리 정보) - 어디에 앉아있는지\n\n**왜 알아야 하는가?**\n- 컨텍스트 스위칭 원리 이해\n- 프로세스 관리 방식 파악\n- 멀티태스킹 동작 원리\n- ps, top 명령어 결과 해석"
      },
      {
        "type": "code",
        "title": "💻 동작 원리",
        "language": "text",
        "code": "PCB 구조:\n\n┌─────────────────────────────────────────────────┐\n│              PCB (Process Control Block)        │\n├─────────────────────────────────────────────────┤\n│  PID (Process ID)          : 1234               │\n│  프로세스 상태              : Running            │\n│  프로그램 카운터 (PC)       : 0x00401000         │\n│  CPU 레지스터              : EAX, EBX, ESP...    │\n│  CPU 스케줄링 정보         : 우선순위 20         │\n│  메모리 관리 정보          : 페이지 테이블 주소   │\n│  계정 정보                 : 사용자 ID, CPU 시간  │\n│  I/O 상태 정보             : 열린 파일 목록       │\n│  부모/자식 프로세스 정보    : PPID, Child PIDs    │\n└─────────────────────────────────────────────────┘\n\n컨텍스트 스위칭과 PCB:\n\n  Process A          OS Kernel          Process B\n ┌─────────┐      ┌─────────────┐      ┌─────────┐\n │ Running │      │             │      │ Ready   │\n │    │    │      │  PCB List   │      │         │\n │    ▼    │      │ ┌─────────┐ │      │         │\n │ 인터럽트 ├─────►│ │ PCB_A   │ │      │         │\n │         │ save │ │ 상태저장 │ │      │         │\n │         │      │ └─────────┘ │      │         │\n │         │      │ ┌─────────┐ │      │         │\n │         │      │ │ PCB_B   │ │◄─────┤         │\n │         │      │ │ 상태복원 │ │restore        │\n │         │      │ └─────────┘ │      │    │    │\n │ Ready   │      │             │      │    ▼    │\n │         │      │             │      │ Running │\n └─────────┘      └─────────────┘      └─────────┘\n\nLinux의 task_struct (실제 PCB):\n- 약 1.7KB 크기의 구조체\n- 300개 이상의 필드 포함\n- include/linux/sched.h에 정의"
      },
      {
        "type": "code",
        "title": "🔧 실무 활용",
        "language": "c",
        "code": "// Linux에서 PCB 정보 확인\n// /proc/[pid]/ 디렉토리에서 프로세스 정보 확인 가능\n\n// C언어 - 프로세스 정보 읽기\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid = getpid();\n    printf(\"Current PID: %d\\n\", pid);\n    \n    // /proc/self/status 읽기\n    char path[256];\n    sprintf(path, \"/proc/%d/status\", pid);\n    \n    FILE *f = fopen(path, \"r\");\n    char line[256];\n    while (fgets(line, sizeof(line), f)) {\n        printf(\"%s\", line);\n    }\n    fclose(f);\n    return 0;\n}\n\n// Java에서 프로세스 정보 확인\npublic class ProcessInfo {\n    public static void main(String[] args) {\n        // 현재 프로세스 정보\n        ProcessHandle current = ProcessHandle.current();\n        System.out.println(\"PID: \" + current.pid());\n        \n        ProcessHandle.Info info = current.info();\n        System.out.println(\"Command: \" + info.command().orElse(\"N/A\"));\n        System.out.println(\"User: \" + info.user().orElse(\"N/A\"));\n        System.out.println(\"Start Time: \" + info.startInstant().orElse(null));\n        System.out.println(\"CPU Time: \" + info.totalCpuDuration().orElse(null));\n        \n        // 모든 프로세스 조회\n        ProcessHandle.allProcesses()\n            .filter(p -> p.info().command().isPresent())\n            .limit(10)\n            .forEach(p -> System.out.println(\n                p.pid() + \": \" + p.info().command().get()));\n    }\n}\n\n// 터미널 명령어\n$ cat /proc/1234/status    # 특정 PID의 PCB 정보\n$ ps aux                    # 모든 프로세스 정보\n$ top -p 1234               # 특정 프로세스 모니터링"
      },
      {
        "type": "tip",
        "title": "💡 체크리스트 & 면접",
        "content": "**PCB 주요 필드**\n| 필드 | 설명 | 용도 |\n|------|------|------|\n| PID | 프로세스 고유 ID | 프로세스 식별 |\n| State | 상태 (Running/Ready 등) | 스케줄링 |\n| PC | 다음 실행 명령어 주소 | 실행 위치 복원 |\n| Registers | CPU 레지스터 값 | 컨텍스트 복원 |\n| Memory | 페이지 테이블, 한계 레지스터 | 메모리 보호 |\n| I/O | 열린 파일, 디바이스 | 자원 관리 |\n\n**/proc/[pid]/ 주요 파일**\n| 파일 | 내용 |\n|------|------|\n| status | PID, 상태, 메모리 사용량 |\n| cmdline | 실행 명령어 |\n| fd/ | 열린 파일 디스크립터 |\n| maps | 메모리 매핑 정보 |\n| stat | CPU 사용 통계 |\n\n**면접 질문**\n\n[주니어]\nQ: PCB에는 어떤 정보가 저장되나요?\nA: PCB에는 프로세스 식별자(PID), 프로세스 상태, 프로그램 카운터(다음 실행할 명령어 주소), CPU 레지스터 값, 메모리 관리 정보(페이지 테이블), 스케줄링 정보(우선순위), I/O 상태 정보(열린 파일 목록) 등이 저장됩니다.\n\n[시니어]\nQ: 컨텍스트 스위칭 비용을 줄이는 방법은?\nA: 1) 스레드 사용 - 같은 프로세스 내 스레드는 메모리 공간을 공유하므로 PCB 전체가 아닌 스택/레지스터만 전환, 2) 코루틴/경량 스레드 - 사용자 레벨에서 전환하여 커널 개입 최소화, 3) CPU 친화성(affinity) 설정 - 캐시 미스 감소, 4) 스케줄러 튜닝 - 타임 슬라이스 조정으로 불필요한 스위칭 감소."
      }
    ]
  },
  "02_프로세스/process-memory": {
    "id": "02_프로세스/process-memory",
    "title": "프로세스 메모리 구조",
    "category": "os",
    "subCategory": "02_프로세스",
    "language": "C",
    "description": "Code, Data, Heap, Stack 영역으로 구성된 프로세스 메모리 구조를 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🎯 프로세스 메모리 구조 완전 정복",
        "content": "**한 줄 요약**: 프로세스 메모리는 Code(코드), Data(전역변수), Heap(동적할당), Stack(지역변수) 4개 영역으로 구성됩니다.\n\n**초등학생도 이해할 비유 - 책상 정리**\n\n공부하는 책상을 상상해보세요:\n- 교과서 선반(Code) - 읽기만 하는 책들, 변경 불가\n- 필통(Data) - 항상 있는 문구류, 프로그램 시작부터 끝까지\n- 서랍(Heap) - 필요할 때 꺼내고 다 쓰면 정리\n- 책상 위(Stack) - 지금 하는 과목 노트, 과목 바뀌면 치움\n\n**각 영역의 특징:**\n1. Code - 실행할 기계어 코드, 읽기 전용\n2. Data - 전역/정적 변수, 프로그램 시작시 할당\n3. Heap - malloc/new로 동적 할당, 개발자가 관리\n4. Stack - 지역변수/매개변수, 함수 호출시 자동 관리\n\n**왜 알아야 하는가?**\n- 메모리 누수(Memory Leak) 이해와 방지\n- StackOverflow 에러 원인 파악\n- 효율적인 메모리 사용 설계\n- JVM 메모리 튜닝의 기초"
      },
      {
        "type": "code",
        "title": "💻 동작 원리",
        "language": "text",
        "code": "프로세스 메모리 레이아웃:\n\n    높은 주소\n    ┌─────────────────────────────────┐\n    │         커널 영역               │ ← 사용자 접근 불가\n    ├─────────────────────────────────┤\n    │                                 │\n    │         Stack 영역              │ ← 아래로 성장 ↓\n    │   (지역변수, 매개변수, 복귀주소) │\n    │                                 │\n    ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n    │              ↓                  │\n    │         빈 공간                 │\n    │              ↑                  │\n    ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n    │                                 │\n    │         Heap 영역               │ ← 위로 성장 ↑\n    │   (동적 할당: malloc, new)      │\n    │                                 │\n    ├─────────────────────────────────┤\n    │         BSS 영역                │ ← 초기화 안 된 전역변수\n    ├─────────────────────────────────┤\n    │         Data 영역               │ ← 초기화된 전역/정적 변수\n    ├─────────────────────────────────┤\n    │         Code(Text) 영역         │ ← 실행 코드 (읽기 전용)\n    └─────────────────────────────────┘\n    낮은 주소\n\n각 영역 크기 (Linux 기준):\n- Stack: 기본 8MB (ulimit -s로 확인)\n- Heap: 가용 메모리까지 확장 가능\n- 전체: 32bit = 4GB, 64bit = 128TB (가상 주소 공간)"
      },
      {
        "type": "code",
        "title": "🔧 실무 활용",
        "language": "c",
        "code": "// C언어로 각 메모리 영역 확인\n#include <stdio.h>\n#include <stdlib.h>\n\nint global_init = 100;      // Data 영역 (초기화된 전역)\nint global_uninit;          // BSS 영역 (초기화 안 된 전역)\n\nvoid function(int param) {  // param: Stack\n    int local = 10;         // Stack 영역\n    int *heap = malloc(sizeof(int) * 10);  // Heap 영역\n    \n    printf(\"Code 영역: %p\\n\", (void*)function);\n    printf(\"Data 영역: %p\\n\", (void*)&global_init);\n    printf(\"BSS 영역:  %p\\n\", (void*)&global_uninit);\n    printf(\"Heap 영역: %p\\n\", (void*)heap);\n    printf(\"Stack 영역: %p\\n\", (void*)&local);\n    \n    free(heap);  // Heap 해제 필수!\n}\n\n// Java에서의 메모리 구조\npublic class MemoryExample {\n    static int staticVar = 100;     // Method Area (Data)\n    int instanceVar = 10;           // Heap (객체와 함께)\n    \n    public void method(int param) { // param: Stack\n        int localVar = 5;           // Stack\n        Object obj = new Object();  // 참조는 Stack, 객체는 Heap\n        \n        // Java는 GC가 Heap을 자동 관리\n    }\n}\n\n// JVM 메모리 설정 (Spring Boot)\njava -Xms512m \\       # Heap 초기 크기\n     -Xmx2g \\         # Heap 최대 크기\n     -Xss1m \\         # Stack 크기 (스레드당)\n     -XX:MetaspaceSize=256m \\  # Method Area\n     -jar app.jar"
      },
      {
        "type": "tip",
        "title": "💡 체크리스트 & 면접",
        "content": "**메모리 영역 비교표**\n| 영역 | 저장 내용 | 크기 결정 | 관리 주체 |\n|------|----------|----------|----------|\n| Code | 실행 코드 | 컴파일 시 | OS |\n| Data | 전역/정적 변수 | 컴파일 시 | OS |\n| Heap | 동적 할당 | 런타임 | 개발자/GC |\n| Stack | 지역변수, 매개변수 | 런타임 | OS(자동) |\n\n**주요 에러와 원인**\n| 에러 | 원인 | 해결책 |\n|------|------|--------|\n| StackOverflow | 재귀 과다, 큰 배열 | 재귀 최적화, Heap 사용 |\n| OutOfMemory | Heap 부족, 메모리 누수 | 힙 증가, 누수 수정 |\n| Segmentation Fault | 잘못된 주소 접근 | 포인터 검증 |\n\n**면접 질문**\n\n[주니어]\nQ: Stack과 Heap의 차이점은?\nA: Stack은 함수 호출시 자동으로 할당/해제되며 LIFO 구조입니다. 지역변수, 매개변수가 저장되고 크기가 제한적입니다. Heap은 개발자가 명시적으로 할당/해제하며 크기가 유동적입니다. Java에서는 객체가 Heap에 생성되고 GC가 관리합니다.\n\n[시니어]\nQ: JVM 메모리 튜닝시 고려사항은?\nA: 1) Heap 크기 - Xms와 Xmx를 동일하게 설정하여 리사이징 오버헤드 방지, 2) GC 선택 - G1GC(균형), ZGC(저지연)등 워크로드에 맞게 선택, 3) Metaspace - 클래스 많으면 증가, 4) Stack - 스레드 많으면 줄여서 메모리 절약. 항상 모니터링하며 조정해야 합니다."
      }
    ]
  },
  "02_프로세스/process-state": {
    "id": "02_프로세스/process-state",
    "title": "프로세스 상태",
    "category": "os",
    "subCategory": "02_프로세스",
    "language": "C",
    "description": "New, Ready, Running, Waiting, Terminated 5가지 프로세스 상태를 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🎯 프로세스 상태 완전 정복",
        "content": "**한 줄 요약**: 프로세스는 생성(New), 준비(Ready), 실행(Running), 대기(Waiting), 종료(Terminated) 5가지 상태를 거치며 생명주기를 가집니다.\n\n**초등학생도 이해할 비유 - 놀이공원 롤러코스터**\n\n롤러코스터를 상상해보세요:\n- 티켓 구매(New) - 탑승 자격 획득\n- 대기줄(Ready) - 탑승 순서 기다림\n- 탑승중(Running) - 실제로 롤러코스터 타는 중\n- 화장실(Waiting) - 급한 일 처리하고 다시 대기줄로\n- 하차(Terminated) - 탑승 완료, 퇴장\n\n**각 상태 설명:**\n1. New - 프로세스 생성 중, PCB 할당\n2. Ready - CPU 할당 대기 중, Ready Queue에서 대기\n3. Running - CPU에서 실행 중 (동시에 1개만)\n4. Waiting(Blocked) - I/O 완료 등 이벤트 대기\n5. Terminated - 실행 완료, 자원 반납 중\n\n**왜 알아야 하는가?**\n- 프로세스 스케줄링 이해\n- top/ps 명령어 상태 해석\n- 성능 병목 분석 (D 상태 프로세스 등)\n- 멀티태스킹 원리 파악"
      },
      {
        "type": "code",
        "title": "💻 동작 원리",
        "language": "text",
        "code": "프로세스 상태 전이 다이어그램:\n\n                        ┌───────────────────────┐\n                        │                       │\n                        ▼                       │\n    ┌─────┐  admit   ┌───────┐  dispatch  ┌─────────┐\n    │ New │ ───────► │ Ready │ ─────────► │ Running │\n    └─────┘          └───────┘            └─────────┘\n                        ▲  ▲                  │ │ │\n                        │  │   timeout/       │ │ │\n                        │  │   preempt        │ │ │\n                        │  └──────────────────┘ │ │\n                        │                       │ │\n                        │   I/O or event        │ │  exit\n                        │    complete           │ │\n                        │                       │ │\n                     ┌─────────┐   I/O or      │ │   ┌────────────┐\n                     │ Waiting │ ◄── event ────┘ └──►│ Terminated │\n                     │(Blocked)│     wait            └────────────┘\n                     └─────────┘\n\n상태 전이 조건:\n1. New → Ready     : 프로세스 생성 완료 (admit)\n2. Ready → Running : CPU 스케줄러가 선택 (dispatch)\n3. Running → Ready : 타임아웃, 더 높은 우선순위 등장 (preempt)\n4. Running → Waiting: I/O 요청, 이벤트 대기 (I/O wait)\n5. Waiting → Ready : I/O 완료, 이벤트 발생 (I/O complete)\n6. Running → Terminated: 프로세스 종료 (exit)\n\nLinux 프로세스 상태 코드:\n┌──────┬─────────────┬─────────────────────────────┐\n│ 코드 │ 상태        │ 설명                        │\n├──────┼─────────────┼─────────────────────────────┤\n│ R    │ Running     │ 실행 중 또는 Ready Queue    │\n│ S    │ Sleeping    │ 인터럽트 가능한 대기        │\n│ D    │ Disk Sleep  │ 인터럽트 불가 대기 (I/O)    │\n│ Z    │ Zombie      │ 종료되었지만 부모가 수습 안함│\n│ T    │ Stopped     │ 시그널로 중지됨             │\n└──────┴─────────────┴─────────────────────────────┘"
      },
      {
        "type": "code",
        "title": "🔧 실무 활용",
        "language": "bash",
        "code": "# Linux에서 프로세스 상태 확인\n$ ps aux\nUSER  PID %CPU %MEM  STAT COMMAND\nroot    1  0.0  0.1  Ss   /sbin/init\nroot  123  0.5  2.0  R    java -jar app.jar\nroot  456  0.0  0.1  S    sleep 100\nroot  789  0.0  0.0  D    dd if=/dev/sda  # 디스크 I/O 대기\nroot  999  0.0  0.0  Z    <defunct>       # 좀비 프로세스\n\n# 상태별 프로세스 수 확인\n$ ps -eo stat | sort | uniq -c\n    150 S    # Sleeping\n     10 R    # Running\n      2 D    # Disk Sleep (주의 필요!)\n      1 Z    # Zombie (정리 필요)\n\n# Java에서 스레드 상태 확인\npublic class ThreadStateDemo {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(() -> {\n            try {\n                Thread.sleep(10000);  // TIMED_WAITING 상태\n            } catch (InterruptedException e) {}\n        });\n        \n        System.out.println(thread.getState());  // NEW\n        thread.start();\n        System.out.println(thread.getState());  // RUNNABLE\n        Thread.sleep(100);\n        System.out.println(thread.getState());  // TIMED_WAITING\n        thread.join();\n        System.out.println(thread.getState());  // TERMINATED\n    }\n}\n\n// Java Thread 상태:\n// NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED\n\n# 좀비 프로세스 정리\n$ ps aux | grep Z        # 좀비 프로세스 찾기\n$ kill -SIGCHLD <PPID>   # 부모에게 SIGCHLD 전송\n$ kill -9 <PPID>         # 부모 강제 종료 (최후 수단)"
      },
      {
        "type": "tip",
        "title": "💡 체크리스트 & 면접",
        "content": "**프로세스 5가지 상태**\n| 상태 | 설명 | Linux 코드 |\n|------|------|------------|\n| New | 프로세스 생성 중 | - |\n| Ready | CPU 대기 중 | R |\n| Running | CPU에서 실행 중 | R |\n| Waiting | I/O 등 이벤트 대기 | S, D |\n| Terminated | 종료됨 | Z (좀비) |\n\n**주의해야 할 상태**\n| 상태 | 문제점 | 해결책 |\n|------|--------|--------|\n| D (Disk Sleep) | 많으면 I/O 병목 | 디스크 성능 확인 |\n| Z (Zombie) | 자원 누수 | 부모 프로세스 수정 |\n| 과다한 R | CPU 부족 | 스케일 아웃 |\n\n**면접 질문**\n\n[주니어]\nQ: 프로세스 상태 5가지와 전이 조건을 설명해주세요.\nA: New(생성)에서 Ready(준비)로 전이하고, 스케줄러가 선택하면 Running(실행)이 됩니다. 실행 중 I/O 요청시 Waiting(대기)으로, 타임아웃시 Ready로 돌아갑니다. 실행 완료시 Terminated(종료)가 됩니다.\n\n[시니어]\nQ: 좀비 프로세스가 발생하는 원인과 해결책은?\nA: 자식 프로세스가 종료되었지만 부모가 wait()를 호출하지 않아 PCB가 남아있는 상태입니다. 해결책: 1) 부모 프로세스에서 wait()/waitpid() 호출, 2) SIGCHLD 시그널 핸들러 등록, 3) 부모를 double fork로 init에 입양시키기. 좀비 자체는 자원을 많이 안 쓰지만, PID 고갈 가능성이 있습니다."
      }
    ]
  },
  "02_프로세스스레드/context-switching": {
    "id": "02_프로세스스레드/context-switching",
    "title": "Context Switching",
    "category": "os",
    "subCategory": "02_프로세스스레드",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Context Switching",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "02_프로세스스레드/process-concept": {
    "id": "02_프로세스스레드/process-concept",
    "title": "프로세스 개념",
    "category": "os",
    "subCategory": "02_프로세스스레드",
    "language": "C",
    "description": "프로세스의 기본 개념과 특징을 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🎯 프로세스 개념 완전 정복",
        "content": "**한 줄 요약**: 프로세스는 실행 중인 프로그램으로, 독립된 메모리 공간과 자원을 가진 실행 단위입니다.\n\n**초등학생도 이해할 비유 - 요리사와 레시피**\n\n주방을 상상해보세요:\n- 레시피(프로그램) - 종이에 적힌 요리 방법, 실행 전\n- 요리하는 행위(프로세스) - 레시피를 보고 실제로 요리\n- 조리대(메모리) - 재료와 도구를 놓는 공간\n- 요리사(CPU) - 실제로 요리를 수행\n\n**프로그램 vs 프로세스:**\n- 프로그램: 디스크에 저장된 정적인 코드\n- 프로세스: 메모리에 올라와 실행 중인 동적인 상태\n\n**프로세스의 특징:**\n1. 독립된 메모리 공간 (Code, Data, Heap, Stack)\n2. 최소 하나의 스레드 포함\n3. 고유한 PID (Process ID)\n4. 자원의 소유 단위 (파일, 소켓 등)\n\n**왜 알아야 하는가?**\n- 멀티프로세싱 vs 멀티스레딩 선택\n- 시스템 자원 관리 이해\n- 프로세스 간 통신(IPC) 필요성 파악"
      },
      {
        "type": "code",
        "title": "💻 동작 원리",
        "language": "text",
        "code": "프로그램에서 프로세스로:\n\n  디스크                        메모리(RAM)\n ┌──────────────┐             ┌──────────────────────┐\n │              │             │      Process A       │\n │  program.exe │    로딩     │  ┌────────────────┐  │\n │  (실행파일)  │ ──────────► │  │ Code (Text)    │  │\n │              │             │  ├────────────────┤  │\n │  - 코드      │             │  │ Data           │  │\n │  - 초기 데이터│             │  ├────────────────┤  │\n │              │             │  │ Heap           │  │\n └──────────────┘             │  ├────────────────┤  │\n                              │  │ Stack          │  │\n                              │  └────────────────┘  │\n                              │  PCB: PID=1234       │\n                              └──────────────────────┘\n\n같은 프로그램, 여러 프로세스:\n\n  Chrome.exe (1개)            Chrome 프로세스 (여러 개)\n ┌──────────────┐           ┌────────┐ ┌────────┐ ┌────────┐\n │              │    실행   │ PID:100│ │ PID:101│ │ PID:102│\n │  Chrome.exe  │ ────────► │ 탭 1   │ │ 탭 2   │ │ 탭 3   │\n │              │           │ 독립   │ │ 독립   │ │ 독립   │\n │              │           │ 메모리 │ │ 메모리 │ │ 메모리 │\n └──────────────┘           └────────┘ └────────┘ └────────┘\n\n프로세스 생성 과정:\n1. fork() 시스템 콜 → 부모 프로세스 복제\n2. exec() 시스템 콜 → 새 프로그램 코드로 교체\n\n  Parent Process              Child Process\n ┌──────────────┐   fork()   ┌──────────────┐\n │ PID: 100     │ ─────────► │ PID: 101     │\n │ Code: A      │   복사     │ Code: A      │\n │ Data: {...}  │            │ Data: {...}  │\n └──────────────┘            └──────────────┘\n                                    │\n                               exec()\n                                    ▼\n                             ┌──────────────┐\n                             │ PID: 101     │\n                             │ Code: B      │ ← 새 프로그램\n                             │ Data: {...}  │\n                             └──────────────┘"
      },
      {
        "type": "code",
        "title": "🔧 실무 활용",
        "language": "c",
        "code": "// C언어 - 프로세스 생성\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    printf(\"Parent PID: %d\\n\", getpid());\n    \n    pid_t pid = fork();  // 프로세스 복제\n    \n    if (pid < 0) {\n        perror(\"fork failed\");\n        return 1;\n    } else if (pid == 0) {\n        // 자식 프로세스\n        printf(\"Child PID: %d, Parent: %d\\n\", getpid(), getppid());\n        execl(\"/bin/ls\", \"ls\", \"-la\", NULL);  // 새 프로그램 실행\n    } else {\n        // 부모 프로세스\n        printf(\"Created child with PID: %d\\n\", pid);\n        wait(NULL);  // 자식 종료 대기\n        printf(\"Child finished\\n\");\n    }\n    return 0;\n}\n\n// Java - 프로세스 생성\npublic class ProcessExample {\n    public static void main(String[] args) throws Exception {\n        // ProcessBuilder로 새 프로세스 생성\n        ProcessBuilder pb = new ProcessBuilder(\"notepad.exe\", \"test.txt\");\n        pb.directory(new File(\"C:/temp\"));\n        pb.environment().put(\"MY_VAR\", \"value\");\n        \n        Process process = pb.start();  // 프로세스 시작\n        \n        // 프로세스 출력 읽기\n        BufferedReader reader = new BufferedReader(\n            new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n        \n        int exitCode = process.waitFor();  // 종료 대기\n        System.out.println(\"Exit code: \" + exitCode);\n    }\n}\n\n// Spring에서 외부 프로세스 실행\n@Service\npublic class CommandService {\n    public String executeCommand(String command) {\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            // ... 결과 처리\n        } catch (IOException e) {\n            log.error(\"Command execution failed\", e);\n        }\n    }\n}"
      },
      {
        "type": "tip",
        "title": "💡 체크리스트 & 면접",
        "content": "**프로그램 vs 프로세스 비교**\n| 구분 | 프로그램 | 프로세스 |\n|------|----------|----------|\n| 상태 | 정적 | 동적 |\n| 저장 위치 | 디스크 | 메모리 |\n| 자원 소유 | X | O (메모리, 파일 등) |\n| 생명주기 | 없음 | 있음 (생성-종료) |\n| 개수 | 1개 | 여러 개 가능 |\n\n**프로세스 생성 시스템 콜**\n| 시스템 콜 | 역할 | 특징 |\n|----------|------|------|\n| fork() | 프로세스 복제 | 부모와 동일한 복사본 |\n| exec() | 프로그램 교체 | 코드/데이터 새로 로드 |\n| wait() | 자식 종료 대기 | 좀비 방지 |\n| exit() | 프로세스 종료 | 자원 반납 |\n\n**면접 질문**\n\n[주니어]\nQ: 프로그램과 프로세스의 차이점은?\nA: 프로그램은 디스크에 저장된 정적인 실행 파일이고, 프로세스는 그 프로그램이 메모리에 로드되어 실행 중인 동적인 상태입니다. 하나의 프로그램에서 여러 프로세스가 생성될 수 있습니다.\n\n[시니어]\nQ: fork()가 Copy-on-Write를 사용하는 이유는?\nA: fork() 시 자식 프로세스의 전체 메모리를 즉시 복사하면 비효율적입니다. 대신 부모와 자식이 같은 물리 페이지를 공유하고, 둘 중 하나가 수정할 때만 해당 페이지를 복사합니다. 이로써 fork() 직후 exec()하는 일반적인 패턴에서 불필요한 복사를 피할 수 있습니다."
      }
    ]
  },
  "02_프로세스스레드/process-vs-thread": {
    "id": "02_프로세스스레드/process-vs-thread",
    "title": "프로세스 vs 스레드 비교",
    "category": "os",
    "subCategory": "02_프로세스스레드",
    "language": "C",
    "description": "프로세스와 스레드의 차이점을 비교하고 적절한 선택 기준을 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🎯 프로세스 vs 스레드 완전 정복",
        "content": "**한 줄 요약**: 프로세스는 독립된 메모리 공간을 가진 실행 단위이고, 스레드는 프로세스 내에서 메모리를 공유하는 가벼운 실행 단위입니다.\n\n**초등학생도 이해할 비유 - 집과 방**\n\n아파트를 상상해보세요:\n- 각 세대(프로세스) - 독립된 공간, 이웃집에 못 들어감\n- 세대 내 방들(스레드) - 거실/주방은 공유, 각자 방은 개인\n\n**프로세스 = 독립된 세대**\n- 자기만의 주방, 화장실 (독립 메모리)\n- 이웃과 소통하려면 초인종, 전화 (IPC)\n- 한 세대 문제가 다른 세대에 영향 X\n\n**스레드 = 같은 세대의 가족**\n- 거실, 주방 함께 사용 (공유 메모리)\n- 말로 바로 소통 (직접 통신)\n- 한 사람이 물 틀어놓으면 다른 사람도 영향\n\n**언제 무엇을 선택?**\n- 프로세스: 안정성 중요, 독립 실행 필요\n- 스레드: 성능 중요, 데이터 공유 필요"
      },
      {
        "type": "code",
        "title": "💻 동작 원리",
        "language": "text",
        "code": "프로세스 vs 스레드 비교 다이어그램:\n\n┌─────────── 멀티프로세스 ───────────┐  ┌─────────── 멀티스레드 ───────────┐\n│                                    │  │                                  │\n│  Process A       Process B         │  │           Process                │\n│ ┌──────────┐   ┌──────────┐       │  │ ┌──────────────────────────────┐ │\n│ │ Code     │   │ Code     │       │  │ │         Code (공유)          │ │\n│ ├──────────┤   ├──────────┤       │  │ ├──────────────────────────────┤ │\n│ │ Data     │   │ Data     │       │  │ │         Data (공유)          │ │\n│ ├──────────┤   ├──────────┤       │  │ ├──────────────────────────────┤ │\n│ │ Heap     │   │ Heap     │       │  │ │         Heap (공유)          │ │\n│ ├──────────┤   ├──────────┤       │  │ ├──────────┬───────────────────┤ │\n│ │ Stack    │   │ Stack    │       │  │ │ Stack A  │      Stack B      │ │\n│ └──────────┘   └──────────┘       │  │ └──────────┴───────────────────┘ │\n│       ↑              ↑             │  │  Thread A      Thread B          │\n│       └──── IPC ─────┘             │  │       ↑            ↑              │\n│          (파이프, 소켓)             │  │       └── 직접 접근 ─┘             │\n└────────────────────────────────────┘  └──────────────────────────────────┘\n\n비용 비교:\n┌────────────────────────────────────────────────────────────────┐\n│                    생성 비용                                    │\n├────────────────────────────────────────────────────────────────┤\n│ 프로세스: ████████████████████████████████  (메모리 복사, PCB) │\n│ 스레드:   ████████  (Stack만 할당)                              │\n└────────────────────────────────────────────────────────────────┘\n\n┌────────────────────────────────────────────────────────────────┐\n│                컨텍스트 스위칭 비용                              │\n├────────────────────────────────────────────────────────────────┤\n│ 프로세스: ████████████████████████  (전체 메모리 맵 전환)       │\n│ 스레드:   ████████  (Stack, 레지스터만)                         │\n└────────────────────────────────────────────────────────────────┘\n\n┌────────────────────────────────────────────────────────────────┐\n│                    통신 비용                                    │\n├────────────────────────────────────────────────────────────────┤\n│ 프로세스: ████████████████  (IPC 필요 - 커널 경유)              │\n│ 스레드:   ████  (공유 메모리 직접 접근)                         │\n└────────────────────────────────────────────────────────────────┘"
      },
      {
        "type": "code",
        "title": "🔧 실무 활용",
        "language": "java",
        "code": "// 멀티프로세스 예시: Chrome 브라우저\n// - 각 탭이 독립 프로세스\n// - 한 탭 크래시가 다른 탭에 영향 X\n\n// Java에서 멀티프로세스\npublic class MultiProcessExample {\n    public static void main(String[] args) throws Exception {\n        // 별도 프로세스로 실행\n        ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"worker.jar\");\n        Process worker1 = pb.start();\n        Process worker2 = pb.start();\n        // 각 워커는 독립된 JVM (힙, 스택 모두 분리)\n    }\n}\n\n// 멀티스레드 예시: 웹 서버\n// - 요청마다 스레드 할당\n// - 공유 데이터(캐시, 커넥션 풀) 활용\n\n// Java에서 멀티스레드\npublic class MultiThreadExample {\n    private static int sharedCounter = 0;  // 공유 자원\n    \n    public static void main(String[] args) {\n        // ExecutorService로 스레드 풀 관리\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n        \n        for (int i = 0; i < 100; i++) {\n            executor.submit(() -> {\n                // 공유 자원 접근 시 동기화 필요!\n                synchronized (MultiThreadExample.class) {\n                    sharedCounter++;\n                }\n            });\n        }\n        \n        executor.shutdown();\n    }\n}\n\n// 실무 선택 기준\n/*\n멀티프로세스 선택:\n- 안정성이 최우선 (한 프로세스 죽어도 서비스 유지)\n- 언어가 다른 컴포넌트 연동\n- CPU 집약적 작업 (GIL 우회 - Python)\n\n멀티스레드 선택:\n- 성능이 최우선 (빠른 통신, 낮은 오버헤드)\n- 데이터 공유가 많은 경우\n- I/O 바운드 작업 (웹 서버, DB 접근)\n*/\n\n// Spring Boot: 기본적으로 멀티스레드 (톰캣 스레드 풀)\nserver:\n  tomcat:\n    threads:\n      max: 200      # 최대 스레드\n      min-spare: 10 # 최소 유지 스레드"
      },
      {
        "type": "tip",
        "title": "💡 체크리스트 & 면접",
        "content": "**프로세스 vs 스레드 종합 비교**\n| 항목 | 프로세스 | 스레드 |\n|------|----------|--------|\n| 메모리 | 독립 공간 | 공유 (Stack만 독립) |\n| 생성 비용 | 높음 | 낮음 |\n| 컨텍스트 스위칭 | 느림 | 빠름 |\n| 통신 | IPC (느림) | 공유 메모리 (빠름) |\n| 안정성 | 높음 (격리) | 낮음 (영향 전파) |\n| 동기화 | 불필요 | 필요 |\n| 디버깅 | 쉬움 | 어려움 |\n\n**실무 선택 가이드**\n| 상황 | 추천 | 이유 |\n|------|------|------|\n| 웹 서버 | 스레드 | 빠른 응답, 커넥션 풀 공유 |\n| 브라우저 탭 | 프로세스 | 탭 간 격리, 보안 |\n| CPU 집약 연산 | 프로세스 | 멀티코어 활용 |\n| I/O 바운드 | 스레드 | 대기 시간 활용 |\n\n**면접 질문**\n\n[주니어]\nQ: 프로세스와 스레드의 차이점은?\nA: 프로세스는 독립된 메모리 공간을 가져 서로 직접 접근이 불가능하고 IPC로 통신합니다. 스레드는 같은 프로세스 내에서 Code, Data, Heap을 공유하며, Stack만 독립적입니다. 스레드가 생성/전환 비용이 낮지만 동기화가 필요합니다.\n\n[시니어]\nQ: 대규모 트래픽 처리 시 멀티프로세스와 멀티스레드 중 어떤 것을 선택하겠습니까?\nA: 상황에 따라 다릅니다. 웹 서버는 멀티스레드 + 이벤트 루프(Netty, WebFlux)로 I/O 대기 시간을 활용합니다. CPU 집약적 작업은 프로세스 분리 또는 워커 스레드 풀을 사용합니다. 실제로는 둘을 조합하여 멀티프로세스(수평 확장) + 멀티스레드(프로세스 내 동시성)로 구성합니다."
      }
    ]
  },
  "02_프로세스스레드/thread-concept": {
    "id": "02_프로세스스레드/thread-concept",
    "title": "스레드 개념",
    "category": "os",
    "subCategory": "02_프로세스스레드",
    "language": "C",
    "description": "프로세스 내 실행 흐름인 스레드의 개념과 특징을 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🎯 스레드 개념 완전 정복",
        "content": "**한 줄 요약**: 스레드는 프로세스 내에서 실행되는 가벼운 실행 단위로, 같은 프로세스의 스레드들은 메모리(Code, Data, Heap)를 공유합니다.\n\n**초등학생도 이해할 비유 - 같은 주방의 요리사들**\n\n레스토랑 주방을 상상해보세요:\n- 주방(프로세스) - 요리하는 공간 전체\n- 요리사들(스레드) - 같은 주방에서 일하는 사람들\n- 냉장고/조리대(공유 메모리) - 모든 요리사가 함께 사용\n- 개인 도마(Stack) - 각 요리사의 개인 작업 공간\n\n**스레드의 특징:**\n1. 프로세스 내 실행 흐름\n2. Code, Data, Heap 영역 공유\n3. 각자 독립적인 Stack과 레지스터\n4. 같은 프로세스 내 스레드끼리 빠른 통신\n\n**왜 스레드를 사용하는가?**\n- 병렬 처리로 성능 향상\n- 프로세스보다 생성/전환 비용 저렴\n- 메모리 공유로 통신 간편\n- 응답성 향상 (UI + 백그라운드 작업)"
      },
      {
        "type": "code",
        "title": "💻 동작 원리",
        "language": "text",
        "code": "프로세스 vs 스레드 메모리 구조:\n\n  멀티프로세스                    멀티스레드\n ┌─────────────┐                ┌─────────────────────────┐\n │ Process A   │                │       Process           │\n │ ┌─────────┐ │                │ ┌─────────────────────┐ │\n │ │  Code   │ │                │ │       Code          │ │\n │ ├─────────┤ │                │ ├─────────────────────┤ │\n │ │  Data   │ │                │ │       Data          │ │\n │ ├─────────┤ │                │ ├─────────────────────┤ │\n │ │  Heap   │ │                │ │       Heap          │ │\n │ ├─────────┤ │                │ ├─────────────────────┤ │\n │ │  Stack  │ │                │ │ Stack A │ Stack B   │ │\n │ └─────────┘ │                │ └─────────┴───────────┘ │\n └─────────────┘                │  Thread A   Thread B    │\n ┌─────────────┐                └─────────────────────────┘\n │ Process B   │                  ▲ 메모리 공유\n │ ┌─────────┐ │\n │ │  Code   │ │\n │ ├─────────┤ │\n │ │  Data   │ │  ← 완전히 분리\n │ ├─────────┤ │\n │ │  Heap   │ │\n │ ├─────────┤ │\n │ │  Stack  │ │\n │ └─────────┘ │\n └─────────────┘\n\n스레드별 독립/공유 영역:\n┌─────────────────────────────────────────────────┐\n│              프로세스 메모리                     │\n├─────────────────────────────────────────────────┤\n│ [공유]                                          │\n│  - Code: 실행 코드                              │\n│  - Data: 전역/정적 변수                         │\n│  - Heap: 동적 할당 메모리                       │\n│  - 파일 디스크립터, 시그널 핸들러               │\n├─────────────────────────────────────────────────┤\n│ [스레드별 독립]                                 │\n│  - Stack: 지역변수, 함수 호출 정보              │\n│  - PC(Program Counter): 다음 실행 명령어        │\n│  - 레지스터 집합                                │\n│  - 스레드 ID (TID)                              │\n└─────────────────────────────────────────────────┘"
      },
      {
        "type": "code",
        "title": "🔧 실무 활용",
        "language": "java",
        "code": "// Java 스레드 생성 방법 1: Thread 상속\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Thread: \" + Thread.currentThread().getName());\n    }\n}\n\n// 방법 2: Runnable 구현 (권장)\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Runnable: \" + Thread.currentThread().getName());\n    }\n}\n\n// 방법 3: Lambda (Java 8+)\nThread thread = new Thread(() -> {\n    System.out.println(\"Lambda Thread\");\n});\n\n// 스레드 실행\npublic class ThreadExample {\n    public static void main(String[] args) {\n        // 스레드 생성 및 시작\n        Thread t1 = new MyThread();\n        Thread t2 = new Thread(new MyRunnable());\n        Thread t3 = new Thread(() -> System.out.println(\"Lambda\"));\n        \n        t1.start();  // run()이 아닌 start() 호출!\n        t2.start();\n        t3.start();\n        \n        // 스레드 종료 대기\n        try {\n            t1.join();\n            t2.join();\n            t3.join();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\n// Spring에서 비동기 처리\n@Service\npublic class AsyncService {\n    \n    @Async  // 별도 스레드에서 실행\n    public CompletableFuture<String> asyncMethod() {\n        // 시간이 오래 걸리는 작업\n        return CompletableFuture.completedFuture(\"Done\");\n    }\n}\n\n// 스레드 풀 사용 (권장)\n@Configuration\n@EnableAsync\npublic class AsyncConfig {\n    @Bean\n    public Executor taskExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(10);\n        executor.setMaxPoolSize(50);\n        executor.setQueueCapacity(100);\n        executor.setThreadNamePrefix(\"Async-\");\n        executor.initialize();\n        return executor;\n    }\n}"
      },
      {
        "type": "tip",
        "title": "💡 체크리스트 & 면접",
        "content": "**스레드 공유/독립 영역**\n| 영역 | 공유 여부 | 설명 |\n|------|----------|------|\n| Code | 공유 | 실행 코드 |\n| Data | 공유 | 전역/정적 변수 |\n| Heap | 공유 | 동적 할당 객체 |\n| Stack | 독립 | 지역변수, 매개변수 |\n| PC/레지스터 | 독립 | 실행 위치, CPU 상태 |\n\n**스레드 장단점**\n| 장점 | 단점 |\n|------|------|\n| 생성 비용 낮음 | 동기화 필요 |\n| 컨텍스트 스위칭 빠름 | 하나가 죽으면 전체 영향 |\n| 메모리 공유로 통신 쉬움 | 디버깅 어려움 |\n| 응답성 향상 | 공유 자원 경쟁 |\n\n**면접 질문**\n\n[주니어]\nQ: 스레드가 공유하는 자원과 독립적인 자원은?\nA: Code, Data, Heap 영역과 파일 디스크립터는 공유합니다. 반면 Stack, Program Counter, 레지스터는 각 스레드가 독립적으로 가집니다. 이로 인해 스레드 간 통신은 쉽지만 동기화가 필요합니다.\n\n[시니어]\nQ: 사용자 수준 스레드와 커널 수준 스레드의 차이는?\nA: 사용자 수준 스레드는 라이브러리가 관리하여 커널이 모르므로 전환이 빠르지만, 하나가 블로킹되면 전체가 멈춥니다. 커널 수준 스레드는 OS가 직접 관리하여 블로킹 시에도 다른 스레드가 실행되지만, 전환 비용이 큽니다. Java의 스레드는 1:1 모델로 커널 스레드와 매핑됩니다."
      }
    ]
  },
  "03_동기화/deadlock": {
    "id": "03_동기화/deadlock",
    "title": "Deadlock",
    "category": "os",
    "subCategory": "03_동기화",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Deadlock",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "03_동기화/monitor": {
    "id": "03_동기화/monitor",
    "title": "Monitor",
    "category": "os",
    "subCategory": "03_동기화",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Monitor",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "03_동기화/mutex": {
    "id": "03_동기화/mutex",
    "title": "Mutex",
    "category": "os",
    "subCategory": "03_동기화",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Mutex",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "03_동기화/race-condition": {
    "id": "03_동기화/race-condition",
    "title": "Race Condition",
    "category": "os",
    "subCategory": "03_동기화",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Race Condition",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "03_동기화/semaphore": {
    "id": "03_동기화/semaphore",
    "title": "Semaphore",
    "category": "os",
    "subCategory": "03_동기화",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Semaphore",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "03_스레드/multi-thread": {
    "id": "03_스레드/multi-thread",
    "title": "Multi Thread",
    "category": "os",
    "subCategory": "03_스레드",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Multi Thread",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "03_스레드/user-kernel-thread": {
    "id": "03_스레드/user-kernel-thread",
    "title": "User Kernel Thread",
    "category": "os",
    "subCategory": "03_스레드",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "User Kernel Thread",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "04_메모리/memory-structure": {
    "id": "04_메모리/memory-structure",
    "title": "메모리 구조",
    "category": "os",
    "subCategory": "04_메모리",
    "language": "C",
    "description": "물리 메모리와 논리 메모리의 구조와 차이점을 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "메모리 구조 개념",
        "content": "메모리 구조는 프로그램이 실행될 때 데이터가 저장되는 방식을 정의합니다.\n\n**한 줄 요약**: 물리 메모리는 실제 RAM, 논리 메모리는 프로세스가 보는 가상의 주소 공간입니다.\n\n**도서관 비유**:\n- 물리 메모리 = 도서관의 실제 책장 (고정된 물리적 위치)\n- 논리 메모리 = 도서 목록 카드 (책의 논리적 분류 번호)\n- 사서(MMU) = 목록 번호를 실제 책장 위치로 변환\n\n**핵심 개념**:\n1. **물리 메모리 (Physical Memory)**\n   - 실제 RAM 하드웨어\n   - 물리 주소로 직접 접근\n   - 크기가 고정됨\n\n2. **논리 메모리 (Logical Memory)**\n   - 프로세스가 인식하는 주소 공간\n   - 가상 주소 사용\n   - 각 프로세스마다 독립적\n\n3. **주소 변환**\n   - MMU(Memory Management Unit)가 담당\n   - 논리 주소 -> 물리 주소 매핑\n   - 페이지 테이블 활용"
      },
      {
        "type": "code",
        "title": "메모리 레이아웃 다이어그램",
        "language": "text",
        "code": "[ 프로세스 메모리 레이아웃 ]\n\n높은 주소 (0xFFFFFFFF)\n+------------------+\n|      Stack       | <- 지역변수, 함수 호출 정보\n|        |         |    (아래로 성장)\n|        v         |\n+------------------+\n|                  |\n|   빈 공간        | <- Stack과 Heap 사이 여유 공간\n|                  |\n+------------------+\n|        ^         |\n|        |         |    (위로 성장)\n|       Heap       | <- 동적 할당 메모리 (malloc)\n+------------------+\n|       BSS        | <- 초기화되지 않은 전역변수\n+------------------+\n|       Data       | <- 초기화된 전역변수\n+------------------+\n|       Text       | <- 프로그램 코드 (Read-Only)\n+------------------+\n낮은 주소 (0x00000000)\n\n[ 주소 변환 과정 ]\n\n논리 주소        MMU           물리 주소\n0x0040 -----> [페이지 테이블] -----> 0x7040\n\n+--------+--------+     +--------+--------+\n| 페이지 | 오프셋 |     | 프레임 | 오프셋 |\n| 번호   |        | --> | 번호   |        |\n+--------+--------+     +--------+--------+\n   4        40             7        40"
      },
      {
        "type": "code",
        "title": "C 메모리 영역 확인",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Data 영역 - 초기화된 전역변수\nint global_init = 100;\n\n// BSS 영역 - 초기화되지 않은 전역변수\nint global_uninit;\n\nvoid memory_layout_demo() {\n    // Stack 영역 - 지역변수\n    int local_var = 50;\n    \n    // Heap 영역 - 동적 할당\n    int *heap_ptr = (int*)malloc(sizeof(int) * 10);\n    \n    printf(\"=== 메모리 레이아웃 ===\");\n    printf(\"Text (코드): %p\", (void*)memory_layout_demo);\n    printf(\"Data (초기화): %p\", (void*)&global_init);\n    printf(\"BSS (미초기화): %p\", (void*)&global_uninit);\n    printf(\"Heap (동적): %p\", (void*)heap_ptr);\n    printf(\"Stack (지역): %p\", (void*)&local_var);\n    \n    free(heap_ptr);\n}\n\nint main() {\n    memory_layout_demo();\n    return 0;\n}"
      },
      {
        "type": "tip",
        "title": "면접 대비 정리",
        "content": "**물리 vs 논리 메모리 비교표**:\n| 구분 | 물리 메모리 | 논리 메모리 |\n|------|------------|------------|\n| 정의 | 실제 RAM | 가상 주소 공간 |\n| 주소 | 물리 주소 | 가상 주소 |\n| 크기 | RAM 용량 | 프로세스별 독립 |\n| 관리 | 하드웨어 | OS + MMU |\n| 접근 | 직접 접근 | 주소 변환 필요 |\n\n**면접 빈출 질문**:\n\nQ1: 논리 주소와 물리 주소의 차이점은?\nA: 논리 주소는 프로세스가 사용하는 가상 주소이고, 물리 주소는 실제 RAM의 위치입니다. MMU가 논리->물리 변환을 수행합니다.\n\nQ2: 프로세스 메모리 레이아웃을 설명하세요.\nA: 낮은 주소부터 Text(코드), Data(초기화된 전역), BSS(미초기화 전역), Heap(동적할당, 위로 성장), Stack(지역변수, 아래로 성장) 순서입니다.\n\nQ3: Stack과 Heap의 차이점은?\nA: Stack은 컴파일 타임에 크기 결정, LIFO, 자동 해제. Heap은 런타임 동적 할당, 수동 해제 필요.\n\n**핵심 키워드**: MMU, 페이지 테이블, 주소 바인딩, 메모리 보호"
      }
    ]
  },
  "04_메모리/paging": {
    "id": "04_메모리/paging",
    "title": "페이징",
    "category": "os",
    "subCategory": "04_메모리",
    "language": "C",
    "description": "고정 크기 블록으로 메모리를 관리하는 페이징 기법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "페이징 개념",
        "content": "페이징은 메모리를 고정 크기 블록(페이지/프레임)으로 나누어 관리하는 기법입니다.\n\n**한 줄 요약**: 메모리를 동일한 크기의 블록으로 나눠 외부 단편화를 해결합니다.\n\n**아파트 비유**:\n- 페이지 = 이사할 짐 박스 (모두 같은 크기)\n- 프레임 = 아파트 방 (모두 같은 크기)\n- 페이지 테이블 = 짐 박스가 어느 방에 있는지 기록\n- 연속된 방이 필요 없음 (외부 단편화 없음)\n\n**핵심 구성요소**:\n1. **페이지 (Page)**: 가상 메모리의 고정 크기 블록\n2. **프레임 (Frame)**: 물리 메모리의 고정 크기 블록\n3. **페이지 테이블**: 페이지->프레임 매핑 정보\n4. **페이지 크기**: 보통 4KB (2^12 bytes)\n\n**장점**:\n- 외부 단편화 완전 해결\n- 메모리 할당이 단순\n- 공유 메모리 구현 용이\n\n**단점**:\n- 내부 단편화 발생 가능\n- 페이지 테이블 메모리 오버헤드"
      },
      {
        "type": "code",
        "title": "페이징 주소 변환 다이어그램",
        "language": "text",
        "code": "[ 페이징 시스템 구조 ]\n\n논리 주소 (32bit, 4KB 페이지)\n+------------------+------------------+\n|  페이지 번호     |     오프셋       |\n|    (20 bit)      |    (12 bit)      |\n+------------------+------------------+\n         |                  |\n         v                  |\n   +----------+             |\n   |페이지    |             |\n   |테이블    |             |\n   +----------+             |\n   | 0 | F5  |             |\n   +----------+             |\n   | 1 | F2  | <--+        |\n   +----------+    |        |\n   | 2 | F8  |    |        |\n   +----------+    |        |\n   | 3 | F1  |    |        |\n   +----------+    |        |\n         |         |        |\n         +---------+        |\n         v                  v\n   +------------------+------------------+\n   |  프레임 번호     |     오프셋       |\n   |     (F2)         |    (동일)        |\n   +------------------+------------------+\n                물리 주소\n\n[ 주소 변환 예시 ]\n\n논리 주소: 8196 (0x2004)\n페이지 크기: 4KB (4096)\n\n페이지 번호 = 8196 / 4096 = 2\n오프셋 = 8196 % 4096 = 4\n\n페이지 테이블[2] = 프레임 5\n\n물리 주소 = (5 * 4096) + 4 = 20484\n\n[ 다단계 페이지 테이블 (2-Level) ]\n\n+--------+--------+--------+\n| 디렉토리| 페이지 | 오프셋 |\n| (10bit)| (10bit)| (12bit)|\n+--------+--------+--------+\n    |        |\n    v        v\n+------+   +------+\n|Page  |-->|Page  |-->프레임\n|Dir   |   |Table |   번호\n+------+   +------+"
      },
      {
        "type": "code",
        "title": "페이징 시뮬레이션 코드",
        "language": "c",
        "code": "// === 페이징 시뮬레이션 ===\n#include <stdio.h>\n#include <stdlib.h>\n\n#define PAGE_SIZE 4096        // 4KB\n#define PAGE_BITS 12          // log2(4096)\n#define NUM_PAGES 256         // 페이지 테이블 엔트리 수\n#define NUM_FRAMES 64         // 물리 프레임 수\n\n// 페이지 테이블 엔트리\ntypedef struct {\n    int frame_number;     // 프레임 번호\n    int valid;            // 유효 비트\n    int dirty;            // 수정 비트\n    int referenced;       // 참조 비트\n} PageTableEntry;\n\nPageTableEntry page_table[NUM_PAGES];\n\n// 주소 변환 함수\nunsigned int translate_address(unsigned int logical_addr) {\n    // 페이지 번호와 오프셋 분리\n    unsigned int page_num = logical_addr >> PAGE_BITS;\n    unsigned int offset = logical_addr & (PAGE_SIZE - 1);\n    \n    printf(\"논리 주소: %u (0x%X)\", logical_addr, logical_addr);\n    printf(\"페이지 번호: %u, 오프셋: %u\", page_num, offset);\n    \n    // 페이지 테이블 조회\n    if (!page_table[page_num].valid) {\n        printf(\"Page Fault 발생! 페이지 %u\", page_num);\n        return -1;  // Page fault\n    }\n    \n    // 물리 주소 계산\n    int frame_num = page_table[page_num].frame_number;\n    unsigned int physical_addr = (frame_num << PAGE_BITS) | offset;\n    \n    printf(\"프레임 번호: %d\", frame_num);\n    printf(\"물리 주소: %u (0x%X)\", physical_addr, physical_addr);\n    \n    return physical_addr;\n}\n\n// 페이지 테이블 초기화\nvoid init_page_table() {\n    for (int i = 0; i < NUM_PAGES; i++) {\n        page_table[i].valid = 0;\n        page_table[i].frame_number = -1;\n    }\n    // 일부 페이지 매핑\n    page_table[0].frame_number = 5;  page_table[0].valid = 1;\n    page_table[1].frame_number = 2;  page_table[1].valid = 1;\n    page_table[2].frame_number = 8;  page_table[2].valid = 1;\n}\n\nint main() {\n    init_page_table();\n    translate_address(8196);  // 페이지 2, 오프셋 4\n    return 0;\n}"
      },
      {
        "type": "tip",
        "title": "면접 대비 정리",
        "content": "**페이징 vs 세그멘테이션 비교**:\n| 구분 | 페이징 | 세그멘테이션 |\n|------|--------|-------------|\n| 크기 | 고정 (4KB 등) | 가변 |\n| 단편화 | 내부 단편화 | 외부 단편화 |\n| 논리적 구분 | 없음 | 있음 (코드/데이터) |\n| 주소 변환 | 단순 | 복잡 |\n| 공유 | 페이지 단위 | 세그먼트 단위 |\n\n**페이지 테이블 엔트리 구성**:\n| 필드 | 설명 |\n|------|------|\n| 프레임 번호 | 물리 메모리 프레임 위치 |\n| 유효 비트 (V) | 메모리에 존재 여부 |\n| 수정 비트 (D) | 페이지 수정 여부 |\n| 참조 비트 (R) | 최근 접근 여부 |\n| 보호 비트 | R/W/X 권한 |\n\n**면접 빈출 질문**:\n\nQ1: 페이징이란 무엇인가요?\nA: 메모리를 고정 크기 블록(페이지/프레임)으로 나누어 비연속적으로 할당하는 기법입니다.\n\nQ2: 내부 단편화와 외부 단편화의 차이는?\nA: 내부 단편화는 할당된 블록 내부의 낭비, 외부 단편화는 블록 사이의 빈 공간 낭비입니다. 페이징은 외부 단편화를 해결하지만 내부 단편화가 발생합니다.\n\nQ3: TLB Miss 발생 시 과정을 설명하세요.\nA: 1) TLB 검색 실패 2) 페이지 테이블 접근 3) 물리 주소 획득 4) TLB 갱신 5) 메모리 접근\n\n**핵심 키워드**: 페이지/프레임, 페이지 테이블, TLB, 다단계 페이징, 내부 단편화"
      }
    ]
  },
  "04_메모리/stack-heap": {
    "id": "04_메모리/stack-heap",
    "title": "스택 vs 힙",
    "category": "os",
    "subCategory": "04_메모리",
    "language": "C",
    "description": "스택과 힙의 정적/동적 메모리 할당 방식을 비교합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "스택과 힙 개념",
        "content": "스택과 힙은 프로그램 실행 중 데이터를 저장하는 두 가지 핵심 메모리 영역입니다.\n\n**한 줄 요약**: 스택은 자동 관리되는 빠른 메모리, 힙은 수동 관리되는 유연한 메모리입니다.\n\n**아파트 비유**:\n- 스택 = 호텔 방 (체크인/아웃 자동, 정해진 크기, 빠른 배정)\n- 힙 = 임대 아파트 (계약 필요, 원하는 크기, 직접 관리)\n\n**스택 (Stack)**:\n- 함수 호출 시 자동 할당\n- LIFO (Last In First Out) 구조\n- 함수 종료 시 자동 해제\n- 크기 제한 있음 (보통 1-8MB)\n- 매우 빠른 할당/해제\n\n**힙 (Heap)**:\n- malloc/new로 명시적 할당\n- 프로그래머가 직접 관리\n- free/delete로 명시적 해제\n- 큰 데이터 저장 가능\n- 상대적으로 느린 할당/해제"
      },
      {
        "type": "code",
        "title": "스택/힙 메모리 다이어그램",
        "language": "text",
        "code": "[ 스택 메모리 동작 ]\n\nfunc_a() 호출     func_b() 호출     func_b() 반환     func_a() 반환\n+----------+     +----------+     +----------+     +----------+\n|          |     | func_b() |     |          |     |          |\n+----------+     +----------+     +----------+     +----------+\n| func_a() |     | func_a() |     | func_a() |     |          |\n+----------+     +----------+     +----------+     +----------+\n|  main()  |     |  main()  |     |  main()  |     |  main()  |\n+----------+     +----------+     +----------+     +----------+\n\n[ 힙 메모리 동작 ]\n\nmalloc(100)      malloc(200)      free(ptr1)       malloc(50)\n+----------+     +----------+     +----------+     +----------+\n|  100B    |     |  100B    |     |  (빈공간) |     |  50B     |\n+----------+     +----------+     +----------+     +----------+\n|          |     |  200B    |     |  200B    |     |  200B    |\n+----------+     +----------+     +----------+     +----------+\n  ptr1             ptr1,ptr2         ptr2           ptr3,ptr2\n\n[ 스택 프레임 구조 ]\n\n+-----------------------+\n| 반환 주소 (Return Addr)|  <- 함수 종료 후 돌아갈 위치\n+-----------------------+\n| 이전 프레임 포인터     |  <- 호출자의 스택 프레임\n+-----------------------+\n| 지역 변수 1           |\n+-----------------------+\n| 지역 변수 2           |\n+-----------------------+\n| 매개변수              |  <- 함수 인자\n+-----------------------+"
      },
      {
        "type": "code",
        "title": "C/Java 스택-힙 비교",
        "language": "c",
        "code": "// === C 언어 스택 vs 힙 ===\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid stack_example() {\n    // 스택 할당 - 자동 관리\n    int stack_arr[100];      // 컴파일 타임에 크기 결정\n    int stack_var = 42;      // 함수 종료 시 자동 해제\n    \n    printf(\"Stack 변수 주소: %p\", &stack_var);\n}\n\nvoid heap_example() {\n    // 힙 할당 - 수동 관리\n    int *heap_arr = (int*)malloc(100 * sizeof(int));\n    \n    if (heap_arr == NULL) {\n        printf(\"메모리 할당 실패!\");\n        return;\n    }\n    \n    // 사용\n    heap_arr[0] = 42;\n    printf(\"Heap 변수 주소: %p\", heap_arr);\n    \n    // 반드시 해제 필요!\n    free(heap_arr);\n    heap_arr = NULL;  // Dangling pointer 방지\n}\n\n// 스택 오버플로우 예시 (위험!)\nvoid stack_overflow() {\n    int huge_array[10000000];  // 스택 초과 가능!\n}\n\n// 메모리 누수 예시 (잘못된 코드)\nvoid memory_leak() {\n    int *ptr = (int*)malloc(sizeof(int));\n    // free(ptr); 누락 -> 메모리 누수!\n}"
      },
      {
        "type": "tip",
        "title": "면접 대비 정리",
        "content": "**스택 vs 힙 비교표**:\n| 구분 | 스택 (Stack) | 힙 (Heap) |\n|------|-------------|----------|\n| 할당 | 자동 (컴파일) | 수동 (런타임) |\n| 해제 | 자동 | 수동 (free/delete) |\n| 속도 | 매우 빠름 | 상대적 느림 |\n| 크기 | 제한적 (1-8MB) | 큰 메모리 가능 |\n| 성장 | 아래로 성장 | 위로 성장 |\n| 에러 | Stack Overflow | Memory Leak |\n| 구조 | LIFO | 비순차적 |\n\n**면접 빈출 질문**:\n\nQ1: 스택과 힙의 차이점을 설명하세요.\nA: 스택은 함수 호출 시 자동 할당/해제되며 빠르지만 크기 제한이 있습니다. 힙은 동적 할당으로 큰 데이터를 저장할 수 있지만 수동 관리가 필요합니다.\n\nQ2: 스택 오버플로우는 왜 발생하나요?\nA: 스택 크기를 초과하는 큰 지역 변수나 무한 재귀 호출로 발생합니다.\n\nQ3: 메모리 누수(Memory Leak)란?\nA: 힙에 할당한 메모리를 해제하지 않아 사용 불가능한 메모리가 누적되는 현상입니다.\n\nQ4: Java에서 Stack과 Heap의 차이는?\nA: 기본형은 Stack, 객체는 Heap에 저장됩니다. GC가 Heap 메모리를 자동 관리합니다.\n\n**핵심 키워드**: LIFO, malloc/free, Stack Overflow, Memory Leak, GC"
      }
    ]
  },
  "04_메모리/virtual-memory": {
    "id": "04_메모리/virtual-memory",
    "title": "가상 메모리",
    "category": "os",
    "subCategory": "04_메모리",
    "language": "C",
    "description": "가상 메모리를 통해 실제 RAM보다 큰 메모리를 사용하는 원리를 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "가상 메모리 개념",
        "content": "가상 메모리는 물리 메모리보다 큰 주소 공간을 프로세스에 제공하는 메모리 관리 기법입니다.\n\n**한 줄 요약**: 디스크를 RAM의 확장처럼 사용하여 물리 메모리 한계를 극복합니다.\n\n**도서관 비유**:\n- 물리 메모리 = 열람실 책상 (제한된 공간)\n- 가상 메모리 = 전체 도서관 장서 (훨씬 큰 저장소)\n- 필요한 책만 책상에 가져옴 (요구 페이징)\n- 다 읽은 책은 다시 서가로 (페이지 교체)\n\n**핵심 원리**:\n1. **주소 공간 분리**: 프로세스마다 독립적인 가상 주소 공간\n2. **요구 페이징 (Demand Paging)**: 필요할 때만 메모리에 적재\n3. **페이지 교체**: 메모리 부족 시 사용 안 하는 페이지를 디스크로\n4. **스왑 영역**: 디스크의 가상 메모리 저장 공간\n\n**장점**:\n- 물리 메모리보다 큰 프로그램 실행 가능\n- 프로세스 간 메모리 보호\n- 메모리 효율적 사용\n- 공유 메모리 구현 용이"
      },
      {
        "type": "code",
        "title": "가상 메모리 구조 다이어그램",
        "language": "text",
        "code": "[ 가상 메모리 개념도 ]\n\n프로세스 A          프로세스 B          물리 메모리       디스크(Swap)\n가상 주소공간       가상 주소공간\n+----------+       +----------+       +----------+     +----------+\n| Page 0   |--+    | Page 0   |--+    | Frame 0  |<----| Page X   |\n+----------+  |    +----------+  |    +----------+     +----------+\n| Page 1   |--|---\\| Page 1   |  |    | Frame 1  |<-+  | Page Y   |\n+----------+  |    +----------+  |    +----------+  |  +----------+\n| Page 2   |  +----| Page 2   |--+---\\| Frame 2  |  |  | Page Z   |\n+----------+       +----------+      /+----------+  |  +----------+\n| Page 3   |----------------------+ | | Frame 3  |--+\n+----------+       +----------+   | | +----------+\n                                  +-+->\n\n[ 주소 변환 과정 ]\n\n가상 주소 (32bit 예시)\n+------------+------------+\n| 페이지번호 |   오프셋   |\n|   (20bit)  |  (12bit)   |   4KB 페이지\n+------------+------------+\n      |             |\n      v             |\n+------------+      |\n|페이지테이블|      |\n| 0 -> F3   |      |\n| 1 -> F7   |      |\n| 2 -> DISK |      |      Page Fault!\n| 3 -> F1   |      |\n+------------+      |\n      |             |\n      v             v\n+------------+------------+\n| 프레임번호 |   오프셋   |\n+------------+------------+\n      물리 주소"
      },
      {
        "type": "code",
        "title": "가상 메모리 시스템 콜",
        "language": "c",
        "code": "// === 가상 메모리 관련 시스템 콜 ===\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <unistd.h>\n\n// mmap: 가상 메모리 영역 매핑\nvoid mmap_example() {\n    size_t size = 4096;  // 1 페이지\n    \n    // 익명 메모리 매핑\n    void *addr = mmap(NULL, size,\n                      PROT_READ | PROT_WRITE,\n                      MAP_PRIVATE | MAP_ANONYMOUS,\n                      -1, 0);\n    \n    if (addr == MAP_FAILED) {\n        perror(\"mmap failed\");\n        return;\n    }\n    \n    // 메모리 사용\n    int *ptr = (int*)addr;\n    ptr[0] = 42;\n    \n    // 매핑 해제\n    munmap(addr, size);\n}\n\n// 메모리 정보 확인 (Linux)\nvoid check_memory_info() {\n    // /proc/self/maps에서 가상 메모리 매핑 확인\n    printf(\"가상 메모리 매핑 정보:\");\n    system(\"cat /proc/self/maps | head -10\");\n    \n    // 메모리 사용량 확인\n    printf(\"메모리 사용량:\");\n    system(\"free -h\");\n}\n\n// 대용량 메모리 할당 테스트\nvoid large_allocation_test() {\n    // 물리 메모리보다 큰 할당 시도\n    size_t huge_size = 1024UL * 1024 * 1024;  // 1GB\n    \n    void *huge_mem = malloc(huge_size);\n    if (huge_mem) {\n        printf(\"1GB 할당 성공 (가상 메모리 사용)\");\n        // 실제 접근 전까지 물리 메모리 미할당\n        free(huge_mem);\n    }\n}"
      },
      {
        "type": "tip",
        "title": "면접 대비 정리",
        "content": "**가상 메모리 핵심 개념**:\n| 용어 | 설명 |\n|------|------|\n| 가상 주소 | 프로세스가 사용하는 논리적 주소 |\n| 물리 주소 | 실제 RAM의 주소 |\n| 페이지 | 가상 메모리의 고정 크기 블록 (보통 4KB) |\n| 프레임 | 물리 메모리의 고정 크기 블록 |\n| 페이지 테이블 | 가상->물리 주소 매핑 테이블 |\n| TLB | 페이지 테이블 캐시 (빠른 변환) |\n| Page Fault | 페이지가 메모리에 없을 때 발생 |\n| Swap | 디스크의 가상 메모리 영역 |\n\n**면접 빈출 질문**:\n\nQ1: 가상 메모리란 무엇인가요?\nA: 디스크를 RAM의 확장으로 사용하여 물리 메모리보다 큰 주소 공간을 프로세스에 제공하는 기법입니다.\n\nQ2: Page Fault가 발생하면 어떤 일이 일어나나요?\nA: 1) CPU가 트랩 발생 2) OS가 페이지 위치 확인 3) 디스크에서 페이지 로드 4) 페이지 테이블 갱신 5) 명령어 재실행\n\nQ3: TLB(Translation Lookaside Buffer)의 역할은?\nA: 최근 사용된 페이지 테이블 항목을 캐싱하여 주소 변환 속도를 높입니다.\n\nQ4: 스래싱(Thrashing)이란?\nA: 페이지 부재가 과도하게 발생하여 실제 작업보다 페이지 교체에 더 많은 시간을 소비하는 현상입니다.\n\n**핵심 키워드**: 요구 페이징, Page Fault, TLB, Swap, 스래싱"
      }
    ]
  },
  "04_스케줄링/cpu-scheduling": {
    "id": "04_스케줄링/cpu-scheduling",
    "title": "CPU 스케줄링",
    "category": "os",
    "subCategory": "04_스케줄링",
    "language": "C",
    "description": "CPU 자원을 프로세스에 효율적으로 배분하는 스케줄링 개념을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "CPU 스케줄링 개념",
        "content": "CPU 스케줄링은 여러 프로세스 중 어떤 프로세스에 CPU를 할당할지 결정하는 기법입니다.\n\n**한 줄 요약**: 여러 프로세스가 CPU를 공정하고 효율적으로 사용하도록 순서를 정합니다.\n\n**은행 창구 비유**:\n- CPU = 은행 창구 직원\n- 프로세스 = 대기 고객\n- 스케줄러 = 번호표 시스템\n- 목표: 고객 대기 시간 최소화, 직원 효율 최대화\n\n**스케줄링 목표**:\n1. **CPU 이용률 극대화**: CPU가 쉬지 않도록\n2. **처리량 최대화**: 단위 시간당 완료 프로세스 수\n3. **대기 시간 최소화**: Ready Queue에서 기다리는 시간\n4. **응답 시간 최소화**: 요청부터 첫 응답까지 시간\n5. **공정성**: 모든 프로세스에 적절한 CPU 시간\n\n**스케줄링 발생 시점**:\n- 프로세스가 Running -> Waiting (I/O 요청)\n- 프로세스가 Running -> Ready (인터럽트)\n- 프로세스가 Waiting -> Ready (I/O 완료)\n- 프로세스 종료"
      },
      {
        "type": "code",
        "title": "CPU 스케줄링 구조 다이어그램",
        "language": "text",
        "code": "[ CPU 스케줄링 전체 흐름 ]\n\n                    +-------------------+\n     새 프로세스 -->|   Ready Queue     |<-- I/O 완료\n                    | [P1][P2][P3][P4]  |\n                    +--------+----------+\n                             |\n                    +--------v----------+\n                    |     Scheduler     |\n                    |   (스케줄러)       |\n                    +--------+----------+\n                             |\n                    +--------v----------+\n                    |    Dispatcher     |\n                    | (컨텍스트 스위칭)  |\n                    +--------+----------+\n                             |\n                    +--------v----------+\n                    |       CPU         |\n                    |   [실행 중: P2]   |\n                    +--------+----------+\n                             |\n         +-------------------+-------------------+\n         |                   |                   |\n         v                   v                   v\n    종료 (Exit)        I/O 요청            Time Quantum\n                    (Waiting Queue)         만료 (선점)\n\n[ 스케줄링 성능 지표 ]\n\n      도착        시작        완료\n        |          |          |\n        v          v          v\n   ----[==========|##########]-----> 시간\n        |<-------->|<-------->|\n        대기 시간    실행 시간\n        |<------------------->|\n             반환 시간\n\n대기 시간 = 시작 시간 - 도착 시간\n반환 시간 = 완료 시간 - 도착 시간\n응답 시간 = 첫 응답 시간 - 도착 시간"
      },
      {
        "type": "code",
        "title": "스케줄링 시뮬레이션",
        "language": "c",
        "code": "// === CPU 스케줄링 기본 구조 ===\n#include <stdio.h>\n#include <stdlib.h>\n\n// 프로세스 구조체\ntypedef struct {\n    int pid;              // 프로세스 ID\n    int arrival_time;     // 도착 시간\n    int burst_time;       // 실행 시간 (CPU burst)\n    int remaining_time;   // 남은 실행 시간\n    int start_time;       // 시작 시간\n    int completion_time;  // 완료 시간\n    int waiting_time;     // 대기 시간\n    int turnaround_time;  // 반환 시간\n    int priority;         // 우선순위\n} Process;\n\n// 성능 지표 계산\nvoid calculate_metrics(Process *p) {\n    p->turnaround_time = p->completion_time - p->arrival_time;\n    p->waiting_time = p->turnaround_time - p->burst_time;\n}\n\n// FCFS 스케줄링 예시\nvoid fcfs_scheduling(Process processes[], int n) {\n    int current_time = 0;\n    \n    printf(\"=== FCFS 스케줄링 ===\");\n    \n    for (int i = 0; i < n; i++) {\n        // 프로세스 도착 대기\n        if (current_time < processes[i].arrival_time) {\n            current_time = processes[i].arrival_time;\n        }\n        \n        processes[i].start_time = current_time;\n        processes[i].completion_time = current_time + processes[i].burst_time;\n        current_time = processes[i].completion_time;\n        \n        calculate_metrics(&processes[i]);\n        \n        printf(\"P%d: 시작=%d, 완료=%d, 대기=%d, 반환=%d\",\n               processes[i].pid,\n               processes[i].start_time,\n               processes[i].completion_time,\n               processes[i].waiting_time,\n               processes[i].turnaround_time);\n    }\n}\n\nint main() {\n    Process p[] = {\n        {1, 0, 5, 5, 0, 0, 0, 0, 0},\n        {2, 1, 3, 3, 0, 0, 0, 0, 0},\n        {3, 2, 8, 8, 0, 0, 0, 0, 0}\n    };\n    fcfs_scheduling(p, 3);\n    return 0;\n}"
      },
      {
        "type": "tip",
        "title": "면접 대비 정리",
        "content": "**스케줄링 성능 지표 정리**:\n| 지표 | 정의 | 계산식 |\n|------|------|--------|\n| CPU 이용률 | CPU 사용 비율 | (실행시간/전체시간)*100 |\n| 처리량 | 완료 프로세스/시간 | 완료 수 / 전체 시간 |\n| 대기 시간 | Ready Queue 대기 | 시작 - 도착 |\n| 반환 시간 | 제출~완료 시간 | 완료 - 도착 |\n| 응답 시간 | 첫 응답까지 시간 | 첫 실행 - 도착 |\n\n**스케줄러 종류**:\n| 종류 | 역할 | 빈도 |\n|------|------|------|\n| 장기 스케줄러 | 어떤 프로세스를 Ready Queue에 | 드묾 |\n| 단기 스케줄러 | Ready -> Running 결정 | 매우 자주 |\n| 중기 스케줄러 | Swapping 결정 | 중간 |\n\n**면접 빈출 질문**:\n\nQ1: CPU 스케줄링이 왜 필요한가요?\nA: 다중 프로그래밍 환경에서 CPU 자원을 효율적이고 공정하게 배분하기 위해 필요합니다.\n\nQ2: 대기 시간과 반환 시간의 차이는?\nA: 대기 시간은 Ready Queue에서 기다린 시간, 반환 시간은 도착부터 완료까지의 전체 시간입니다.\n\nQ3: Dispatcher의 역할은?\nA: 스케줄러가 선택한 프로세스에게 실제로 CPU를 할당하고 컨텍스트 스위칭을 수행합니다.\n\n**핵심 키워드**: Ready Queue, Dispatcher, 대기시간, 반환시간, 처리량"
      }
    ]
  },
  "04_스케줄링/preemptive": {
    "id": "04_스케줄링/preemptive",
    "title": "선점형 vs 비선점형",
    "category": "os",
    "subCategory": "04_스케줄링",
    "language": "C",
    "description": "선점형과 비선점형 스케줄링의 차이점과 특징을 비교합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "선점형과 비선점형 개념",
        "content": "스케줄링은 실행 중인 프로세스를 강제로 중단할 수 있는지에 따라 선점형/비선점형으로 구분됩니다.\n\n**한 줄 요약**: 선점형은 CPU를 빼앗을 수 있고, 비선점형은 자발적으로 반납할 때까지 기다립니다.\n\n**택시 비유**:\n- 비선점형 = 일반 택시 (손님이 내릴 때까지 대기)\n- 선점형 = 앰뷸런스 (긴급 환자 발생 시 택시 비켜!)\n\n**비선점형 (Non-preemptive)**:\n- 프로세스가 자발적으로 CPU 반납\n- I/O 요청 또는 종료 시에만 교체\n- 단순한 구현, 문맥 교환 적음\n- 응답 시간 보장 어려움\n- 예: FCFS, SJF (Non-preemptive)\n\n**선점형 (Preemptive)**:\n- OS가 강제로 CPU 회수 가능\n- 타임 퀀텀, 우선순위 변경 시 교체\n- 응답 시간 보장 가능\n- 문맥 교환 오버헤드 있음\n- 예: Round Robin, SRTF, 우선순위 스케줄링"
      },
      {
        "type": "code",
        "title": "선점형/비선점형 비교 다이어그램",
        "language": "text",
        "code": "[ 비선점형 스케줄링 (FCFS) ]\n\n시간:  0    5   8        16\n       |----|----|--------|\nP1     [####]               burst=5\nP2          [###]           burst=3  (도착:1, 대기:4)\nP3               [########] burst=8  (도착:2, 대기:6)\n\n-> P1이 끝날 때까지 P2, P3는 무조건 대기\n\n[ 선점형 스케줄링 (Round Robin, 퀀텀=2) ]\n\n시간:  0  2  4  5  7  9  10 12 14 16\n       |--|--|--|--|--|--|--|--|--|--|\nP1     [##]     [##]     [#]          burst=5\nP2        [##]     [#]                burst=3\nP3           [##]     [##]  [##][##]  burst=8\n\n-> 타임 퀀텀마다 강제 교체, 공정한 CPU 분배\n\n[ 선점 발생 시점 ]\n\n+------------------+------------------+\n|     비선점형      |      선점형       |\n+------------------+------------------+\n| Running->Waiting | Running->Waiting |\n| 프로세스 종료     | 프로세스 종료     |\n|                  | Running->Ready   |\n|                  | Waiting->Ready   |\n+------------------+------------------+\n\n[ SJF vs SRTF 비교 ]\n\n        도착  버스트\n  P1     0      7\n  P2     2      4\n  P3     4      1\n\nSJF (비선점):  P1[#######]P3[#]P2[####]\n시간:          0        7   8      12\n\nSRTF (선점):   P1[##]P2[##]P3[#]P2[##]P1[#####]\n시간:          0   2    4   5    7      12\n-> P2 도착 시 P1 선점, P3 도착 시 P2 선점"
      },
      {
        "type": "code",
        "title": "선점형/비선점형 구현",
        "language": "c",
        "code": "// === 선점형 vs 비선점형 스케줄링 ===\n#include <stdio.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int pid;\n    int arrival;\n    int burst;\n    int remaining;\n    int completion;\n} Process;\n\n// 비선점형 SJF\nvoid sjf_nonpreemptive(Process p[], int n) {\n    int time = 0, completed = 0;\n    bool done[n];\n    for (int i = 0; i < n; i++) done[i] = false;\n    \n    printf(\"=== SJF (비선점형) ===\");\n    \n    while (completed < n) {\n        int shortest = -1;\n        int min_burst = 9999;\n        \n        // 도착한 프로세스 중 가장 짧은 것 선택\n        for (int i = 0; i < n; i++) {\n            if (!done[i] && p[i].arrival <= time && p[i].burst < min_burst) {\n                shortest = i;\n                min_burst = p[i].burst;\n            }\n        }\n        \n        if (shortest == -1) {\n            time++;\n            continue;\n        }\n        \n        // 선택된 프로세스 완료까지 실행 (비선점)\n        time += p[shortest].burst;\n        p[shortest].completion = time;\n        done[shortest] = true;\n        completed++;\n        \n        printf(\"P%d 완료: time=%d\", p[shortest].pid, time);\n    }\n}\n\n// 선점형 SRTF (Shortest Remaining Time First)\nvoid srtf_preemptive(Process p[], int n) {\n    int time = 0, completed = 0;\n    \n    printf(\"=== SRTF (선점형) ===\");\n    \n    while (completed < n) {\n        int shortest = -1;\n        int min_remaining = 9999;\n        \n        // 매 시간마다 가장 짧은 남은 시간 선택\n        for (int i = 0; i < n; i++) {\n            if (p[i].arrival <= time && p[i].remaining > 0 && p[i].remaining < min_remaining) {\n                shortest = i;\n                min_remaining = p[i].remaining;\n            }\n        }\n        \n        if (shortest == -1) {\n            time++;\n            continue;\n        }\n        \n        // 1단위 시간만 실행 (선점 가능)\n        p[shortest].remaining--;\n        time++;\n        \n        if (p[shortest].remaining == 0) {\n            p[shortest].completion = time;\n            completed++;\n            printf(\"P%d 완료: time=%d\", p[shortest].pid, time);\n        }\n    }\n}"
      },
      {
        "type": "tip",
        "title": "면접 대비 정리",
        "content": "**선점형 vs 비선점형 비교표**:\n| 구분 | 선점형 | 비선점형 |\n|------|--------|----------|\n| CPU 회수 | 강제 가능 | 자발적 반납 |\n| 응답 시간 | 보장 가능 | 보장 어려움 |\n| 문맥 교환 | 자주 발생 | 적게 발생 |\n| 구현 | 복잡 | 단순 |\n| 공정성 | 높음 | 낮음 |\n| 오버헤드 | 있음 | 적음 |\n\n**알고리즘 분류**:\n| 비선점형 | 선점형 |\n|----------|--------|\n| FCFS | Round Robin |\n| SJF | SRTF |\n| 우선순위 (Non) | 우선순위 (Pre) |\n| HRN | Multilevel Queue |\n\n**면접 빈출 질문**:\n\nQ1: 선점형과 비선점형의 차이점은?\nA: 선점형은 OS가 실행 중인 프로세스를 강제로 중단시킬 수 있고, 비선점형은 프로세스가 자발적으로 CPU를 반납해야 합니다.\n\nQ2: 언제 선점형 스케줄링을 사용하나요?\nA: 실시간 시스템, 대화형 시스템처럼 응답 시간이 중요한 경우에 사용합니다.\n\nQ3: Round Robin이 선점형인 이유는?\nA: 타임 퀀텀이 만료되면 프로세스 의지와 관계없이 강제로 CPU를 회수하기 때문입니다.\n\nQ4: SRTF의 문제점은?\nA: 긴 프로세스의 기아(Starvation) 현상이 발생할 수 있습니다.\n\n**핵심 키워드**: 선점(Preemption), 타임 퀀텀, 문맥 교환, 기아 현상, 응답 시간"
      }
    ]
  },
  "04_스케줄링/scheduling-algorithm": {
    "id": "04_스케줄링/scheduling-algorithm",
    "title": "스케줄링 알고리즘",
    "category": "os",
    "subCategory": "04_스케줄링",
    "language": "C",
    "description": "주요 CPU 스케줄링 알고리즘의 특징과 동작 방식을 비교합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "스케줄링 알고리즘 개요",
        "content": "다양한 스케줄링 알고리즘이 각각의 목표와 환경에 맞게 사용됩니다.\n\n**한 줄 요약**: FCFS는 단순, SJF는 효율적, RR은 공정, 우선순위는 중요도 반영.\n\n**음식점 비유**:\n- FCFS = 번호표 순서대로 (먼저 온 손님 먼저)\n- SJF = 간단한 주문 먼저 (짧은 작업 먼저)\n- RR = 셀프바 순환 (조금씩 돌아가며)\n- 우선순위 = VIP 우선 (중요 손님 먼저)\n\n**주요 알고리즘**:\n\n1. **FCFS (First Come First Served)**\n   - 먼저 도착한 순서대로 처리\n   - 비선점형, 구현 단순\n   - Convoy Effect 문제\n\n2. **SJF (Shortest Job First)**\n   - 실행 시간이 짧은 순서대로\n   - 평균 대기 시간 최소화\n   - 기아(Starvation) 문제\n\n3. **Round Robin**\n   - 타임 퀀텀만큼 순환 실행\n   - 선점형, 공정한 분배\n   - 퀀텀 크기가 성능 좌우\n\n4. **Priority Scheduling**\n   - 우선순위 높은 것 먼저\n   - 기아 문제 -> Aging으로 해결"
      },
      {
        "type": "code",
        "title": "알고리즘별 동작 다이어그램",
        "language": "text",
        "code": "[ 예시 프로세스 ]\n\n프로세스  도착시간  실행시간  우선순위\n  P1        0         8        3\n  P2        1         4        1 (높음)\n  P3        2         2        2\n\n[ FCFS - 도착 순서대로 ]\n\n  0       8      12    14\n  |-------|------|-----|-->\nP1[#######]\nP2        [####]\nP3              [##]\n\n평균 대기: (0+7+10)/3 = 5.67\n\n[ SJF - 짧은 작업 먼저 ]\n\n  0       8  10    14\n  |-------|--|-----|-->\nP1[#######]\nP3        [##]         (P2보다 짧음)\nP2           [####]\n\n평균 대기: (0+6+8)/3 = 4.67\n\n[ Round Robin (퀀텀=3) ]\n\n  0   3   6   8  11  14\n  |---|---|---|---|---|-->\nP1[###]       [###]   [##]\nP2    [###]       [#]\nP3        [##]\n\n평균 대기: (6+7+4)/3 = 5.67\n공정한 응답 시간 보장\n\n[ 우선순위 스케줄링 ]\n\n  0   4   6      14\n  |---|---|------|-->\nP2[####]            (우선순위 1)\nP3    [##]          (우선순위 2)\nP1       [########] (우선순위 3)\n\n평균 대기: (6+3+0)/3 = 3"
      },
      {
        "type": "code",
        "title": "Round Robin 구현",
        "language": "c",
        "code": "// === Round Robin 스케줄링 구현 ===\n#include <stdio.h>\n#include <stdbool.h>\n\n#define TIME_QUANTUM 3\n#define MAX_PROCESS 10\n\ntypedef struct {\n    int pid;\n    int arrival;\n    int burst;\n    int remaining;\n    int completion;\n    int waiting;\n    int turnaround;\n    int response;\n    bool first_run;\n} Process;\n\nvoid round_robin(Process p[], int n) {\n    int queue[MAX_PROCESS * 10];\n    int front = 0, rear = 0;\n    int time = 0, completed = 0;\n    bool in_queue[MAX_PROCESS] = {false};\n    \n    // 초기화\n    for (int i = 0; i < n; i++) {\n        p[i].remaining = p[i].burst;\n        p[i].first_run = true;\n    }\n    \n    // 시간 0에 도착한 프로세스 큐에 추가\n    for (int i = 0; i < n; i++) {\n        if (p[i].arrival == 0) {\n            queue[rear++] = i;\n            in_queue[i] = true;\n        }\n    }\n    \n    printf(\"=== Round Robin (Quantum=%d) ===\", TIME_QUANTUM);\n    \n    while (completed < n) {\n        if (front == rear) {\n            time++;\n            // 새로 도착한 프로세스 확인\n            for (int i = 0; i < n; i++) {\n                if (!in_queue[i] && p[i].arrival <= time && p[i].remaining > 0) {\n                    queue[rear++] = i;\n                    in_queue[i] = true;\n                }\n            }\n            continue;\n        }\n        \n        int idx = queue[front++];\n        \n        // 응답 시간 기록\n        if (p[idx].first_run) {\n            p[idx].response = time - p[idx].arrival;\n            p[idx].first_run = false;\n        }\n        \n        // 타임 퀀텀 또는 남은 시간만큼 실행\n        int exec_time = (p[idx].remaining < TIME_QUANTUM) ? p[idx].remaining : TIME_QUANTUM;\n        \n        printf(\"Time %d-%d: P%d 실행\", time, time + exec_time, p[idx].pid);\n        \n        time += exec_time;\n        p[idx].remaining -= exec_time;\n        \n        // 새로 도착한 프로세스 큐에 추가\n        for (int i = 0; i < n; i++) {\n            if (!in_queue[i] && p[i].arrival <= time && p[i].remaining > 0) {\n                queue[rear++] = i;\n                in_queue[i] = true;\n            }\n        }\n        \n        if (p[idx].remaining > 0) {\n            queue[rear++] = idx;  // 다시 큐에 추가\n        } else {\n            p[idx].completion = time;\n            p[idx].turnaround = time - p[idx].arrival;\n            p[idx].waiting = p[idx].turnaround - p[idx].burst;\n            completed++;\n            printf(\"  -> P%d 완료!\", p[idx].pid);\n        }\n    }\n}"
      },
      {
        "type": "tip",
        "title": "면접 대비 정리",
        "content": "**스케줄링 알고리즘 비교표**:\n| 알고리즘 | 선점 | 장점 | 단점 | 사용처 |\n|---------|------|------|------|--------|\n| FCFS | X | 단순 | Convoy | 배치 |\n| SJF | X/O | 최적 대기 | 기아 | 배치 |\n| RR | O | 공정 | 오버헤드 | 대화형 |\n| 우선순위 | X/O | 중요도 | 기아 | 실시간 |\n| MLQ | O | 분류 처리 | 복잡 | 범용 |\n| MLFQ | O | 적응형 | 복잡 | 범용 |\n\n**주요 문제와 해결책**:\n| 문제 | 원인 | 해결책 |\n|------|------|--------|\n| Convoy Effect | 긴 프로세스 | SJF/RR 사용 |\n| Starvation | 낮은 우선순위 | Aging 기법 |\n| 잦은 문맥교환 | 작은 퀀텀 | 퀀텀 크기 조정 |\n\n**면접 빈출 질문**:\n\nQ1: Round Robin의 타임 퀀텀 크기는 어떻게 정하나요?\nA: 너무 크면 FCFS처럼 동작, 너무 작으면 문맥 교환 오버헤드 증가. 보통 10-100ms.\n\nQ2: SJF가 최적인 이유는?\nA: 짧은 작업을 먼저 처리하면 뒤따르는 작업들의 대기 시간이 줄어들어 평균 대기 시간이 최소화됩니다.\n\nQ3: Aging이란 무엇인가요?\nA: 오래 대기한 프로세스의 우선순위를 점진적으로 높여 기아 현상을 방지하는 기법입니다.\n\nQ4: MLFQ(Multilevel Feedback Queue)를 설명하세요.\nA: 여러 우선순위 큐를 두고, CPU 많이 사용하면 낮은 큐로, I/O 중심이면 높은 큐에 유지하는 적응형 알고리즘입니다.\n\n**핵심 키워드**: FCFS, SJF, RR, 우선순위, Aging, MLFQ, 타임 퀀텀"
      }
    ]
  },
  "05_동기비동기/blocking-nonblocking": {
    "id": "05_동기비동기/blocking-nonblocking",
    "title": "블로킹 vs 논블로킹",
    "category": "os",
    "subCategory": "05_동기비동기",
    "language": "Java",
    "description": "블로킹과 논블로킹의 제어권 개념을 카페 알바생 비유로 이해하고, I/O 모델에서의 차이를 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "블로킹 vs 논블로킹: 제어권을 돌려주는가?",
        "content": "## 카페 알바생으로 이해하는 블로킹/논블로킹\n\n### 블로킹(Blocking) - 멍때리며 기다리기\n```\n[알바생] --> [에스프레소 추출 시작] --> [멍때림...] --> [추출 완료]\n                |<-------- 아무것도 안함 -------->|\n                          (제어권 없음)\n```\n- 에스프레소 머신 앞에서 추출될 때까지 서있음\n- 추출 완료될 때까지 **다른 일을 할 수 없음**\n- **제어권이 호출된 함수에게 넘어감**\n\n### 논블로킹(Non-Blocking) - 다른 일 하면서 기다리기\n```\n[알바생] --> [에스프레소 추출 시작] --> [컵 준비] --> [시럽 추가] --> [추출 확인]\n                |                         |\n                +---- 제어권 즉시 반환 ----+\n                      (다른 일 가능)\n```\n- 추출 버튼 누르고 바로 다른 준비 작업\n- 중간중간 추출 완료 여부 확인(polling)\n- **제어권이 즉시 호출자에게 반환됨**\n\n### 핵심 차이점: 제어권(Control)\n| 구분 | 블로킹 | 논블로킹 |\n|------|--------|----------|\n| 제어권 | 작업 완료까지 넘겨줌 | 즉시 반환받음 |\n| 대기 방식 | 아무것도 안함 | 다른 일 가능 |\n| 함수 반환 | 결과와 함께 반환 | 즉시 반환 (결과 없을 수 있음) |\n| CPU 사용 | 대기 중 유휴 | 다른 작업에 활용 |\n\n### 동기/비동기와의 차이\n- **동기/비동기**: 결과를 **어떻게** 받을 것인가? (직접 vs 콜백)\n- **블로킹/논블로킹**: 결과를 **기다리는 동안** 뭘 할 것인가? (대기 vs 다른일)"
      },
      {
        "type": "code",
        "title": "Java NIO 블로킹 vs 논블로킹 소켓",
        "language": "java",
        "code": "import java.io.*;\nimport java.net.*;\nimport java.nio.*;\nimport java.nio.channels.*;\n\npublic class BlockingNonBlockingIO {\n    \n    // === 블로킹 I/O: 데이터 올 때까지 멈춤 ===\n    public static void blockingServer() throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        System.out.println(\"[블로킹] 서버 시작\");\n        \n        while (true) {\n            // accept()는 클라이언트 연결까지 블로킹됨\n            // 이 줄에서 멈춰있음 (멍때림 상태)\n            Socket clientSocket = serverSocket.accept();\n            System.out.println(\"클라이언트 연결됨\");\n            \n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(clientSocket.getInputStream()));\n            \n            // read()도 데이터 올 때까지 블로킹됨\n            String line = reader.readLine(); // 여기서도 멍때림\n            System.out.println(\"받은 데이터: \" + line);\n        }\n        // 문제: 클라이언트 1000명이면 스레드 1000개 필요\n    }\n    \n    // === 논블로킹 I/O: 즉시 반환, 나중에 확인 ===\n    public static void nonBlockingServer() throws IOException {\n        ServerSocketChannel serverChannel = ServerSocketChannel.open();\n        serverChannel.bind(new InetSocketAddress(8080));\n        serverChannel.configureBlocking(false); // 논블로킹 모드!\n        \n        Selector selector = Selector.open();\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n        \n        System.out.println(\"[논블로킹] 서버 시작\");\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        \n        while (true) {\n            // select()는 이벤트가 있을 때만 반환\n            // 이벤트 없으면 다른 일 가능!\n            selector.select();\n            \n            for (SelectionKey key : selector.selectedKeys()) {\n                if (key.isAcceptable()) {\n                    // 연결 수락 (논블로킹: 즉시 반환)\n                    SocketChannel clientChannel = serverChannel.accept();\n                    if (clientChannel != null) {\n                        clientChannel.configureBlocking(false);\n                        clientChannel.register(selector, SelectionKey.OP_READ);\n                        System.out.println(\"클라이언트 연결됨\");\n                    }\n                } else if (key.isReadable()) {\n                    // 데이터 읽기 (논블로킹: 데이터 없으면 0 반환)\n                    SocketChannel clientChannel = (SocketChannel) key.channel();\n                    buffer.clear();\n                    int bytesRead = clientChannel.read(buffer); // 즉시 반환!\n                    if (bytesRead > 0) {\n                        buffer.flip();\n                        System.out.println(\"받은 데이터: \" + new String(buffer.array(), 0, bytesRead));\n                    }\n                }\n            }\n            selector.selectedKeys().clear();\n            \n            // 여기서 다른 작업 가능! (논블로킹이니까)\n            doOtherWork();\n        }\n    }\n    \n    private static void doOtherWork() {\n        // 컵 준비, 시럽 추가 등 다른 작업\n    }\n}"
      },
      {
        "type": "code",
        "title": "Node.js 논블로킹 I/O 활용",
        "language": "javascript",
        "code": "const fs = require('fs');\nconst net = require('net');\n\n// === Node.js는 기본적으로 논블로킹 I/O ===\n\n// 1. 파일 읽기 - 논블로킹\nconsole.log('1. 파일 읽기 시작');\nfs.readFile('large-file.txt', 'utf8', (err, data) => {\n    // 파일 읽기 완료되면 콜백 실행\n    console.log('3. 파일 읽기 완료');\n});\nconsole.log('2. 다른 작업 수행'); // 제어권 즉시 반환되어 바로 실행!\n\n// 실행 순서: 1 -> 2 -> 3\n\n// 2. TCP 서버 - 논블로킹 소켓\nconst server = net.createServer((socket) => {\n    console.log('클라이언트 연결됨');\n    \n    // data 이벤트: 데이터가 도착하면 호출 (논블로킹)\n    socket.on('data', (data) => {\n        console.log('받은 데이터:', data.toString());\n        socket.write('응답: ' + data.toString());\n    });\n    \n    socket.on('end', () => {\n        console.log('클라이언트 연결 종료');\n    });\n});\n\nserver.listen(8080, () => {\n    console.log('서버 시작 (논블로킹 모드)');\n});\n\n// 3. 논블로킹 HTTP 요청 여러 개 동시 처리\nconst https = require('https');\n\nfunction fetchUrl(url) {\n    return new Promise((resolve, reject) => {\n        // https.get은 논블로킹 - 즉시 반환\n        https.get(url, (res) => {\n            let data = '';\n            res.on('data', chunk => data += chunk);\n            res.on('end', () => resolve(data));\n        }).on('error', reject);\n    });\n}\n\nasync function fetchMultiple() {\n    const startTime = Date.now();\n    \n    // 논블로킹이라 동시에 3개 요청 가능\n    const results = await Promise.all([\n        fetchUrl('https://api1.example.com'),\n        fetchUrl('https://api2.example.com'),\n        fetchUrl('https://api3.example.com')\n    ]);\n    \n    console.log(`3개 API 호출 완료: ${Date.now() - startTime}ms`);\n    // 블로킹이었다면 순차 실행으로 3배 시간 소요\n}\n\n// 4. 이벤트 루프가 논블로킹을 가능하게 함\n/*\n  Node.js 이벤트 루프:\n  \n  ┌───────────────────────────┐\n  │         timers            │  <-- setTimeout, setInterval\n  ├───────────────────────────┤\n  │     pending callbacks     │  <-- I/O 콜백\n  ├───────────────────────────┤\n  │       idle, prepare       │\n  ├───────────────────────────┤\n  │          poll             │  <-- 새 I/O 이벤트 대기\n  ├───────────────────────────┤\n  │          check            │  <-- setImmediate\n  ├───────────────────────────┤\n  │     close callbacks       │  <-- socket.close()\n  └───────────────────────────┘\n*/"
      },
      {
        "type": "tip",
        "title": "면접 대비 핵심 정리",
        "content": "## 블로킹 vs 논블로킹 핵심 요약\n\n### 면접 답변 템플릿\n```\n\"블로킹과 논블로킹은 제어권의 관점에서 구분합니다.\n\n블로킹은 함수를 호출하면 작업이 완료될 때까지 제어권이 넘어가서\n호출자는 아무것도 할 수 없이 대기합니다.\n\n논블로킹은 함수 호출 후 즉시 제어권이 반환되어\n호출자가 다른 작업을 수행할 수 있습니다.\n\n카페 알바생에 비유하면, 블로킹은 에스프레소 추출 중 멍때리는 것이고,\n논블로킹은 추출 버튼 누르고 바로 컵 준비하러 가는 것입니다.\"\n```\n\n### 블로킹 vs 논블로킹 비교표\n| 구분 | 블로킹 | 논블로킹 |\n|------|--------|----------|\n| 제어권 | 완료까지 대기 | 즉시 반환 |\n| 코드 복잡도 | 낮음 | 높음 |\n| 스레드 효율 | 낮음 | 높음 |\n| 대표 예시 | JDBC, 일반 소켓 | NIO, Node.js |\n\n### 자주 나오는 면접 질문\n1. **Q: 동기와 블로킹의 차이점은?**\n   - A: 동기는 결과를 직접 받음, 블로킹은 제어권이 없음\n   - 동기-논블로킹 조합도 가능 (결과 직접 받지만 제어권은 있음)\n\n2. **Q: Node.js가 빠른 이유는?**\n   - A: 논블로킹 I/O + 이벤트 루프로 단일 스레드가 많은 연결 처리\n\n3. **Q: 블로킹 I/O의 단점은?**\n   - A: 동시 연결당 스레드 필요 -> 메모리 낭비, 컨텍스트 스위칭 오버헤드"
      }
    ]
  },
  "05_동기비동기/sync-async": {
    "id": "05_동기비동기/sync-async",
    "title": "동기 vs 비동기",
    "category": "os",
    "subCategory": "05_동기비동기",
    "language": "Java",
    "description": "동기와 비동기의 핵심 차이점을 커피숍 비유로 이해하고, 실무에서의 활용법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "동기 vs 비동기: 결과를 기다리는가?",
        "content": "## 커피숍 주문으로 이해하는 동기/비동기\n\n### 동기(Synchronous) - 카운터에서 기다리기\n```\n[고객] --> [주문] --> [기다림...] --> [커피 받음] --> [자리로 이동]\n         |<-------- 아무것도 못함 -------->|\n```\n- 커피가 나올 때까지 카운터 앞에서 대기\n- 결과(커피)를 받을 때까지 다른 일을 하지 않음\n- **호출자가 결과를 직접 받아감**\n\n### 비동기(Asynchronous) - 진동벨 받고 자리로\n```\n[고객] --> [주문] --> [진동벨 받음] --> [자리에서 대기/다른 일]\n                           |\n                    [진동벨 울림] --> [커피 받으러 감]\n```\n- 진동벨을 받고 자리에서 다른 일 가능\n- 커피가 준비되면 알림(콜백)을 받음\n- **결과는 나중에 콜백/알림으로 전달됨**\n\n### 핵심 차이점\n| 구분 | 동기 | 비동기 |\n|------|------|--------|\n| 결과 수신 | 직접 대기하며 받음 | 콜백/알림으로 받음 |\n| 실행 순서 | 순차적 보장 | 순서 보장 안됨 |\n| 코드 흐름 | 직관적 | 콜백 지옥 가능 |\n| 자원 활용 | 대기 중 낭비 | 효율적 활용 |"
      },
      {
        "type": "code",
        "title": "Java CompletableFuture로 비동기 처리",
        "language": "java",
        "code": "import java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\n\npublic class SyncAsyncExample {\n    \n    // 동기 방식: 결과를 직접 기다림\n    public static String syncOrderCoffee(String type) {\n        System.out.println(\"[동기] 커피 주문: \" + type);\n        try {\n            Thread.sleep(3000); // 커피 제조 시간\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        return type + \" 완성!\";\n    }\n    \n    // 비동기 방식: 진동벨(Future) 받고 나중에 결과 수신\n    public static CompletableFuture<String> asyncOrderCoffee(String type) {\n        System.out.println(\"[비동기] 커피 주문: \" + type);\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                Thread.sleep(3000); // 커피 제조 시간\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            return type + \" 완성!\";\n        });\n    }\n    \n    public static void main(String[] args) throws Exception {\n        // === 동기 방식 ===\n        long start = System.currentTimeMillis();\n        String coffee1 = syncOrderCoffee(\"아메리카노\");\n        String coffee2 = syncOrderCoffee(\"라떼\");\n        System.out.println(coffee1 + \", \" + coffee2);\n        System.out.println(\"동기 소요시간: \" + (System.currentTimeMillis() - start) + \"ms\");\n        // 결과: 약 6000ms (순차 실행)\n        \n        // === 비동기 방식 ===\n        start = System.currentTimeMillis();\n        CompletableFuture<String> future1 = asyncOrderCoffee(\"아메리카노\");\n        CompletableFuture<String> future2 = asyncOrderCoffee(\"라떼\");\n        \n        // 진동벨 울리면 받으러 감 (콜백)\n        future1.thenAccept(result -> System.out.println(\"콜백: \" + result));\n        future2.thenAccept(result -> System.out.println(\"콜백: \" + result));\n        \n        // 두 작업 모두 완료 대기\n        CompletableFuture.allOf(future1, future2).join();\n        System.out.println(\"비동기 소요시간: \" + (System.currentTimeMillis() - start) + \"ms\");\n        // 결과: 약 3000ms (병렬 실행)\n    }\n}"
      },
      {
        "type": "code",
        "title": "Node.js 동기/비동기 비교",
        "language": "javascript",
        "code": "const fs = require('fs');\nconst fsPromises = require('fs').promises;\n\n// === 동기 방식: 파일 읽기 완료까지 블로킹 ===\nconsole.log('1. 동기 읽기 시작');\nconst dataSync = fs.readFileSync('file.txt', 'utf8');\nconsole.log('2. 동기 읽기 완료:', dataSync);\nconsole.log('3. 다음 작업'); // 2번 이후에만 실행됨\n\n// 실행 순서: 1 -> 2 -> 3 (보장됨)\n\n// === 비동기 방식 (콜백): 진동벨 패턴 ===\nconsole.log('1. 비동기 읽기 시작');\nfs.readFile('file.txt', 'utf8', (err, data) => {\n    // 이 콜백은 파일 읽기가 완료되면 호출됨 (진동벨 울림)\n    console.log('3. 비동기 읽기 완료:', data);\n});\nconsole.log('2. 다음 작업'); // 바로 실행됨 (기다리지 않음)\n\n// 실행 순서: 1 -> 2 -> 3 (순서 보장 안됨!)\n\n// === 비동기 방식 (Promise + async/await) ===\nasync function readFileAsync() {\n    console.log('1. async 읽기 시작');\n    \n    // await로 비동기를 동기처럼 작성 (가독성 향상)\n    const data = await fsPromises.readFile('file.txt', 'utf8');\n    console.log('2. async 읽기 완료:', data);\n    \n    console.log('3. 다음 작업');\n}\n\n// === 여러 비동기 작업 병렬 처리 ===\nasync function parallelRead() {\n    console.log('병렬 읽기 시작');\n    const startTime = Date.now();\n    \n    // Promise.all: 모든 진동벨이 울릴 때까지 대기\n    const [file1, file2, file3] = await Promise.all([\n        fsPromises.readFile('file1.txt', 'utf8'),\n        fsPromises.readFile('file2.txt', 'utf8'),\n        fsPromises.readFile('file3.txt', 'utf8')\n    ]);\n    \n    console.log(`병렬 완료: ${Date.now() - startTime}ms`);\n    // 3개 파일을 동시에 읽어서 가장 느린 파일 시간만 소요\n}"
      },
      {
        "type": "tip",
        "title": "면접 대비 핵심 정리",
        "content": "## 동기 vs 비동기 핵심 요약\n\n### 면접 답변 템플릿\n```\n\"동기는 작업의 결과를 직접 기다리는 방식이고,\n비동기는 작업을 맡겨두고 결과는 나중에 콜백으로 받는 방식입니다.\n\n커피숍에 비유하면, 동기는 카운터에서 커피가 나올 때까지 대기하는 것이고,\n비동기는 진동벨을 받고 자리에서 다른 일을 하다가 벨이 울리면 받으러 가는 것입니다.\"\n```\n\n### 실무 선택 기준\n| 상황 | 추천 방식 | 이유 |\n|------|----------|------|\n| 순서 보장 필요 | 동기 | 실행 순서 예측 가능 |\n| I/O 작업 많음 | 비동기 | CPU 대기 시간 활용 |\n| 독립적 작업 여러 개 | 비동기 병렬 | 총 소요 시간 단축 |\n| 간단한 스크립트 | 동기 | 코드 복잡도 낮음 |\n\n### 자주 나오는 면접 질문\n1. **Q: 동기와 비동기의 차이점은?**\n   - A: 결과를 직접 기다리느냐(동기), 콜백으로 받느냐(비동기)의 차이\n\n2. **Q: 비동기 처리의 장단점은?**\n   - 장점: 자원 효율적 활용, 응답성 향상\n   - 단점: 코드 복잡도 증가, 디버깅 어려움\n\n3. **Q: async/await는 동기인가요 비동기인가요?**\n   - A: 비동기입니다. 동기처럼 보이게 작성하는 문법적 설탕(Syntactic Sugar)일 뿐"
      }
    ]
  },
  "05_동기비동기/sync-blocking-matrix": {
    "id": "05_동기비동기/sync-blocking-matrix",
    "title": "동기/비동기 x 블로킹/논블로킹 매트릭스",
    "category": "os",
    "subCategory": "05_동기비동기",
    "language": "Java",
    "description": "4가지 조합(동기-블로킹, 동기-논블로킹, 비동기-블로킹, 비동기-논블로킹)을 실무 예시와 함께 완벽하게 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "4가지 조합 완벽 이해",
        "content": "## 동기/비동기 x 블로킹/논블로킹 매트릭스\n\n```\n                    │     블로킹          │      논블로킹\n────────────────────┼─────────────────────┼─────────────────────\n   동  기           │  카운터에서 멍때림   │  카운터에서 폰 보기\n (결과 직접 받음)   │  - JDBC 쿼리        │  - Polling 방식\n                    │  - 일반 HTTP 요청   │  - CompletableFuture.isDone()\n────────────────────┼─────────────────────┼─────────────────────\n   비동기           │  진동벨+멍때림      │  진동벨+자리서 작업\n (콜백으로 받음)    │  - select() 후 대기 │  - Node.js I/O\n                    │  - Future.get()     │  - Spring WebFlux\n```\n\n### 1. 동기 + 블로킹 (가장 흔함)\n```\n[나] --요청--> [작업] --대기(멍때림)--> [결과] --반환--> [나]\n               |<-- 제어권 없음, 결과 직접 대기 -->|\n```\n- 예: JDBC 쿼리, 일반 HTTP 요청\n- 카운터에서 커피 나올 때까지 멍하니 서있기\n\n### 2. 동기 + 논블로킹 (폴링)\n```\n[나] --요청--> [작업]\n     <--반환-- (아직 안됨)\n[나] --됐나?-> [작업]\n     <--반환-- (아직 안됨)\n[나] --됐나?-> [작업]\n     <--반환-- [결과!]\n```\n- 예: Future.isDone() 체크, busy-wait\n- 카운터에서 \"됐나요?\" 계속 물어보기\n\n### 3. 비동기 + 블로킹 (드묾)\n```\n[나] --요청--> [작업] --진동벨-->\n              <------- 대기(멍때림) ------->\n                      [벨 울림!] --> [결과]\n```\n- 예: select() 시스템 콜\n- 진동벨 받고도 멍하니 벨만 쳐다봄\n\n### 4. 비동기 + 논블로킹 (가장 효율적)\n```\n[나] --요청--> [작업] --진동벨-->\n[나] --다른일--> [다른일] --> [다른일]\n                      [벨 울림!] --> [결과]\n```\n- 예: Node.js, Spring WebFlux, Netty\n- 진동벨 받고 자리에서 다른 일 하기"
      },
      {
        "type": "code",
        "title": "Java로 4가지 조합 구현",
        "language": "java",
        "code": "import java.util.concurrent.*;\n\npublic class SyncAsyncBlockingMatrix {\n    \n    // 커피 만드는 작업 (3초 소요)\n    private static String makeCoffee() {\n        try { Thread.sleep(3000); } \n        catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        return \"커피 완성!\";\n    }\n    \n    // ============================================\n    // 1. 동기 + 블로킹: 가장 기본적인 방식\n    // ============================================\n    public static void syncBlocking() {\n        System.out.println(\"[동기+블로킹] 주문 시작\");\n        \n        // 결과 직접 받음(동기) + 완료까지 대기(블로킹)\n        String coffee = makeCoffee();\n        \n        System.out.println(\"[동기+블로킹] \" + coffee);\n        // 특징: 코드 단순, 하지만 3초간 아무것도 못함\n    }\n    \n    // ============================================\n    // 2. 동기 + 논블로킹: 폴링 방식\n    // ============================================\n    public static void syncNonBlocking() throws Exception {\n        System.out.println(\"[동기+논블로킹] 주문 시작\");\n        \n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        Future<String> future = executor.submit(() -> makeCoffee());\n        \n        // 결과 직접 확인(동기) + 즉시 반환(논블로킹)\n        while (!future.isDone()) {\n            System.out.println(\"아직 안됨... 다른 일 하는 중\");\n            Thread.sleep(500); // 다른 작업\n        }\n        \n        String coffee = future.get(); // 이미 완료됨\n        System.out.println(\"[동기+논블로킹] \" + coffee);\n        executor.shutdown();\n        // 특징: 폴링 오버헤드, 하지만 대기 중 다른 일 가능\n    }\n    \n    // ============================================\n    // 3. 비동기 + 블로킹: 흔하지 않은 조합\n    // ============================================\n    public static void asyncBlocking() throws Exception {\n        System.out.println(\"[비동기+블로킹] 주문 시작\");\n        \n        CompletableFuture<String> future = CompletableFuture\n            .supplyAsync(() -> makeCoffee());\n        \n        // 콜백 등록(비동기)\n        future.thenAccept(coffee -> {\n            System.out.println(\"콜백: \" + coffee);\n        });\n        \n        // 하지만 여기서 블로킹 대기...\n        String coffee = future.get(); // 블로킹!\n        System.out.println(\"[비동기+블로킹] \" + coffee);\n        // 특징: 비동기로 시작했지만 get()에서 블로킹\n    }\n    \n    // ============================================\n    // 4. 비동기 + 논블로킹: 가장 효율적\n    // ============================================\n    public static void asyncNonBlocking() {\n        System.out.println(\"[비동기+논블로킹] 주문 시작\");\n        \n        CompletableFuture<String> future = CompletableFuture\n            .supplyAsync(() -> makeCoffee())\n            .thenAccept(coffee -> {\n                // 콜백으로 결과 수신(비동기)\n                System.out.println(\"[비동기+논블로킹] 콜백: \" + coffee);\n            });\n        \n        // 즉시 반환(논블로킹) - 다른 작업 수행 가능\n        System.out.println(\"주문 완료, 다른 일 하는 중...\");\n        doOtherWork();\n        doOtherWork();\n        doOtherWork();\n        \n        // 메인 스레드 종료 방지 (실제로는 서버 환경에서 불필요)\n        future.join();\n        // 특징: 가장 효율적, 대기 시간 없이 자원 활용\n    }\n    \n    private static void doOtherWork() {\n        System.out.println(\"  -> 다른 작업 수행 중...\");\n        try { Thread.sleep(500); } catch (InterruptedException e) {}\n    }\n    \n    public static void main(String[] args) throws Exception {\n        syncBlocking();\n        System.out.println(\"---\");\n        syncNonBlocking();\n        System.out.println(\"---\");\n        asyncBlocking();\n        System.out.println(\"---\");\n        asyncNonBlocking();\n    }\n}"
      },
      {
        "type": "code",
        "title": "Spring WebFlux 비동기 논블로킹 실무 코드",
        "language": "java",
        "code": "// === Spring WebFlux: 비동기 + 논블로킹의 정석 ===\n\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.reactive.function.client.WebClient;\nimport reactor.core.publisher.Mono;\nimport reactor.core.publisher.Flux;\nimport java.time.Duration;\n\n@RestController\npublic class AsyncNonBlockingController {\n    \n    private final WebClient webClient = WebClient.create();\n    \n    // === 비동기 + 논블로킹 API 호출 ===\n    @GetMapping(\"/user/{id}\")\n    public Mono<User> getUser(@PathVariable String id) {\n        // WebClient는 논블로킹 HTTP 클라이언트\n        return webClient.get()\n            .uri(\"https://api.example.com/users/\" + id)\n            .retrieve()\n            .bodyToMono(User.class)\n            .timeout(Duration.ofSeconds(5))\n            .onErrorReturn(new User(\"fallback\", \"Unknown\"));\n        // 스레드가 블로킹되지 않음!\n    }\n    \n    // === 여러 API 동시 호출 (병렬 처리) ===\n    @GetMapping(\"/dashboard/{userId}\")\n    public Mono<Dashboard> getDashboard(@PathVariable String userId) {\n        // 3개 API를 동시에 호출 (논블로킹)\n        Mono<User> userMono = webClient.get()\n            .uri(\"/users/\" + userId)\n            .retrieve().bodyToMono(User.class);\n        \n        Mono<List<Order>> ordersMono = webClient.get()\n            .uri(\"/orders?userId=\" + userId)\n            .retrieve().bodyToMono(new ParameterizedTypeReference<List<Order>>() {});\n        \n        Mono<List<Notification>> notificationsMono = webClient.get()\n            .uri(\"/notifications?userId=\" + userId)\n            .retrieve().bodyToMono(new ParameterizedTypeReference<List<Notification>>() {});\n        \n        // 모든 결과를 조합 (zip)\n        return Mono.zip(userMono, ordersMono, notificationsMono)\n            .map(tuple -> new Dashboard(\n                tuple.getT1(),  // User\n                tuple.getT2(),  // Orders\n                tuple.getT3()   // Notifications\n            ));\n        // 가장 느린 API 시간만큼만 소요! (병렬 처리)\n    }\n    \n    // === 스트리밍 응답 (Server-Sent Events) ===\n    @GetMapping(value = \"/stream\", produces = \"text/event-stream\")\n    public Flux<String> streamEvents() {\n        // 1초마다 이벤트 전송 (논블로킹)\n        return Flux.interval(Duration.ofSeconds(1))\n            .map(seq -> \"Event \" + seq + \" at \" + System.currentTimeMillis());\n    }\n    \n    // === R2DBC: 비동기 논블로킹 DB 접근 ===\n    @Autowired\n    private UserRepository userRepository; // R2DBC Repository\n    \n    @GetMapping(\"/users\")\n    public Flux<User> getAllUsers() {\n        // JDBC는 블로킹, R2DBC는 논블로킹!\n        return userRepository.findAll()\n            .delayElements(Duration.ofMillis(100)); // 백프레셔 조절\n    }\n}\n\n// === 동기 블로킹 vs 비동기 논블로킹 성능 비교 ===\n/*\n시나리오: 1000명 동시 요청, API 응답 1초\n\n[동기 블로킹 - Spring MVC + RestTemplate]\n- 스레드 풀: 200개\n- 동시 처리: 200개\n- 나머지 800개: 대기\n- 총 소요: 약 5초\n\n[비동기 논블로킹 - Spring WebFlux + WebClient]\n- 스레드: 4개 (CPU 코어 수)\n- 동시 처리: 1000개 전부!\n- 총 소요: 약 1초\n*/"
      },
      {
        "type": "tip",
        "title": "4가지 조합 비교표 및 면접 질문",
        "content": "## 4가지 조합 완벽 비교표\n\n| 조합 | 제어권 | 결과 수신 | 예시 | 효율성 |\n|------|--------|----------|------|--------|\n| 동기+블로킹 | X | 직접 | JDBC, RestTemplate | ★☆☆☆ |\n| 동기+논블로킹 | O | 직접(폴링) | Future.isDone() | ★★☆☆ |\n| 비동기+블로킹 | X | 콜백 | select() | ★★☆☆ |\n| 비동기+논블로킹 | O | 콜백 | WebFlux, Node.js | ★★★★ |\n\n### 커피숍 비유 정리\n```\n동기+블로킹:     카운터에서 멍하니 대기\n동기+논블로킹:   카운터에서 \"됐나요?\" 반복\n비동기+블로킹:   진동벨 받고 멍하니 벨만 봄\n비동기+논블로킹: 진동벨 받고 자리서 다른 일\n```\n\n### 면접 핵심 질문\n\n**Q1: 동기/비동기와 블로킹/논블로킹의 차이?**\n```\n동기/비동기: 결과를 어떻게 받는가?\n  - 동기: 직접 대기하며 받음\n  - 비동기: 콜백/이벤트로 받음\n\n블로킹/논블로킹: 대기 중 제어권이 있는가?\n  - 블로킹: 완료까지 제어권 없음\n  - 논블로킹: 즉시 제어권 반환\n```\n\n**Q2: Spring MVC vs WebFlux 차이?**\n```\nMVC: 동기+블로킹 (스레드 per 요청)\n  - 구현 쉬움, 디버깅 쉬움\n  - 동시 연결 많으면 스레드 부족\n\nWebFlux: 비동기+논블로킹 (이벤트 루프)\n  - 적은 스레드로 많은 연결 처리\n  - 학습 곡선 높음, 디버깅 어려움\n```\n\n**Q3: 언제 무엇을 써야 하나요?**\n```\n- CPU 집약적 작업: 동기 블로킹 OK\n- I/O 집약적 + 동시 연결 많음: 비동기 논블로킹\n- 간단한 CRUD API: Spring MVC\n- 실시간 스트리밍: WebFlux\n```"
      }
    ]
  },
  "05_동기화/critical-section": {
    "id": "05_동기화/critical-section",
    "title": "임계 영역 (Critical Section)",
    "category": "os",
    "subCategory": "05_동기화",
    "language": "Java",
    "description": "임계 영역의 개념과 발생 조건, 해결을 위한 3가지 조건을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "임계 영역: 한 번에 하나만 들어갈 수 있는 구역",
        "content": "## 화장실로 이해하는 임계 영역\n\n### 비유: 1인용 화장실\n```\n    [대기줄]     [화장실]     [사용 중]\n    스레드B  -->   🚽    <--  스레드A\n    스레드C       (잠금)       (사용 중)\n    \n    - 화장실 = 임계 영역 (Critical Section)\n    - 문 잠금 = Lock/Mutex\n    - 한 번에 한 명만 사용 가능!\n```\n\n### 임계 영역이란?\n공유 자원에 접근하는 코드 영역으로, **동시에 여러 스레드가 접근하면 문제가 발생**하는 구간\n\n```\n[공유 자원]          [임계 영역]\n- 전역 변수         - 전역 변수 읽기/쓰기\n- 파일              - 파일 읽기/쓰기  \n- DB 레코드         - DB UPDATE\n- 공유 메모리       - 공유 메모리 접근\n```\n\n### 임계 영역 문제 예시: 은행 계좌\n```\n[초기 잔액: 1000원]\n\n스레드A (출금 500원)        스레드B (출금 300원)\n────────────────────────────────────────────────\n1. 잔액 읽기: 1000원\n                           2. 잔액 읽기: 1000원\n3. 계산: 1000-500=500\n                           4. 계산: 1000-300=700\n5. 잔액 저장: 500원\n                           6. 잔액 저장: 700원\n\n[최종 잔액: 700원]  ← 오류! 실제로는 200원이어야 함\n```\n\n### 임계 영역 해결의 3가지 조건\n\n| 조건 | 설명 | 비유 |\n|------|------|------|\n| **상호 배제** (Mutual Exclusion) | 한 번에 하나의 프로세스만 진입 | 화장실 문 잠금 |\n| **진행** (Progress) | 아무도 없으면 대기 없이 진입 가능 | 빈 화장실은 바로 입장 |\n| **한정 대기** (Bounded Waiting) | 무한 대기 방지, 공정하게 진입 | 대기 순서 지킴 |"
      },
      {
        "type": "code",
        "title": "Java synchronized로 임계 영역 보호",
        "language": "java",
        "code": "public class CriticalSectionExample {\n    \n    // === 문제 상황: 임계 영역 보호 없음 ===\n    static class UnsafeBankAccount {\n        private int balance = 1000;\n        \n        // 임계 영역: balance 읽기/쓰기\n        public void withdraw(int amount) {\n            if (balance >= amount) {\n                // 문제 발생 지점!\n                // 여러 스레드가 동시에 이 코드 실행 가능\n                int newBalance = balance - amount;\n                try { Thread.sleep(1); } catch (Exception e) {}\n                balance = newBalance;\n            }\n        }\n        \n        public int getBalance() { return balance; }\n    }\n    \n    // === 해결: synchronized로 임계 영역 보호 ===\n    static class SafeBankAccount {\n        private int balance = 1000;\n        private final Object lock = new Object();\n        \n        // 방법 1: synchronized 메서드 (this 잠금)\n        public synchronized void withdrawSync(int amount) {\n            if (balance >= amount) {\n                int newBalance = balance - amount;\n                try { Thread.sleep(1); } catch (Exception e) {}\n                balance = newBalance;\n            }\n        }\n        \n        // 방법 2: synchronized 블록 (특정 객체 잠금)\n        public void withdrawBlock(int amount) {\n            synchronized (lock) {  // lock 획득\n                // === 임계 영역 시작 ===\n                if (balance >= amount) {\n                    int newBalance = balance - amount;\n                    try { Thread.sleep(1); } catch (Exception e) {}\n                    balance = newBalance;\n                }\n                // === 임계 영역 끝 ===\n            }  // lock 반환\n        }\n        \n        public int getBalance() { return balance; }\n    }\n    \n    public static void main(String[] args) throws Exception {\n        // 안전하지 않은 계좌 테스트\n        UnsafeBankAccount unsafeAccount = new UnsafeBankAccount();\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 100; i++) unsafeAccount.withdraw(5);\n        });\n        Thread t2 = new Thread(() -> {\n            for (int i = 0; i < 100; i++) unsafeAccount.withdraw(5);\n        });\n        t1.start(); t2.start();\n        t1.join(); t2.join();\n        System.out.println(\"[Unsafe] 예상: 0, 실제: \" + unsafeAccount.getBalance());\n        \n        // 안전한 계좌 테스트\n        SafeBankAccount safeAccount = new SafeBankAccount();\n        Thread t3 = new Thread(() -> {\n            for (int i = 0; i < 100; i++) safeAccount.withdrawSync(5);\n        });\n        Thread t4 = new Thread(() -> {\n            for (int i = 0; i < 100; i++) safeAccount.withdrawSync(5);\n        });\n        t3.start(); t4.start();\n        t3.join(); t4.join();\n        System.out.println(\"[Safe] 예상: 0, 실제: \" + safeAccount.getBalance());\n    }\n}"
      },
      {
        "type": "code",
        "title": "다양한 임계 영역 보호 방법",
        "language": "java",
        "code": "import java.util.concurrent.locks.*;\nimport java.util.concurrent.atomic.*;\n\npublic class CriticalSectionSolutions {\n    \n    // === 1. ReentrantLock: 명시적 잠금 ===\n    static class LockAccount {\n        private int balance = 1000;\n        private final Lock lock = new ReentrantLock();\n        \n        public void withdraw(int amount) {\n            lock.lock();  // 잠금 획득\n            try {\n                // === 임계 영역 ===\n                if (balance >= amount) {\n                    balance -= amount;\n                }\n            } finally {\n                lock.unlock();  // 반드시 해제!\n            }\n        }\n        \n        // tryLock: 잠금 시도 (대기하지 않음)\n        public boolean tryWithdraw(int amount) {\n            if (lock.tryLock()) {\n                try {\n                    if (balance >= amount) {\n                        balance -= amount;\n                        return true;\n                    }\n                } finally {\n                    lock.unlock();\n                }\n            }\n            return false; // 잠금 실패\n        }\n    }\n    \n    // === 2. AtomicInteger: Lock-free 동기화 ===\n    static class AtomicAccount {\n        private AtomicInteger balance = new AtomicInteger(1000);\n        \n        public void withdraw(int amount) {\n            // CAS (Compare-And-Swap) 연산 사용\n            int current, newValue;\n            do {\n                current = balance.get();\n                if (current < amount) return;\n                newValue = current - amount;\n            } while (!balance.compareAndSet(current, newValue));\n            // 실패하면 재시도 (낙관적 락)\n        }\n        \n        // 더 간단한 방법\n        public void withdrawSimple(int amount) {\n            balance.addAndGet(-amount);\n        }\n    }\n    \n    // === 3. ReadWriteLock: 읽기/쓰기 분리 ===\n    static class ReadWriteAccount {\n        private int balance = 1000;\n        private final ReadWriteLock rwLock = new ReentrantReadWriteLock();\n        private final Lock readLock = rwLock.readLock();\n        private final Lock writeLock = rwLock.writeLock();\n        \n        // 읽기: 여러 스레드 동시 가능\n        public int getBalance() {\n            readLock.lock();\n            try {\n                return balance;\n            } finally {\n                readLock.unlock();\n            }\n        }\n        \n        // 쓰기: 한 스레드만 가능\n        public void withdraw(int amount) {\n            writeLock.lock();\n            try {\n                if (balance >= amount) {\n                    balance -= amount;\n                }\n            } finally {\n                writeLock.unlock();\n            }\n        }\n    }\n    \n    // === 성능 비교 ===\n    /*\n    상황: 읽기 80%, 쓰기 20%\n    \n    synchronized:     ████████████ (읽기도 직렬화)\n    ReentrantLock:    ████████████ (읽기도 직렬화)\n    ReadWriteLock:    ████ (읽기 병렬 가능)\n    AtomicInteger:    ██ (Lock-free, 가장 빠름)\n    \n    선택 기준:\n    - 단순한 경우: synchronized\n    - 타임아웃 필요: ReentrantLock\n    - 읽기 많음: ReadWriteLock\n    - 단일 변수: AtomicInteger\n    */\n}"
      },
      {
        "type": "tip",
        "title": "면접 대비 핵심 정리",
        "content": "## 임계 영역 핵심 요약\n\n### 면접 답변 템플릿\n```\n\"임계 영역은 공유 자원에 접근하는 코드 영역으로,\n여러 스레드가 동시에 접근하면 Race Condition이 발생합니다.\n\n화장실에 비유하면, 1인용 화장실처럼 한 번에 한 명만\n사용할 수 있도록 보호해야 하는 구역입니다.\n\n해결을 위해서는 상호 배제(한 번에 하나),\n진행(빈 곳은 바로 진입), 한정 대기(무한 대기 방지)\n세 가지 조건을 만족해야 합니다.\"\n```\n\n### 동기화 도구 비교표\n| 도구 | 특징 | 사용 시기 |\n|------|------|----------|\n| synchronized | 간단, 자동 해제 | 기본적인 동기화 |\n| ReentrantLock | 타임아웃, 공정성 | 세밀한 제어 필요 |\n| ReadWriteLock | 읽기 병렬화 | 읽기 >> 쓰기 |\n| Atomic 클래스 | Lock-free | 단일 변수 연산 |\n\n### 자주 나오는 면접 질문\n\n**Q1: 임계 영역이란?**\n- 공유 자원에 접근하는 코드 영역으로, 동시 접근 시 문제 발생\n\n**Q2: Race Condition이란?**\n- 여러 스레드가 공유 자원에 동시 접근하여 결과가 실행 순서에 따라 달라지는 상황\n\n**Q3: synchronized vs Lock 차이?**\n- synchronized: 암묵적, 자동 해제, 단순\n- Lock: 명시적, 수동 해제, 타임아웃/조건 지원\n\n**Q4: 임계 영역 해결의 3가지 조건?**\n- 상호 배제: 동시 진입 불가\n- 진행: 빈 곳은 즉시 진입\n- 한정 대기: 무한 대기 방지"
      }
    ]
  },
  "05_동기화/deadlock-solution": {
    "id": "05_동기화/deadlock-solution",
    "title": "데드락 해결 방법",
    "category": "os",
    "subCategory": "05_동기화",
    "language": "Java",
    "description": "데드락의 4가지 필요조건과 해결 방법(예방, 회피, 탐지, 회복)을 실무 예시와 함께 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "데드락과 4가지 해결 전략",
        "content": "## 교착 상태(Deadlock) 이해하기\n\n### 비유: 좁은 골목길에서 마주친 두 차\n```\n    ← 차A [====]        [====] 차B →\n              ↑        ↑\n           진행불가  진행불가\n           \n    둘 다 양보 안하면 영원히 멈춤!\n```\n\n### 데드락 발생의 4가지 필요조건 (모두 충족 시 발생)\n\n| 조건 | 설명 | 비유 |\n|------|------|------|\n| **상호 배제** | 자원은 한 번에 하나만 사용 | 일방통행 골목 |\n| **점유 대기** | 자원 보유하며 다른 자원 대기 | 내 차 안놓고 기다림 |\n| **비선점** | 강제로 빼앗을 수 없음 | 차를 밀어버릴 수 없음 |\n| **순환 대기** | 원형으로 서로 대기 | A→B, B→A 대기 |\n\n### 4가지 해결 전략\n\n```\n    ┌─────────────────────────────────────────────┐\n    │             데드락 해결 전략                 │\n    ├─────────────┬─────────────┬────────────────┤\n    │   예방      │   회피      │  탐지 & 회복   │\n    │ Prevention  │  Avoidance  │ Detection &    │\n    │             │             │   Recovery     │\n    ├─────────────┼─────────────┼────────────────┤\n    │ 조건 자체를 │ 안전 상태만 │ 발생 후 해결  │\n    │ 제거        │ 허용        │               │\n    ├─────────────┼─────────────┼────────────────┤\n    │ 자원 낭비↑  │ 오버헤드↑   │ 자원 효율↑   │\n    │ 구현 쉬움   │ 은행원알고리즘│ 주기적 검사  │\n    └─────────────┴─────────────┴────────────────┘\n```\n\n### 1. 예방 (Prevention)\n- 4가지 조건 중 하나 이상 제거\n- **상호 배제 제거**: 불가능 (자원 특성)\n- **점유 대기 제거**: 모든 자원을 한 번에 요청\n- **비선점 제거**: 강제 자원 회수 허용\n- **순환 대기 제거**: 자원 번호 순서대로 요청\n\n### 2. 회피 (Avoidance)\n- 안전 상태(Safe State)만 허용\n- 은행원 알고리즘 (Banker's Algorithm)\n\n### 3. 탐지 & 회복 (Detection & Recovery)\n- 주기적으로 데드락 검사\n- 발견 시 프로세스 종료 또는 자원 선점"
      },
      {
        "type": "code",
        "title": "데드락 발생 및 예방 코드",
        "language": "java",
        "code": "import java.util.concurrent.locks.*;\nimport java.util.concurrent.TimeUnit;\n\npublic class DeadlockSolution {\n    \n    // === 데드락 발생 코드 ===\n    static class DeadlockExample {\n        private final Object lockA = new Object();\n        private final Object lockB = new Object();\n        \n        public void method1() {\n            synchronized (lockA) {  // A 획득\n                System.out.println(\"Thread1: lockA 획득\");\n                try { Thread.sleep(100); } catch (Exception e) {}\n                \n                synchronized (lockB) {  // B 대기 -> 데드락!\n                    System.out.println(\"Thread1: lockB 획득\");\n                }\n            }\n        }\n        \n        public void method2() {\n            synchronized (lockB) {  // B 획득\n                System.out.println(\"Thread2: lockB 획득\");\n                try { Thread.sleep(100); } catch (Exception e) {}\n                \n                synchronized (lockA) {  // A 대기 -> 데드락!\n                    System.out.println(\"Thread2: lockA 획득\");\n                }\n            }\n        }\n    }\n    \n    // === 해결1: 순환 대기 제거 (Lock Ordering) ===\n    static class LockOrderingSolution {\n        private final Object lockA = new Object();\n        private final Object lockB = new Object();\n        \n        // 항상 A -> B 순서로 획득 (순환 불가)\n        public void method1() {\n            synchronized (lockA) {\n                System.out.println(\"Thread1: lockA 획득\");\n                synchronized (lockB) {\n                    System.out.println(\"Thread1: lockB 획득\");\n                }\n            }\n        }\n        \n        public void method2() {\n            synchronized (lockA) {  // B가 아닌 A 먼저!\n                System.out.println(\"Thread2: lockA 획득\");\n                synchronized (lockB) {\n                    System.out.println(\"Thread2: lockB 획득\");\n                }\n            }\n        }\n    }\n    \n    // === 해결2: tryLock으로 타임아웃 (비선점 제거) ===\n    static class TryLockSolution {\n        private final Lock lockA = new ReentrantLock();\n        private final Lock lockB = new ReentrantLock();\n        \n        public void method1() {\n            while (true) {\n                try {\n                    if (lockA.tryLock(100, TimeUnit.MILLISECONDS)) {\n                        try {\n                            if (lockB.tryLock(100, TimeUnit.MILLISECONDS)) {\n                                try {\n                                    // 작업 수행\n                                    System.out.println(\"작업 완료!\");\n                                    return;\n                                } finally {\n                                    lockB.unlock();\n                                }\n                            }\n                        } finally {\n                            lockA.unlock();\n                        }\n                    }\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n                // 실패 시 잠시 대기 후 재시도\n                System.out.println(\"락 획득 실패, 재시도...\");\n                try { Thread.sleep((long)(Math.random() * 100)); } \n                catch (Exception e) {}\n            }\n        }\n    }\n    \n    // === 해결3: 모든 자원 한 번에 요청 (점유 대기 제거) ===\n    static class AllOrNothingSolution {\n        private final Lock lockA = new ReentrantLock();\n        private final Lock lockB = new ReentrantLock();\n        \n        public void doWork() {\n            // 모든 락을 한 번에 획득 시도\n            while (true) {\n                lockA.lock();\n                if (lockB.tryLock()) {\n                    try {\n                        // 모든 락 획득 성공!\n                        System.out.println(\"모든 자원 획득 성공!\");\n                        return;\n                    } finally {\n                        lockB.unlock();\n                        lockA.unlock();\n                    }\n                } else {\n                    // B 획득 실패 -> A도 반납 (점유 대기 방지)\n                    lockA.unlock();\n                    System.out.println(\"락B 실패, 모두 반납 후 재시도\");\n                }\n            }\n        }\n    }\n}"
      },
      {
        "type": "code",
        "title": "은행원 알고리즘 (회피 전략)",
        "language": "java",
        "code": "// === 은행원 알고리즘 (Banker's Algorithm) ===\n// 데드락 회피: 안전 상태일 때만 자원 할당\n\npublic class BankersAlgorithm {\n    \n    private int[] available;      // 현재 사용 가능한 자원\n    private int[][] max;          // 각 프로세스의 최대 요구량\n    private int[][] allocation;   // 현재 할당된 자원\n    private int[][] need;         // 추가로 필요한 자원 (max - allocation)\n    \n    private int numProcesses;\n    private int numResources;\n    \n    public BankersAlgorithm(int processes, int resources, \n                           int[] available, int[][] max, int[][] allocation) {\n        this.numProcesses = processes;\n        this.numResources = resources;\n        this.available = available.clone();\n        this.max = max.clone();\n        this.allocation = allocation.clone();\n        \n        // need 계산\n        this.need = new int[processes][resources];\n        for (int i = 0; i < processes; i++) {\n            for (int j = 0; j < resources; j++) {\n                need[i][j] = max[i][j] - allocation[i][j];\n            }\n        }\n    }\n    \n    // 안전 상태 검사 (Safety Algorithm)\n    public boolean isSafeState() {\n        int[] work = available.clone();\n        boolean[] finish = new boolean[numProcesses];\n        \n        // 안전 순서열 찾기\n        StringBuilder safeSequence = new StringBuilder();\n        int count = 0;\n        \n        while (count < numProcesses) {\n            boolean found = false;\n            \n            for (int i = 0; i < numProcesses; i++) {\n                if (!finish[i] && canAllocate(need[i], work)) {\n                    // 프로세스 i 완료 가능\n                    for (int j = 0; j < numResources; j++) {\n                        work[j] += allocation[i][j]; // 자원 반납\n                    }\n                    finish[i] = true;\n                    safeSequence.append(\"P\").append(i).append(\" -> \");\n                    count++;\n                    found = true;\n                }\n            }\n            \n            if (!found) {\n                System.out.println(\"안전 상태 아님! 데드락 가능\");\n                return false;\n            }\n        }\n        \n        System.out.println(\"안전 순서열: \" + safeSequence.toString());\n        return true;\n    }\n    \n    // 자원 요청 처리 (Resource Request Algorithm)\n    public boolean requestResources(int processId, int[] request) {\n        System.out.println(\"P\" + processId + \" 요청: \" + arrayToString(request));\n        \n        // 1. 요청이 필요량 이하인지 확인\n        if (!canAllocate(request, need[processId])) {\n            System.out.println(\"오류: 최대 요구량 초과\");\n            return false;\n        }\n        \n        // 2. 요청이 사용 가능량 이하인지 확인\n        if (!canAllocate(request, available)) {\n            System.out.println(\"대기: 자원 부족\");\n            return false;\n        }\n        \n        // 3. 가상 할당 후 안전 상태 검사\n        // 임시로 할당\n        for (int j = 0; j < numResources; j++) {\n            available[j] -= request[j];\n            allocation[processId][j] += request[j];\n            need[processId][j] -= request[j];\n        }\n        \n        if (isSafeState()) {\n            System.out.println(\"요청 승인: 안전 상태 유지\");\n            return true;\n        } else {\n            // 롤백\n            for (int j = 0; j < numResources; j++) {\n                available[j] += request[j];\n                allocation[processId][j] -= request[j];\n                need[processId][j] += request[j];\n            }\n            System.out.println(\"요청 거부: 데드락 위험\");\n            return false;\n        }\n    }\n    \n    private boolean canAllocate(int[] request, int[] available) {\n        for (int i = 0; i < request.length; i++) {\n            if (request[i] > available[i]) return false;\n        }\n        return true;\n    }\n    \n    private String arrayToString(int[] arr) {\n        StringBuilder sb = new StringBuilder(\"[\");\n        for (int i = 0; i < arr.length; i++) {\n            sb.append(arr[i]);\n            if (i < arr.length - 1) sb.append(\", \");\n        }\n        return sb.append(\"]\").toString();\n    }\n    \n    public static void main(String[] args) {\n        // 예시: 3종류 자원, 5개 프로세스\n        int[] available = {3, 3, 2};\n        int[][] max = {\n            {7, 5, 3}, // P0\n            {3, 2, 2}, // P1\n            {9, 0, 2}, // P2\n            {2, 2, 2}, // P3\n            {4, 3, 3}  // P4\n        };\n        int[][] allocation = {\n            {0, 1, 0}, // P0\n            {2, 0, 0}, // P1\n            {3, 0, 2}, // P2\n            {2, 1, 1}, // P3\n            {0, 0, 2}  // P4\n        };\n        \n        BankersAlgorithm banker = new BankersAlgorithm(5, 3, available, max, allocation);\n        banker.isSafeState();\n        \n        // P1이 (1, 0, 2) 요청\n        banker.requestResources(1, new int[]{1, 0, 2});\n    }\n}"
      },
      {
        "type": "tip",
        "title": "면접 대비 핵심 정리",
        "content": "## 데드락 해결 핵심 요약\n\n### 면접 답변 템플릿\n```\n\"데드락은 상호 배제, 점유 대기, 비선점, 순환 대기\n네 가지 조건이 모두 충족될 때 발생합니다.\n\n해결 방법은 예방, 회피, 탐지&회복 세 가지가 있습니다.\n\n예방은 네 조건 중 하나를 제거하는 방식이고,\n회피는 은행원 알고리즘처럼 안전 상태만 허용하며,\n탐지&회복은 데드락 발생 후 프로세스 종료로 해결합니다.\n\n실무에서는 Lock Ordering(순환 대기 제거)이나\ntryLock 타임아웃을 주로 사용합니다.\"\n```\n\n### 해결 전략 비교표\n| 전략 | 방법 | 장점 | 단점 |\n|------|------|------|------|\n| 예방 | 조건 제거 | 데드락 원천 봉쇄 | 자원 낭비 |\n| 회피 | 안전 상태 검사 | 유연한 할당 | 오버헤드 |\n| 탐지&회복 | 주기적 검사 | 자원 효율 | 복구 비용 |\n\n### 실무에서 자주 쓰는 방법\n1. **Lock Ordering**: 항상 같은 순서로 락 획득\n2. **tryLock + 타임아웃**: 일정 시간 후 포기\n3. **단일 글로벌 락**: 모든 자원을 하나의 락으로 (간단하지만 비효율)\n\n### 자주 나오는 면접 질문\n\n**Q1: 데드락 발생 조건 4가지?**\n- 상호 배제, 점유 대기, 비선점, 순환 대기\n\n**Q2: 실무에서 데드락 예방 방법?**\n- Lock Ordering (순환 대기 제거)\n- tryLock 타임아웃 (비선점 제거)\n\n**Q3: 은행원 알고리즘이란?**\n- 자원 요청 시 안전 상태 검사\n- 안전하면 할당, 아니면 거부\n\n**Q4: 데드락 vs 라이브락 차이?**\n- 데드락: 서로 대기하며 멈춤\n- 라이브락: 서로 양보하며 진행 못함"
      }
    ]
  },
  "05_동기화/mutex-semaphore": {
    "id": "05_동기화/mutex-semaphore",
    "title": "뮤텍스 vs 세마포어",
    "category": "os",
    "subCategory": "05_동기화",
    "language": "Java",
    "description": "뮤텍스와 세마포어의 차이점을 화장실과 주차장 비유로 이해하고, 실무에서의 활용법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "뮤텍스 vs 세마포어: 화장실과 주차장",
        "content": "## 비유로 이해하는 뮤텍스와 세마포어\n\n### 뮤텍스(Mutex): 1인용 화장실\n```\n    🚽 [1인용 화장실]       🔑 [열쇠 1개]\n    \n    상황: 열쇠가 1개뿐!\n    - 사용하려면 열쇠를 가져감\n    - 나올 때 열쇠를 반납\n    - 열쇠 없으면 대기\n    \n    특징:\n    - 소유권 개념: 잠근 사람만 열 수 있음\n    - Binary(0 또는 1)\n    - 상호 배제(Mutual Exclusion)의 약자\n```\n\n### 세마포어(Semaphore): 주차장 (N칸)\n```\n    🅿️ [주차장 3칸]        📟 [카운터: 3]\n    \n    상황: 주차 가능 대수 표시!\n    - 입장 시: 카운터 -1\n    - 퇴장 시: 카운터 +1\n    - 카운터 0이면 대기\n    \n    특징:\n    - 소유권 없음: 아무나 신호 보낼 수 있음\n    - Counting(0 ~ N)\n    - 자원 개수 관리\n```\n\n### 핵심 차이점\n\n| 구분 | 뮤텍스 | 세마포어 |\n|------|--------|----------|\n| 비유 | 1인용 화장실 열쇠 | 주차장 카운터 |\n| 값 범위 | 0 또는 1 (Binary) | 0 ~ N (Counting) |\n| 소유권 | 있음 (잠근 스레드만 해제) | 없음 (아무나 signal 가능) |\n| 용도 | 상호 배제 | 자원 개수 제한, 순서 제어 |\n| 해제 조건 | 소유 스레드만 | 아무 스레드나 |\n\n### Binary Semaphore vs Mutex\n```\nBinary Semaphore (값이 0 또는 1):\n  - 소유권 없음\n  - 스레드 A가 wait(), 스레드 B가 signal() 가능\n  - 주로 동기화(순서 제어)에 사용\n\nMutex:\n  - 소유권 있음\n  - 잠근 스레드만 해제 가능\n  - 주로 상호 배제에 사용\n```"
      },
      {
        "type": "code",
        "title": "Java Semaphore 활용 예시",
        "language": "java",
        "code": "import java.util.concurrent.Semaphore;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class MutexSemaphoreExample {\n    \n    // === 뮤텍스: ReentrantLock (소유권 있음) ===\n    static class MutexExample {\n        private final ReentrantLock mutex = new ReentrantLock();\n        private int sharedResource = 0;\n        \n        public void accessResource(String threadName) {\n            mutex.lock();  // 열쇠 획득\n            try {\n                System.out.println(threadName + \": 화장실 입장\");\n                sharedResource++;\n                Thread.sleep(1000);  // 사용 중\n                System.out.println(threadName + \": 화장실 퇴장\");\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            } finally {\n                mutex.unlock();  // 열쇠 반납 (잠근 스레드만 가능!)\n            }\n        }\n    }\n    \n    // === 세마포어: 동시 접근 수 제한 ===\n    static class ParkingLot {\n        private final Semaphore parking = new Semaphore(3); // 주차 3칸\n        \n        public void park(String carName) {\n            try {\n                System.out.println(carName + \": 주차 대기 (남은 자리: \" \n                    + parking.availablePermits() + \")\");\n                \n                parking.acquire();  // P연산: 카운터 -1\n                System.out.println(carName + \": 주차 완료!\");\n                \n                Thread.sleep(2000);  // 주차 중\n                \n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            } finally {\n                parking.release();  // V연산: 카운터 +1\n                System.out.println(carName + \": 출차 완료!\");\n            }\n        }\n    }\n    \n    // === 세마포어로 순서 제어 (동기화) ===\n    static class OrderedExecution {\n        private final Semaphore step1Done = new Semaphore(0);\n        private final Semaphore step2Done = new Semaphore(0);\n        \n        public void step1() {\n            System.out.println(\"Step 1 실행\");\n            step1Done.release();  // Step 1 완료 신호\n        }\n        \n        public void step2() throws InterruptedException {\n            step1Done.acquire();  // Step 1 완료 대기\n            System.out.println(\"Step 2 실행\");\n            step2Done.release();  // Step 2 완료 신호\n        }\n        \n        public void step3() throws InterruptedException {\n            step2Done.acquire();  // Step 2 완료 대기\n            System.out.println(\"Step 3 실행\");\n        }\n    }\n    \n    public static void main(String[] args) {\n        // 주차장 테스트\n        ParkingLot lot = new ParkingLot();\n        for (int i = 1; i <= 5; i++) {\n            final String carName = \"차량\" + i;\n            new Thread(() -> lot.park(carName)).start();\n        }\n        // 결과: 3대 동시 주차, 2대는 대기 후 순차 주차\n    }\n}"
      },
      {
        "type": "code",
        "title": "생산자-소비자 문제 해결",
        "language": "java",
        "code": "import java.util.concurrent.Semaphore;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n// === 세마포어로 생산자-소비자 문제 해결 ===\npublic class ProducerConsumer {\n    \n    private static final int BUFFER_SIZE = 5;\n    private final Queue<Integer> buffer = new LinkedList<>();\n    \n    // 세마포어 3개 사용\n    private final Semaphore empty = new Semaphore(BUFFER_SIZE); // 빈 공간 수\n    private final Semaphore full = new Semaphore(0);            // 채워진 공간 수\n    private final Semaphore mutex = new Semaphore(1);           // 상호 배제용\n    \n    /*\n    버퍼 상태 시각화:\n    \n    초기: [  ][  ][  ][  ][  ]  empty=5, full=0\n    \n    생산 후: [1][  ][  ][  ][  ]  empty=4, full=1\n    \n    가득 참: [1][2][3][4][5]  empty=0, full=5\n    (생산자 블로킹!)\n    \n    소비 후: [  ][2][3][4][5]  empty=1, full=4\n    */\n    \n    public void produce(int item) throws InterruptedException {\n        empty.acquire();  // 빈 공간 있는지 확인 (없으면 대기)\n        mutex.acquire();  // 버퍼 접근 잠금\n        try {\n            buffer.add(item);\n            System.out.println(\"생산: \" + item + \" (버퍼 크기: \" + buffer.size() + \")\");\n        } finally {\n            mutex.release();  // 버퍼 접근 해제\n            full.release();   // 채워진 공간 +1\n        }\n    }\n    \n    public int consume() throws InterruptedException {\n        full.acquire();   // 채워진 공간 있는지 확인 (없으면 대기)\n        mutex.acquire();  // 버퍼 접근 잠금\n        try {\n            int item = buffer.poll();\n            System.out.println(\"소비: \" + item + \" (버퍼 크기: \" + buffer.size() + \")\");\n            return item;\n        } finally {\n            mutex.release();  // 버퍼 접근 해제\n            empty.release();  // 빈 공간 +1\n        }\n    }\n    \n    public static void main(String[] args) {\n        ProducerConsumer pc = new ProducerConsumer();\n        \n        // 생산자 스레드\n        Thread producer = new Thread(() -> {\n            try {\n                for (int i = 1; i <= 10; i++) {\n                    pc.produce(i);\n                    Thread.sleep(100);\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        });\n        \n        // 소비자 스레드\n        Thread consumer = new Thread(() -> {\n            try {\n                for (int i = 1; i <= 10; i++) {\n                    pc.consume();\n                    Thread.sleep(300);  // 소비가 더 느림\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        });\n        \n        producer.start();\n        consumer.start();\n    }\n}\n\n/*\n실행 결과:\n생산: 1 (버퍼 크기: 1)\n생산: 2 (버퍼 크기: 2)\n생산: 3 (버퍼 크기: 3)\n소비: 1 (버퍼 크기: 2)  <- 소비 시작\n생산: 4 (버퍼 크기: 3)\n생산: 5 (버퍼 크기: 4)\n생산: 6 (버퍼 크기: 5)  <- 버퍼 가득 참\n소비: 2 (버퍼 크기: 4)  <- 소비해야 생산 가능\n생산: 7 (버퍼 크기: 5)\n...\n*/"
      },
      {
        "type": "tip",
        "title": "면접 대비 핵심 정리",
        "content": "## 뮤텍스 vs 세마포어 핵심 요약\n\n### 면접 답변 템플릿\n```\n\"뮤텍스는 1인용 화장실 열쇠처럼 한 번에 하나의 스레드만\n자원에 접근할 수 있게 하며, 잠근 스레드만 해제할 수 있습니다.\n\n세마포어는 주차장 카운터처럼 동시에 N개의 스레드가\n자원에 접근할 수 있게 하며, 아무 스레드나 신호를 보낼 수 있습니다.\n\n핵심 차이는 소유권입니다.\n뮤텍스는 소유권이 있고, 세마포어는 소유권이 없습니다.\"\n```\n\n### 비교표\n| 구분 | 뮤텍스 | 세마포어 |\n|------|--------|----------|\n| 비유 | 화장실 열쇠 | 주차장 카운터 |\n| 동시 접근 | 1개 | N개 |\n| 소유권 | 있음 | 없음 |\n| 주요 용도 | 상호 배제 | 자원 수 제한, 순서 제어 |\n| Java | ReentrantLock | Semaphore |\n\n### P/V 연산 (세마포어)\n```\nP연산 (wait/acquire): 카운터 -1, 0이면 대기\nV연산 (signal/release): 카운터 +1, 대기 중인 스레드 깨움\n```\n\n### 자주 나오는 면접 질문\n\n**Q1: 뮤텍스와 세마포어 차이?**\n- 뮤텍스: 소유권 있음, 잠근 스레드만 해제\n- 세마포어: 소유권 없음, 아무나 signal 가능\n\n**Q2: Binary Semaphore와 Mutex 차이?**\n- 둘 다 값은 0 또는 1이지만, 소유권 유무가 다름\n- Mutex는 잠근 스레드만 해제 가능\n\n**Q3: 세마포어는 언제 사용?**\n- DB 커넥션 풀 제한 (동시 접근 수 제한)\n- 생산자-소비자 문제 (순서 제어)\n- Rate Limiting (동시 요청 수 제한)\n\n**Q4: 생산자-소비자 문제에서 세마포어 역할?**\n- empty: 빈 공간 수 (생산자 대기)\n- full: 채워진 공간 수 (소비자 대기)\n- mutex: 버퍼 접근 상호 배제"
      }
    ]
  },
  "06_메모리/cache": {
    "id": "06_메모리/cache",
    "title": "Cache",
    "category": "os",
    "subCategory": "06_메모리",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Cache",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "06_메모리/fragmentation": {
    "id": "06_메모리/fragmentation",
    "title": "Fragmentation",
    "category": "os",
    "subCategory": "06_메모리",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Fragmentation",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "06_메모리/memory-allocation": {
    "id": "06_메모리/memory-allocation",
    "title": "Memory Allocation",
    "category": "os",
    "subCategory": "06_메모리",
    "language": "C",
    "description": "페이징, 세그멘테이션 및 페이지 교체 알고리즘을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Memory Allocation",
        "content": "페이징, 세그멘테이션 및 페이지 교체 알고리즘을 학습합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "// 동적 메모리 할당 예제\r\nint *ptr = (int*)malloc(sizeof(int) * 10);\r\nif (ptr != NULL) {\r\n    // 메모리 사용\r\n    free(ptr);\r\n}"
      }
    ]
  },
  "06_메모리/page-fault": {
    "id": "06_메모리/page-fault",
    "title": "Page Fault",
    "category": "os",
    "subCategory": "06_메모리",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Page Fault",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "06_메모리/page-replacement": {
    "id": "06_메모리/page-replacement",
    "title": "Page Replacement",
    "category": "os",
    "subCategory": "06_메모리",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Page Replacement",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "06_메모리/segmentation": {
    "id": "06_메모리/segmentation",
    "title": "Segmentation",
    "category": "os",
    "subCategory": "06_메모리",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Segmentation",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "06_스케줄링/fcfs": {
    "id": "06_스케줄링/fcfs",
    "title": "Fcfs",
    "category": "os",
    "subCategory": "06_스케줄링",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Fcfs",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "06_스케줄링/round-robin": {
    "id": "06_스케줄링/round-robin",
    "title": "Round Robin",
    "category": "os",
    "subCategory": "06_스케줄링",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Round Robin",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "06_스케줄링/scheduling-intro": {
    "id": "06_스케줄링/scheduling-intro",
    "title": "Scheduling Intro",
    "category": "os",
    "subCategory": "06_스케줄링",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Scheduling Intro",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "07_동기비동기/io-model": {
    "id": "07_동기비동기/io-model",
    "title": "I/O 모델",
    "category": "os",
    "subCategory": "07_동기비동기",
    "language": "C",
    "description": "Blocking I/O, Non-blocking I/O, I/O Multiplexing, Async I/O의 동작 원리와 차이점을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "I/O 모델의 이해",
        "content": "I/O 모델은 프로그램이 입출력 작업을 처리하는 방식입니다.\n\n**도서관 비유로 이해하기**\n\n도서관에서 책을 빌리는 상황을 상상해보세요:\n\n1. **Blocking I/O (동기 블로킹)**\n   - 사서에게 책을 요청하고, 책이 올 때까지 카운터 앞에서 기다림\n   - 그 동안 아무것도 할 수 없음\n   - 가장 단순하지만 비효율적\n\n2. **Non-blocking I/O (동기 논블로킹)**\n   - 책을 요청하고 \"아직 없어요\"라는 답을 받으면 다른 일을 함\n   - 주기적으로 와서 \"책 왔나요?\" 확인 (polling)\n   - CPU를 낭비할 수 있음\n\n3. **I/O Multiplexing (select/poll/epoll)**\n   - 여러 책을 동시에 요청해두고, 안내 방송을 기다림\n   - \"3번 손님, 책 준비되었습니다\" 방송이 오면 가져감\n   - 하나의 스레드로 여러 I/O를 효율적으로 처리\n\n4. **Async I/O (비동기 I/O)**\n   - 책을 요청하고 집 주소를 남김\n   - 책이 준비되면 집으로 배달해줌\n   - 완전한 비동기, 가장 효율적\n\n**핵심 차이점**\n\n| 모델 | 호출 시 블록 | 완료 통보 방식 | 사용 예 |\n|------|-------------|---------------|--------|\n| Blocking | O | 직접 확인 | 전통적 소켓 |\n| Non-blocking | X | Polling | 게임 루프 |\n| Multiplexing | O (대기) | 이벤트 | 웹서버(Nginx) |\n| Async | X | 콜백/시그널 | io_uring, IOCP |"
      },
      {
        "type": "code",
        "title": "I/O 모델 비교 다이어그램",
        "language": "text",
        "code": "=== I/O 모델 비교 다이어그램 ===\n\n[1] Blocking I/O\n\n    Application          Kernel\n        |                   |\n        |--- read() ------->|\n        |    (blocked)      |<-- 데이터 대기 -->\n        |                   |<-- 데이터 복사 -->\n        |<-- return --------|  \n        |                   |\n\n[2] Non-blocking I/O\n\n    Application          Kernel\n        |                   |\n        |--- read() ------->|\n        |<-- EAGAIN --------|  (데이터 없음)\n        |--- read() ------->|\n        |<-- EAGAIN --------|  (polling 반복)\n        |--- read() ------->|\n        |<-- return data ---|  (데이터 준비됨)\n        |                   |\n\n[3] I/O Multiplexing (select/epoll)\n\n    Application          Kernel\n        |                   |\n        |--- select() ----->|  (여러 fd 감시)\n        |    (blocked)      |<-- 이벤트 대기 -->\n        |<-- fd ready ------|  (준비된 fd 알림)\n        |--- read() ------->|\n        |<-- return data ---|  (데이터 읽기)\n        |                   |\n\n[4] Async I/O (aio_read, io_uring)\n\n    Application          Kernel\n        |                   |\n        |--- aio_read() --->|  (즉시 반환)\n        |<-- return --------|  \n        |  (다른 작업 수행)  |<-- 데이터 처리 -->\n        |                   |\n        |<-- 시그널/콜백 ---|  (완료 통보)\n        |                   |"
      },
      {
        "type": "code",
        "title": "실무 I/O 모델 구현 예제",
        "language": "c",
        "code": "/* === 1. Blocking I/O === */\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nvoid blocking_read() {\n    char buf[1024];\n    // read()는 데이터가 올 때까지 블록됨\n    ssize_t n = read(STDIN_FILENO, buf, sizeof(buf));\n    printf(\"Read %zd bytes\\n\", n);\n}\n\n/* === 2. Non-blocking I/O === */\n#include <errno.h>\n\nvoid nonblocking_read(int fd) {\n    char buf[1024];\n    \n    // Non-blocking 모드 설정\n    int flags = fcntl(fd, F_GETFL, 0);\n    fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n    \n    while (1) {\n        ssize_t n = read(fd, buf, sizeof(buf));\n        if (n > 0) {\n            printf(\"Read %zd bytes\\n\", n);\n            break;\n        } else if (n == -1 && errno == EAGAIN) {\n            printf(\"No data yet, doing other work...\\n\");\n            usleep(100000);  // 다른 작업 수행\n        }\n    }\n}\n\n/* === 3. I/O Multiplexing (epoll) === */\n#include <sys/epoll.h>\n\n#define MAX_EVENTS 10\n\nvoid epoll_example(int server_fd) {\n    int epoll_fd = epoll_create1(0);\n    struct epoll_event ev, events[MAX_EVENTS];\n    \n    // 서버 소켓 등록\n    ev.events = EPOLLIN;\n    ev.data.fd = server_fd;\n    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &ev);\n    \n    while (1) {\n        // 이벤트 대기 (여러 fd 동시 감시)\n        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);\n        \n        for (int i = 0; i < nfds; i++) {\n            if (events[i].data.fd == server_fd) {\n                // 새 연결 처리\n                int client_fd = accept(server_fd, NULL, NULL);\n                ev.events = EPOLLIN | EPOLLET;  // Edge Trigger\n                ev.data.fd = client_fd;\n                epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev);\n            } else {\n                // 클라이언트 데이터 처리\n                handle_client(events[i].data.fd);\n            }\n        }\n    }\n}\n\n/* === 4. select vs poll vs epoll 비교 === */\n/*\n+----------+-----------+------------+------------------+\n| 방식     | 시간복잡도 | fd 제한    | 커널 통신        |\n+----------+-----------+------------+------------------+\n| select   | O(n)      | 1024       | 매번 fd 복사     |\n| poll     | O(n)      | 제한 없음  | 매번 fd 복사     |\n| epoll    | O(1)      | 제한 없음  | 콜백 방식        |\n+----------+-----------+------------+------------------+\n\nepoll의 장점:\n1. Level Trigger / Edge Trigger 선택 가능\n2. 등록된 fd에 대해서만 이벤트 전달\n3. 대규모 연결에서 뛰어난 성능\n*/"
      },
      {
        "type": "tip",
        "title": "I/O 모델 선택 가이드 및 면접 대비",
        "content": "**실무에서의 I/O 모델 선택**\n\n1. **Blocking I/O**\n   - 단순한 CLI 도구, 스크립트\n   - 클라이언트당 스레드 모델\n\n2. **Non-blocking + Polling**\n   - 게임 서버의 메인 루프\n   - 실시간 시스템\n\n3. **I/O Multiplexing (epoll)**\n   - 웹 서버 (Nginx, Node.js)\n   - 채팅 서버, 게임 서버\n   - C10K 문제 해결의 핵심\n\n4. **Async I/O (io_uring)**\n   - 고성능 데이터베이스\n   - 저지연 네트워크 서버\n   - Linux 5.1+ 최신 기술\n\n**면접 빈출 질문**\n\nQ1. select와 epoll의 차이점은?\n- select: O(n), fd 제한(1024), 매번 fd_set 복사\n- epoll: O(1), 제한 없음, 콜백 방식\n\nQ2. Level Trigger vs Edge Trigger?\n- LT: 데이터 있으면 계속 알림 (기본값)\n- ET: 상태 변화시에만 알림 (효율적, 복잡)\n\nQ3. Nginx가 빠른 이유는?\n- 이벤트 기반 + I/O Multiplexing\n- 단일 프로세스로 수만 연결 처리\n\nQ4. Node.js의 이벤트 루프와 epoll의 관계?\n- libuv가 OS별로 epoll(Linux), kqueue(Mac), IOCP(Windows) 사용\n\n**C10K 문제란?**\n1만 개의 동시 연결을 처리하는 문제\n- 해결책: 이벤트 기반 I/O Multiplexing\n- 현재는 C10M(천만 연결)까지 논의"
      }
    ]
  },
  "07_면접/interview-os": {
    "id": "07_면접/interview-os",
    "title": "OS 면접 질문 총정리",
    "category": "os",
    "subCategory": "07_면접",
    "language": "Text",
    "description": "주니어/시니어 레벨별 OS 면접 질문 25개와 모범 답변을 정리합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "OS 면접 준비 가이드",
        "content": "운영체제 면접은 CS 기초를 평가하는 핵심 영역입니다.\n\n**면접 준비 전략**\n\n면접관이 보는 관점을 이해하세요:\n- 주니어: 기본 개념의 정확한 이해\n- 시니어: 깊이 있는 이해 + 실무 적용 능력\n\n**답변의 3단계 구조**\n\n1. **정의** (What): 간단명료하게 개념 설명\n2. **원리** (How): 동작 방식 설명\n3. **실무** (Why): 왜 중요한지, 어디서 사용되는지\n\n**핵심 출제 영역 (빈도순)**\n\n1. 프로세스 vs 스레드 (90%)\n2. 동기화 (Mutex, Semaphore, Deadlock) (85%)\n3. 메모리 관리 (페이징, 가상메모리) (80%)\n4. CPU 스케줄링 (70%)\n5. I/O 모델 (동기/비동기, Blocking) (65%)\n\n**면접 팁**\n- 모르면 솔직히 말하고, 아는 부분까지 설명\n- 실제 경험이나 프로젝트와 연결해서 답변\n- 그림을 그려가며 설명하면 효과적"
      },
      {
        "type": "code",
        "title": "주니어 면접 질문 15선 (모범 답변)",
        "language": "text",
        "code": "=== 주니어 OS 면접 질문 15선 ===\n\n[Q1] 프로세스와 스레드의 차이점은 무엇인가요?\n\nA: 프로세스는 실행 중인 프로그램으로 독립적인 메모리 공간(Code, Data, \nHeap, Stack)을 가집니다. 스레드는 프로세스 내의 실행 단위로, 같은 \n프로세스의 스레드들은 Code, Data, Heap을 공유하고 Stack만 별도로 \n가집니다. 따라서 스레드 간 통신이 빠르지만, 동기화 문제가 발생할 수 \n있습니다.\n\n---\n[Q2] 컨텍스트 스위칭이란 무엇인가요?\n\nA: CPU가 현재 실행 중인 프로세스/스레드에서 다른 것으로 전환할 때, \n현재 상태(레지스터, PC 등)를 PCB에 저장하고 새 프로세스의 상태를 \n복원하는 과정입니다. 오버헤드가 발생하므로, 잦은 컨텍스트 스위칭은 \n성능 저하를 유발합니다.\n\n---\n[Q3] 데드락(Deadlock)이란 무엇이고, 발생 조건은?\n\nA: 데드락은 두 개 이상의 프로세스가 서로가 가진 자원을 기다리며 \n무한히 대기하는 상태입니다.\n\n4가지 필요조건:\n1. 상호배제: 자원을 한 번에 하나만 사용\n2. 점유대기: 자원을 가진 채 다른 자원 대기\n3. 비선점: 강제로 자원을 빼앗을 수 없음\n4. 순환대기: 프로세스들이 원형으로 자원 대기\n\n---\n[Q4] Mutex와 Semaphore의 차이는?\n\nA: Mutex는 1개의 스레드만 임계영역에 접근 가능(이진 잠금), \nSemaphore는 N개의 스레드가 접근 가능합니다. Mutex는 소유권 개념이 \n있어 잠근 스레드만 해제 가능하지만, Semaphore는 다른 스레드가 \n해제할 수 있습니다.\n\n---\n[Q5] 가상 메모리란 무엇인가요?\n\nA: 물리 메모리보다 큰 메모리 공간을 사용할 수 있게 해주는 기술입니다.\n프로세스는 가상 주소를 사용하고, MMU가 물리 주소로 변환합니다. \n필요한 페이지만 물리 메모리에 올리고, 나머지는 디스크(swap)에 \n저장합니다.\n\n---\n[Q6] 페이지 폴트란?\n\nA: 접근하려는 페이지가 물리 메모리에 없을 때 발생하는 인터럽트입니다.\nOS가 디스크에서 해당 페이지를 메모리로 로드합니다. 빈번한 페이지 \n폴트는 성능을 크게 저하시킵니다(스래싱).\n\n---\n[Q7] 페이지 교체 알고리즘을 설명해주세요.\n\nA: 물리 메모리가 부족할 때 어떤 페이지를 내릴지 결정하는 알고리즘입니다.\n- FIFO: 가장 오래된 페이지 교체\n- LRU: 가장 오래 사용 안 된 페이지 교체 (실무에서 많이 사용)\n- LFU: 가장 적게 사용된 페이지 교체\n- OPT: 앞으로 가장 오래 안 쓸 페이지 (이론적 최적)\n\n---\n[Q8] 동기와 비동기의 차이는?\n\nA: 동기는 요청 후 결과가 올 때까지 기다립니다. 비동기는 요청만 하고 \n다른 작업을 수행하다가 결과가 오면 처리합니다. 비동기는 효율적이지만 \n콜백 관리가 복잡합니다.\n\n---\n[Q9] Blocking과 Non-blocking의 차이는?\n\nA: Blocking은 호출한 함수가 완료될 때까지 제어권을 반환하지 않습니다.\nNon-blocking은 즉시 제어권을 반환하고, 결과가 준비되지 않았으면 \n에러코드를 반환합니다.\n\n---\n[Q10] CPU 스케줄링 알고리즘 3가지를 설명해주세요.\n\nA: \n1. FCFS: 먼저 온 순서대로 처리 (단순, 호위효과 문제)\n2. Round Robin: 시간 할당량만큼 돌아가며 실행 (공정, 반응성 좋음)\n3. Priority: 우선순위 높은 순서로 (기아 문제 -> 에이징으로 해결)\n\n---\n[Q11] 사용자 모드와 커널 모드의 차이는?\n\nA: 사용자 모드는 제한된 명령만 실행 가능하고, 커널 모드는 모든 명령을 \n실행할 수 있습니다. 시스템 콜을 통해 커널 모드로 전환하여 하드웨어 \n접근 등 특권 작업을 수행합니다.\n\n---\n[Q12] 시스템 콜이란?\n\nA: 사용자 프로그램이 커널의 서비스를 요청하는 인터페이스입니다.\n파일 I/O(open, read, write), 프로세스 관리(fork, exec), \n메모리 관리(mmap) 등이 있습니다.\n\n---\n[Q13] 캐시 메모리란?\n\nA: CPU와 메인 메모리 사이의 고속 메모리로, 자주 사용하는 데이터를 \n저장합니다. 지역성(Locality) 원리를 활용하여 메모리 접근 속도를 \n향상시킵니다. L1, L2, L3 캐시가 있습니다.\n\n---\n[Q14] 인터럽트란?\n\nA: CPU가 현재 작업을 중단하고 긴급한 이벤트를 처리하는 메커니즘입니다.\n하드웨어 인터럽트(키보드, 타이머)와 소프트웨어 인터럽트(시스템콜, \n예외)가 있습니다.\n\n---\n[Q15] Stack과 Heap의 차이는?\n\nA: Stack은 함수 호출 시 지역변수, 매개변수가 저장되며 자동 할당/해제됩니다.\nHeap은 동적 메모리 할당 영역으로, 프로그래머가 직접 관리합니다.\nStack은 빠르지만 크기 제한이 있고, Heap은 느리지만 유연합니다."
      },
      {
        "type": "code",
        "title": "시니어 면접 질문 10선 (심화 답변)",
        "language": "text",
        "code": "=== 시니어 OS 면접 질문 10선 ===\n\n[Q1] 멀티스레드 환경에서 Race Condition을 어떻게 해결하셨나요?\n\nA: Race Condition은 여러 스레드가 공유 자원에 동시 접근할 때 발생합니다.\n\n해결 경험:\n1. Mutex/Lock: 임계영역 보호 (단순하지만 성능 저하)\n2. Atomic 연산: CAS 기반 lock-free 자료구조\n3. Thread-local 저장소: 공유 자체를 피함\n4. 불변 객체: 상태 변경 없이 새 객체 생성\n\n실무에서는 먼저 공유를 최소화하고, 필요시 적절한 수준의 동기화를 \n적용합니다. 과도한 락은 성능 병목이 되므로 프로파일링 후 최적화합니다.\n\n---\n[Q2] 메모리 릭을 디버깅한 경험을 설명해주세요.\n\nA: \n진단 과정:\n1. 증상 확인: 메모리 사용량 지속 증가, OOM 발생\n2. 도구 활용: Valgrind, AddressSanitizer, pmap\n3. 힙 덤프 분석: 어떤 객체가 증가하는지 확인\n\n해결 사례:\n- 이벤트 리스너 미해제 -> weak reference 적용\n- 캐시 무한 증가 -> LRU 캐시로 교체, TTL 설정\n- 순환 참조 -> weak_ptr 사용 또는 명시적 해제\n\n예방책:\n- RAII 패턴, 스마트 포인터 사용\n- 정적 분석 도구 CI 연동\n\n---\n[Q3] 대규모 동시 접속을 처리하기 위한 I/O 모델 선택 기준은?\n\nA: \nC10K 이상의 연결 처리 시:\n\n1. I/O Multiplexing (epoll/kqueue)\n   - 하나의 스레드로 수만 연결 처리\n   - Nginx, Redis 아키텍처\n   - Level/Edge Trigger 선택 중요\n\n2. 스레드 풀 + epoll 조합\n   - 이벤트 감지: epoll\n   - 작업 처리: 스레드 풀\n   - CPU bound 작업이 섞인 경우\n\n3. io_uring (최신)\n   - 커널-유저 공간 복사 최소화\n   - 배치 처리로 syscall 오버헤드 감소\n\n선택 기준: 연결 수, 요청 특성(CPU/IO bound), 지연시간 요구사항\n\n---\n[Q4] 데드락을 시스템 레벨에서 어떻게 탐지/해결하나요?\n\nA: \n탐지 방법:\n1. 자원 할당 그래프에서 사이클 탐지\n2. 타임아웃 기반 탐지 (실용적)\n3. 주기적 데드락 검사 스레드\n\n해결 방법:\n1. 프로세스 종료: 비용 적은 프로세스 선택\n2. 자원 선점: 롤백 후 재시작\n3. 예방: 자원 순서 정의, 한번에 모든 자원 요청\n\n실무 경험:\n- DB 트랜잭션 데드락: 순서 일관성 유지, 타임아웃 설정\n- 락 계층 정의: 항상 같은 순서로 락 획득\n\n---\n[Q5] 컨테이너(Docker)의 격리 원리를 OS 관점에서 설명해주세요.\n\nA: \n리눅스 커널 기술 활용:\n\n1. Namespace: 자원 격리\n   - PID ns: 프로세스 ID 격리\n   - Network ns: 네트워크 스택 격리\n   - Mount ns: 파일시스템 격리\n   - User ns: 사용자/그룹 ID 격리\n\n2. Cgroups: 자원 제한\n   - CPU, Memory, I/O 사용량 제한\n   - OOM 시 특정 컨테이너만 kill\n\n3. UnionFS: 레이어 파일시스템\n   - 이미지 레이어 재사용\n   - Copy-on-Write로 효율적 저장\n\nVM과 차이: 하이퍼바이저 없이 커널 공유, 더 가벼움\n\n---\n[Q6] 커널 패닉 상황을 디버깅한 경험이 있나요?\n\nA: \n진단 과정:\n1. 커널 로그 분석: dmesg, /var/log/kern.log\n2. 크래시 덤프 분석: kdump + crash 유틸리티\n3. 스택 트레이스로 원인 모듈 파악\n\n경험 사례:\n- OOM Killer 동작 -> 메모리 누수 애플리케이션 발견\n- 드라이버 버그 -> 커널 버전 업그레이드로 해결\n- 파일시스템 손상 -> fsck 후 복구\n\n예방책:\n- 커널 파라미터 튜닝 (vm.overcommit_memory)\n- 리소스 모니터링 및 알림 설정\n\n---\n[Q7] NUMA 아키텍처에서 성능 최적화 경험은?\n\nA: \nNUMA(Non-Uniform Memory Access) 이해:\n- 각 CPU가 로컬 메모리를 가짐\n- 원격 메모리 접근은 느림 (2-3배)\n\n최적화 전략:\n1. numactl로 프로세스를 특정 노드에 바인딩\n2. 메모리 할당 정책: local, interleave\n3. CPU affinity 설정\n4. 대용량 페이지(Huge Pages) 활용\n\n모니터링:\n- numastat: NUMA 히트/미스 확인\n- perf stat: 원격 메모리 접근 측정\n\n---\n[Q8] 실시간 시스템에서 스케줄링 요구사항은?\n\nA: \n실시간 시스템 분류:\n- Hard Real-time: 데드라인 필수 (항공, 의료)\n- Soft Real-time: 데드라인 권장 (멀티미디어)\n\n리눅스 실시간 스케줄링:\n1. SCHED_FIFO: 우선순위 기반, 선점 없음\n2. SCHED_RR: 우선순위 + 라운드로빈\n3. SCHED_DEADLINE: EDF 알고리즘\n\n튜닝 경험:\n- 인터럽트 처리 최적화\n- 커널 선점 활성화 (PREEMPT_RT 패치)\n- 메모리 락 (mlockall)으로 페이지 폴트 방지\n\n---\n[Q9] 파일시스템 선택 기준과 성능 특성은?\n\nA: \n주요 파일시스템 비교:\n\n1. ext4: 범용, 안정적, 저널링\n   - 대부분의 리눅스 서버\n\n2. XFS: 대용량 파일, 병렬 I/O\n   - 데이터베이스, 미디어 서버\n\n3. Btrfs: CoW, 스냅샷, 압축\n   - 백업, 개발 환경\n\n4. ZFS: 무결성, RAID, 압축\n   - 엔터프라이즈 스토리지\n\n성능 튜닝:\n- noatime 마운트 옵션\n- I/O 스케줄러 선택 (none for SSD)\n- 적절한 블록 크기 설정\n\n---\n[Q10] OS 레벨에서 보안 강화 방법은?\n\nA: \n다층 방어 전략:\n\n1. 접근 제어\n   - SELinux/AppArmor: MAC(Mandatory Access Control)\n   - 최소 권한 원칙\n\n2. 메모리 보호\n   - ASLR: 주소 공간 랜덤화\n   - DEP/NX: 실행 불가 메모리\n   - Stack Canary: 버퍼 오버플로우 방지\n\n3. 감사 및 모니터링\n   - auditd: 시스템 콜 로깅\n   - 침입 탐지 시스템\n\n4. 컨테이너 보안\n   - Seccomp: 시스템 콜 필터링\n   - 루트리스 컨테이너\n   - 이미지 취약점 스캔"
      },
      {
        "type": "tip",
        "title": "면접 실전 팁 및 체크리스트",
        "content": "**면접 직전 체크리스트**\n\n[ ] 프로세스 vs 스레드 명확히 구분 가능\n[ ] 동기화 3총사 (Mutex, Semaphore, Monitor) 설명 가능\n[ ] 데드락 4조건 암기\n[ ] 가상메모리, 페이징 동작 원리 이해\n[ ] 동기/비동기, Blocking/Non-blocking 2x2 매트릭스\n[ ] 스케줄링 알고리즘 3개 이상\n\n**답변 시 피해야 할 것**\n\n1. \"잘 모르겠습니다\"만 하지 말 것\n   -> \"정확히는 모르지만, ~라고 추측합니다\"\n\n2. 외운 대로만 말하지 말 것\n   -> 실제 경험, 프로젝트와 연결\n\n3. 너무 길게 말하지 말 것\n   -> 핵심 먼저, 질문 시 상세 설명\n\n**꼬리 질문 대비**\n\nQ: 프로세스 vs 스레드 답변 후\n-> \"그럼 멀티프로세스보다 멀티스레드가 항상 좋나요?\"\nA: \"아닙니다. 스레드는 하나가 죽으면 전체가 영향받고, \n    메모리 공유로 동기화 문제가 생깁니다. \n    Chrome은 탭마다 프로세스로 안정성을 높였습니다.\"\n\n**실무 연결 예시**\n\n\"저는 프로젝트에서 Redis를 사용했는데, Redis가 싱글 스레드임에도 \n빠른 이유를 공부하면서 I/O Multiplexing(epoll)의 효율성을 \n이해하게 되었습니다.\"\n\n**추천 학습 순서**\n1. 프로세스/스레드 (기본)\n2. 동기화 (필수)\n3. 메모리 관리 (중요)\n4. 스케줄링 (이론)\n5. I/O 모델 (실무)"
      }
    ]
  },
  "08_파일시스템/file-system": {
    "id": "08_파일시스템/file-system",
    "title": "파일 시스템 개념",
    "category": "os",
    "subCategory": "08_파일시스템",
    "language": "Bash",
    "description": "FAT, NTFS, ext4 등 파일 시스템의 구조와 특징을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "파일 시스템의 이해",
        "content": "파일 시스템은 저장 장치에서 데이터를 조직화하고 관리하는 방법입니다.\n\n**도서관 비유로 이해하기**\n\n파일 시스템을 도서관에 비유해보면:\n\n1. **하드디스크** = 도서관 건물 전체\n2. **파티션** = 각 층 (1층: 소설, 2층: 과학 등)\n3. **파일 시스템** = 책 정리 방법 (듀이십진분류법 등)\n4. **디렉토리** = 책장/서가\n5. **파일** = 책\n6. **inode** = 책의 위치 카드 (어느 서가, 몇 번째)\n\n**주요 파일 시스템 비교**\n\n| 파일시스템 | OS | 최대 파일 | 최대 볼륨 | 특징 |\n|-----------|-----|----------|----------|------|\n| FAT32 | 범용 | 4GB | 2TB | 단순, 호환성 |\n| NTFS | Windows | 16EB | 256TB | 저널링, 권한 |\n| ext4 | Linux | 16TB | 1EB | 저널링, 안정 |\n| XFS | Linux | 8EB | 8EB | 대용량 특화 |\n| APFS | macOS | 8EB | - | SSD 최적화 |\n\n**저널링(Journaling)이란?**\n\n변경 전 로그를 먼저 기록하는 방식:\n1. 트랜잭션 로그 기록\n2. 실제 데이터 기록\n3. 로그 삭제\n\n비정상 종료 시 로그로 복구 -> 데이터 무결성 보장"
      },
      {
        "type": "code",
        "title": "파일 시스템 구조 다이어그램",
        "language": "text",
        "code": "=== ext4 파일 시스템 구조 ===\n\n+----------------------------------------------------------+\n|                      Disk Partition                       |\n+----------------------------------------------------------+\n|  Boot  |  Super  | Group | Block | Inode | Inode |  Data  |\n| Block  |  Block  | Desc. | Bitmap| Bitmap| Table | Blocks |\n+--------+---------+-------+-------+-------+-------+--------+\n|  1KB   |   1KB   |  nKB  |  1 Blk| 1 Blk | n Blk |  ....  |\n+----------------------------------------------------------+\n\n[ Super Block ]\n- 파일 시스템 전체 정보\n- 블록 크기, 블록 수, inode 수\n- 마운트 횟수, 마지막 마운트 시간\n\n[ Block Group 구조 ]\n\n    Block Group 0        Block Group 1        Block Group N\n+-------------------+-------------------+-------------------+\n| Super | GDT |Data | Super | GDT |Data | Super | GDT |Data |\n| Block |     |     | Block |     |     | Block |     |     |\n+-------------------+-------------------+-------------------+\n        (백업)             (백업)             (백업)\n\n=== NTFS 구조 ===\n\n+----------------------------------------------------------+\n|  Boot  |  MFT   | MFT    | Log   | Volume | Root | Data  |\n| Sector | (Master| Mirror | File  | Info   | Dir  | Area  |\n|        |  File  |        |       |        |      |       |\n|        | Table) |        |       |        |      |       |\n+--------+--------+--------+-------+--------+------+-------+\n\n[ MFT 레코드 구조 ]\n+------------+------------+------------+------------+\n| $STANDARD_ | $FILE_NAME | $DATA      | $INDEX_    |\n| INFORMATION|            | (파일내용) | ROOT       |\n+------------+------------+------------+------------+\n\n=== FAT32 구조 ===\n\n+----------------------------------------------------------+\n|  Boot  |  FAT1  |  FAT2  |  Root    |    Data Area      |\n| Sector | (File  | (File  |Directory |    (Clusters)      |\n|        |  Alloc |  Alloc |          |                    |\n|        | Table) | Table) |          |                    |\n+--------+--------+--------+----------+--------------------+\n\n[ FAT 테이블 - 클러스터 체인 ]\n\n클러스터 2 -> 클러스터 5 -> 클러스터 8 -> EOF\n    |            |            |\n    v            v            v\n[File A]     [File A]     [File A]\n[part 1]     [part 2]     [part 3]"
      },
      {
        "type": "code",
        "title": "파일 시스템 실무 명령어",
        "language": "bash",
        "code": "# === 파일 시스템 정보 확인 ===\n\n# 마운트된 파일 시스템 확인\ndf -Th\n# Filesystem     Type      Size  Used Avail Use% Mounted on\n# /dev/sda1      ext4      100G   30G   70G  30% /\n# /dev/sdb1      xfs       500G  200G  300G  40% /data\n\n# 블록 장치 정보\nlsblk -f\n# NAME   FSTYPE LABEL UUID                                 MOUNTPOINT\n# sda                                                       \n# ├─sda1 ext4         a1b2c3d4-...                         /\n# └─sda2 swap         e5f6g7h8-...                         [SWAP]\n\n# 파일 시스템 상세 정보 (ext4)\nsudo dumpe2fs /dev/sda1 | head -30\n\n# === 파일 시스템 생성 ===\n\n# ext4 파일 시스템 생성\nsudo mkfs.ext4 /dev/sdb1\n\n# ext4 with 라벨\nsudo mkfs.ext4 -L \"DataDrive\" /dev/sdb1\n\n# XFS 파일 시스템 생성\nsudo mkfs.xfs /dev/sdc1\n\n# NTFS 파일 시스템 생성 (Linux에서)\nsudo mkfs.ntfs /dev/sdd1\n\n# === 마운트/언마운트 ===\n\n# 마운트\nsudo mount /dev/sdb1 /mnt/data\n\n# 특정 옵션으로 마운트\nsudo mount -o noatime,nodiratime /dev/sdb1 /mnt/data\n\n# UUID로 마운트 (안전한 방법)\nsudo mount UUID=a1b2c3d4-... /mnt/data\n\n# 언마운트\nsudo umount /mnt/data\n\n# 강제 언마운트 (busy 상태일 때)\nsudo umount -l /mnt/data  # lazy unmount\n\n# === /etc/fstab 설정 ===\n# 부팅 시 자동 마운트 설정\n\n# UUID=xxxx  /mnt/data  ext4  defaults,noatime  0  2\n# |          |          |     |                 |  |\n# 장치ID     마운트포인트 타입  옵션              덤프 fsck순서\n\n# fstab 테스트 (실제 마운트 없이)\nsudo mount -a --fake\n\n# === 파일 시스템 점검/복구 ===\n\n# ext4 점검 (언마운트 상태에서)\nsudo fsck.ext4 /dev/sdb1\n\n# 자동 복구\nsudo fsck.ext4 -y /dev/sdb1\n\n# XFS 점검\nsudo xfs_repair /dev/sdc1\n\n# === 파일 시스템 튜닝 ===\n\n# ext4 파라미터 조정\nsudo tune2fs -c 30 /dev/sda1      # 30회 마운트마다 fsck\nsudo tune2fs -i 180d /dev/sda1    # 180일마다 fsck\n\n# reserved blocks 조정 (기본 5%)\nsudo tune2fs -m 1 /dev/sda1       # 1%로 변경\n\n# === 디스크 사용량 분석 ===\n\n# 디렉토리별 사용량\ndu -sh /var/*\n\n# 가장 큰 파일/디렉토리 찾기\ndu -ah / 2>/dev/null | sort -rh | head -20\n\n# ncdu (시각적 디스크 사용량 분석기)\nsudo apt install ncdu\nncdu /"
      },
      {
        "type": "tip",
        "title": "파일 시스템 선택 가이드 및 면접 질문",
        "content": "**용도별 파일 시스템 선택**\n\n1. **일반 서버**: ext4\n   - 안정적, 범용적, 복구 도구 풍부\n\n2. **대용량 파일 서버**: XFS\n   - 대용량 파일 처리 최적화\n   - 병렬 I/O 성능 우수\n\n3. **백업/개발**: Btrfs\n   - 스냅샷, CoW 지원\n   - 데이터 압축 기능\n\n4. **Windows 호환**: NTFS, exFAT\n   - USB: exFAT (4GB 제한 없음)\n\n5. **SSD**: ext4(discard), F2FS\n   - TRIM 지원 중요\n\n**성능 튜닝 옵션**\n\n- `noatime`: 읽기 시 시간 기록 안 함\n- `nodiratime`: 디렉토리 접근 시간 안 기록\n- `discard`: SSD TRIM 활성화\n- `data=writeback`: 메타데이터만 저널링 (성능 우선)\n\n**면접 빈출 질문**\n\nQ1. 저널링이란?\nA: 변경 전 로그를 먼저 기록하여 비정상 종료 시 복구 가능하게 하는 기술\n\nQ2. inode가 부족하면 어떻게 되나요?\nA: 디스크 공간이 있어도 새 파일 생성 불가. 작은 파일이 많으면 발생.\n\nQ3. ext4와 XFS의 차이?\nA: ext4는 범용, XFS는 대용량 파일과 병렬 I/O에 강함\n\nQ4. soft link vs hard link?\nA: soft link는 경로를 가리킴(원본 삭제시 깨짐), hard link는 같은 inode 공유\n\n**트러블슈팅 체크리스트**\n\n[ ] df와 du 결과 불일치 -> 삭제된 파일의 열린 핸들\n[ ] No space left but df shows free -> inode 부족\n[ ] Read-only filesystem -> fsck 필요, 하드웨어 확인"
      }
    ]
  },
  "08_파일시스템/inode": {
    "id": "08_파일시스템/inode",
    "title": "아이노드 (Inode)",
    "category": "os",
    "subCategory": "08_파일시스템",
    "language": "Bash",
    "description": "파일 메타데이터를 저장하는 inode의 구조와 역할을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Inode의 이해",
        "content": "Inode(Index Node)는 파일의 메타데이터를 저장하는 자료구조입니다.\n\n**도서관 목록 카드 비유**\n\n도서관에서 책을 찾을 때:\n1. 목록 카드(inode)에서 책 정보 확인\n   - 제목, 저자, 출판년도 (메타데이터)\n   - 서가 위치 (데이터 블록 주소)\n2. 서가로 가서 실제 책(데이터)을 가져옴\n\n파일 시스템에서:\n- 파일명은 디렉토리에 저장\n- 파일 속성과 위치는 inode에 저장\n- 실제 데이터는 데이터 블록에 저장\n\n**Inode에 저장되는 정보**\n\n| 필드 | 설명 |\n|------|------|\n| 파일 타입 | 일반, 디렉토리, 심볼릭링크 등 |\n| 권한 | rwxr-xr-x |\n| 소유자/그룹 | UID, GID |\n| 파일 크기 | bytes |\n| 시간 정보 | atime, mtime, ctime |\n| 링크 수 | hard link 개수 |\n| 블록 포인터 | 데이터 블록 주소 |\n\n**주의: inode에 없는 것**\n- 파일 이름 (디렉토리에 저장)\n- 파일 내용 (데이터 블록에 저장)\n\n**왜 파일명이 inode에 없을까?**\n하나의 파일에 여러 이름(hard link)을 가질 수 있기 때문"
      },
      {
        "type": "code",
        "title": "Inode 구조 및 블록 포인터",
        "language": "text",
        "code": "=== Inode 구조 (ext4 기준) ===\n\n+----------------------------------+\n|           Inode (256 bytes)      |\n+----------------------------------+\n| File Type & Permissions (2)      |  # 파일 타입 + 권한\n| Owner UID (2)                    |  # 소유자 ID\n| File Size (lower 32 bits) (4)    |  # 파일 크기 (하위)\n| Access Time (4)                  |  # 최근 접근 시간\n| Change Time (4)                  |  # inode 변경 시간\n| Modification Time (4)            |  # 내용 수정 시간\n| Deletion Time (4)                |  # 삭제 시간\n| Group GID (2)                    |  # 그룹 ID\n| Links Count (2)                  |  # 하드링크 수\n| Blocks Count (4)                 |  # 할당된 블록 수\n| Flags (4)                        |  # 플래그\n| ... OS specific ...              |\n+----------------------------------+\n|       Block Pointers (60)        |  # 데이터 블록 포인터\n+----------------------------------+\n| Generation Number (4)            |  # NFS용\n| Extended Attributes (4)          |  # 확장 속성\n| File Size (upper 32 bits) (4)    |  # 파일 크기 (상위)\n+----------------------------------+\n\n\n=== 블록 포인터 구조 (전통적 ext2/3 방식) ===\n\n                    Inode\n                +----------+\nDirect Blocks   | Block 0  |---------> [Data Block]\n(12개)          | Block 1  |---------> [Data Block]\n                |   ...    |\n                | Block 11 |---------> [Data Block]\n                +----------+\nSingle Indirect | Indirect |----+\n(1개)           +----------+    |\n                                v\n                        +---------------+\n                        | Ptr | Ptr |...|---> [Data Blocks]\n                        +---------------+\n                        (1024개 포인터)\n\nDouble Indirect +----------+\n(1개)           | 2x Indir |----+\n                +----------+    |\n                                v\n                        +---------------+\n                        | Ptr | Ptr |...|---> [Single Indirect]\n                        +---------------+         |\n                                                  v\n                                          [Data Blocks]\n\nTriple Indirect +----------+\n(1개)           | 3x Indir |---> [Double Indirect]---> ...\n                +----------+\n\n\n=== 최대 파일 크기 계산 (4KB 블록 기준) ===\n\nDirect Blocks:       12 * 4KB = 48KB\nSingle Indirect:     1024 * 4KB = 4MB  \nDouble Indirect:     1024 * 1024 * 4KB = 4GB\nTriple Indirect:     1024^3 * 4KB = 4TB\n\n총 최대 파일 크기 ≈ 4TB (실제로는 다른 제한 있음)\n\n\n=== ext4 Extent 방식 (현대적) ===\n\n전통적 블록 포인터: 블록마다 포인터 필요 (비효율적)\next4 Extent: 연속 블록을 하나의 extent로 표현\n\n+----------------------------------+\n|        Extent Header             |\n+----------------------------------+\n| Start Block | Length | Phys Addr |\n+----------------------------------+\n|    1000     |  100   | 50000     |  # 블록 1000~1099 -> 50000~50099\n+----------------------------------+\n\n장점: 대용량 파일에서 메타데이터 크게 감소"
      },
      {
        "type": "code",
        "title": "Inode 실무 명령어",
        "language": "bash",
        "code": "# === Inode 정보 확인 ===\n\n# 파일의 inode 번호 확인\nls -i filename.txt\n# 12345678 filename.txt\n\n# 상세 정보 함께 보기\nls -li\n# 12345678 -rw-r--r-- 1 user group 1024 Jan 30 10:00 file.txt\n# inode    권한       링크수 소유자 그룹 크기 시간       파일명\n\n# stat으로 상세 정보\nstat filename.txt\n#   File: filename.txt\n#   Size: 1024            Blocks: 8          IO Block: 4096   regular file\n# Device: 801h/2049d      Inode: 12345678    Links: 1\n# Access: (0644/-rw-r--r--)  Uid: ( 1000/  user)   Gid: ( 1000/  group)\n# Access: 2024-01-30 10:00:00.000000000 +0900\n# Modify: 2024-01-30 09:00:00.000000000 +0900\n# Change: 2024-01-30 09:00:00.000000000 +0900\n#  Birth: 2024-01-29 08:00:00.000000000 +0900\n\n# === Inode 사용량 확인 ===\n\n# 파일 시스템별 inode 사용량\ndf -i\n# Filesystem      Inodes   IUsed   IFree IUse% Mounted on\n# /dev/sda1      6553600  250000 6303600    4% /\n\n# 특정 디렉토리의 inode 수\nfind /var -xdev | wc -l\n\n# inode를 많이 사용하는 디렉토리 찾기\nfor d in /*; do echo \"$d: $(find $d -xdev 2>/dev/null | wc -l)\"; done | sort -t: -k2 -rn | head\n\n# === Hard Link와 Soft Link ===\n\n# Hard Link 생성 (같은 inode 공유)\nln original.txt hardlink.txt\nls -li original.txt hardlink.txt\n# 12345678 -rw-r--r-- 2 user group 1024 ... original.txt\n# 12345678 -rw-r--r-- 2 user group 1024 ... hardlink.txt\n#                   ^ 링크 수 2\n\n# Soft Link 생성 (새로운 inode, 경로 저장)\nln -s original.txt softlink.txt\nls -li original.txt softlink.txt\n# 12345678 -rw-r--r-- 1 user group 1024 ... original.txt\n# 87654321 lrwxrwxrwx 1 user group   12 ... softlink.txt -> original.txt\n\n# Hard Link vs Soft Link 동작 차이\necho \"Hello\" > original.txt\nln original.txt hard.txt\nln -s original.txt soft.txt\n\nrm original.txt\n\ncat hard.txt   # Hello (데이터 유지)\ncat soft.txt   # Error: No such file (깨진 링크)\n\n# === Inode 관련 문제 해결 ===\n\n# 문제: \"No space left on device\" but df shows free space\n# 원인: inode 부족\n\n# 진단\ndf -i /\ndf -h /\n\n# 해결: 작은 파일이 많은 디렉토리 정리\nfind /tmp -type f -mtime +30 -delete\n\n# 특정 inode 번호로 파일 찾기\nfind / -inum 12345678 2>/dev/null\n\n# 삭제된 파일이지만 프로세스가 잡고 있는 경우\nlsof +L1  # 링크 수가 0인 열린 파일\n# 해당 프로세스 재시작하면 공간 확보\n\n# === 디버깅 도구 ===\n\n# debugfs로 inode 직접 확인 (읽기 전용)\nsudo debugfs -R 'stat <12345678>' /dev/sda1\n\n# 디렉토리 내용 확인\nsudo debugfs -R 'ls -l /home/user' /dev/sda1\n\n# 삭제된 inode 목록 (복구 시)\nsudo debugfs -R 'lsdel' /dev/sda1"
      },
      {
        "type": "tip",
        "title": "Inode 관련 면접 질문 및 실무 팁",
        "content": "**면접 빈출 질문**\n\nQ1. inode란 무엇인가요?\nA: 파일의 메타데이터(권한, 소유자, 크기, 블록 위치 등)를 저장하는 자료구조. 파일명은 포함하지 않음.\n\nQ2. Hard Link와 Soft Link의 차이?\nA: \n- Hard Link: 같은 inode를 가리킴, 원본 삭제해도 데이터 유지\n- Soft Link: 새 inode, 경로만 저장, 원본 삭제시 깨짐\n- Hard Link는 파티션 경계 불가, Soft Link는 가능\n\nQ3. inode가 부족하면 어떻게 되나요?\nA: 디스크 공간이 있어도 새 파일 생성 불가. 작은 파일이 매우 많을 때 발생. df -i로 확인.\n\nQ4. 왜 파일명이 inode에 없나요?\nA: 하나의 파일에 여러 이름(hard link)을 가질 수 있기 때문. 파일명은 디렉토리 엔트리에 저장.\n\n**시간 정보 구분**\n\n- atime: 마지막 접근 시간 (read)\n- mtime: 마지막 수정 시간 (write)\n- ctime: inode 변경 시간 (권한, 소유자 변경)\n\n```\ncat file.txt      # atime 변경\necho >> file.txt  # mtime 변경\nchmod 755 file.txt # ctime 변경\n```\n\n**실무 팁**\n\n1. **성능 튜닝**: noatime 마운트로 불필요한 inode 업데이트 방지\n\n2. **inode 고갈 예방**: \n   - 임시 파일 정기 정리\n   - 세션 파일을 파티션 분리\n\n3. **백업 시 주의**: \n   - Hard Link 보존 옵션 사용\n   - rsync -H (hard links 보존)\n\n4. **파일 복구**: \n   - 삭제 직후 debugfs로 inode 확인 가능\n   - 데이터 덮어쓰기 전 복구 가능성 있음"
      }
    ]
  },
  "08_파일시스템/linux-command": {
    "id": "08_파일시스템/linux-command",
    "title": "리눅스 필수 명령어",
    "category": "os",
    "subCategory": "08_파일시스템",
    "language": "Bash",
    "description": "ls, cd, chmod, grep, ps, top 등 개발자 필수 리눅스 명령어를 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "리눅스 명령어 기초",
        "content": "리눅스 명령어는 개발자의 필수 도구입니다.\n\n**서랍장 비유로 이해하기**\n\n리눅스 파일 시스템을 서랍장에 비유하면:\n\n- **cd** (Change Directory): 서랍장 칸 이동\n- **ls** (List): 현재 칸의 내용물 보기\n- **pwd** (Print Working Directory): 현재 위치 확인\n- **mkdir/rmdir**: 새 칸 만들기/제거하기\n- **cp/mv/rm**: 물건 복사/이동/버리기\n\n**명령어 구조**\n\n```\ncommand [options] [arguments]\n명령어   [옵션]    [인자]\n\n예: ls -la /home\n    |  |   |\n    |  |   +-- 인자: 대상 디렉토리\n    |  +------ 옵션: long format, all files\n    +--------- 명령어: list\n```\n\n**자주 쓰는 옵션 패턴**\n\n- `-h`: human readable (사람이 읽기 쉽게)\n- `-r`: recursive (하위 디렉토리 포함)\n- `-f`: force (강제 실행)\n- `-v`: verbose (상세 출력)\n- `-i`: interactive (확인 후 실행)\n\n**핵심 명령어 분류**\n\n| 분류 | 명령어 |\n|------|--------|\n| 파일 | ls, cp, mv, rm, cat, find, grep |\n| 프로세스 | ps, top, kill, bg, fg |\n| 권한 | chmod, chown, chgrp |\n| 시스템 | df, du, free, uname |\n| 네트워크 | curl, wget, ss, netstat |"
      },
      {
        "type": "code",
        "title": "파일/디렉토리 명령어",
        "language": "bash",
        "code": "# =============================================\n# 파일 및 디렉토리 기본 명령어\n# =============================================\n\n# === ls (List) ===\nls                    # 현재 디렉토리 목록\nls -l                 # 상세 정보 (권한, 소유자, 크기, 시간)\nls -la                # 숨김 파일 포함 (.으로 시작하는 파일)\nls -lh                # 파일 크기를 KB/MB로 표시\nls -lt                # 시간순 정렬 (최신 먼저)\nls -lS                # 크기순 정렬 (큰 것 먼저)\nls -lR                # 하위 디렉토리까지 재귀적 출력\n\n# === cd (Change Directory) ===\ncd /home/user         # 절대 경로로 이동\ncd ..                 # 상위 디렉토리\ncd ~                  # 홈 디렉토리\ncd -                  # 이전 디렉토리로 돌아가기\ncd                    # 홈 디렉토리 (cd ~ 와 동일)\n\n# === 파일 조작 ===\ncp source dest        # 파일 복사\ncp -r dir1 dir2       # 디렉토리 복사 (recursive)\ncp -p file1 file2     # 권한, 시간 정보 유지\n\nmv old new            # 이름 변경/이동\nmv file.txt /tmp/     # 파일 이동\n\nrm file.txt           # 파일 삭제\nrm -r directory       # 디렉토리 삭제\nrm -rf directory      # 강제 삭제 (주의!)\nrm -i file.txt        # 확인 후 삭제\n\n# === 파일 내용 보기 ===\ncat file.txt          # 전체 출력\nhead -20 file.txt     # 처음 20줄\ntail -20 file.txt     # 마지막 20줄\ntail -f log.txt       # 실시간 로그 모니터링\nless file.txt         # 페이지 단위로 보기 (q: 종료)\n\n# === 파일 검색 ===\nfind /home -name \"*.txt\"              # 이름으로 검색\nfind /var -size +100M                 # 100MB 이상 파일\nfind . -mtime -7                      # 7일 내 수정된 파일\nfind . -type f -name \"*.log\" -delete  # 찾아서 삭제\n\n# === grep (텍스트 검색) ===\ngrep \"error\" log.txt           # 패턴 검색\ngrep -i \"error\" log.txt        # 대소문자 무시\ngrep -r \"TODO\" ./src           # 디렉토리 재귀 검색\ngrep -n \"function\" script.js   # 줄 번호 표시\ngrep -v \"debug\" log.txt        # 패턴 제외\ngrep -E \"error|warn\" log.txt   # 정규식 (OR)\n\n# 실용적인 조합\ngrep -rn \"TODO\" --include=\"*.py\"  # Python 파일에서 TODO 검색\n\n# === chmod (권한 변경) ===\n# 숫자 방식: r=4, w=2, x=1\nchmod 755 script.sh   # rwxr-xr-x (소유자 full, 그룹/기타 읽기+실행)\nchmod 644 file.txt    # rw-r--r-- (소유자 읽기쓰기, 나머지 읽기)\nchmod 600 secret.key  # rw------- (소유자만)\n\n# 심볼릭 방식\nchmod +x script.sh    # 실행 권한 추가\nchmod u+w file.txt    # 소유자에게 쓰기 권한\nchmod go-w file.txt   # 그룹/기타 쓰기 권한 제거\nchmod -R 755 dir/     # 디렉토리 재귀 적용\n\n# === chown (소유자 변경) ===\nchown user file.txt           # 소유자 변경\nchown user:group file.txt     # 소유자와 그룹 변경\nchown -R user:group dir/      # 재귀적 변경"
      },
      {
        "type": "code",
        "title": "프로세스/시스템 명령어",
        "language": "bash",
        "code": "# =============================================\n# 프로세스 관리 명령어\n# =============================================\n\n# === ps (Process Status) ===\nps                    # 현재 터미널의 프로세스\nps aux                # 모든 프로세스 상세 정보\n# USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND\n\nps -ef                # 모든 프로세스 (다른 형식)\nps aux | grep nginx   # 특정 프로세스 찾기\nps -u username        # 특정 사용자 프로세스\n\n# === top (실시간 모니터링) ===\ntop                   # 실시간 프로세스 모니터링\n# 대화형 명령:\n#   q: 종료\n#   M: 메모리 순 정렬\n#   P: CPU 순 정렬\n#   k: 프로세스 kill\n#   1: CPU 코어별 표시\n\nhtop                  # top의 개선판 (설치 필요)\n\n# === kill (프로세스 종료) ===\nkill PID              # SIGTERM (정상 종료 요청)\nkill -9 PID           # SIGKILL (강제 종료)\nkill -15 PID          # SIGTERM (기본값)\nkillall nginx         # 이름으로 모든 프로세스 종료\npkill -f \"python app\" # 패턴 매칭으로 종료\n\n# === 백그라운드 실행 ===\ncommand &             # 백그라운드 실행\nnohup command &       # 터미널 종료해도 계속 실행\nnohup python app.py > output.log 2>&1 &\n\nCtrl+Z                # 현재 프로세스 일시 정지\nbg                    # 백그라운드로 보내기\nfg                    # 포그라운드로 가져오기\njobs                  # 백그라운드 작업 목록\n\n# =============================================\n# 시스템 정보 명령어\n# =============================================\n\n# === 디스크 사용량 ===\ndf -h                 # 파일시스템 사용량\ndf -i                 # inode 사용량\ndu -sh /var/*         # 디렉토리별 크기\ndu -sh * | sort -h    # 크기순 정렬\nncdu                  # 시각적 디스크 분석 (설치 필요)\n\n# === 메모리 ===\nfree -h               # 메모리 사용량\n# total: 전체, used: 사용중, free: 미사용, \n# buff/cache: 버퍼/캐시, available: 실제 사용 가능\n\n# === 시스템 정보 ===\nuname -a              # 커널 정보\nlsb_release -a        # 배포판 정보\nhostname              # 호스트명\nuptime                # 가동 시간, 로드 평균\nwho                   # 로그인한 사용자\n\n# === 네트워크 ===\nip addr               # IP 주소 확인\nip route              # 라우팅 테이블\nss -tuln              # 열린 포트 확인 (netstat 대체)\nss -tulnp             # 프로세스 정보 포함\n\ncurl -I https://example.com   # HTTP 헤더만\ncurl -o file.zip URL          # 파일 다운로드\nwget URL                      # 파일 다운로드\n\n# === 로그 확인 ===\njournalctl -f                 # 시스템 로그 실시간\njournalctl -u nginx           # 특정 서비스 로그\ndmesg | tail                  # 커널 메시지\n\n# === 서비스 관리 (systemd) ===\nsystemctl status nginx        # 서비스 상태\nsystemctl start nginx         # 서비스 시작\nsystemctl stop nginx          # 서비스 중지\nsystemctl restart nginx       # 재시작\nsystemctl enable nginx        # 부팅시 자동 시작\nsystemctl disable nginx       # 자동 시작 해제\nsystemctl list-units --type=service  # 모든 서비스"
      },
      {
        "type": "tip",
        "title": "명령어 치트시트 및 실무 조합",
        "content": "**자주 쓰는 명령어 조합**\n\n```bash\n# 로그에서 에러 찾고 개수 세기\ngrep -c \"ERROR\" app.log\n\n# 최근 수정된 파일 10개\nfind . -type f -mmin -60 | head -10\n\n# 큰 파일 찾기\nfind / -type f -size +100M 2>/dev/null\n\n# 특정 포트 사용 프로세스\nlsof -i :8080\nss -tulnp | grep 8080\n\n# 디스크 사용량 상위 10개\ndu -ah / 2>/dev/null | sort -rh | head -10\n\n# 특정 프로세스 CPU/메모리\nps aux | grep nginx | grep -v grep\n\n# 로그 실시간 + 필터\ntail -f /var/log/app.log | grep --line-buffered \"ERROR\"\n```\n\n**단축키 & 팁**\n\n- `Ctrl+R`: 명령어 히스토리 검색\n- `!!`: 이전 명령어 반복\n- `!$`: 이전 명령의 마지막 인자\n- `Ctrl+A/E`: 줄 처음/끝으로 이동\n- `Tab`: 자동 완성\n\n**권한 숫자 외우기**\n```\n7 = rwx (4+2+1)\n6 = rw- (4+2)\n5 = r-x (4+1)\n4 = r--\n0 = ---\n\n755 = rwxr-xr-x (실행 파일)\n644 = rw-r--r-- (일반 파일)\n600 = rw------- (비밀 파일)\n```\n\n**면접 빈출 질문**\n\nQ1. 프로세스가 사용 중인 포트 확인 방법?\nA: `ss -tulnp` 또는 `lsof -i :포트번호`\n\nQ2. 좀비 프로세스란? 확인 방법?\nA: 종료되었지만 부모가 wait() 안 한 상태. `ps aux | grep Z`\n\nQ3. 디스크 풀인데 du로 확인 안 될 때?\nA: 삭제된 파일을 프로세스가 잡고 있음. `lsof +L1`로 확인\n\n**자주 실수하는 것**\n\n- `rm -rf /` 주의! (공백 실수로 `rm -rf / home` 가능)\n- `chmod 777`은 보안상 피하기\n- `kill -9`는 정상 종료 실패 후에만\n- 백그라운드 실행 시 nohup 잊지 말기"
      }
    ]
  },
  "index": {
    "id": "index",
    "title": "운영체제 학습 로드맵",
    "category": "os",
    "subCategory": null,
    "language": "Text",
    "description": "운영체제의 핵심 개념을 체계적으로 학습하기 위한 가이드입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "운영체제 학습 가이드",
        "content": "운영체제(OS)는 하드웨어와 소프트웨어 사이의 인터페이스입니다.\n\n**왜 OS를 배워야 할까요?**\n\n1. **면접 필수**: CS 기술 면접의 핵심 영역\n2. **성능 최적화**: 병목 현상의 원인 파악\n3. **시스템 설계**: 효율적인 아키텍처 구현\n4. **트러블슈팅**: 서버 장애 해결 능력\n\n**학습 로드맵 개요**\n\n```\n[1단계: 기초]           [2단계: 핵심]           [3단계: 심화]\n     |                       |                       |\n  OS 개념  ───────>  프로세스/스레드  ───────>  파일시스템\n  커널      ───────>  동기화/데드락   ───────>  I/O 모델\n  시스템 콜 ───────>  메모리 관리     ───────>  면접 준비\n                      스케줄링\n```\n\n**추천 학습 시간**\n- 1단계: 1-2일 (개념 이해)\n- 2단계: 1-2주 (핵심 내용)\n- 3단계: 1주 (심화 + 면접)\n\n**병행 추천 학습**\n- 리눅스 명령어 실습\n- C/시스템 프로그래밍\n- 컴퓨터 구조 기초"
      },
      {
        "type": "code",
        "title": "섹션별 학습 내용 요약",
        "language": "text",
        "code": "=== 운영체제 전체 커리큘럼 ===\n\n[01_기초] - 운영체제의 기본 개념\n+--------------------------------------------------+\n| os-intro     | OS란 무엇인가, 역할과 목적        |\n| os-structure | 모놀리식, 마이크로커널, 하이브리드 |\n| kernel       | 커널의 역할과 종류                |\n| system-call  | 사용자모드 <-> 커널모드 전환      |\n+--------------------------------------------------+\n> 실무 연관: 컨테이너(Docker)의 커널 공유 이해\n\n\n[02_프로세스스레드] - 실행의 단위\n+--------------------------------------------------+\n| process-concept   | 프로세스 정의와 생명주기     |\n| process-vs-thread | 프로세스 vs 스레드 비교      |\n| thread-concept    | 스레드의 구조와 장단점       |\n| context-switching | 컨텍스트 스위칭 오버헤드     |\n+--------------------------------------------------+\n> 실무 연관: 웹서버 아키텍처(Apache vs Nginx)\n> 면접 빈도: ★★★★★ (가장 자주 출제)\n\n\n[03_동기화] - 공유 자원 관리\n+--------------------------------------------------+\n| race-condition | 경쟁 상태와 임계 영역           |\n| mutex          | 상호배제, 락의 개념             |\n| semaphore      | 세마포어, P/V 연산              |\n| monitor        | 모니터, 조건 변수               |\n| deadlock       | 데드락 조건과 해결 방법         |\n+--------------------------------------------------+\n> 실무 연관: DB 트랜잭션, 분산 시스템 동기화\n> 면접 빈도: ★★★★★\n\n\n[04_스케줄링] - CPU 시간 분배\n+--------------------------------------------------+\n| scheduling-intro    | 스케줄링 기준과 목표       |\n| cpu-scheduling      | 선점형 vs 비선점형         |\n| scheduling-algorithm| FCFS, SJF, RR, Priority   |\n| preemptive          | 선점 스케줄링 상세         |\n+--------------------------------------------------+\n> 실무 연관: 쿠버네티스 리소스 스케줄링\n> 면접 빈도: ★★★☆☆\n\n\n[06_메모리] - 메모리 관리\n+--------------------------------------------------+\n| memory-structure  | 메모리 계층 구조            |\n| memory-allocation | 연속/불연속 할당            |\n| paging            | 페이징, 페이지 테이블       |\n| segmentation      | 세그멘테이션               |\n| virtual-memory    | 가상 메모리, Demand Paging  |\n| page-replacement  | LRU, FIFO, OPT 알고리즘    |\n| page-fault        | 페이지 폴트, 스래싱        |\n| fragmentation     | 내부/외부 단편화           |\n| cache             | 캐시 메모리, 지역성        |\n+--------------------------------------------------+\n> 실무 연관: GC 동작 이해, 메모리 릭 디버깅\n> 면접 빈도: ★★★★☆\n\n\n[07_동기비동기] - I/O 처리 방식\n+--------------------------------------------------+\n| sync-async           | 동기 vs 비동기           |\n| blocking-nonblocking | 블로킹 vs 논블로킹       |\n| sync-blocking-matrix | 4가지 조합 분석          |\n| io-model             | I/O 멀티플렉싱, Async IO |\n+--------------------------------------------------+\n> 실무 연관: Node.js, Nginx, Redis 아키텍처\n> 면접 빈도: ★★★★☆ (백엔드 필수)\n\n\n[08_파일시스템] - 저장소 관리\n+--------------------------------------------------+\n| file-system    | FAT, NTFS, ext4 비교          |\n| inode          | 아이노드, 메타데이터          |\n| linux-command  | 리눅스 필수 명령어            |\n+--------------------------------------------------+\n> 실무 연관: 서버 운영, 로그 분석, 트러블슈팅\n> 면접 빈도: ★★★☆☆\n\n\n[07_면접] - 면접 대비 총정리\n+--------------------------------------------------+\n| interview-os | 주니어 15문항 + 시니어 10문항  |\n+--------------------------------------------------+"
      },
      {
        "type": "code",
        "title": "추천 학습 순서",
        "language": "text",
        "code": "=== 레벨별 추천 학습 순서 ===\n\n[주니어 개발자 / 취업 준비생]\n\n1일차: 기초 개념\n├── os-intro (30분)\n├── os-structure (30분)\n└── system-call (30분)\n\n2-3일차: 프로세스와 스레드 ⭐중요\n├── process-concept (1시간)\n├── thread-concept (1시간)\n├── process-vs-thread (1시간) ← 면접 필수!\n└── context-switching (30분)\n\n4-5일차: 동기화 ⭐중요\n├── race-condition (30분)\n├── mutex (1시간)\n├── semaphore (1시간)\n└── deadlock (1시간) ← 면접 필수!\n\n6-7일차: 메모리 관리\n├── memory-structure (30분)\n├── paging (1시간)\n├── virtual-memory (1시간)\n└── page-replacement (1시간)\n\n8일차: I/O 모델 ⭐백엔드 필수\n├── sync-async (30분)\n├── blocking-nonblocking (30분)\n└── io-model (1시간)\n\n9-10일차: 면접 준비\n├── interview-os (2시간)\n└── 복습 및 모의 면접\n\n\n[시니어 / 심화 학습]\n\n추가 학습 추천:\n├── NUMA 아키텍처\n├── 커널 내부 구조 (리눅스 커널 소스)\n├── io_uring 최신 I/O 모델\n├── eBPF 시스템 프로그래밍\n└── 컨테이너 기술 (namespace, cgroups)\n\n\n=== 학습 팁 ===\n\n1. 실습 병행하기\n   - 리눅스 가상머신 설치\n   - 명령어 직접 타이핑\n   - 시스템 프로그래밍 실습\n\n2. 면접 질문으로 점검\n   - 각 섹션 끝의 면접 질문 확인\n   - 답을 보지 않고 설명해보기\n   - 꼬리 질문 대비\n\n3. 그림으로 이해하기\n   - 프로세스 메모리 구조 그리기\n   - 데드락 상황 시각화\n   - 페이지 테이블 손으로 계산\n\n4. 실무와 연결하기\n   - Redis가 싱글스레드인 이유?\n   - Nginx가 Apache보다 빠른 이유?\n   - Docker의 격리 원리?"
      },
      {
        "type": "tip",
        "title": "실무 연관성 및 학습 리소스",
        "content": "**실무에서 OS 지식이 필요한 순간**\n\n1. **서버 장애 대응**\n   - CPU 100% -> 프로세스 분석, 스케줄링 이해\n   - 메모리 부족 -> 가상 메모리, OOM 이해\n   - 디스크 풀 -> 파일 시스템, inode 이해\n\n2. **성능 최적화**\n   - 응답 지연 -> I/O 모델, 비동기 처리\n   - 동시성 이슈 -> 동기화, 락 전략\n   - GC 튜닝 -> 메모리 구조 이해\n\n3. **시스템 설계**\n   - 멀티프로세스 vs 멀티스레드 선택\n   - 이벤트 기반 vs 스레드풀 아키텍처\n   - 캐시 전략, 버퍼 관리\n\n4. **기술 면접**\n   - CS 기초 질문의 핵심 영역\n   - 경력에 상관없이 자주 출제\n   - 깊이 있는 답변으로 차별화\n\n**추천 학습 리소스**\n\n- 책: \"Operating System Concepts\" (공룡책)\n- 책: \"리눅스 커널의 이해\"\n- 강의: KOCW 운영체제 (반효경 교수)\n- 실습: Linux From Scratch\n\n**체크리스트: 학습 완료 기준**\n\n[ ] 프로세스와 스레드의 차이를 그림으로 설명 가능\n[ ] 데드락 4가지 조건을 암기하고 해결법 설명 가능\n[ ] 가상 메모리 동작 원리 설명 가능\n[ ] 동기/비동기, 블로킹/논블로킹 조합 설명 가능\n[ ] 주요 리눅스 명령어 실무 활용 가능\n[ ] 면접 빈출 질문 20개에 답변 가능\n\n**OS 학습이 도움이 되는 기술들**\n\n- Docker/Kubernetes: 커널, namespace, cgroups\n- Redis: 싱글스레드, 이벤트루프, I/O 멀티플렉싱\n- Nginx: 비동기 이벤트 기반 아키텍처\n- Node.js: 이벤트 루프, libuv\n- JVM: 메모리 관리, GC 알고리즘"
      }
    ]
  }
}