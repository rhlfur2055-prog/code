{
  "01_기초/db-intro": {
    "id": "01_기초/db-intro",
    "title": "데이터베이스 소개",
    "category": "db",
    "subCategory": "01_기초",
    "language": "SQL",
    "description": "데이터베이스의 개념과 필요성을 이해합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 데이터베이스가 뭐야?",
        "content": "## 🔥 한 줄 요약\n> **데이터를 체계적으로 저장하고 관리하는 시스템** - \"엑셀의 진화 버전\"\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 실무에서:\n- **모든 서비스의 핵심**: 회원정보, 주문, 결제... 다 DB에 저장\n- **취업 필수**: 백엔드 공고 100% \"SQL 능숙자\"\n- **연봉 협상 무기**: DB 최적화 가능하면 시니어 대우\n\n### 현실 예시:\n```\n🏢 쿠팡에서 \"아이폰\" 검색 → 0.1초 만에 10만 개 상품 출력\n📱 인스타에서 좋아요 누르면 → 전세계 어디서든 반영\n🎮 롤에서 전적 검색 → 과거 1000판 기록 즉시 조회\n```\n\n---\n\n## 🎯 핵심 개념\n\n### 📚 도서관으로 이해하기\n\n**파일 시스템 (엑셀)**\n```\n📁 고객.xlsx\n📁 주문.xlsx\n📁 상품.xlsx\n→ 파일 열고, 찾고, 수정하고... 느림!\n→ 동시에 여러 명이 수정하면? 충돌!\n```\n\n**데이터베이스**\n```\n🏛️ 도서관 시스템\n→ 사서(DBMS)가 책 관리\n→ 색인(인덱스)으로 빠른 검색\n→ 여러 명이 동시에 대출 가능\n```\n\n### DB vs 파일 비교\n\n| 구분 | 파일(엑셀) | 데이터베이스 |\n|-----|----------|------------|\n| 동시 접근 | ❌ 충돌 | ✅ 가능 |\n| 검색 속도 | 느림 | 빠름 (인덱스) |\n| 데이터 무결성 | 없음 | 제약조건 |\n| 백업/복구 | 수동 | 자동화 |\n| 보안 | 없음 | 권한 관리 |\n\n### DBMS 종류\n\n```\n🔵 관계형 (RDBMS)\n├── MySQL (무료, 가장 대중적)\n├── PostgreSQL (무료, 기능 풍부)\n├── Oracle (유료, 대기업)\n└── SQL Server (MS, 윈도우)\n\n🟢 NoSQL\n├── MongoDB (문서형)\n├── Redis (키-값, 캐시)\n└── Elasticsearch (검색)\n```"
      },
      {
        "type": "code",
        "title": "💻 첫 번째 SQL",
        "content": "### 데이터 조회의 시작\n\n```sql\n-- 모든 고객 정보 조회\nSELECT * FROM customers;\n\n-- 특정 컬럼만 조회\nSELECT name, email FROM customers;\n\n-- 조건으로 필터링\nSELECT * FROM customers WHERE age >= 20;\n\n-- 정렬\nSELECT * FROM customers ORDER BY created_at DESC;\n```\n\n### 데이터 구조 예시\n\n```\ncustomers 테이블\n+----+--------+-------------------+-----+\n| id | name   | email             | age |\n+----+--------+-------------------+-----+\n| 1  | 김철수  | kim@example.com   | 25  |\n| 2  | 이영희  | lee@example.com   | 30  |\n| 3  | 박민수  | park@example.com  | 22  |\n+----+--------+-------------------+-----+\n```\n\n### Python에서 DB 연결\n\n```python\nimport mysql.connector\n\n# DB 연결\nconn = mysql.connector.connect(\n    host=\"localhost\",\n    user=\"root\",\n    password=\"password\",\n    database=\"myapp\"\n)\n\ncursor = conn.cursor()\ncursor.execute(\"SELECT * FROM customers\")\nresults = cursor.fetchall()\n\nfor row in results:\n    print(row)\n\nconn.close()\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### 어떤 DB를 선택할까?\n\n```\n🟢 MySQL\n├── 스타트업, 중소기업\n├── 무료 + 쉬운 학습곡선\n└── 대부분의 웹 서비스\n\n🔵 PostgreSQL\n├── 복잡한 쿼리, GIS 데이터\n├── JSON 지원 우수\n└── 스타트업에서 인기 상승 중\n\n🟡 Oracle\n├── 대기업, 금융권\n├── 비싸지만 안정적\n└── DBA 연봉이 높음\n```\n\n### 학습 로드맵\n\n```\n1단계: SQL 기초 (SELECT, INSERT, UPDATE, DELETE)\n2단계: JOIN, 서브쿼리\n3단계: 인덱스, 실행계획\n4단계: 트랜잭션, 락\n5단계: 성능 최적화\n```"
      }
    ]
  },
  "01_기초/rdbms-concept": {
    "id": "01_기초/rdbms-concept",
    "title": "RDBMS 핵심 개념",
    "category": "db",
    "subCategory": "01_기초",
    "language": "SQL",
    "description": "스키마, 테이블, 제약조건의 개념을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 스키마와 제약조건",
        "content": "## 🔥 한 줄 요약\n> **스키마 = 설계도, 제약조건 = 규칙** - \"건물 청사진 + 안전 규정\"\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 실무 사고 예방:\n```\n❌ 제약조건 없이 개발\n├── 이메일 중복 가입 → 고객 항의\n├── 마이너스 재고 → 주문 불가 사태\n├── 존재하지 않는 유저의 주문 → 데이터 꼬임\n└── 복구에 3일 걸림 + 야근\n\n✅ 제약조건 설정\n└── DB가 알아서 막아줌!\n```\n\n---\n\n## 🎯 핵심 개념\n\n### 📋 스키마(Schema)\n\n```\n스키마 = 데이터베이스 구조 정의\n\n┌─────────────────────────────────┐\n│  Database: shopping_mall        │\n├─────────────────────────────────┤\n│  Schema                         │\n│  ├── users 테이블               │\n│  │   ├── id (PK)               │\n│  │   ├── email (UNIQUE)        │\n│  │   └── name                  │\n│  ├── products 테이블            │\n│  └── orders 테이블              │\n└─────────────────────────────────┘\n```\n\n### 🔒 제약조건 종류\n\n```sql\n-- 1. NOT NULL: 필수값\nemail VARCHAR(100) NOT NULL\n\n-- 2. UNIQUE: 중복 불가\nemail VARCHAR(100) UNIQUE\n\n-- 3. PRIMARY KEY: 유일 식별자\nid INT PRIMARY KEY\n\n-- 4. FOREIGN KEY: 참조 무결성\nuser_id INT REFERENCES users(id)\n\n-- 5. CHECK: 값 범위 제한\nprice INT CHECK (price >= 0)\n\n-- 6. DEFAULT: 기본값\nstatus VARCHAR(20) DEFAULT 'active'\n```\n\n### 제약조건 실전 예시\n\n```sql\nCREATE TABLE products (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(200) NOT NULL,           -- 상품명 필수\n    price INT NOT NULL CHECK (price > 0), -- 0원 이상\n    stock INT DEFAULT 0 CHECK (stock >= 0), -- 재고 0 이상\n    status ENUM('active', 'inactive', 'deleted') DEFAULT 'active',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n);\n```"
      },
      {
        "type": "code",
        "title": "💻 제약조건 활용",
        "content": "### 제약조건 위반 시\n\n```sql\n-- 1. NOT NULL 위반\nINSERT INTO users (email, name) VALUES (NULL, '김철수');\n-- Error: Column 'email' cannot be null\n\n-- 2. UNIQUE 위반\nINSERT INTO users (email, name) VALUES ('kim@test.com', '김철수');\nINSERT INTO users (email, name) VALUES ('kim@test.com', '이영희');\n-- Error: Duplicate entry 'kim@test.com' for key 'email'\n\n-- 3. FOREIGN KEY 위반\nINSERT INTO orders (user_id, total_price) VALUES (9999, 50000);\n-- Error: Cannot add or update a child row:\n--        a foreign key constraint fails\n```\n\n### CASCADE 옵션\n\n```sql\nCREATE TABLE orders (\n    id INT PRIMARY KEY,\n    user_id INT,\n    FOREIGN KEY (user_id) REFERENCES users(id)\n        ON DELETE CASCADE    -- 유저 삭제 시 주문도 삭제\n        ON UPDATE CASCADE    -- 유저 ID 변경 시 같이 변경\n);\n\n-- 옵션 종류\n-- CASCADE: 같이 삭제/수정\n-- SET NULL: NULL로 설정\n-- RESTRICT: 삭제/수정 막음 (기본값)\n-- NO ACTION: RESTRICT와 동일\n```\n\n### 제약조건 추가/삭제\n\n```sql\n-- 기존 테이블에 제약조건 추가\nALTER TABLE users\nADD CONSTRAINT uk_email UNIQUE (email);\n\n-- 제약조건 삭제\nALTER TABLE users\nDROP CONSTRAINT uk_email;\n\n-- 인덱스 확인\nSHOW INDEX FROM users;\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### 제약조건 베스트 프랙티스\n\n```\n✅ 항상 PK 설정 (AUTO_INCREMENT 추천)\n✅ 이메일, 주민번호 등은 UNIQUE\n✅ 가격, 수량은 CHECK로 음수 방지\n✅ FK로 데이터 무결성 보장\n✅ created_at, updated_at 자동 설정\n\n❌ 모든 컬럼에 NOT NULL (유연성 저하)\n❌ CHECK 남발 (애플리케이션에서 검증)\n❌ CASCADE DELETE 무분별 사용\n```\n\n### 제약조건 vs 애플리케이션 검증\n\n```\nDB 제약조건: 최후의 보루 (절대 뚫리면 안 됨)\n앱 검증: 사용자 친화적 에러 메시지\n\n→ 둘 다 해야 함!\n```"
      }
    ]
  },
  "01_기초/rdbms": {
    "id": "01_기초/rdbms",
    "title": "관계형 데이터베이스",
    "category": "db",
    "subCategory": "01_기초",
    "language": "SQL",
    "description": "RDBMS의 핵심 개념과 구조를 이해합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 RDBMS란?",
        "content": "## 🔥 한 줄 요약\n> **테이블 간 관계로 데이터를 관리** - \"엑셀 시트를 연결한 것\"\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 취업 시장:\n- 백엔드 공고 **95%**: \"MySQL/PostgreSQL 경험\"\n- 데이터 분석 공고 **100%**: \"SQL 필수\"\n- 연봉 1억 DBA: RDBMS 전문가\n\n### 현실 예시:\n```\n🛒 쿠팡 주문 시스템\n├── 회원 테이블 (누가 샀는지)\n├── 상품 테이블 (뭘 샀는지)\n├── 주문 테이블 (언제 샀는지)\n└── 배송 테이블 (어디로 보내는지)\n→ 4개 테이블이 관계로 연결!\n```\n\n---\n\n## 🎯 핵심 개념\n\n### 📊 테이블 구조\n\n```\n┌─────────────────────────────────────┐\n│           customers 테이블           │\n├────┬────────┬──────────────┬────────┤\n│ id │ name   │ email        │ age    │  ← Row (행, 레코드)\n├────┼────────┼──────────────┼────────┤\n│ 1  │ 김철수  │ kim@test.com │ 25     │\n│ 2  │ 이영희  │ lee@test.com │ 30     │\n└────┴────────┴──────────────┴────────┘\n  ↑      ↑          ↑           ↑\n  Column (열, 필드, 속성)\n```\n\n### 🔑 키(Key)의 종류\n\n```sql\n-- Primary Key (기본키): 유일하게 식별\nCREATE TABLE users (\n    id INT PRIMARY KEY AUTO_INCREMENT,  -- 이게 PK\n    email VARCHAR(100) UNIQUE,\n    name VARCHAR(50)\n);\n\n-- Foreign Key (외래키): 다른 테이블 참조\nCREATE TABLE orders (\n    id INT PRIMARY KEY,\n    user_id INT,  -- users.id를 참조\n    FOREIGN KEY (user_id) REFERENCES users(id)\n);\n```\n\n### 관계의 종류\n\n```\n1:1 (일대일)\n├── 유저 ↔ 프로필\n└── 하나의 유저는 하나의 프로필만\n\n1:N (일대다) ⭐ 가장 흔함\n├── 유저 ↔ 주문\n└── 한 유저가 여러 주문 가능\n\nN:M (다대다)\n├── 학생 ↔ 수업\n└── 중간 테이블 필요 (수강신청)\n```"
      },
      {
        "type": "code",
        "title": "💻 테이블 설계 예시",
        "content": "### 쇼핑몰 DB 설계\n\n```sql\n-- 1. 회원 테이블\nCREATE TABLE users (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    email VARCHAR(100) UNIQUE NOT NULL,\n    password VARCHAR(255) NOT NULL,\n    name VARCHAR(50) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- 2. 상품 테이블\nCREATE TABLE products (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(200) NOT NULL,\n    price INT NOT NULL,\n    stock INT DEFAULT 0,\n    category VARCHAR(50)\n);\n\n-- 3. 주문 테이블 (users와 1:N 관계)\nCREATE TABLE orders (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    user_id INT NOT NULL,\n    total_price INT NOT NULL,\n    status ENUM('pending', 'paid', 'shipped', 'delivered') DEFAULT 'pending',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (user_id) REFERENCES users(id)\n);\n\n-- 4. 주문상세 테이블 (orders, products와 관계)\nCREATE TABLE order_items (\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    order_id INT NOT NULL,\n    product_id INT NOT NULL,\n    quantity INT NOT NULL,\n    price INT NOT NULL,\n    FOREIGN KEY (order_id) REFERENCES orders(id),\n    FOREIGN KEY (product_id) REFERENCES products(id)\n);\n```\n\n### 관계 조회 (JOIN)\n\n```sql\n-- 회원별 주문 내역 조회\nSELECT\n    u.name AS 회원명,\n    o.id AS 주문번호,\n    o.total_price AS 총액,\n    o.created_at AS 주문일\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE u.id = 1;\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### RDBMS 선택 가이드\n\n| DB | 장점 | 단점 | 추천 |\n|----|-----|-----|------|\n| MySQL | 쉬움, 무료, 빠름 | 기능 제한 | 웹서비스 |\n| PostgreSQL | 기능 풍부, JSON | 설정 복잡 | 복잡한 쿼리 |\n| Oracle | 안정성, 성능 | 비용 | 대기업 |\n\n### 설계 원칙\n\n```\n✅ 정규화: 중복 제거 (3NF까지)\n✅ 적절한 인덱스: 검색 성능\n✅ 외래키 설정: 데이터 무결성\n✅ 명명 규칙: snake_case 추천\n```"
      }
    ]
  },
  "02_SQL/aggregate-function": {
    "id": "02_SQL/aggregate-function",
    "title": "집계 함수 마스터",
    "category": "db",
    "subCategory": "02_SQL",
    "language": "SQL",
    "description": "COUNT, SUM, AVG 등 집계 함수를 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 집계 함수 총정리",
        "content": "## 🔥 한 줄 요약\n> **여러 행을 하나의 값으로 계산** - COUNT, SUM, AVG, MAX, MIN\n\n---\n\n## 🎯 주요 집계 함수\n\n### COUNT\n\n```sql\nCOUNT(*)       -- 전체 행 수 (NULL 포함)\nCOUNT(column)  -- NULL 제외 개수\nCOUNT(DISTINCT column) -- 중복 제외 개수\n```\n\n### SUM / AVG\n\n```sql\nSUM(column)    -- 합계 (NULL 무시)\nAVG(column)    -- 평균 (NULL 무시)\n```\n\n### MAX / MIN\n\n```sql\nMAX(column)    -- 최대값\nMIN(column)    -- 최소값\n-- 숫자, 문자, 날짜 모두 가능\n```\n\n### 기타 함수\n\n```sql\n-- MySQL\nGROUP_CONCAT(column)           -- 값들을 문자열로 연결\nGROUP_CONCAT(DISTINCT column)  -- 중복 제외 연결\n\n-- 표준 SQL\nSTDDEV(column)    -- 표준편차\nVARIANCE(column)  -- 분산\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 집계",
        "content": "### 기본 집계\n\n```sql\n-- 전체 통계\nSELECT\n    COUNT(*) AS 전체주문수,\n    COUNT(DISTINCT user_id) AS 주문고객수,\n    SUM(total_price) AS 총매출,\n    AVG(total_price) AS 평균주문액,\n    MAX(total_price) AS 최대주문액,\n    MIN(total_price) AS 최소주문액\nFROM orders\nWHERE status = 'completed';\n```\n\n### 조건부 집계\n\n```sql\n-- CASE와 함께 (피벗 테이블)\nSELECT\n    DATE(created_at) AS date,\n    COUNT(*) AS total,\n    SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) AS completed,\n    SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) AS cancelled,\n    SUM(CASE WHEN status = 'completed' THEN total_price ELSE 0 END) AS revenue\nFROM orders\nGROUP BY DATE(created_at);\n\n-- NULL 처리\nSELECT\n    AVG(COALESCE(rating, 0)) AS avg_rating,  -- NULL을 0으로\n    AVG(rating) AS avg_rating_no_null        -- NULL 제외\nFROM reviews;\n```\n\n### GROUP_CONCAT 활용\n\n```sql\n-- 카테고리별 상품명 나열\nSELECT\n    category,\n    GROUP_CONCAT(name SEPARATOR ', ') AS products\nFROM products\nGROUP BY category;\n\n-- 결과: 전자기기 | 아이폰, 갤럭시, 맥북\n\n-- 정렬해서 연결\nSELECT\n    user_id,\n    GROUP_CONCAT(\n        product_name\n        ORDER BY created_at DESC\n        SEPARATOR ' → '\n    ) AS purchase_history\nFROM orders\nGROUP BY user_id;\n```\n\n### 윈도우 함수 (고급)\n\n```sql\n-- 전체 합계와 개별 값 동시에\nSELECT\n    id,\n    total_price,\n    SUM(total_price) OVER() AS grand_total,\n    total_price * 100.0 / SUM(total_price) OVER() AS percentage\nFROM orders;\n\n-- 누적 합계\nSELECT\n    DATE(created_at) AS date,\n    SUM(total_price) AS daily_revenue,\n    SUM(SUM(total_price)) OVER(ORDER BY DATE(created_at)) AS cumulative\nFROM orders\nGROUP BY DATE(created_at);\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### NULL 주의사항\n\n```sql\n-- COUNT(*)는 NULL 포함\n-- COUNT(column)은 NULL 제외\n-- SUM, AVG는 NULL 무시\n\n-- 예시\n-- data: [10, 20, NULL, 30]\nCOUNT(*)      = 4\nCOUNT(value)  = 3\nSUM(value)    = 60\nAVG(value)    = 20  -- 60/3, NULL 제외\n```\n\n### 성능 팁\n\n```sql\n-- ❌ 느림: COUNT(DISTINCT)는 비용 큼\nSELECT COUNT(DISTINCT user_id) FROM orders;\n\n-- ✅ 빠름: 근사값으로 대체 (대용량)\nSELECT APPROX_COUNT_DISTINCT(user_id) FROM orders;  -- BigQuery\n```\n\n### 소수점 처리\n\n```sql\n-- 정확한 계산\nSELECT ROUND(AVG(price), 2) AS avg_price;\n\n-- 금액 계산 시\nSELECT CAST(SUM(price) AS DECIMAL(12,2));\n```"
      }
    ]
  },
  "02_SQL/case-when": {
    "id": "02_SQL/case-when",
    "title": "CASE WHEN 조건문",
    "category": "db",
    "subCategory": "02_SQL",
    "language": "SQL",
    "description": "SQL에서 조건 분기를 처리하는 방법을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 CASE WHEN이란?",
        "content": "## 🔥 한 줄 요약\n> **SQL의 if-else문** - 조건에 따라 다른 값 반환\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 실무 필수:\n```\n📊 \"등급별로 다른 할인율 적용\"\n📈 \"상태 코드를 한글로 변환\"\n👥 \"연령대별 그룹 분류\"\n\n→ CASE 없이는 조건 분기 불가\n```\n\n---\n\n## 🎯 기본 문법\n\n### 단순 CASE\n\n```sql\nCASE column\n    WHEN value1 THEN result1\n    WHEN value2 THEN result2\n    ELSE default_result\nEND\n```\n\n### 검색 CASE (더 유연)\n\n```sql\nCASE\n    WHEN condition1 THEN result1\n    WHEN condition2 THEN result2\n    ELSE default_result\nEND\n```\n\n### 실제 예시\n\n```sql\n-- 상태 코드 → 한글\nSELECT\n    id,\n    status,\n    CASE status\n        WHEN 'pending' THEN '대기중'\n        WHEN 'processing' THEN '처리중'\n        WHEN 'completed' THEN '완료'\n        WHEN 'cancelled' THEN '취소'\n        ELSE '알수없음'\n    END AS status_korean\nFROM orders;\n\n-- 가격대 분류\nSELECT\n    name,\n    price,\n    CASE\n        WHEN price < 10000 THEN '저가'\n        WHEN price < 50000 THEN '중가'\n        WHEN price < 100000 THEN '고가'\n        ELSE '프리미엄'\n    END AS price_tier\nFROM products;\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 CASE WHEN",
        "content": "### 조건부 계산\n\n```sql\n-- 등급별 할인 적용\nSELECT\n    name,\n    price,\n    membership,\n    CASE membership\n        WHEN 'VIP' THEN price * 0.8     -- 20% 할인\n        WHEN 'Gold' THEN price * 0.9    -- 10% 할인\n        ELSE price\n    END AS final_price\nFROM products p\nJOIN users u ON p.seller_id = u.id;\n\n-- 배송비 계산\nSELECT\n    id,\n    total_price,\n    CASE\n        WHEN total_price >= 50000 THEN 0\n        WHEN total_price >= 30000 THEN 2500\n        ELSE 3000\n    END AS shipping_fee\nFROM orders;\n```\n\n### 집계와 함께 (피벗 테이블)\n\n```sql\n-- 상태별 집계 (행 → 열)\nSELECT\n    DATE(created_at) AS date,\n    COUNT(*) AS total,\n    SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) AS completed,\n    SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) AS cancelled,\n    SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) AS pending\nFROM orders\nGROUP BY DATE(created_at);\n\n-- 결과:\n-- date       | total | completed | cancelled | pending\n-- 2024-01-15 | 100   | 80        | 10        | 10\n\n-- 월별 상품 카테고리 매출\nSELECT\n    DATE_FORMAT(o.created_at, '%Y-%m') AS month,\n    SUM(CASE WHEN p.category = '전자기기' THEN oi.price ELSE 0 END) AS electronics,\n    SUM(CASE WHEN p.category = '의류' THEN oi.price ELSE 0 END) AS clothing,\n    SUM(CASE WHEN p.category = '식품' THEN oi.price ELSE 0 END) AS food\nFROM orders o\nJOIN order_items oi ON o.id = oi.order_id\nJOIN products p ON oi.product_id = p.id\nGROUP BY DATE_FORMAT(o.created_at, '%Y-%m');\n```\n\n### UPDATE/WHERE에서 활용\n\n```sql\n-- 조건부 UPDATE\nUPDATE users\nSET membership = CASE\n    WHEN total_purchase >= 1000000 THEN 'VIP'\n    WHEN total_purchase >= 500000 THEN 'Gold'\n    ELSE 'Normal'\nEND;\n\n-- ORDER BY에서 커스텀 정렬\nSELECT * FROM orders\nORDER BY CASE status\n    WHEN 'pending' THEN 1\n    WHEN 'processing' THEN 2\n    WHEN 'shipped' THEN 3\n    WHEN 'delivered' THEN 4\n    ELSE 5\nEND;\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### CASE vs IF\n\n```sql\n-- MySQL IF 함수 (단순 조건)\nSELECT IF(price > 10000, '비쌈', '저렴') AS price_label;\n\n-- CASE (복잡한 조건)\nSELECT CASE\n    WHEN price < 10000 THEN '저가'\n    WHEN price < 50000 THEN '중가'\n    ELSE '고가'\nEND AS price_tier;\n\n-- IF는 2가지 분기만 가능\n-- CASE는 여러 분기 가능\n```\n\n### NULL 처리\n\n```sql\n-- CASE에서 NULL 체크\nSELECT\n    name,\n    CASE\n        WHEN phone IS NULL THEN '미등록'\n        ELSE phone\n    END AS phone\nFROM users;\n\n-- COALESCE/IFNULL이 더 간단\nSELECT\n    name,\n    COALESCE(phone, '미등록') AS phone\nFROM users;\n```\n\n### ELSE 생략 주의\n\n```sql\n-- ELSE 없으면 NULL 반환\nSELECT CASE status\n    WHEN 'active' THEN '활성'\n    WHEN 'inactive' THEN '비활성'\n    -- status가 'deleted'면? → NULL\nEND AS status_korean;\n\n-- 항상 ELSE 넣는 것 권장\n```"
      }
    ]
  },
  "02_SQL/date-function": {
    "id": "02_SQL/date-function",
    "title": "날짜 함수",
    "category": "db",
    "subCategory": "02_SQL",
    "language": "SQL",
    "description": "SQL에서 날짜/시간을 다루는 함수들을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 날짜 함수 총정리",
        "content": "## 🔥 한 줄 요약\n> **날짜/시간 조작의 모든 것** - 추출, 계산, 포맷팅\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 실무 필수:\n```\n📊 \"이번 달 매출\" → 날짜 범위 조건\n📈 \"월별 통계\" → 날짜 그룹화\n👥 \"7일 이내 가입자\" → 날짜 계산\n```\n\n---\n\n## 🎯 주요 함수\n\n### 현재 날짜/시간\n\n```sql\nNOW()              -- 현재 날짜+시간 (2024-01-15 14:30:00)\nCURDATE()          -- 현재 날짜 (2024-01-15)\nCURTIME()          -- 현재 시간 (14:30:00)\nCURRENT_TIMESTAMP  -- NOW()와 동일\n```\n\n### 날짜 추출\n\n```sql\nYEAR(date)         -- 연도 (2024)\nMONTH(date)        -- 월 (1~12)\nDAY(date)          -- 일 (1~31)\nHOUR(time)         -- 시 (0~23)\nMINUTE(time)       -- 분 (0~59)\nSECOND(time)       -- 초 (0~59)\nDAYOFWEEK(date)    -- 요일 (1=일, 7=토)\nWEEKDAY(date)      -- 요일 (0=월, 6=일)\n```\n\n### 날짜 연산\n\n```sql\nDATE_ADD(date, INTERVAL n unit)  -- 더하기\nDATE_SUB(date, INTERVAL n unit)  -- 빼기\nDATEDIFF(date1, date2)           -- 일수 차이\nTIMESTAMPDIFF(unit, dt1, dt2)    -- 단위별 차이\n```\n\n### 포맷팅\n\n```sql\nDATE_FORMAT(date, format)  -- 날짜 → 문자열\nSTR_TO_DATE(str, format)   -- 문자열 → 날짜\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 날짜 함수",
        "content": "### 날짜 추출\n\n```sql\n-- 연/월/일 추출\nSELECT\n    created_at,\n    YEAR(created_at) AS year,\n    MONTH(created_at) AS month,\n    DAY(created_at) AS day,\n    DAYNAME(created_at) AS day_name\nFROM orders;\n\n-- 시간 추출\nSELECT\n    created_at,\n    HOUR(created_at) AS hour,\n    DATE_FORMAT(created_at, '%p') AS am_pm  -- AM/PM\nFROM orders;\n```\n\n### 날짜 연산\n\n```sql\n-- 7일 전 ~ 오늘\nSELECT * FROM orders\nWHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY);\n\n-- 다음 달 1일\nSELECT DATE_ADD(\n    LAST_DAY(NOW()),\n    INTERVAL 1 DAY\n) AS next_month_first;\n\n-- 가입 후 경과일\nSELECT\n    name,\n    created_at,\n    DATEDIFF(NOW(), created_at) AS days_since_join\nFROM users;\n\n-- 나이 계산\nSELECT\n    name,\n    birth_date,\n    TIMESTAMPDIFF(YEAR, birth_date, CURDATE()) AS age\nFROM users;\n```\n\n### 기간 조회\n\n```sql\n-- 이번 달\nSELECT * FROM orders\nWHERE YEAR(created_at) = YEAR(NOW())\n  AND MONTH(created_at) = MONTH(NOW());\n\n-- 더 효율적인 방법\nSELECT * FROM orders\nWHERE created_at >= DATE_FORMAT(NOW(), '%Y-%m-01')\n  AND created_at < DATE_ADD(DATE_FORMAT(NOW(), '%Y-%m-01'), INTERVAL 1 MONTH);\n\n-- 최근 30일 일별 통계\nSELECT\n    DATE(created_at) AS date,\n    COUNT(*) AS order_count\nFROM orders\nWHERE created_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)\nGROUP BY DATE(created_at)\nORDER BY date;\n```\n\n### 포맷팅\n\n```sql\n-- 다양한 포맷\nSELECT\n    created_at,\n    DATE_FORMAT(created_at, '%Y-%m-%d') AS date_only,\n    DATE_FORMAT(created_at, '%Y년 %m월 %d일') AS korean,\n    DATE_FORMAT(created_at, '%H:%i:%s') AS time_only,\n    DATE_FORMAT(created_at, '%Y-%m') AS year_month\nFROM orders;\n\n-- 문자열 → 날짜\nSELECT STR_TO_DATE('2024-01-15', '%Y-%m-%d');\nSELECT STR_TO_DATE('15/01/2024', '%d/%m/%Y');\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### 인덱스와 날짜 함수\n\n```sql\n-- ❌ 인덱스 못 씀 (함수 사용)\nWHERE YEAR(created_at) = 2024\nWHERE DATE(created_at) = '2024-01-15'\n\n-- ✅ 인덱스 사용 (범위 조건)\nWHERE created_at >= '2024-01-01' AND created_at < '2025-01-01'\nWHERE created_at >= '2024-01-15' AND created_at < '2024-01-16'\n```\n\n### 타임존 주의\n\n```sql\n-- TIMESTAMP: 서버 타임존 자동 변환\n-- DATETIME: 그대로 저장\n\n-- UTC로 저장 권장\nINSERT INTO logs (created_at)\nVALUES (UTC_TIMESTAMP());\n\n-- 조회 시 변환\nSELECT CONVERT_TZ(created_at, 'UTC', 'Asia/Seoul');\n```\n\n### 자주 쓰는 패턴\n\n```sql\n-- 이번 주\nWHERE YEARWEEK(created_at) = YEARWEEK(NOW())\n\n-- 지난 달\nWHERE created_at >= DATE_SUB(DATE_FORMAT(NOW(), '%Y-%m-01'), INTERVAL 1 MONTH)\n  AND created_at < DATE_FORMAT(NOW(), '%Y-%m-01')\n\n-- 분기별\nSELECT\n    QUARTER(created_at) AS quarter,\n    SUM(total_price)\nFROM orders\nGROUP BY QUARTER(created_at);\n```"
      }
    ]
  },
  "02_SQL/ddl": {
    "id": "02_SQL/ddl",
    "title": "DDL - 테이블 생성/수정/삭제",
    "category": "db",
    "subCategory": "02_SQL",
    "language": "SQL",
    "description": "데이터베이스 구조를 정의하는 DDL을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 DDL이란?",
        "content": "## 🔥 한 줄 요약\n> **DB 구조를 정의하는 SQL** - CREATE, ALTER, DROP\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 실무 필수:\n```\n🏗️ 새 기능 개발 → CREATE TABLE\n📝 요구사항 변경 → ALTER TABLE\n🗑️ 레거시 정리 → DROP TABLE\n\n→ DDL 모르면 스키마 수정 불가\n```\n\n---\n\n## 🎯 핵심 문법\n\n### CREATE TABLE\n\n```sql\nCREATE TABLE table_name (\n    column1 datatype constraints,\n    column2 datatype constraints,\n    ...\n    table_constraints\n);\n```\n\n### 주요 데이터 타입\n\n```\n📊 숫자\n├── INT: 정수 (-21억 ~ 21억)\n├── BIGINT: 큰 정수\n├── DECIMAL(10,2): 정확한 소수 (금액용)\n└── FLOAT, DOUBLE: 부동소수점\n\n📝 문자\n├── VARCHAR(n): 가변 길이 (최대 n자)\n├── CHAR(n): 고정 길이 (정확히 n자)\n└── TEXT: 긴 텍스트\n\n📅 날짜/시간\n├── DATE: 날짜 (2024-01-15)\n├── TIME: 시간 (14:30:00)\n├── DATETIME: 날짜+시간\n└── TIMESTAMP: UTC 기준 시간\n\n🔘 기타\n├── BOOLEAN: true/false\n├── ENUM: 열거형\n├── JSON: JSON 데이터\n└── BLOB: 바이너리 데이터\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 DDL",
        "content": "### CREATE TABLE 예제\n\n```sql\n-- 회원 테이블\nCREATE TABLE users (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    email VARCHAR(100) NOT NULL UNIQUE,\n    password VARCHAR(255) NOT NULL,\n    name VARCHAR(50) NOT NULL,\n    phone VARCHAR(20),\n    status ENUM('active', 'inactive', 'deleted') DEFAULT 'active',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n\n    INDEX idx_email (email),\n    INDEX idx_status_created (status, created_at)\n);\n\n-- 주문 테이블 (FK 포함)\nCREATE TABLE orders (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    user_id BIGINT NOT NULL,\n    total_price DECIMAL(12,2) NOT NULL,\n    status ENUM('pending', 'paid', 'shipped', 'delivered', 'cancelled') DEFAULT 'pending',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,\n    INDEX idx_user_id (user_id),\n    INDEX idx_status (status)\n);\n```\n\n### ALTER TABLE 예제\n\n```sql\n-- 컬럼 추가\nALTER TABLE users ADD COLUMN birth_date DATE;\n\n-- 컬럼 수정\nALTER TABLE users MODIFY COLUMN phone VARCHAR(30);\n\n-- 컬럼 이름 변경\nALTER TABLE users CHANGE COLUMN phone mobile VARCHAR(30);\n\n-- 컬럼 삭제\nALTER TABLE users DROP COLUMN birth_date;\n\n-- 인덱스 추가\nALTER TABLE users ADD INDEX idx_name (name);\n\n-- 인덱스 삭제\nALTER TABLE users DROP INDEX idx_name;\n\n-- 외래키 추가\nALTER TABLE orders\nADD FOREIGN KEY (user_id) REFERENCES users(id);\n```\n\n### DROP 명령어\n\n```sql\n-- 테이블 삭제 (주의!)\nDROP TABLE users;\n\n-- 테이블 존재하면 삭제\nDROP TABLE IF EXISTS users;\n\n-- 데이터만 삭제 (구조 유지)\nTRUNCATE TABLE logs;\n\n-- 데이터베이스 삭제\nDROP DATABASE test_db;\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### 컬럼 타입 선택 가이드\n\n```\nID → BIGINT (INT 한계 21억)\n금액 → DECIMAL (절대 FLOAT 사용 금지)\n상태 → ENUM 또는 VARCHAR\n날짜 → TIMESTAMP (UTC 자동 변환)\n긴 텍스트 → TEXT\n짧은 텍스트 → VARCHAR\n```\n\n### DDL 실행 주의사항\n\n```\n⚠️ 프로덕션 DDL은 위험!\n├── 락 발생 가능\n├── 대용량 테이블은 시간 오래 걸림\n└── 서비스 영향 가능\n\n✅ 안전한 방법\n├── 점검 시간에 실행\n├── pt-online-schema-change 사용\n└── 테스트 환경에서 먼저 검증\n```\n\n### 마이그레이션 도구 활용\n\n```\nFlask: Flask-Migrate (Alembic)\nDjango: Django Migrations\nNode.js: Knex, Prisma\nJava: Flyway, Liquibase\n\n→ DDL 직접 실행보다 마이그레이션 도구 사용 권장\n```"
      }
    ]
  },
  "02_SQL/dml-insert": {
    "id": "02_SQL/dml-insert",
    "title": "INSERT 완벽 가이드",
    "category": "db",
    "subCategory": "02_SQL",
    "language": "SQL",
    "description": "데이터 삽입의 모든 것을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 INSERT 마스터하기",
        "content": "## 🔥 한 줄 요약\n> **테이블에 새 데이터 추가** - 회원가입, 주문생성 등 모든 '생성' 작업\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 실무 필수:\n```\n회원가입 → INSERT INTO users\n상품등록 → INSERT INTO products\n주문생성 → INSERT INTO orders\n로그기록 → INSERT INTO logs\n\n→ INSERT 모르면 데이터 생성 불가\n```\n\n---\n\n## 🎯 핵심 문법\n\n### 기본 구조\n\n```sql\n-- 1. 컬럼 명시 (권장)\nINSERT INTO table_name (col1, col2, col3)\nVALUES (val1, val2, val3);\n\n-- 2. 컬럼 생략 (비권장)\nINSERT INTO table_name\nVALUES (val1, val2, val3);  -- 모든 컬럼 순서대로\n\n-- 3. 다중 삽입\nINSERT INTO table_name (col1, col2)\nVALUES\n    (val1, val2),\n    (val3, val4),\n    (val5, val6);\n```\n\n### INSERT 옵션들\n\n```sql\n-- 1. INSERT IGNORE: 에러 무시\nINSERT IGNORE INTO users (email, name)\nVALUES ('duplicate@test.com', '김철수');\n-- 중복 시 에러 대신 무시\n\n-- 2. ON DUPLICATE KEY UPDATE: 중복 시 업데이트\nINSERT INTO users (email, name, login_count)\nVALUES ('kim@test.com', '김철수', 1)\nON DUPLICATE KEY UPDATE\n    login_count = login_count + 1;\n\n-- 3. REPLACE: 중복 시 삭제 후 삽입\nREPLACE INTO users (email, name)\nVALUES ('kim@test.com', '김철수');\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 INSERT",
        "content": "### 기본 삽입\n\n```sql\n-- 단일 삽입\nINSERT INTO users (email, name, age)\nVALUES ('kim@test.com', '김철수', 25);\n\n-- 다중 삽입 (훨씬 빠름!)\nINSERT INTO users (email, name, age) VALUES\n    ('lee@test.com', '이영희', 30),\n    ('park@test.com', '박민수', 22),\n    ('choi@test.com', '최지원', 28);\n```\n\n### SELECT로 삽입\n\n```sql\n-- 다른 테이블에서 복사\nINSERT INTO users_backup (email, name, age)\nSELECT email, name, age\nFROM users\nWHERE created_at < '2024-01-01';\n\n-- 집계 결과 삽입\nINSERT INTO daily_stats (date, total_orders, total_revenue)\nSELECT\n    CURDATE(),\n    COUNT(*),\n    SUM(total_price)\nFROM orders\nWHERE DATE(created_at) = CURDATE();\n```\n\n### 자동 생성 값 처리\n\n```sql\n-- AUTO_INCREMENT ID 얻기\nINSERT INTO orders (user_id, total_price)\nVALUES (1, 50000);\n\nSELECT LAST_INSERT_ID();  -- 방금 생성된 ID\n\n-- Python에서\ncursor.execute(\"INSERT INTO orders ...\")\norder_id = cursor.lastrowid\n```\n\n### 트랜잭션과 함께\n\n```sql\nSTART TRANSACTION;\n\nINSERT INTO orders (user_id, total_price)\nVALUES (1, 50000);\n\nSET @order_id = LAST_INSERT_ID();\n\nINSERT INTO order_items (order_id, product_id, quantity)\nVALUES (@order_id, 100, 2);\n\nCOMMIT;\n```"
      },
      {
        "type": "common-mistake",
        "title": "⚠️ 흔한 실수",
        "content": "### 1. 컬럼 순서 불일치\n\n```sql\n-- ❌ 컬럼 개수/순서 불일치\nINSERT INTO users (name, email, age)\nVALUES ('kim@test.com', '김철수');\n-- Error: Column count doesn't match\n\n-- ✅ 정확히 매칭\nINSERT INTO users (email, name, age)\nVALUES ('kim@test.com', '김철수', 25);\n```\n\n### 2. 문자열 이스케이프\n\n```sql\n-- ❌ 작은따옴표 오류\nINSERT INTO products (name) VALUES ('Kim's Shop');\n\n-- ✅ 이스케이프\nINSERT INTO products (name) VALUES ('Kim''s Shop');\n-- 또는\nINSERT INTO products (name) VALUES (\"Kim's Shop\");\n```\n\n### 3. 대량 삽입 시 성능\n\n```sql\n-- ❌ 느림: 건건이 INSERT\nfor item in items:\n    INSERT INTO table VALUES (item);\n\n-- ✅ 빠름: 배치 INSERT (1000건씩)\nINSERT INTO table VALUES\n    (item1), (item2), ... (item1000);\n```"
      }
    ]
  },
  "02_SQL/dml-select": {
    "id": "02_SQL/dml-select",
    "title": "SELECT 완벽 가이드",
    "category": "db",
    "subCategory": "02_SQL",
    "language": "SQL",
    "description": "데이터 조회의 모든 것을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 SELECT 마스터하기",
        "content": "## 🔥 한 줄 요약\n> **DB에서 원하는 데이터만 뽑아오기** - SQL의 80%는 SELECT\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 실무 현실:\n```\n📊 기획자: \"어제 가입한 유저 중 결제한 사람 뽑아주세요\"\n📈 마케터: \"30대 여성 중 최근 3개월 미접속자 리스트요\"\n🔧 개발자: 버그 추적하려면 데이터 조회 필수\n\n→ SELECT 못하면 일 못함\n```\n\n---\n\n## 🎯 핵심 문법\n\n### 기본 구조\n\n```sql\nSELECT [DISTINCT] column1, column2, ...\nFROM table_name\n[WHERE condition]\n[GROUP BY column]\n[HAVING condition]\n[ORDER BY column [ASC|DESC]]\n[LIMIT number];\n```\n\n### 실행 순서 (중요!)\n\n```\nFROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT\n\n1️⃣ FROM: 어느 테이블?\n2️⃣ WHERE: 어떤 조건?\n3️⃣ GROUP BY: 어떻게 묶을까?\n4️⃣ HAVING: 그룹 조건\n5️⃣ SELECT: 뭘 출력할까?\n6️⃣ ORDER BY: 어떻게 정렬?\n7️⃣ LIMIT: 몇 개까지?\n```\n\n### WHERE 조건 연산자\n\n```sql\n-- 비교 연산자\n=, <>, !=, <, >, <=, >=\n\n-- 범위\nBETWEEN 10 AND 20\n\n-- 목록\nIN ('A', 'B', 'C')\n\n-- 패턴 매칭\nLIKE 'kim%'      -- kim으로 시작\nLIKE '%@gmail%'  -- @gmail 포함\nLIKE '___'       -- 정확히 3글자\n\n-- NULL 체크\nIS NULL, IS NOT NULL\n\n-- 논리 연산\nAND, OR, NOT\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 SELECT",
        "content": "### 조건 조합\n\n```sql\n-- AND, OR 조합\nSELECT * FROM users\nWHERE age >= 20\n  AND age <= 30\n  AND status = 'active';\n\n-- BETWEEN 사용\nSELECT * FROM users\nWHERE age BETWEEN 20 AND 30;\n\n-- IN 사용\nSELECT * FROM products\nWHERE category IN ('전자기기', '의류', '식품');\n\n-- LIKE 패턴\nSELECT * FROM users\nWHERE email LIKE '%@gmail.com';\n```\n\n### 정렬과 제한\n\n```sql\n-- 단일 정렬\nSELECT * FROM products ORDER BY price DESC;\n\n-- 다중 정렬\nSELECT * FROM products\nORDER BY category ASC, price DESC;\n\n-- 페이징 (OFFSET)\nSELECT * FROM products\nORDER BY id\nLIMIT 10 OFFSET 20;  -- 21번째부터 10개\n```\n\n### 집계 함수\n\n```sql\n-- 기본 집계\nSELECT\n    COUNT(*) AS 총개수,\n    SUM(price) AS 총합,\n    AVG(price) AS 평균,\n    MAX(price) AS 최대값,\n    MIN(price) AS 최소값\nFROM products;\n\n-- GROUP BY와 함께\nSELECT\n    category,\n    COUNT(*) AS 상품수,\n    AVG(price) AS 평균가격\nFROM products\nGROUP BY category\nHAVING COUNT(*) >= 5;\n```\n\n### 별칭(Alias) 사용\n\n```sql\n-- 컬럼 별칭\nSELECT\n    name AS 상품명,\n    price AS 가격,\n    price * 0.1 AS 부가세\nFROM products;\n\n-- 테이블 별칭\nSELECT u.name, o.total_price\nFROM users u\nJOIN orders o ON u.id = o.user_id;\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### SELECT 성능 팁\n\n```sql\n-- ❌ 느림: SELECT *\nSELECT * FROM users;\n\n-- ✅ 빠름: 필요한 컬럼만\nSELECT id, name, email FROM users;\n\n-- ❌ 느림: LIKE '%keyword%'\nSELECT * FROM products WHERE name LIKE '%아이폰%';\n\n-- ✅ 빠름: LIKE 'keyword%' (앞부분 고정)\nSELECT * FROM products WHERE name LIKE '아이폰%';\n\n-- ❌ 느림: 함수로 컬럼 감싸기\nSELECT * FROM users WHERE YEAR(created_at) = 2024;\n\n-- ✅ 빠름: 범위 조건\nSELECT * FROM users\nWHERE created_at >= '2024-01-01'\n  AND created_at < '2025-01-01';\n```\n\n### 디버깅 순서\n\n```\n1. SELECT * 로 전체 확인\n2. WHERE 조건 하나씩 추가\n3. 원하는 결과 나오면 컬럼 정리\n4. EXPLAIN으로 성능 확인\n```"
      }
    ]
  },
  "02_SQL/group-by": {
    "id": "02_SQL/group-by",
    "title": "GROUP BY 완벽 가이드",
    "category": "db",
    "subCategory": "02_SQL",
    "language": "SQL",
    "description": "데이터 그룹화와 집계를 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 GROUP BY란?",
        "content": "## 🔥 한 줄 요약\n> **같은 값끼리 묶어서 집계** - \"카테고리별 매출\", \"월별 가입자\"\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 실무 필수:\n```\n📊 \"이번 달 일별 매출 보여줘\"\n📈 \"카테고리별 상품 개수는?\"\n👥 \"지역별 회원 수 통계\"\n\n→ GROUP BY 없이는 리포트 불가능\n```\n\n---\n\n## 🎯 핵심 개념\n\n### 기본 문법\n\n```sql\nSELECT column1, AGG_FUNC(column2)\nFROM table\nWHERE condition\nGROUP BY column1\nHAVING agg_condition\nORDER BY column1;\n```\n\n### 집계 함수\n\n```sql\nCOUNT(*)      -- 행 개수\nCOUNT(column) -- NULL 제외 개수\nSUM(column)   -- 합계\nAVG(column)   -- 평균\nMAX(column)   -- 최대값\nMIN(column)   -- 최소값\nGROUP_CONCAT(column) -- 문자열 연결 (MySQL)\n```\n\n### 실행 순서\n\n```\nFROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY\n\n1️⃣ FROM: 테이블 선택\n2️⃣ WHERE: 그룹화 전 필터링\n3️⃣ GROUP BY: 그룹화\n4️⃣ HAVING: 그룹화 후 필터링\n5️⃣ SELECT: 출력\n6️⃣ ORDER BY: 정렬\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 GROUP BY",
        "content": "### 기본 집계\n\n```sql\n-- 카테고리별 상품 수\nSELECT category, COUNT(*) AS product_count\nFROM products\nGROUP BY category;\n\n-- 결과:\n-- 전자기기 | 150\n-- 의류     | 230\n-- 식품     | 80\n\n-- 카테고리별 평균 가격\nSELECT\n    category,\n    COUNT(*) AS cnt,\n    AVG(price) AS avg_price,\n    MAX(price) AS max_price,\n    MIN(price) AS min_price\nFROM products\nGROUP BY category;\n```\n\n### 날짜별 집계\n\n```sql\n-- 일별 주문 통계\nSELECT\n    DATE(created_at) AS order_date,\n    COUNT(*) AS order_count,\n    SUM(total_price) AS daily_revenue\nFROM orders\nWHERE created_at >= '2024-01-01'\nGROUP BY DATE(created_at)\nORDER BY order_date;\n\n-- 월별 가입자 수\nSELECT\n    DATE_FORMAT(created_at, '%Y-%m') AS month,\n    COUNT(*) AS new_users\nFROM users\nGROUP BY DATE_FORMAT(created_at, '%Y-%m')\nORDER BY month;\n```\n\n### 다중 컬럼 GROUP BY\n\n```sql\n-- 카테고리 + 상태별 집계\nSELECT\n    category,\n    status,\n    COUNT(*) AS cnt\nFROM products\nGROUP BY category, status\nORDER BY category, status;\n\n-- 결과:\n-- 전자기기 | active   | 100\n-- 전자기기 | inactive | 50\n-- 의류     | active   | 200\n```\n\n### HAVING으로 그룹 필터링\n\n```sql\n-- 주문 5회 이상인 고객\nSELECT\n    user_id,\n    COUNT(*) AS order_count,\n    SUM(total_price) AS total_spent\nFROM orders\nGROUP BY user_id\nHAVING COUNT(*) >= 5\nORDER BY total_spent DESC;\n\n-- 평균 가격 10만원 이상인 카테고리\nSELECT\n    category,\n    AVG(price) AS avg_price\nFROM products\nGROUP BY category\nHAVING AVG(price) >= 100000;\n```"
      },
      {
        "type": "common-mistake",
        "title": "⚠️ 흔한 실수",
        "content": "### 1. SELECT에 비집계 컬럼\n\n```sql\n-- ❌ 에러: name이 GROUP BY에 없음\nSELECT user_id, name, COUNT(*)\nFROM orders\nGROUP BY user_id;\n\n-- ✅ GROUP BY에 포함하거나\nSELECT user_id, name, COUNT(*)\nFROM orders\nGROUP BY user_id, name;\n\n-- ✅ 집계 함수 사용\nSELECT user_id, MAX(name), COUNT(*)\nFROM orders\nGROUP BY user_id;\n```\n\n### 2. WHERE vs HAVING\n\n```sql\n-- ❌ WHERE에서 집계 함수 사용 불가\nSELECT user_id, COUNT(*)\nFROM orders\nWHERE COUNT(*) >= 5  -- 에러!\nGROUP BY user_id;\n\n-- ✅ HAVING 사용\nSELECT user_id, COUNT(*)\nFROM orders\nGROUP BY user_id\nHAVING COUNT(*) >= 5;\n```\n\n### 3. 집계 전후 필터링 혼동\n\n```sql\n-- WHERE: 그룹화 전 필터링 (개별 행)\n-- HAVING: 그룹화 후 필터링 (그룹)\n\nSELECT category, COUNT(*)\nFROM products\nWHERE price > 10000      -- 1만원 이상 상품만 대상\nGROUP BY category\nHAVING COUNT(*) >= 10;   -- 그 중 10개 이상인 카테고리만\n```"
      }
    ]
  },
  "02_SQL/insert-update-delete": {
    "id": "02_SQL/insert-update-delete",
    "title": "UPDATE/DELETE 완벽 가이드",
    "category": "db",
    "subCategory": "02_SQL",
    "language": "SQL",
    "description": "데이터 수정과 삭제를 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 UPDATE와 DELETE",
        "content": "## 🔥 한 줄 요약\n> **UPDATE = 수정, DELETE = 삭제** - 가장 위험한 SQL!\n\n---\n\n## 💡 왜 위험한가?\n\n### 실제 사고:\n```\n🔴 2017년 GitLab 사고\n- 실수로 프로덕션 DB DELETE\n- 300GB 데이터 손실\n- 18시간 서비스 중단\n\n🔴 2023년 모 스타트업\n- WHERE 없이 UPDATE 실행\n- 전체 회원 비밀번호 초기화\n- 10만 명 로그인 불가\n```\n\n---\n\n## 🎯 핵심 문법\n\n### UPDATE 기본\n\n```sql\nUPDATE table_name\nSET column1 = value1, column2 = value2\nWHERE condition;\n\n-- ⚠️ WHERE 없으면 전체 수정!\n```\n\n### DELETE 기본\n\n```sql\nDELETE FROM table_name\nWHERE condition;\n\n-- ⚠️ WHERE 없으면 전체 삭제!\n```\n\n### 안전한 실행 순서\n\n```sql\n-- 1단계: SELECT로 대상 확인\nSELECT * FROM users WHERE status = 'inactive';\n-- 결과: 100건 확인\n\n-- 2단계: 트랜잭션 시작\nSTART TRANSACTION;\n\n-- 3단계: UPDATE/DELETE 실행\nDELETE FROM users WHERE status = 'inactive';\n\n-- 4단계: 결과 확인\nSELECT * FROM users WHERE status = 'inactive';\n-- 결과: 0건 확인 (정상)\n\n-- 5단계: 확정 또는 취소\nCOMMIT;    -- 확정\n-- ROLLBACK;  -- 취소\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 UPDATE/DELETE",
        "content": "### UPDATE 예제\n\n```sql\n-- 단일 컬럼 수정\nUPDATE users\nSET status = 'inactive'\nWHERE last_login < '2024-01-01';\n\n-- 다중 컬럼 수정\nUPDATE products\nSET\n    price = price * 1.1,  -- 10% 인상\n    updated_at = NOW()\nWHERE category = '전자기기';\n\n-- CASE 문으로 조건별 수정\nUPDATE users\nSET membership = CASE\n    WHEN total_purchase >= 1000000 THEN 'VIP'\n    WHEN total_purchase >= 500000 THEN 'Gold'\n    ELSE 'Normal'\nEND;\n\n-- JOIN UPDATE\nUPDATE orders o\nJOIN users u ON o.user_id = u.id\nSET o.shipping_address = u.default_address\nWHERE o.shipping_address IS NULL;\n```\n\n### DELETE 예제\n\n```sql\n-- 조건 삭제\nDELETE FROM logs\nWHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY);\n\n-- LIMIT으로 안전하게\nDELETE FROM old_data\nWHERE created_at < '2020-01-01'\nLIMIT 10000;  -- 1만건씩 삭제\n\n-- JOIN DELETE\nDELETE o\nFROM orders o\nJOIN users u ON o.user_id = u.id\nWHERE u.status = 'deleted';\n```\n\n### Soft Delete (권장)\n\n```sql\n-- ❌ 물리 삭제 (복구 불가)\nDELETE FROM users WHERE id = 1;\n\n-- ✅ 논리 삭제 (복구 가능)\nUPDATE users\nSET\n    deleted_at = NOW(),\n    status = 'deleted'\nWHERE id = 1;\n\n-- 조회 시 삭제된 데이터 제외\nSELECT * FROM users WHERE deleted_at IS NULL;\n```"
      },
      {
        "type": "tip",
        "title": "💡 안전 수칙",
        "content": "### UPDATE/DELETE 체크리스트\n\n```\n□ WHERE 절 있는지 확인\n□ SELECT로 대상 먼저 확인\n□ 트랜잭션 사용\n□ 백업 확인\n□ 실행 전 동료 검토 (프로덕션)\n```\n\n### MySQL Safe Mode\n\n```sql\n-- Safe Mode 활성화\nSET SQL_SAFE_UPDATES = 1;\n\n-- 이제 WHERE 없이 실행 불가\nUPDATE users SET status = 'inactive';\n-- Error: You are using safe update mode\n\n-- KEY 조건 필수\nUPDATE users SET status = 'inactive' WHERE id = 1;\n-- OK\n```\n\n### 실무 규칙\n\n```\n1. 프로덕션 직접 수정 금지\n2. 스테이징에서 먼저 테스트\n3. DBA 또는 시니어 검토 후 실행\n4. 실행 로그 남기기\n5. 롤백 스크립트 준비\n```"
      }
    ]
  },
  "02_SQL/sql-intro": {
    "id": "02_SQL/sql-intro",
    "title": "SQL 기초",
    "category": "db",
    "subCategory": "02_SQL",
    "language": "SQL",
    "description": "SQL 언어의 기본 문법을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 SQL이란?",
        "content": "## 🔥 한 줄 요약\n> **데이터베이스와 대화하는 언어** - \"DB야, 이 데이터 줘!\"\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 취업 필수:\n- 백엔드 개발자 공고 **100%**: SQL 필수\n- 데이터 분석가 공고 **100%**: SQL 필수\n- PM/기획자도 SQL 알면 연봉 UP\n\n### 현실 예시:\n```\n📊 \"이번 달 매출 얼마야?\"\n→ SELECT SUM(price) FROM orders WHERE created_at >= '2024-01-01'\n→ 0.001초 만에 답변!\n\n📈 \"VIP 고객 100명 뽑아줘\"\n→ SELECT * FROM users ORDER BY total_purchase DESC LIMIT 100\n```\n\n---\n\n## 🎯 핵심 개념\n\n### SQL 종류\n\n```\n📝 DDL (Data Definition Language) - 구조 정의\n├── CREATE: 생성\n├── ALTER: 수정\n├── DROP: 삭제\n└── TRUNCATE: 데이터 전체 삭제\n\n📝 DML (Data Manipulation Language) - 데이터 조작\n├── SELECT: 조회\n├── INSERT: 삽입\n├── UPDATE: 수정\n└── DELETE: 삭제\n\n📝 DCL (Data Control Language) - 권한 제어\n├── GRANT: 권한 부여\n└── REVOKE: 권한 회수\n\n📝 TCL (Transaction Control Language)\n├── COMMIT: 확정\n├── ROLLBACK: 취소\n└── SAVEPOINT: 저장점\n```\n\n### SELECT 문법 순서\n\n```sql\nSELECT column_name    -- 5. 출력할 컬럼\nFROM table_name       -- 1. 테이블 선택\nWHERE condition       -- 2. 조건 필터링\nGROUP BY column       -- 3. 그룹화\nHAVING condition      -- 4. 그룹 필터링\nORDER BY column       -- 6. 정렬\nLIMIT n               -- 7. 개수 제한\n```"
      },
      {
        "type": "code",
        "title": "💻 기본 SQL 문법",
        "content": "### SELECT (조회)\n\n```sql\n-- 전체 조회\nSELECT * FROM users;\n\n-- 특정 컬럼 조회\nSELECT name, email FROM users;\n\n-- 조건 조회\nSELECT * FROM users WHERE age >= 20;\n\n-- 정렬\nSELECT * FROM users ORDER BY created_at DESC;\n\n-- 개수 제한\nSELECT * FROM users LIMIT 10;\n\n-- 중복 제거\nSELECT DISTINCT category FROM products;\n```\n\n### INSERT (삽입)\n\n```sql\n-- 단일 삽입\nINSERT INTO users (name, email, age)\nVALUES ('김철수', 'kim@test.com', 25);\n\n-- 다중 삽입\nINSERT INTO users (name, email, age) VALUES\n('이영희', 'lee@test.com', 30),\n('박민수', 'park@test.com', 22);\n```\n\n### UPDATE (수정)\n\n```sql\n-- 특정 행 수정\nUPDATE users SET age = 26 WHERE id = 1;\n\n-- 여러 컬럼 수정\nUPDATE users SET age = 26, name = '김철수2' WHERE id = 1;\n\n-- ⚠️ WHERE 없으면 전체 수정!\nUPDATE users SET age = 26;  -- 위험!\n```\n\n### DELETE (삭제)\n\n```sql\n-- 특정 행 삭제\nDELETE FROM users WHERE id = 1;\n\n-- ⚠️ WHERE 없으면 전체 삭제!\nDELETE FROM users;  -- 위험!\n```"
      },
      {
        "type": "common-mistake",
        "title": "⚠️ 흔한 실수",
        "content": "### 1. WHERE 없는 UPDATE/DELETE\n\n```sql\n-- 💀 전 직원 월급이 0원이 되는 사고\nUPDATE employees SET salary = 0;\n\n-- ✅ 항상 WHERE 먼저 확인\nSELECT * FROM employees WHERE id = 1;  -- 먼저 확인\nUPDATE employees SET salary = 0 WHERE id = 1;\n```\n\n### 2. 작은따옴표 vs 큰따옴표\n\n```sql\n-- ❌ 큰따옴표 (DB마다 다름)\nSELECT * FROM users WHERE name = \"김철수\";\n\n-- ✅ 작은따옴표 (표준)\nSELECT * FROM users WHERE name = '김철수';\n```\n\n### 3. NULL 비교\n\n```sql\n-- ❌ = NULL은 항상 FALSE\nSELECT * FROM users WHERE phone = NULL;\n\n-- ✅ IS NULL 사용\nSELECT * FROM users WHERE phone IS NULL;\nSELECT * FROM users WHERE phone IS NOT NULL;\n```"
      }
    ]
  },
  "02_SQL/string-function": {
    "id": "02_SQL/string-function",
    "title": "문자열 함수",
    "category": "db",
    "subCategory": "02_SQL",
    "language": "SQL",
    "description": "SQL에서 문자열을 다루는 함수들을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 문자열 함수 총정리",
        "content": "## 🔥 한 줄 요약\n> **문자열 조작의 모든 것** - 자르고, 붙이고, 변환하고\n\n---\n\n## 🎯 주요 함수\n\n### 길이 / 변환\n\n```sql\nLENGTH(str)      -- 바이트 길이\nCHAR_LENGTH(str) -- 문자 길이 (한글도 1)\nUPPER(str)       -- 대문자로\nLOWER(str)       -- 소문자로\n```\n\n### 추출 / 자르기\n\n```sql\nLEFT(str, n)     -- 왼쪽에서 n자\nRIGHT(str, n)    -- 오른쪽에서 n자\nSUBSTRING(str, start, length)  -- 부분 문자열\nTRIM(str)        -- 양쪽 공백 제거\nLTRIM(str)       -- 왼쪽 공백 제거\nRTRIM(str)       -- 오른쪽 공백 제거\n```\n\n### 연결 / 치환\n\n```sql\nCONCAT(str1, str2, ...)  -- 문자열 연결\nCONCAT_WS(sep, str1, str2, ...) -- 구분자로 연결\nREPLACE(str, from, to)   -- 문자열 치환\n```\n\n### 검색 / 포맷\n\n```sql\nLOCATE(substr, str)  -- 위치 찾기 (1부터)\nINSTR(str, substr)   -- 위치 찾기\nLPAD(str, len, pad)  -- 왼쪽 채우기\nRPAD(str, len, pad)  -- 오른쪽 채우기\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 문자열 함수",
        "content": "### 기본 사용\n\n```sql\n-- 이름 처리\nSELECT\n    name,\n    UPPER(name) AS upper_name,\n    LOWER(name) AS lower_name,\n    CHAR_LENGTH(name) AS name_length\nFROM users;\n\n-- 이메일에서 도메인 추출\nSELECT\n    email,\n    SUBSTRING(email, LOCATE('@', email) + 1) AS domain\nFROM users;\n-- kim@gmail.com → gmail.com\n\n-- 전화번호 포맷팅\nSELECT\n    phone,\n    CONCAT(\n        LEFT(phone, 3), '-',\n        SUBSTRING(phone, 4, 4), '-',\n        RIGHT(phone, 4)\n    ) AS formatted_phone\nFROM users;\n-- 01012345678 → 010-1234-5678\n```\n\n### 데이터 정제\n\n```sql\n-- 공백 제거\nSELECT TRIM(name) FROM users;\n\n-- 특수문자 제거\nSELECT REPLACE(REPLACE(phone, '-', ''), ' ', '')\nFROM users;\n\n-- 마스킹 처리\nSELECT\n    name,\n    CONCAT(LEFT(email, 3), '****@',\n           SUBSTRING(email, LOCATE('@', email) + 1)) AS masked_email\nFROM users;\n-- kim@gmail.com → kim****@gmail.com\n\n-- 주민번호 마스킹\nSELECT CONCAT(LEFT(ssn, 6), '-*******') AS masked_ssn\nFROM users;\n-- 900101-1234567 → 900101-*******\n```\n\n### 검색과 조건\n\n```sql\n-- 특정 문자 포함 여부\nSELECT * FROM users\nWHERE LOCATE('@gmail', email) > 0;\n\n-- 특정 패턴으로 시작\nSELECT * FROM users\nWHERE LEFT(phone, 3) = '010';\n\n-- 이름 검색 (대소문자 무시)\nSELECT * FROM products\nWHERE LOWER(name) LIKE LOWER('%iphone%');\n```\n\n### 숫자 포맷\n\n```sql\n-- 천단위 콤마\nSELECT FORMAT(price, 0) AS formatted_price\nFROM products;\n-- 1234567 → 1,234,567\n\n-- 금액 표시\nSELECT CONCAT('₩', FORMAT(price, 0)) AS price_display\nFROM products;\n-- 50000 → ₩50,000\n\n-- 자릿수 맞추기\nSELECT LPAD(id, 6, '0') AS order_number\nFROM orders;\n-- 123 → 000123\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### 인덱스와 함수\n\n```sql\n-- ❌ 인덱스 못 씀\nWHERE LOWER(email) = 'test@test.com'\nWHERE LEFT(phone, 3) = '010'\n\n-- ✅ 인덱스 사용\nWHERE email = 'test@test.com'\nWHERE phone LIKE '010%'\n```\n\n### CONCAT NULL 주의\n\n```sql\n-- NULL이 있으면 전체가 NULL\nSELECT CONCAT('Hello', NULL, 'World');\n-- 결과: NULL\n\n-- CONCAT_WS는 NULL 무시\nSELECT CONCAT_WS(' ', 'Hello', NULL, 'World');\n-- 결과: Hello World\n\n-- COALESCE로 NULL 처리\nSELECT CONCAT(first_name, ' ', COALESCE(middle_name, ''), last_name);\n```\n\n### DB별 차이\n\n```\nMySQL: CONCAT, SUBSTRING\nPostgreSQL: ||로 연결, SUBSTRING\nOracle: ||로 연결, SUBSTR\nSQL Server: +로 연결, SUBSTRING\n```"
      }
    ]
  },
  "02_SQL/subquery": {
    "id": "02_SQL/subquery",
    "title": "서브쿼리 마스터",
    "category": "db",
    "subCategory": "02_SQL",
    "language": "SQL",
    "description": "쿼리 안의 쿼리, 서브쿼리를 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 서브쿼리란?",
        "content": "## 🔥 한 줄 요약\n> **쿼리 안에 또 다른 쿼리** - 복잡한 조건을 단계별로 해결\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 실무 예시:\n```\n📊 \"평균보다 비싼 상품 목록\"\n→ 평균 가격 구하고 → 그 값보다 큰 것 조회\n→ 서브쿼리 필요!\n\n👥 \"주문한 적 있는 고객만\"\n→ 주문 테이블에서 user_id 목록 → users에서 조회\n→ 서브쿼리 필요!\n```\n\n---\n\n## 🎯 서브쿼리 유형\n\n### 위치에 따른 분류\n\n```sql\n-- 1. SELECT 절 (스칼라 서브쿼리)\nSELECT name,\n       (SELECT AVG(price) FROM products) AS avg_price\nFROM products;\n\n-- 2. FROM 절 (인라인 뷰)\nSELECT * FROM (\n    SELECT user_id, COUNT(*) AS cnt\n    FROM orders\n    GROUP BY user_id\n) AS order_stats\nWHERE cnt >= 5;\n\n-- 3. WHERE 절 (가장 흔함)\nSELECT * FROM products\nWHERE price > (SELECT AVG(price) FROM products);\n```\n\n### 반환값에 따른 분류\n\n```sql\n-- 단일 값 (스칼라)\nWHERE price > (SELECT AVG(price) FROM products)\n\n-- 단일 열 (리스트)\nWHERE user_id IN (SELECT user_id FROM vip_users)\n\n-- 다중 열\nWHERE (user_id, product_id) IN (\n    SELECT user_id, product_id FROM wishlist\n)\n\n-- 테이블 (FROM절)\nFROM (SELECT ...) AS derived_table\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 서브쿼리",
        "content": "### WHERE 절 서브쿼리\n\n```sql\n-- 평균보다 비싼 상품\nSELECT * FROM products\nWHERE price > (SELECT AVG(price) FROM products);\n\n-- 주문한 적 있는 고객\nSELECT * FROM users\nWHERE id IN (SELECT DISTINCT user_id FROM orders);\n\n-- 주문한 적 없는 고객\nSELECT * FROM users\nWHERE id NOT IN (SELECT user_id FROM orders);\n```\n\n### EXISTS / NOT EXISTS\n\n```sql\n-- EXISTS: 존재 여부 확인 (효율적)\nSELECT * FROM users u\nWHERE EXISTS (\n    SELECT 1 FROM orders o\n    WHERE o.user_id = u.id\n);\n\n-- NOT EXISTS\nSELECT * FROM users u\nWHERE NOT EXISTS (\n    SELECT 1 FROM orders o\n    WHERE o.user_id = u.id\n);\n```\n\n### 상관 서브쿼리\n\n```sql\n-- 각 카테고리의 최고가 상품\nSELECT * FROM products p1\nWHERE price = (\n    SELECT MAX(price)\n    FROM products p2\n    WHERE p2.category = p1.category\n);\n\n-- 각 고객의 최근 주문\nSELECT * FROM orders o1\nWHERE created_at = (\n    SELECT MAX(created_at)\n    FROM orders o2\n    WHERE o2.user_id = o1.user_id\n);\n```\n\n### FROM 절 서브쿼리 (Derived Table)\n\n```sql\n-- 주문 5회 이상 고객의 총 매출\nSELECT\n    u.name,\n    stats.order_count,\n    stats.total_spent\nFROM users u\nJOIN (\n    SELECT\n        user_id,\n        COUNT(*) AS order_count,\n        SUM(total_price) AS total_spent\n    FROM orders\n    GROUP BY user_id\n    HAVING COUNT(*) >= 5\n) AS stats ON u.id = stats.user_id;\n```"
      },
      {
        "type": "tip",
        "title": "💡 서브쿼리 vs JOIN",
        "content": "### 언제 무엇을 쓸까?\n\n```sql\n-- 서브쿼리가 나은 경우\n-- 1. 존재 여부만 확인\nWHERE EXISTS (SELECT 1 FROM ...)\n\n-- 2. 집계값과 비교\nWHERE price > (SELECT AVG(price) FROM ...)\n\n-- JOIN이 나은 경우\n-- 1. 여러 테이블 데이터 함께 출력\n-- 2. 대용량 데이터 (보통 더 빠름)\n```\n\n### 성능 비교\n\n```sql\n-- ❌ 느림: IN + 서브쿼리 (대용량)\nSELECT * FROM orders\nWHERE user_id IN (SELECT id FROM users WHERE status = 'vip');\n\n-- ✅ 빠름: JOIN\nSELECT o.* FROM orders o\nJOIN users u ON o.user_id = u.id\nWHERE u.status = 'vip';\n\n-- ✅ EXISTS도 효율적\nSELECT * FROM orders o\nWHERE EXISTS (\n    SELECT 1 FROM users u\n    WHERE u.id = o.user_id AND u.status = 'vip'\n);\n```\n\n### NOT IN 주의!\n\n```sql\n-- ⚠️ NULL이 있으면 결과 없음!\nSELECT * FROM users\nWHERE id NOT IN (SELECT user_id FROM blacklist);\n-- blacklist에 NULL이 있으면 항상 0건\n\n-- ✅ NOT EXISTS 사용\nSELECT * FROM users u\nWHERE NOT EXISTS (\n    SELECT 1 FROM blacklist b WHERE b.user_id = u.id\n);\n```"
      }
    ]
  },
  "02_SQL/where-clause": {
    "id": "02_SQL/where-clause",
    "title": "WHERE 절 마스터",
    "category": "db",
    "subCategory": "02_SQL",
    "language": "SQL",
    "description": "조건 필터링의 모든 것을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 WHERE 절 완벽 정복",
        "content": "## 🔥 한 줄 요약\n> **원하는 데이터만 걸러내는 필터** - SQL의 핵심!\n\n---\n\n## 🎯 연산자 총정리\n\n### 비교 연산자\n\n```sql\n=     같다\n<>    다르다 (또는 !=)\n>     크다\n<     작다\n>=    크거나 같다\n<=    작거나 같다\n```\n\n### 범위 연산자\n\n```sql\n-- BETWEEN: 범위 (양 끝 포함)\nWHERE age BETWEEN 20 AND 30\n-- = WHERE age >= 20 AND age <= 30\n\n-- NOT BETWEEN\nWHERE age NOT BETWEEN 20 AND 30\n```\n\n### 목록 연산자\n\n```sql\n-- IN: 목록 중 하나\nWHERE status IN ('active', 'pending', 'approved')\n\n-- NOT IN\nWHERE status NOT IN ('deleted', 'banned')\n```\n\n### 패턴 연산자\n\n```sql\n-- LIKE: 패턴 매칭\n%   0개 이상의 문자\n_   정확히 1개의 문자\n\nLIKE 'kim%'      -- kim으로 시작\nLIKE '%kim'      -- kim으로 끝\nLIKE '%kim%'     -- kim 포함\nLIKE 'kim_'      -- kim + 1글자\nLIKE '___'       -- 정확히 3글자\n```\n\n### NULL 연산자\n\n```sql\n-- IS NULL: NULL인 것\nWHERE phone IS NULL\n\n-- IS NOT NULL: NULL 아닌 것\nWHERE phone IS NOT NULL\n\n-- ⚠️ = NULL은 항상 FALSE!\nWHERE phone = NULL  -- 작동 안 함!\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 WHERE",
        "content": "### 논리 연산자 조합\n\n```sql\n-- AND: 모든 조건 만족\nSELECT * FROM users\nWHERE age >= 20\n  AND status = 'active'\n  AND email LIKE '%@gmail.com';\n\n-- OR: 하나라도 만족\nSELECT * FROM products\nWHERE category = '전자기기'\n   OR category = '가전제품';\n\n-- NOT: 부정\nSELECT * FROM users\nWHERE NOT (status = 'deleted' OR status = 'banned');\n\n-- 복합 조건 (괄호 중요!)\nSELECT * FROM orders\nWHERE (status = 'pending' OR status = 'processing')\n  AND total_price > 50000\n  AND created_at >= '2024-01-01';\n```\n\n### 날짜 조건\n\n```sql\n-- 특정 날짜\nWHERE DATE(created_at) = '2024-01-15'\n\n-- 날짜 범위\nWHERE created_at >= '2024-01-01'\n  AND created_at < '2024-02-01'\n\n-- 최근 7일\nWHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)\n\n-- 이번 달\nWHERE YEAR(created_at) = YEAR(NOW())\n  AND MONTH(created_at) = MONTH(NOW())\n```\n\n### 서브쿼리와 함께\n\n```sql\n-- IN + 서브쿼리\nSELECT * FROM users\nWHERE id IN (\n    SELECT user_id FROM orders\n    WHERE total_price > 100000\n);\n\n-- EXISTS\nSELECT * FROM users u\nWHERE EXISTS (\n    SELECT 1 FROM orders o\n    WHERE o.user_id = u.id\n);\n```"
      },
      {
        "type": "tip",
        "title": "💡 성능 팁",
        "content": "### 인덱스를 타는 조건\n\n```sql\n-- ✅ 인덱스 사용\nWHERE id = 1\nWHERE email = 'test@test.com'\nWHERE created_at >= '2024-01-01'\nWHERE name LIKE 'kim%'\n\n-- ❌ 인덱스 못 씀\nWHERE YEAR(created_at) = 2024  -- 함수 사용\nWHERE name LIKE '%kim%'         -- 앞에 %\nWHERE age + 1 = 25              -- 연산\nWHERE UPPER(email) = 'TEST'     -- 함수 사용\n```\n\n### OR vs IN\n\n```sql\n-- ❌ 느림\nWHERE status = 'a' OR status = 'b' OR status = 'c'\n\n-- ✅ 빠름\nWHERE status IN ('a', 'b', 'c')\n```\n\n### NOT IN 주의\n\n```sql\n-- ⚠️ NULL이 포함되면 결과 없음!\nSELECT * FROM users\nWHERE id NOT IN (1, 2, NULL);  -- 항상 0건!\n\n-- ✅ NOT EXISTS 사용\nSELECT * FROM users u\nWHERE NOT EXISTS (\n    SELECT 1 FROM blacklist b\n    WHERE b.user_id = u.id\n);\n```"
      }
    ]
  },
  "03_JOIN/cross-join": {
    "id": "03_JOIN/cross-join",
    "title": "CROSS JOIN",
    "category": "db",
    "subCategory": "03_JOIN",
    "language": "C",
    "description": "모든 조합을 생성하는 CROSS JOIN을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 CROSS JOIN",
        "content": "## 🔥 한 줄 요약\n> **모든 조합 생성** - 곱집합 (Cartesian Product)\n\n---\n\n## 💡 언제 쓸까?\n\n```\n✅ CROSS JOIN 사용\n├── 색상 × 사이즈 조합 생성\n├── 날짜 × 카테고리 조합\n├── 테스트 데이터 생성\n└── 매트릭스 구조 필요 시\n\n⚠️ 주의\n├── 결과 행 수 = A 행수 × B 행수\n├── 1000 × 1000 = 100만 행!\n└── 메모리 폭발 주의\n```\n\n---\n\n## 🎯 시각화\n\n```\ncolors (3행)        sizes (4행)\n┌────────┐         ┌────────┐\n│ Red    │         │ S      │\n│ Blue   │    ×    │ M      │\n│ Green  │         │ L      │\n└────────┘         │ XL     │\n                   └────────┘\n                      ↓\nCROSS JOIN = 3 × 4 = 12행\nRed-S, Red-M, Red-L, Red-XL\nBlue-S, Blue-M, Blue-L, Blue-XL\nGreen-S, Green-M, Green-L, Green-XL\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 CROSS JOIN",
        "content": "### 기본 사용\n\n```sql\n-- 색상 × 사이즈 조합\nSELECT\n    c.name AS color,\n    s.name AS size\nFROM colors c\nCROSS JOIN sizes s;\n\n-- 암시적 CROSS JOIN (동일)\nSELECT c.name, s.name\nFROM colors c, sizes s;\n```\n\n### 실전 예제: 날짜별 카테고리 매출 (0 포함)\n\n```sql\n-- 1. 날짜 테이블 생성\nWITH dates AS (\n    SELECT DATE_ADD('2024-01-01', INTERVAL n DAY) AS date\n    FROM (SELECT 0 n UNION SELECT 1 UNION SELECT 2 UNION SELECT 3) numbers\n),\ncategories AS (\n    SELECT DISTINCT category FROM products\n)\n\n-- 2. CROSS JOIN으로 모든 조합 생성\nSELECT\n    d.date,\n    c.category,\n    COALESCE(SUM(o.total_price), 0) AS revenue\nFROM dates d\nCROSS JOIN categories c\nLEFT JOIN orders o ON DATE(o.created_at) = d.date\n    AND o.category = c.category\nGROUP BY d.date, c.category;\n\n-- 결과: 날짜 × 카테고리 조합 (매출 없으면 0)\n```\n\n### 테스트 데이터 생성\n\n```sql\n-- 1~100 숫자 생성\nWITH RECURSIVE numbers AS (\n    SELECT 1 AS n\n    UNION ALL\n    SELECT n + 1 FROM numbers WHERE n < 100\n)\nSELECT n FROM numbers;\n\n-- 10명 유저 × 100개 상품 조합 생성\nINSERT INTO test_orders (user_id, product_id)\nSELECT u.id, p.id\nFROM (SELECT id FROM users LIMIT 10) u\nCROSS JOIN (SELECT id FROM products LIMIT 100) p;\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### 실수 방지\n\n```sql\n-- ❌ 실수로 CROSS JOIN\nSELECT * FROM orders, users;  -- 위험!\n-- 100만 주문 × 10만 유저 = 1000억 행\n\n-- ✅ 명시적 JOIN\nSELECT * FROM orders o\nJOIN users u ON o.user_id = u.id;\n```\n\n### CROSS JOIN 대안\n\n```sql\n-- 적은 조합이면 VALUES 사용\nSELECT * FROM (\n    VALUES ('S'), ('M'), ('L'), ('XL')\n) AS sizes(name);\n\n-- 또는 UNION\nSELECT 'S' AS size\nUNION SELECT 'M'\nUNION SELECT 'L';\n```"
      }
    ]
  },
  "03_JOIN/full-outer-join": {
    "id": "03_JOIN/full-outer-join",
    "title": "FULL OUTER JOIN",
    "category": "db",
    "subCategory": "03_JOIN",
    "language": "SQL",
    "description": "양쪽 테이블 전체를 조회하는 FULL OUTER JOIN을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 FULL OUTER JOIN",
        "content": "## 🔥 한 줄 요약\n> **양쪽 테이블 전체 조회** - 합집합!\n\n---\n\n## 💡 언제 쓸까?\n\n```\n✅ FULL OUTER JOIN 사용\n├── 데이터 일치성 검사\n├── 누락 데이터 찾기\n└── 마이그레이션 검증\n\n⚠️ 주의\n├── MySQL은 지원 안 함!\n├── PostgreSQL, Oracle, SQL Server 지원\n└── MySQL은 UNION으로 구현\n```\n\n---\n\n## 🎯 시각화\n\n```\nusers                      orders\n┌────────────┐          ┌────────────┐\n│ 김철수 ─────┼──────────┼─→ 주문1    │\n│ 이영희     │          │ 주문2 ───────┼─ user_id=999 (없는 유저)\n│ 박민수     │          │            │\n└────────────┘          └────────────┘\n\nFULL OUTER JOIN 결과:\n| user_name | order_id |\n|-----------|----------|\n| 김철수     | 1        |\n| 이영희     | NULL     |\n| 박민수     | NULL     |\n| NULL      | 2        | ← user_id=999\n```"
      },
      {
        "type": "code",
        "title": "💻 FULL OUTER JOIN 구현",
        "content": "### PostgreSQL / Oracle / SQL Server\n\n```sql\n-- 직접 지원\nSELECT\n    u.name AS user_name,\n    o.id AS order_id\nFROM users u\nFULL OUTER JOIN orders o ON u.id = o.user_id;\n```\n\n### MySQL 구현 (UNION 사용)\n\n```sql\n-- LEFT JOIN + RIGHT JOIN\nSELECT u.name, o.id AS order_id\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\n\nUNION\n\nSELECT u.name, o.id AS order_id\nFROM users u\nRIGHT JOIN orders o ON u.id = o.user_id;\n```\n\n### 실전 예제: 데이터 검증\n\n```sql\n-- 두 테이블 간 불일치 찾기\nSELECT\n    old.id AS old_id,\n    new.id AS new_id,\n    old.email AS old_email,\n    new.email AS new_email\nFROM old_users old\nFULL OUTER JOIN new_users new ON old.id = new.id\nWHERE old.id IS NULL OR new.id IS NULL;\n\n-- MySQL 버전\nSELECT old.id, new.id, old.email, new.email\nFROM old_users old LEFT JOIN new_users new ON old.id = new.id\nWHERE new.id IS NULL\nUNION\nSELECT old.id, new.id, old.email, new.email\nFROM old_users old RIGHT JOIN new_users new ON old.id = new.id\nWHERE old.id IS NULL;\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### 사용 빈도\n\n```\nINNER JOIN: 70%\nLEFT JOIN: 25%\nFULL OUTER JOIN: 4%\nRIGHT JOIN: 1%\n\n→ FULL OUTER JOIN은 데이터 검증/마이그레이션 시 주로 사용\n```\n\n### 성능 주의\n\n```sql\n-- FULL OUTER JOIN은 비용이 큼\n-- 대용량 테이블에서는 주의\n\n-- 대안: 작은 범위로 제한\nSELECT * FROM users u\nFULL OUTER JOIN orders o ON u.id = o.user_id\nWHERE u.created_at >= '2024-01-01'\n   OR o.created_at >= '2024-01-01';\n```"
      }
    ]
  },
  "03_JOIN/inner-join": {
    "id": "03_JOIN/inner-join",
    "title": "INNER JOIN",
    "category": "db",
    "subCategory": "03_JOIN",
    "language": "SQL",
    "description": "가장 기본이 되는 INNER JOIN을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 INNER JOIN 완벽 이해",
        "content": "## 🔥 한 줄 요약\n> **양쪽 테이블에 모두 있는 것만 조회** - 교집합!\n\n---\n\n## 💡 언제 쓸까?\n\n```\n✅ INNER JOIN 사용\n├── 주문한 고객의 주문내역 (주문 있어야 의미)\n├── 재고 있는 상품 목록 (재고 없으면 불필요)\n└── 부서 배정된 직원 목록\n\n❌ LEFT JOIN 사용해야 할 때\n├── 모든 고객 + 주문내역 (주문 없어도 표시)\n└── 모든 상품 + 재고현황\n```\n\n---\n\n## 🎯 문법\n\n```sql\n-- 명시적 JOIN (권장)\nSELECT columns\nFROM table1\nINNER JOIN table2 ON table1.col = table2.col;\n\n-- INNER 생략 가능\nSELECT columns\nFROM table1\nJOIN table2 ON table1.col = table2.col;\n\n-- 암시적 JOIN (비권장, 레거시)\nSELECT columns\nFROM table1, table2\nWHERE table1.col = table2.col;\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 INNER JOIN",
        "content": "### 기본 사용\n\n```sql\n-- 주문내역 조회 (고객명 포함)\nSELECT\n    o.id AS order_id,\n    u.name AS customer_name,\n    o.total_price,\n    o.created_at\nFROM orders o\nINNER JOIN users u ON o.user_id = u.id;\n```\n\n### 다중 테이블 JOIN\n\n```sql\n-- 주문 상세내역 (고객 + 상품 정보)\nSELECT\n    o.id AS order_id,\n    u.name AS customer_name,\n    p.name AS product_name,\n    oi.quantity,\n    oi.price\nFROM orders o\nINNER JOIN users u ON o.user_id = u.id\nINNER JOIN order_items oi ON o.id = oi.order_id\nINNER JOIN products p ON oi.product_id = p.id\nWHERE o.status = 'completed';\n```\n\n### 집계와 함께\n\n```sql\n-- 고객별 주문 통계\nSELECT\n    u.name,\n    u.email,\n    COUNT(o.id) AS order_count,\n    SUM(o.total_price) AS total_spent,\n    MAX(o.created_at) AS last_order\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id\nGROUP BY u.id, u.name, u.email\nHAVING COUNT(o.id) >= 3\nORDER BY total_spent DESC;\n```\n\n### 같은 테이블 값 비교\n\n```sql\n-- USING 문법 (컬럼명 같을 때)\nSELECT *\nFROM orders o\nINNER JOIN users u USING (user_id);  -- ON o.user_id = u.user_id\n\n-- 여러 컬럼으로 JOIN\nSELECT *\nFROM order_items oi\nINNER JOIN inventory inv\n    ON oi.product_id = inv.product_id\n    AND oi.warehouse_id = inv.warehouse_id;\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### INNER JOIN vs LEFT JOIN 선택\n\n```sql\n-- 질문: \"주문 없는 고객도 보여야 하나?\"\n-- YES → LEFT JOIN\n-- NO → INNER JOIN\n\n-- 대부분의 리포트는 INNER JOIN\n-- \"주문 고객 목록\" = INNER JOIN\n-- \"전체 고객 현황\" = LEFT JOIN\n```\n\n### 성능 최적화\n\n```sql\n-- 1. 인덱스 확인\nEXPLAIN SELECT * FROM orders o\nINNER JOIN users u ON o.user_id = u.id;\n\n-- 2. 필요한 컬럼만\nSELECT u.name, o.total_price  -- ✅\n-- SELECT *  -- ❌\n\n-- 3. 조건은 JOIN 전에 (서브쿼리)\nSELECT u.name, o.total_price\nFROM (SELECT * FROM users WHERE status = 'active') u\nINNER JOIN orders o ON u.id = o.user_id;\n```"
      }
    ]
  },
  "03_JOIN/join-compare": {
    "id": "03_JOIN/join-compare",
    "title": "JOIN 비교 총정리",
    "category": "db",
    "subCategory": "03_JOIN",
    "language": "SQL",
    "description": "모든 JOIN 유형을 비교하고 선택 기준을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 JOIN 총정리",
        "content": "## 🎯 JOIN 비교표\n\n| JOIN 유형 | 결과 | 사용 빈도 | 용도 |\n|----------|------|----------|------|\n| INNER | 교집합 | ⭐⭐⭐⭐⭐ | 매칭된 것만 |\n| LEFT | 왼쪽 전체 | ⭐⭐⭐⭐ | 왼쪽 기준 전체 |\n| RIGHT | 오른쪽 전체 | ⭐ | 거의 안 씀 |\n| FULL OUTER | 합집합 | ⭐⭐ | 데이터 검증 |\n| CROSS | 곱집합 | ⭐⭐ | 조합 생성 |\n| SELF | 자기참조 | ⭐⭐⭐ | 계층/비교 |\n\n---\n\n## 🎯 선택 가이드\n\n```\nQ: 매칭 안 되는 행도 필요한가?\n├── NO → INNER JOIN\n└── YES → LEFT/RIGHT/FULL\n    ├── 왼쪽 테이블 기준? → LEFT JOIN\n    ├── 오른쪽 테이블 기준? → LEFT JOIN (순서 바꿔서)\n    └── 양쪽 다? → FULL OUTER JOIN\n\nQ: 모든 조합이 필요한가?\n└── YES → CROSS JOIN\n\nQ: 같은 테이블 내 관계/비교?\n└── YES → SELF JOIN\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 비교",
        "content": "### 같은 데이터, 다른 JOIN\n\n```sql\n-- 데이터: users 4명, orders 3건 (1명만 주문)\n\n-- INNER JOIN: 주문한 유저만\nSELECT u.name, o.id FROM users u\nINNER JOIN orders o ON u.id = o.user_id;\n-- 결과: 3행 (1명 × 3주문)\n\n-- LEFT JOIN: 모든 유저\nSELECT u.name, o.id FROM users u\nLEFT JOIN orders o ON u.id = o.user_id;\n-- 결과: 6행 (3주문 + 3명 NULL)\n\n-- RIGHT JOIN: 모든 주문\nSELECT u.name, o.id FROM users u\nRIGHT JOIN orders o ON u.id = o.user_id;\n-- 결과: 3행 (모든 주문 + 유저정보)\n\n-- CROSS JOIN: 모든 조합\nSELECT u.name, o.id FROM users u\nCROSS JOIN orders o;\n-- 결과: 12행 (4명 × 3주문)\n```\n\n### 성능 비교\n\n```sql\n-- INNER JOIN이 가장 빠름 (결과 작음)\n-- LEFT JOIN은 왼쪽 테이블 전체 스캔\n-- CROSS JOIN은 폭발적 증가 주의\n\n-- EXPLAIN으로 확인\nEXPLAIN SELECT * FROM users u\nINNER JOIN orders o ON u.id = o.user_id;\n```"
      },
      {
        "type": "tip",
        "title": "💡 면접 대비",
        "content": "### 자주 묻는 질문\n\n```\nQ: INNER JOIN vs LEFT JOIN 차이?\nA: INNER는 양쪽 매칭만, LEFT는 왼쪽 전체 포함\n\nQ: LEFT JOIN에서 오른쪽 테이블 값이 NULL인 행만 찾으려면?\nA: WHERE right_table.id IS NULL\n\nQ: CROSS JOIN 결과 행 수는?\nA: A 테이블 행 수 × B 테이블 행 수\n\nQ: JOIN 성능 최적화는?\nA: JOIN 컬럼 인덱스, 필요한 컬럼만 SELECT,\n   작은 테이블 먼저, EXPLAIN으로 확인\n```"
      }
    ]
  },
  "03_JOIN/join-concept": {
    "id": "03_JOIN/join-concept",
    "title": "JOIN 개념 완벽 정리",
    "category": "db",
    "subCategory": "03_JOIN",
    "language": "SQL",
    "description": "다양한 JOIN의 동작 원리를 시각적으로 이해합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 JOIN 시각화",
        "content": "## 🎯 벤다이어그램으로 이해하기\n\n```\n테이블 A          테이블 B\n   ┌───┐            ┌───┐\n   │   │            │   │\n   │ ● │────────────│ ● │\n   │   │            │   │\n   └───┘            └───┘\n\nINNER JOIN: 교집합 (●●)\nLEFT JOIN: A 전체 + 교집합\nRIGHT JOIN: B 전체 + 교집합\nFULL OUTER JOIN: A ∪ B\n```\n\n---\n\n## 🎯 실제 예시로 이해하기\n\n### 샘플 데이터\n\n```\nemployees (직원)           departments (부서)\n+----+--------+-------+    +----+----------+\n| id | name   | dept_id|   | id | name     |\n+----+--------+-------+    +----+----------+\n| 1  | 김철수  | 10    |    | 10 | 개발팀    |\n| 2  | 이영희  | 20    |    | 20 | 마케팅팀  |\n| 3  | 박민수  | 30    |    | 40 | 인사팀    |\n| 4  | 최지원  | NULL  |    +----+----------+\n+----+--------+-------+\n```\n\n### 각 JOIN 결과\n\n```sql\n-- INNER JOIN: 부서 있는 직원만\n김철수 - 개발팀\n이영희 - 마케팅팀\n(박민수: dept_id=30인데 부서테이블에 없음 → 제외)\n(최지원: dept_id=NULL → 제외)\n\n-- LEFT JOIN: 모든 직원\n김철수 - 개발팀\n이영희 - 마케팅팀\n박민수 - NULL\n최지원 - NULL\n\n-- RIGHT JOIN: 모든 부서\n김철수 - 개발팀\n이영희 - 마케팅팀\nNULL   - 인사팀 (직원 없음)\n```"
      },
      {
        "type": "code",
        "title": "💻 JOIN 비교",
        "content": "### 모든 JOIN 비교\n\n```sql\n-- INNER JOIN\nSELECT e.name, d.name AS dept\nFROM employees e\nINNER JOIN departments d ON e.dept_id = d.id;\n-- 결과: 2행 (김철수-개발팀, 이영희-마케팅팀)\n\n-- LEFT JOIN\nSELECT e.name, d.name AS dept\nFROM employees e\nLEFT JOIN departments d ON e.dept_id = d.id;\n-- 결과: 4행 (모든 직원)\n\n-- RIGHT JOIN\nSELECT e.name, d.name AS dept\nFROM employees e\nRIGHT JOIN departments d ON e.dept_id = d.id;\n-- 결과: 3행 (모든 부서)\n\n-- FULL OUTER JOIN (MySQL은 지원 안 함)\nSELECT e.name, d.name AS dept\nFROM employees e\nFULL OUTER JOIN departments d ON e.dept_id = d.id;\n-- 결과: 5행 (모든 직원 + 모든 부서)\n\n-- MySQL에서 FULL OUTER JOIN 구현\nSELECT e.name, d.name FROM employees e LEFT JOIN departments d ON e.dept_id = d.id\nUNION\nSELECT e.name, d.name FROM employees e RIGHT JOIN departments d ON e.dept_id = d.id;\n```\n\n### JOIN 조건 (ON vs WHERE)\n\n```sql\n-- ON: JOIN 조건\n-- WHERE: 필터링 조건\n\n-- 차이 예시 (LEFT JOIN에서 중요!)\n-- ON에 조건\nSELECT * FROM employees e\nLEFT JOIN departments d ON e.dept_id = d.id AND d.name = '개발팀';\n-- 모든 직원 나오고, 개발팀 아니면 부서정보만 NULL\n\n-- WHERE에 조건\nSELECT * FROM employees e\nLEFT JOIN departments d ON e.dept_id = d.id\nWHERE d.name = '개발팀';\n-- 개발팀 직원만 나옴 (INNER JOIN과 동일한 결과)\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### 흔한 실수\n\n```sql\n-- ❌ LEFT JOIN 후 WHERE로 NULL 제외\nSELECT * FROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE o.status = 'completed';\n-- 주문 없는 유저 제외됨 (INNER JOIN과 동일)\n\n-- ✅ 의도대로 하려면\nSELECT * FROM users u\nLEFT JOIN orders o ON u.id = o.user_id AND o.status = 'completed';\n-- 모든 유저 + completed 주문만 (없으면 NULL)\n```\n\n### JOIN 성능 체크리스트\n\n```\n□ JOIN 컬럼에 인덱스 있는지\n□ 불필요한 JOIN 없는지\n□ SELECT *  대신 필요한 컬럼만\n□ EXPLAIN으로 실행계획 확인\n```"
      }
    ]
  },
  "03_JOIN/join-intro": {
    "id": "03_JOIN/join-intro",
    "title": "JOIN 소개",
    "category": "db",
    "subCategory": "03_JOIN",
    "language": "SQL",
    "description": "테이블 조인의 기본 개념을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 JOIN이란?",
        "content": "## 🔥 한 줄 요약\n> **여러 테이블을 연결해서 조회** - \"회원정보 + 주문정보를 한 번에\"\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 실무 현실:\n```\n🛒 \"김철수님의 주문내역 보여줘\"\n→ users 테이블 (이름)\n→ orders 테이블 (주문정보)\n→ products 테이블 (상품정보)\n→ JOIN 해야 한 화면에 표시!\n\n📊 모든 실무 쿼리의 80%는 JOIN 포함\n```\n\n---\n\n## 🎯 핵심 개념\n\n### 왜 테이블을 나눌까?\n\n```\n❌ 하나의 거대한 테이블\n┌────┬────────┬───────────┬────────┬─────────┬────────┐\n│ 주문ID │ 고객명 │ 고객이메일 │ 상품명 │ 상품가격 │ 수량   │\n├────┼────────┼───────────┼────────┼─────────┼────────┤\n│ 1  │ 김철수 │ kim@test  │ 아이폰  │ 1000000 │ 1     │\n│ 2  │ 김철수 │ kim@test  │ 맥북   │ 2000000 │ 1     │\n│ 3  │ 김철수 │ kim@test  │ 에어팟  │ 300000  │ 2     │\n└────┴────────┴───────────┴────────┴─────────┴────────┘\n→ 김철수 정보가 3번 중복! 이메일 바꾸면 3곳 수정!\n\n✅ 정규화된 테이블\nusers: id, name, email\nproducts: id, name, price\norders: id, user_id, product_id, quantity\n→ 중복 없음, 관계로 연결!\n```\n\n### JOIN 종류\n\n```\nINNER JOIN: 양쪽 모두 있는 것만 (교집합)\nLEFT JOIN: 왼쪽 전체 + 오른쪽 매칭\nRIGHT JOIN: 오른쪽 전체 + 왼쪽 매칭\nFULL OUTER JOIN: 양쪽 전체 (합집합)\nCROSS JOIN: 모든 조합 (곱집합)\nSELF JOIN: 자기 자신과 조인\n```"
      },
      {
        "type": "code",
        "title": "💻 기본 JOIN",
        "content": "### 샘플 데이터\n\n```sql\n-- users 테이블\n| id | name   |\n|----|--------|\n| 1  | 김철수  |\n| 2  | 이영희  |\n| 3  | 박민수  |\n\n-- orders 테이블\n| id | user_id | product   | price   |\n|----|---------|-----------|---------|\n| 1  | 1       | 아이폰     | 1000000 |\n| 2  | 1       | 맥북       | 2000000 |\n| 3  | 2       | 갤럭시     | 900000  |\n```\n\n### INNER JOIN\n\n```sql\nSELECT u.name, o.product, o.price\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id;\n\n-- 결과: (주문 있는 유저만)\n| name   | product | price   |\n|--------|---------|---------|\n| 김철수  | 아이폰   | 1000000 |\n| 김철수  | 맥북     | 2000000 |\n| 이영희  | 갤럭시   | 900000  |\n-- 박민수는 주문이 없어서 제외됨!\n```\n\n### LEFT JOIN\n\n```sql\nSELECT u.name, o.product, o.price\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id;\n\n-- 결과: (모든 유저)\n| name   | product | price   |\n|--------|---------|---------|\n| 김철수  | 아이폰   | 1000000 |\n| 김철수  | 맥북     | 2000000 |\n| 이영희  | 갤럭시   | 900000  |\n| 박민수  | NULL     | NULL    |\n-- 박민수도 포함 (주문정보는 NULL)\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### JOIN 선택 가이드\n\n```\nINNER JOIN: 양쪽 다 있어야 의미있을 때\n  예) 주문한 고객의 주문내역\n\nLEFT JOIN: 왼쪽 기준으로 전체 필요할 때\n  예) 모든 고객의 주문내역 (주문 없어도 표시)\n\nRIGHT JOIN: 거의 안 씀 (LEFT로 순서 바꾸면 됨)\n\nCROSS JOIN: 모든 조합 필요할 때\n  예) 색상 × 사이즈 조합 생성\n```\n\n### 성능 팁\n\n```sql\n-- JOIN 컬럼에 인덱스 필수!\nCREATE INDEX idx_orders_user_id ON orders(user_id);\n\n-- JOIN 순서도 성능에 영향\n-- 작은 테이블을 먼저 (옵티마이저가 자동 최적화)\n```"
      }
    ]
  },
  "03_JOIN/left-join": {
    "id": "03_JOIN/left-join",
    "title": "LEFT JOIN",
    "category": "db",
    "subCategory": "03_JOIN",
    "language": "SQL",
    "description": "왼쪽 테이블 기준의 LEFT JOIN을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 LEFT JOIN 완벽 이해",
        "content": "## 🔥 한 줄 요약\n> **왼쪽 테이블 전체 + 오른쪽 매칭** - 왼쪽은 무조건 다 나옴!\n\n---\n\n## 💡 언제 쓸까?\n\n```\n✅ LEFT JOIN 사용\n├── \"모든 고객\" + 주문내역 (주문 없어도 표시)\n├── \"모든 상품\" + 리뷰 (리뷰 없어도 표시)\n├── \"전체 직원\" + 프로젝트 (미배정도 표시)\n└── NULL 체크가 필요할 때\n\n❌ INNER JOIN이 나은 경우\n├── 매칭된 것만 필요할 때\n└── 양쪽 다 있어야 의미있을 때\n```\n\n---\n\n## 🎯 시각화\n\n```\nusers (왼쪽)              orders (오른쪽)\n┌────────────┐          ┌────────────┐\n│ 김철수 ─────┼──────────┼─→ 주문1    │\n│ 이영희 ─────┼──────────┼─→ 주문2    │\n│ 박민수     │          │            │\n│ 최지원     │          │            │\n└────────────┘          └────────────┘\n     ↓\nLEFT JOIN 결과\n┌─────────┬─────────┐\n│ 김철수   │ 주문1    │\n│ 이영희   │ 주문2    │\n│ 박민수   │ NULL    │  ← 매칭 없음\n│ 최지원   │ NULL    │  ← 매칭 없음\n└─────────┴─────────┘\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 LEFT JOIN",
        "content": "### 기본 사용\n\n```sql\n-- 모든 고객 + 주문정보\nSELECT\n    u.name,\n    u.email,\n    o.id AS order_id,\n    o.total_price\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id;\n```\n\n### NULL 활용 패턴\n\n```sql\n-- 주문 없는 고객만 찾기\nSELECT u.name, u.email\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE o.id IS NULL;\n\n-- 최근 30일 구매 없는 고객\nSELECT u.name, u.email\nFROM users u\nLEFT JOIN (\n    SELECT DISTINCT user_id\n    FROM orders\n    WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)\n) recent_orders ON u.id = recent_orders.user_id\nWHERE recent_orders.user_id IS NULL;\n```\n\n### 집계와 함께\n\n```sql\n-- 모든 고객별 주문 통계 (0건도 포함)\nSELECT\n    u.name,\n    COUNT(o.id) AS order_count,  -- NULL은 카운트 안 됨\n    COALESCE(SUM(o.total_price), 0) AS total_spent\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nGROUP BY u.id, u.name;\n\n-- 결과\n-- 김철수 | 5 | 500000\n-- 이영희 | 2 | 200000\n-- 박민수 | 0 | 0  ← 주문 없음\n```\n\n### 다중 LEFT JOIN\n\n```sql\n-- 모든 상품 + 리뷰 + 주문수량\nSELECT\n    p.name AS product_name,\n    COUNT(DISTINCT r.id) AS review_count,\n    AVG(r.rating) AS avg_rating,\n    SUM(oi.quantity) AS total_sold\nFROM products p\nLEFT JOIN reviews r ON p.id = r.product_id\nLEFT JOIN order_items oi ON p.id = oi.product_id\nGROUP BY p.id, p.name;\n```"
      },
      {
        "type": "common-mistake",
        "title": "⚠️ 흔한 실수",
        "content": "### ON vs WHERE 차이\n\n```sql\n-- ❌ LEFT JOIN 의미 없어짐\nSELECT * FROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE o.status = 'completed';\n-- → 주문 없는 유저 제외됨 (INNER JOIN과 동일)\n\n-- ✅ 의도대로\nSELECT * FROM users u\nLEFT JOIN orders o ON u.id = o.user_id AND o.status = 'completed';\n-- → 모든 유저 + completed 주문만 (없으면 NULL)\n```\n\n### COUNT(*) vs COUNT(column)\n\n```sql\n-- ❌ 모든 행 카운트\nSELECT u.name, COUNT(*) AS cnt\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nGROUP BY u.name;\n-- 주문 없어도 1로 나옴\n\n-- ✅ 주문 ID 카운트 (NULL 제외)\nSELECT u.name, COUNT(o.id) AS cnt\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nGROUP BY u.name;\n-- 주문 없으면 0\n```\n\n### NULL 비교\n\n```sql\n-- ❌ = NULL은 항상 FALSE\nWHERE o.status = NULL\n\n-- ✅ IS NULL 사용\nWHERE o.id IS NULL\n```"
      }
    ]
  },
  "03_JOIN/practice-join": {
    "id": "03_JOIN/practice-join",
    "title": "JOIN 실전 연습",
    "category": "db",
    "subCategory": "03_JOIN",
    "language": "SQL",
    "description": "다양한 JOIN 시나리오를 실습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 실전 문제",
        "content": "## 📋 시나리오\n\n```\n쇼핑몰 DB\n- users: 회원 정보\n- products: 상품 정보\n- orders: 주문 정보\n- order_items: 주문 상세\n- reviews: 리뷰\n```\n\n---\n\n## 🎯 문제 목록\n\n1. **주문한 고객 목록** (INNER JOIN)\n2. **주문 없는 고객 찾기** (LEFT JOIN + NULL)\n3. **고객별 주문 통계** (LEFT JOIN + 집계)\n4. **상품별 리뷰 현황** (LEFT JOIN)\n5. **VIP 고객의 최근 구매 상품** (다중 JOIN)"
      },
      {
        "type": "code",
        "title": "💻 풀이",
        "content": "### 1. 주문한 고객 목록\n\n```sql\nSELECT DISTINCT\n    u.id,\n    u.name,\n    u.email\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id;\n```\n\n### 2. 주문 없는 고객 찾기\n\n```sql\nSELECT u.id, u.name, u.email\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE o.id IS NULL;\n```\n\n### 3. 고객별 주문 통계\n\n```sql\nSELECT\n    u.id,\n    u.name,\n    COUNT(o.id) AS order_count,\n    COALESCE(SUM(o.total_price), 0) AS total_spent,\n    MAX(o.created_at) AS last_order_date\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nGROUP BY u.id, u.name\nORDER BY total_spent DESC;\n```\n\n### 4. 상품별 리뷰 현황\n\n```sql\nSELECT\n    p.id,\n    p.name AS product_name,\n    COUNT(r.id) AS review_count,\n    ROUND(AVG(r.rating), 1) AS avg_rating\nFROM products p\nLEFT JOIN reviews r ON p.id = r.product_id\nGROUP BY p.id, p.name\nORDER BY review_count DESC;\n```\n\n### 5. VIP 고객의 최근 구매 상품\n\n```sql\nSELECT\n    u.name AS customer,\n    p.name AS product,\n    oi.quantity,\n    o.created_at\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id\nINNER JOIN order_items oi ON o.id = oi.order_id\nINNER JOIN products p ON oi.product_id = p.id\nWHERE u.membership = 'VIP'\n  AND o.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)\nORDER BY o.created_at DESC;\n```"
      },
      {
        "type": "tip",
        "title": "💡 연습 팁",
        "content": "### JOIN 작성 순서\n\n```\n1. 필요한 테이블 파악\n2. 관계(FK) 확인\n3. 기준 테이블 결정\n4. JOIN 유형 선택\n5. SELECT 컬럼 정리\n6. WHERE/GROUP BY 추가\n7. EXPLAIN으로 성능 확인\n```\n\n### 디버깅 팁\n\n```sql\n-- 1. 각 JOIN 단계별로 확인\nSELECT * FROM users u\n-- 여기서 결과 확인\nINNER JOIN orders o ON u.id = o.user_id;\n-- 다시 확인\n\n-- 2. 행 수 비교\nSELECT COUNT(*) FROM users;           -- 100\nSELECT COUNT(*) FROM orders;          -- 500\nSELECT COUNT(*) FROM users u\nINNER JOIN orders o ON u.id = o.user_id;  -- 500\n-- INNER JOIN 결과가 orders와 같으면 모든 주문에 유저 있음\n```"
      }
    ]
  },
  "03_JOIN/right-join": {
    "id": "03_JOIN/right-join",
    "title": "RIGHT JOIN",
    "category": "db",
    "subCategory": "03_JOIN",
    "language": "SQL",
    "description": "오른쪽 테이블 기준의 RIGHT JOIN을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 RIGHT JOIN",
        "content": "## 🔥 한 줄 요약\n> **오른쪽 테이블 전체 + 왼쪽 매칭** - LEFT JOIN의 반대!\n\n---\n\n## 💡 현실적인 조언\n\n```\n🤔 RIGHT JOIN은 거의 안 씀!\n\n이유:\n├── LEFT JOIN으로 테이블 순서만 바꾸면 됨\n├── 가독성이 떨어짐\n└── 코드 리뷰 시 혼란 유발\n\n결론: LEFT JOIN만 써도 됨!\n```\n\n---\n\n## 🎯 LEFT JOIN으로 변환\n\n```sql\n-- RIGHT JOIN\nSELECT * FROM orders o\nRIGHT JOIN users u ON o.user_id = u.id;\n\n-- LEFT JOIN으로 변환 (동일 결과)\nSELECT * FROM users u\nLEFT JOIN orders o ON u.id = o.user_id;\n```"
      },
      {
        "type": "code",
        "title": "💻 RIGHT JOIN 예제",
        "content": "### 기본 사용\n\n```sql\n-- 모든 부서 + 직원 (직원 없는 부서도 포함)\nSELECT\n    d.name AS department,\n    e.name AS employee\nFROM employees e\nRIGHT JOIN departments d ON e.dept_id = d.id;\n\n-- LEFT JOIN으로 동일하게\nSELECT\n    d.name AS department,\n    e.name AS employee\nFROM departments d\nLEFT JOIN employees e ON d.id = e.dept_id;\n```\n\n### 언제 쓸 수 있나?\n\n```sql\n-- 여러 JOIN 중에 RIGHT가 자연스러울 때\nSELECT\n    o.id,\n    oi.product_id,\n    p.name\nFROM order_items oi\nJOIN orders o ON oi.order_id = o.id\nRIGHT JOIN products p ON oi.product_id = p.id;\n-- 모든 상품 + 주문정보 (주문 없는 상품 포함)\n\n-- 하지만 이것도 LEFT JOIN으로 리팩토링 가능\nSELECT\n    p.name,\n    o.id,\n    oi.product_id\nFROM products p\nLEFT JOIN order_items oi ON p.id = oi.product_id\nLEFT JOIN orders o ON oi.order_id = o.id;\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### 코딩 컨벤션\n\n```\n대부분의 팀:\n├── LEFT JOIN만 사용\n├── 테이블 순서로 방향 조절\n└── 코드 리뷰 시 RIGHT JOIN → LEFT JOIN 변환 요청\n\n예외:\n├── 레거시 코드\n├── 특수한 상황\n└── ORM이 자동 생성한 경우\n```\n\n### 면접 TIP\n\n```\nQ: LEFT JOIN과 RIGHT JOIN의 차이?\nA: 기준 테이블의 위치 차이.\n   실무에서는 가독성을 위해 LEFT JOIN만 사용하고,\n   테이블 순서를 바꿔서 원하는 결과를 얻습니다.\n```"
      }
    ]
  },
  "03_JOIN/self-join": {
    "id": "03_JOIN/self-join",
    "title": "SELF JOIN",
    "category": "db",
    "subCategory": "03_JOIN",
    "language": "SQL",
    "description": "같은 테이블을 조인하는 SELF JOIN을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 SELF JOIN",
        "content": "## 🔥 한 줄 요약\n> **같은 테이블을 자기 자신과 조인** - 계층 구조, 비교에 사용\n\n---\n\n## 💡 언제 쓸까?\n\n```\n✅ SELF JOIN 사용\n├── 조직도 (상사-부하 관계)\n├── 카테고리 계층 (대분류-중분류)\n├── 같은 테이블 내 비교\n└── 친구 관계, 팔로우 관계\n\n예시:\n├── \"김부장의 팀원들은?\"\n├── \"전자기기의 하위 카테고리는?\"\n└── \"나보다 비싼 상품은?\"\n```\n\n---\n\n## 🎯 시각화\n\n```\nemployees 테이블\n+----+--------+------------+\n| id | name   | manager_id |\n+----+--------+------------+\n| 1  | 김사장  | NULL       |\n| 2  | 박부장  | 1          |\n| 3  | 이과장  | 2          |\n| 4  | 최대리  | 2          |\n+----+--------+------------+\n\nSELF JOIN\nemployees e1 (직원) ─┐\n                    ├─→ 결과\nemployees e2 (상사) ─┘\n\n+--------+--------+\n| 직원    | 상사    |\n+--------+--------+\n| 박부장  | 김사장   |\n| 이과장  | 박부장   |\n| 최대리  | 박부장   |\n+--------+--------+\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 SELF JOIN",
        "content": "### 조직도 조회\n\n```sql\n-- 직원과 상사 정보\nSELECT\n    e.name AS employee,\n    m.name AS manager\nFROM employees e\nLEFT JOIN employees m ON e.manager_id = m.id;\n\n-- 같은 상사를 둔 동료 찾기\nSELECT\n    e1.name AS employee1,\n    e2.name AS employee2,\n    m.name AS same_manager\nFROM employees e1\nJOIN employees e2 ON e1.manager_id = e2.manager_id\n    AND e1.id < e2.id  -- 중복 제거\nJOIN employees m ON e1.manager_id = m.id;\n```\n\n### 계층 구조 (카테고리)\n\n```sql\n-- categories: id, name, parent_id\nSELECT\n    c.name AS category,\n    p.name AS parent_category\nFROM categories c\nLEFT JOIN categories p ON c.parent_id = p.id;\n\n-- 3단계 계층 조회\nSELECT\n    c1.name AS level1,\n    c2.name AS level2,\n    c3.name AS level3\nFROM categories c1\nLEFT JOIN categories c2 ON c2.parent_id = c1.id\nLEFT JOIN categories c3 ON c3.parent_id = c2.id\nWHERE c1.parent_id IS NULL;\n```\n\n### 같은 테이블 내 비교\n\n```sql\n-- 자신보다 비싼 상품 찾기\nSELECT\n    p1.name AS product,\n    p1.price,\n    p2.name AS more_expensive,\n    p2.price\nFROM products p1\nJOIN products p2 ON p1.category = p2.category\n    AND p1.price < p2.price\nORDER BY p1.name, p2.price;\n\n-- 같은 날 가입한 유저\nSELECT\n    u1.name AS user1,\n    u2.name AS user2,\n    DATE(u1.created_at) AS join_date\nFROM users u1\nJOIN users u2 ON DATE(u1.created_at) = DATE(u2.created_at)\n    AND u1.id < u2.id;  -- 중복 제거\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### 중복 제거 패턴\n\n```sql\n-- 조합 중복 제거\n-- (A,B)와 (B,A)가 같은 경우\n\n-- ❌ 중복 발생\nJOIN ON e1.manager_id = e2.manager_id\n\n-- ✅ id 비교로 중복 제거\nJOIN ON e1.manager_id = e2.manager_id AND e1.id < e2.id\n```\n\n### Recursive CTE (깊은 계층)\n\n```sql\n-- MySQL 8.0+, PostgreSQL\nWITH RECURSIVE org_tree AS (\n    -- 시작점 (사장)\n    SELECT id, name, manager_id, 1 AS level\n    FROM employees\n    WHERE manager_id IS NULL\n\n    UNION ALL\n\n    -- 재귀 (부하 직원)\n    SELECT e.id, e.name, e.manager_id, t.level + 1\n    FROM employees e\n    JOIN org_tree t ON e.manager_id = t.id\n)\nSELECT * FROM org_tree ORDER BY level, id;\n```"
      }
    ]
  },
  "04_인덱스/index-anti-pattern": {
    "id": "04_인덱스/index-anti-pattern",
    "title": "인덱스 안티패턴",
    "category": "db",
    "subCategory": "04_인덱스",
    "language": "SQL",
    "description": "피해야 할 인덱스 사용 패턴을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 인덱스 안티패턴",
        "content": "## 🎯 피해야 할 패턴\n\n### 1. 과도한 인덱스\n```\n❌ 모든 컬럼에 인덱스\n├── INSERT 성능 저하\n├── UPDATE 성능 저하\n├── 디스크 공간 낭비\n└── 옵티마이저 혼란\n\n✅ 필요한 쿼리 기반으로만\n```\n\n### 2. 중복 인덱스\n```sql\n-- ❌ 중복\nCREATE INDEX idx1 ON orders(user_id);\nCREATE INDEX idx2 ON orders(user_id, status);\n-- idx2가 idx1의 역할 커버\n\n-- ✅ 하나로 통합\nCREATE INDEX idx ON orders(user_id, status);\n```\n\n### 3. 사용 안 하는 인덱스\n```sql\n-- 인덱스 사용 통계 확인 (MySQL)\nSELECT * FROM sys.schema_unused_indexes;\n\n-- 사용 안 하면 삭제\nDROP INDEX idx_unused ON table_name;\n```\n\n### 4. 카디널리티 낮은 컬럼 단독 인덱스\n```sql\n-- ❌ 값이 2~3개뿐\nCREATE INDEX idx_gender ON users(gender);  -- M/F\nCREATE INDEX idx_active ON users(is_active);  -- Y/N\n\n-- ✅ 복합 인덱스에 포함\nCREATE INDEX idx ON users(status, gender);\n```"
      },
      {
        "type": "code",
        "title": "💻 안티패턴 예제",
        "content": "### 인덱스 통계 분석\n\n```sql\n-- MySQL: 인덱스 사용 현황\nSELECT\n    TABLE_NAME,\n    INDEX_NAME,\n    SEQ_IN_INDEX,\n    COLUMN_NAME,\n    CARDINALITY\nFROM information_schema.STATISTICS\nWHERE TABLE_SCHEMA = 'your_db'\nORDER BY TABLE_NAME, INDEX_NAME, SEQ_IN_INDEX;\n\n-- 사용되지 않는 인덱스 찾기 (MySQL 8.0+)\nSELECT * FROM sys.schema_unused_indexes\nWHERE object_schema = 'your_db';\n\n-- 중복 인덱스 찾기\nSELECT * FROM sys.schema_redundant_indexes\nWHERE table_schema = 'your_db';\n```\n\n### 인덱스 정리\n\n```sql\n-- 불필요한 인덱스 삭제\nDROP INDEX idx_unused ON orders;\n\n-- 중복 인덱스 통합\nDROP INDEX idx_user_id ON orders;  -- user_id만\n-- idx_user_status (user_id, status) 남김\n\n-- 인덱스 재구성 (조각화 해소)\nALTER TABLE orders ENGINE=InnoDB;  -- MySQL\n-- 또는\nOPTIMIZE TABLE orders;\n```\n\n### 실전 최적화 예제\n\n```sql\n-- Before: 인덱스 6개\nidx_user_id (user_id)\nidx_status (status)\nidx_created (created_at)\nidx_user_status (user_id, status)\nidx_status_created (status, created_at)\nidx_user_created (user_id, created_at)\n\n-- After: 인덱스 3개로 정리\nidx_user_status_created (user_id, status, created_at)\nidx_status_created (status, created_at)\nidx_created (created_at)  -- 기간 조회용\n```"
      },
      {
        "type": "tip",
        "title": "💡 인덱스 관리 가이드",
        "content": "### 정기 점검 항목\n\n```\n월간 점검:\n□ 사용되지 않는 인덱스\n□ 중복 인덱스\n□ 슬로우 쿼리에서 인덱스 안 타는 쿼리\n□ 인덱스 크기 확인\n\n분기별:\n□ 인덱스 재구성 (조각화)\n□ 통계 정보 업데이트\n```\n\n### 인덱스 개수 가이드\n\n```\n소규모 테이블 (1만건 이하): 2~3개\n중규모 테이블 (100만건 이하): 3~5개\n대규모 테이블 (1000만건 이상): 5~10개\n\n넘어가면 검토 필요!\n```"
      }
    ]
  },
  "04_인덱스/index-bad-case": {
    "id": "04_인덱스/index-bad-case",
    "title": "인덱스가 안 타는 경우",
    "category": "db",
    "subCategory": "04_인덱스",
    "language": "SQL",
    "description": "인덱스가 사용되지 않는 상황을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 인덱스 무효화 케이스",
        "content": "## 🎯 인덱스가 안 타는 경우\n\n### 1. 컬럼에 함수/연산 사용\n```sql\n-- ❌ 인덱스 안 탐\nWHERE YEAR(created_at) = 2024\nWHERE price * 1.1 > 10000\nWHERE LOWER(email) = 'test@test.com'\n\n-- ✅ 인덱스 탐\nWHERE created_at >= '2024-01-01' AND created_at < '2025-01-01'\nWHERE price > 10000 / 1.1\nWHERE email = 'test@test.com'  -- 대소문자 무시하려면 CI 콜레이션\n```\n\n### 2. LIKE '%keyword'\n```sql\n-- ❌ 인덱스 안 탐 (앞에 %)\nWHERE name LIKE '%철수'\n\n-- ✅ 인덱스 탐\nWHERE name LIKE '김%'\n```\n\n### 3. OR 조건\n```sql\n-- ❌ 비효율적\nWHERE status = 'A' OR user_id = 1\n\n-- ✅ UNION 또는 각각 인덱스\nSELECT * FROM orders WHERE status = 'A'\nUNION\nSELECT * FROM orders WHERE user_id = 1;\n```\n\n### 4. NOT, <>, != 조건\n```sql\n-- ❌ 인덱스 비효율\nWHERE status != 'deleted'\nWHERE status <> 'cancelled'\nWHERE status NOT IN ('deleted', 'cancelled')\n\n-- ✅ 가능하면 긍정 조건으로\nWHERE status IN ('active', 'pending', 'completed')\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 예제",
        "content": "### 날짜 검색 최적화\n\n```sql\n-- ❌ 함수 사용 (인덱스 X)\nSELECT * FROM orders\nWHERE DATE(created_at) = '2024-01-15';\n\nSELECT * FROM orders\nWHERE YEAR(created_at) = 2024 AND MONTH(created_at) = 1;\n\n-- ✅ 범위 조건 (인덱스 O)\nSELECT * FROM orders\nWHERE created_at >= '2024-01-15'\n  AND created_at < '2024-01-16';\n\nSELECT * FROM orders\nWHERE created_at >= '2024-01-01'\n  AND created_at < '2024-02-01';\n```\n\n### 문자열 검색 최적화\n\n```sql\n-- ❌ LIKE '%keyword%' (인덱스 X)\nSELECT * FROM products\nWHERE name LIKE '%아이폰%';\n\n-- ✅ Full-Text 인덱스 사용\nCREATE FULLTEXT INDEX idx_name ON products(name);\nSELECT * FROM products\nWHERE MATCH(name) AGAINST('아이폰');\n\n-- ✅ 또는 별도 검색 엔진 (Elasticsearch)\n```\n\n### 복합 인덱스 순서\n\n```sql\n-- 인덱스: (status, user_id, created_at)\n\n-- ✅ 인덱스 사용\nWHERE status = 'completed' AND user_id = 1;\n\n-- ❌ 인덱스 안 탐 (첫 번째 컬럼 없음)\nWHERE user_id = 1;\n\n-- ⚠️ 부분만 사용\nWHERE status = 'completed' AND created_at > '2024-01-01';\n-- status만 인덱스 사용, created_at은 필터링\n```"
      },
      {
        "type": "tip",
        "title": "💡 디버깅 팁",
        "content": "### EXPLAIN으로 확인\n\n```sql\nEXPLAIN SELECT * FROM orders WHERE YEAR(created_at) = 2024;\n-- type: ALL (풀스캔)\n-- key: NULL (인덱스 안 씀)\n\nEXPLAIN SELECT * FROM orders\nWHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';\n-- type: range (범위 스캔)\n-- key: idx_created_at (인덱스 사용)\n```\n\n### 체크리스트\n\n```\n인덱스 안 탈 때 확인:\n□ 컬럼에 함수/연산 사용했나?\n□ LIKE '%...'로 시작하나?\n□ 복합 인덱스 순서 맞나?\n□ OR 조건 있나?\n□ 데이터가 너무 많이 조회되나? (30% 이상)\n□ NULL 비교를 = 로 했나?\n```"
      }
    ]
  },
  "04_인덱스/index-concept": {
    "id": "04_인덱스/index-concept",
    "title": "인덱스 개념",
    "category": "db",
    "subCategory": "04_인덱스",
    "language": "SQL",
    "description": "인덱스의 원리와 필요성을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 인덱스란?",
        "content": "## 🔥 한 줄 요약\n> **데이터 검색을 빠르게 하는 목차** - 책의 색인과 동일!\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 실제 사고 사례:\n```\n🔴 드로우 앱 사태 (2023)\n├── 나이키 한정판 드로우 시작\n├── 100만 명 동시 접속\n├── 로그인에 3초 걸림 → 인덱스 없는 쿼리\n├── 서버 다운, 100만 명 이탈\n└── 인덱스 추가 후 0.01초로 해결\n\n🔴 일반적인 상황\n├── 회원 100만 명 테이블\n├── SELECT * FROM users WHERE email = 'kim@test.com'\n├── 인덱스 없음: 100만 행 전체 스캔 (2초)\n├── 인덱스 있음: 바로 찾음 (0.001초)\n└── 2000배 차이!\n```\n\n---\n\n## 🎯 핵심 개념\n\n### 📚 도서관 비유\n\n```\n책 1000권에서 \"파이썬\" 찾기\n\n❌ 인덱스 없음 (Full Table Scan)\n└── 1000권 전부 확인 → 느림!\n\n✅ 인덱스 있음 (Index Scan)\n└── 색인에서 \"파이썬\" → 바로 위치 확인\n```\n\n### 인덱스 동작 원리\n\n```\nusers 테이블 (100만 행)\n+----+------------------+------+\n| id | email            | name |\n+----+------------------+------+\n| 1  | kim@test.com     | 김철수 |\n| 2  | lee@test.com     | 이영희 |\n| ... | ...             | ...  |\n+----+------------------+------+\n\nemail 인덱스 (B-Tree 구조)\n        ┌─────────────────┐\n        │    m@...        │\n        └────────┬────────┘\n           ┌─────┴─────┐\n       ┌───┴───┐   ┌───┴───┐\n       │ a-l   │   │ n-z   │\n       └───────┘   └───────┘\n\n→ kim@test.com 검색: 3단계만에 찾음!\n```"
      },
      {
        "type": "code",
        "title": "💻 인덱스 생성/확인",
        "content": "### 인덱스 생성\n\n```sql\n-- 단일 컬럼 인덱스\nCREATE INDEX idx_email ON users(email);\n\n-- 복합 인덱스 (여러 컬럼)\nCREATE INDEX idx_status_created ON orders(status, created_at);\n\n-- 유니크 인덱스\nCREATE UNIQUE INDEX idx_email_unique ON users(email);\n\n-- 테이블 생성 시 인덱스\nCREATE TABLE users (\n    id BIGINT PRIMARY KEY,\n    email VARCHAR(100),\n    name VARCHAR(50),\n    INDEX idx_email (email),\n    INDEX idx_name (name)\n);\n```\n\n### 인덱스 확인\n\n```sql\n-- 테이블의 인덱스 확인\nSHOW INDEX FROM users;\n\n-- 쿼리가 인덱스를 사용하는지 확인\nEXPLAIN SELECT * FROM users WHERE email = 'kim@test.com';\n-- type: ref, possible_keys: idx_email 확인\n```\n\n### 인덱스 삭제\n\n```sql\n-- 인덱스 삭제\nDROP INDEX idx_email ON users;\n\n-- ALTER TABLE로 삭제\nALTER TABLE users DROP INDEX idx_email;\n```"
      },
      {
        "type": "tip",
        "title": "💡 인덱스 핵심 정리",
        "content": "### 인덱스를 만들어야 하는 컬럼\n\n```\n✅ 인덱스 필요\n├── WHERE 조건에 자주 사용\n├── JOIN 조건 (FK)\n├── ORDER BY 대상\n├── 유니크해야 하는 컬럼\n\n❌ 인덱스 불필요\n├── 데이터가 적은 테이블 (1000건 이하)\n├── 값의 종류가 적은 컬럼 (성별: M/F)\n├── INSERT/UPDATE가 매우 빈번한 테이블\n```\n\n### 인덱스 비용\n\n```\n장점: 조회 속도 ⬆️\n단점:\n├── INSERT 느려짐 (인덱스도 갱신)\n├── UPDATE 느려짐 (인덱스 재구성)\n├── 저장 공간 추가 필요\n└── 과도한 인덱스 = 성능 저하\n```"
      }
    ]
  },
  "04_인덱스/index-design": {
    "id": "04_인덱스/index-design",
    "title": "인덱스 설계",
    "category": "db",
    "subCategory": "04_인덱스",
    "language": "SQL",
    "description": "효율적인 인덱스 설계 전략을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 인덱스 설계 전략",
        "content": "## 🎯 인덱스 설계 프로세스\n\n```\n1단계: 쿼리 분석\n├── 어떤 쿼리가 자주 실행되나?\n├── WHERE, JOIN, ORDER BY 조건은?\n└── 느린 쿼리 로그 분석\n\n2단계: 인덱스 후보 도출\n├── WHERE 조건 컬럼\n├── JOIN 조건 컬럼 (FK)\n├── ORDER BY 컬럼\n\n3단계: 복합 인덱스 설계\n├── 자주 함께 쓰이는 컬럼 묶기\n├── 카디널리티 순서 고려\n└── 커버링 인덱스 가능성 검토\n\n4단계: 테스트 및 모니터링\n├── EXPLAIN으로 확인\n├── 슬로우 쿼리 모니터링\n└── 불필요한 인덱스 제거\n```\n\n---\n\n## 🎯 설계 원칙\n\n### 카디널리티 (Cardinality)\n```\n카디널리티 = 고유값의 개수\n\n높음 (인덱스 효과적):\n├── user_id: 100만 가지\n├── email: 100만 가지\n└── order_id: 500만 가지\n\n낮음 (인덱스 비효율):\n├── gender: 2가지 (M/F)\n├── status: 5가지\n└── is_active: 2가지 (Y/N)\n```"
      },
      {
        "type": "code",
        "title": "💻 실전 인덱스 설계",
        "content": "### 쇼핑몰 orders 테이블\n\n```sql\n-- 테이블 구조\nCREATE TABLE orders (\n    id BIGINT PRIMARY KEY,\n    user_id BIGINT NOT NULL,\n    status ENUM('pending','paid','shipped','delivered','cancelled'),\n    total_price DECIMAL(12,2),\n    created_at TIMESTAMP,\n    updated_at TIMESTAMP\n);\n\n-- 자주 사용되는 쿼리 분석\n-- Q1: 특정 유저의 주문 목록\nSELECT * FROM orders WHERE user_id = ? ORDER BY created_at DESC;\n\n-- Q2: 상태별 주문 (관리자)\nSELECT * FROM orders WHERE status = ? ORDER BY created_at DESC;\n\n-- Q3: 기간별 매출 통계\nSELECT DATE(created_at), SUM(total_price)\nFROM orders\nWHERE created_at BETWEEN ? AND ?\nGROUP BY DATE(created_at);\n```\n\n### 인덱스 설계\n\n```sql\n-- Q1용: user_id + created_at\nCREATE INDEX idx_user_created ON orders(user_id, created_at DESC);\n\n-- Q2용: status + created_at\nCREATE INDEX idx_status_created ON orders(status, created_at DESC);\n\n-- Q3용: created_at (+ 커버링)\nCREATE INDEX idx_created_price ON orders(created_at, total_price);\n```\n\n### EXPLAIN으로 검증\n\n```sql\nEXPLAIN SELECT * FROM orders\nWHERE user_id = 1 ORDER BY created_at DESC LIMIT 10;\n\n-- 확인 항목\n-- type: ref (인덱스 사용)\n-- key: idx_user_created\n-- Extra: Using index condition\n```"
      },
      {
        "type": "tip",
        "title": "💡 인덱스 설계 체크리스트",
        "content": "### 설계 체크리스트\n\n```\n□ WHERE 조건 컬럼에 인덱스?\n□ JOIN 컬럼(FK)에 인덱스?\n□ ORDER BY 컬럼이 인덱스에 포함?\n□ 복합 인덱스 순서 최적화?\n□ 커버링 인덱스 가능?\n□ 중복/유사 인덱스 없는지?\n□ 카디널리티 낮은 단독 인덱스 없는지?\n```\n\n### 안티패턴\n\n```sql\n-- ❌ 모든 컬럼에 인덱스\nCREATE INDEX idx1 ON users(id);      -- PK 이미 있음\nCREATE INDEX idx2 ON users(name);\nCREATE INDEX idx3 ON users(email);\nCREATE INDEX idx4 ON users(phone);\nCREATE INDEX idx5 ON users(address);\n-- INSERT/UPDATE 느려짐!\n\n-- ✅ 필요한 것만\nCREATE INDEX idx_email ON users(email);  -- 로그인\nCREATE INDEX idx_phone ON users(phone);  -- 본인인증\n```"
      }
    ]
  },
  "04_인덱스/index-structure": {
    "id": "04_인덱스/index-structure",
    "title": "인덱스 구조",
    "category": "db",
    "subCategory": "04_인덱스",
    "language": "SQL",
    "description": "B-Tree, Hash 등 인덱스 내부 구조를 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 인덱스 내부 구조",
        "content": "## 🔥 B-Tree 인덱스 (가장 일반적)\n\n```\n               ┌─────────────┐\n               │  50         │  ← Root Node\n               └──────┬──────┘\n            ┌─────────┴─────────┐\n       ┌────┴────┐         ┌────┴────┐\n       │ 25      │         │ 75      │  ← Branch Node\n       └────┬────┘         └────┬────┘\n      ┌─────┴─────┐       ┌─────┴─────┐\n   ┌──┴──┐     ┌──┴──┐ ┌──┴──┐     ┌──┴──┐\n   │10,20│     │30,40│ │60,70│     │80,90│  ← Leaf Node\n   └─────┘     └─────┘ └─────┘     └─────┘\n\n특징:\n├── 정렬된 상태 유지\n├── 범위 검색 가능 (BETWEEN, >, <)\n├── O(log N) 검색 시간\n└── 대부분의 DB 기본 인덱스\n```\n\n---\n\n## 🔥 Hash 인덱스\n\n```\n해시 함수: email → 해시값\n\n\"kim@test.com\" → hash() → 위치 3\n\"lee@test.com\" → hash() → 위치 7\n\n특징:\n├── = 검색 매우 빠름 O(1)\n├── 범위 검색 불가 (>, <, BETWEEN)\n├── Memory 엔진에서 주로 사용\n└── MySQL InnoDB는 내부적으로 해시 인덱스 일부 사용\n```\n\n---\n\n## 🔥 Full-Text 인덱스\n\n```\n\"오늘 날씨가 좋습니다\" 검색\n\n역인덱스 구조:\n오늘 → [문서1, 문서5, 문서10]\n날씨 → [문서1, 문서3, 문서8]\n좋습니다 → [문서1, 문서2]\n\n특징:\n├── 텍스트 검색 특화\n├── LIKE '%keyword%' 대체\n└── MATCH ... AGAINST 문법\n```"
      },
      {
        "type": "code",
        "title": "💻 인덱스 유형별 사용",
        "content": "### B-Tree 인덱스 (기본)\n\n```sql\n-- 일반 인덱스 (B-Tree)\nCREATE INDEX idx_email ON users(email);\n\n-- 적합한 쿼리\nSELECT * FROM users WHERE email = 'kim@test.com';  -- = 검색\nSELECT * FROM users WHERE email LIKE 'kim%';       -- 접두사 검색\nSELECT * FROM users WHERE created_at > '2024-01-01';  -- 범위\nSELECT * FROM users ORDER BY created_at;           -- 정렬\n```\n\n### Hash 인덱스 (Memory 엔진)\n\n```sql\n-- Memory 테이블에서 Hash 인덱스\nCREATE TABLE cache_data (\n    key VARCHAR(100) PRIMARY KEY,\n    value TEXT\n) ENGINE=MEMORY;\n\n-- Hash 인덱스 명시\nCREATE INDEX idx_key USING HASH ON cache_data(key);\n\n-- 적합한 쿼리 (= 검색만)\nSELECT * FROM cache_data WHERE key = 'session_123';\n```\n\n### Full-Text 인덱스\n\n```sql\n-- Full-Text 인덱스 생성\nCREATE FULLTEXT INDEX idx_content ON articles(title, content);\n\n-- 검색 쿼리\nSELECT * FROM articles\nWHERE MATCH(title, content) AGAINST('파이썬 웹개발');\n\n-- 불린 모드 (AND, OR, NOT)\nSELECT * FROM articles\nWHERE MATCH(title, content) AGAINST('+파이썬 +웹개발' IN BOOLEAN MODE);\n```"
      },
      {
        "type": "tip",
        "title": "💡 인덱스 선택 가이드",
        "content": "### 언제 어떤 인덱스?\n\n```\nB-Tree (기본):\n├── 대부분의 경우\n├── =, >, <, BETWEEN, LIKE 'abc%'\n└── ORDER BY, GROUP BY\n\nHash:\n├── = 검색만 사용\n├── 캐시 테이블\n└── 메모리 테이블\n\nFull-Text:\n├── 텍스트 검색\n├── LIKE '%keyword%' 대체\n└── 게시글, 상품 검색\n```\n\n### 클러스터드 vs 논클러스터드\n\n```\n클러스터드 인덱스 (Primary Key):\n├── 테이블당 1개만\n├── 데이터가 인덱스 순서로 물리적 정렬\n└── PK 검색 가장 빠름\n\n논클러스터드 인덱스 (일반 인덱스):\n├── 테이블당 여러 개 가능\n├── 별도의 인덱스 구조\n└── Leaf Node에 PK 포함 → PK로 다시 검색\n```"
      }
    ]
  },
  "04_인덱스/index-types": {
    "id": "04_인덱스/index-types",
    "title": "인덱스 종류",
    "category": "db",
    "subCategory": "04_인덱스",
    "language": "SQL",
    "description": "단일, 복합, 커버링 인덱스 등을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 인덱스 종류 총정리",
        "content": "## 🎯 인덱스 종류\n\n### 1. 단일 컬럼 인덱스\n```sql\nCREATE INDEX idx_email ON users(email);\n-- WHERE email = 'test@test.com' 빠름\n```\n\n### 2. 복합 인덱스 (Composite)\n```sql\nCREATE INDEX idx_status_created ON orders(status, created_at);\n-- 컬럼 순서 중요! (왼쪽부터 사용)\n```\n\n### 3. 유니크 인덱스\n```sql\nCREATE UNIQUE INDEX idx_email ON users(email);\n-- 중복 불가 + 검색 최적화\n```\n\n### 4. 커버링 인덱스\n```sql\n-- 인덱스만으로 쿼리 완료 (테이블 접근 X)\nCREATE INDEX idx_covering ON orders(status, user_id, total_price);\nSELECT user_id, total_price FROM orders WHERE status = 'completed';\n```\n\n### 5. 클러스터드 인덱스\n```sql\n-- Primary Key가 자동으로 클러스터드 인덱스\n-- 테이블당 1개, 데이터 물리적 정렬\n```"
      },
      {
        "type": "code",
        "title": "💻 복합 인덱스 핵심",
        "content": "### 복합 인덱스 순서가 중요한 이유\n\n```sql\n-- 인덱스: (status, created_at)\nCREATE INDEX idx_status_created ON orders(status, created_at);\n\n-- ✅ 인덱스 사용\nWHERE status = 'completed'                    -- 첫 번째 컬럼\nWHERE status = 'completed' AND created_at > '2024-01-01'  -- 둘 다\n\n-- ❌ 인덱스 못 씀\nWHERE created_at > '2024-01-01'              -- 두 번째 컬럼만\n```\n\n### 복합 인덱스 설계 원칙\n\n```sql\n-- 1. 카디널리티 높은 것 먼저 (값 종류 많은 것)\n-- user_id: 100만 가지 vs status: 5가지\nCREATE INDEX idx_bad ON orders(status, user_id);    -- ❌\nCREATE INDEX idx_good ON orders(user_id, status);   -- ✅\n\n-- 2. 등호 조건 먼저, 범위 조건 나중에\n-- 범위 조건 이후 컬럼은 인덱스 효과 없음\nCREATE INDEX idx ON orders(status, created_at, user_id);\nWHERE status = 'completed'           -- 인덱스 O\n  AND created_at > '2024-01-01'     -- 인덱스 O (범위)\n  AND user_id = 1;                   -- 인덱스 X (범위 이후)\n```\n\n### 커버링 인덱스 예제\n\n```sql\n-- 쿼리에 필요한 모든 컬럼이 인덱스에 있으면\n-- 테이블 접근 없이 인덱스만으로 결과 반환\n\nCREATE INDEX idx_covering ON orders(status, user_id, total_price);\n\n-- 이 쿼리는 테이블 접근 X (Extra: Using index)\nSELECT user_id, SUM(total_price)\nFROM orders\nWHERE status = 'completed'\nGROUP BY user_id;\n```"
      },
      {
        "type": "tip",
        "title": "💡 인덱스 설계 가이드",
        "content": "### 복합 인덱스 vs 단일 인덱스\n\n```\n복합 인덱스 (a, b, c) 하나로 커버:\n├── WHERE a = ?\n├── WHERE a = ? AND b = ?\n├── WHERE a = ? AND b = ? AND c = ?\n\n단일 인덱스 3개보다 효율적!\n```\n\n### 실무 설계 패턴\n\n```sql\n-- 1. 자주 쓰는 쿼리 분석\nSELECT * FROM orders WHERE user_id = ? AND status = ?;\nSELECT * FROM orders WHERE status = ? ORDER BY created_at;\n\n-- 2. 인덱스 설계\nCREATE INDEX idx_user_status ON orders(user_id, status);\nCREATE INDEX idx_status_created ON orders(status, created_at);\n```\n\n### 인덱스 개수 제한\n\n```\n권장: 테이블당 5~10개 이하\n├── 너무 많으면 INSERT/UPDATE 느림\n├── 비슷한 인덱스 통합 검토\n└── 사용 안 하는 인덱스 삭제\n```"
      }
    ]
  },
  "05_트랜잭션/acid": {
    "id": "05_트랜잭션/acid",
    "title": "ACID 원칙",
    "category": "db",
    "subCategory": "05_트랜잭션",
    "language": "SQL",
    "description": "트랜잭션의 4가지 특성을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 ACID란?",
        "content": "## 🔥 한 줄 요약\n> **트랜잭션이 지켜야 할 4가지 약속** - 데이터 안전의 핵심!\n\n---\n\n## 🎯 ACID 상세\n\n### A - Atomicity (원자성)\n```\n\"다 되거나, 다 안 되거나\"\n\n송금: 출금 + 입금\n├── 둘 다 성공 → OK\n└── 하나만 성공 → 둘 다 취소\n\n= 쪼갤 수 없는 최소 단위\n```\n\n### C - Consistency (일관성)\n```\n\"규칙을 항상 만족\"\n\n계좌 잔액 >= 0 규칙\n├── 출금 전: 잔액 100만원 ✅\n├── 출금 후: 잔액 -10만원 ❌\n└── 규칙 위반 → 트랜잭션 실패\n\n= 데이터 무결성 유지\n```\n\n### I - Isolation (격리성)\n```\n\"다른 트랜잭션과 간섭 없음\"\n\nA 트랜잭션: 재고 10 → 9\nB 트랜잭션: 재고 10 → 9 (동시에)\n\n격리성 보장:\n├── A 먼저 → 재고 9\n├── B 나중 → 재고 8\n└── 순서대로 처리\n\n= 동시성 제어\n```\n\n### D - Durability (지속성)\n```\n\"커밋하면 영구 보존\"\n\nCOMMIT 후:\n├── 서버 다운 → 데이터 유지\n├── 정전 → 데이터 유지\n└── 재부팅 → 데이터 유지\n\n= 로그 기반 복구\n```"
      },
      {
        "type": "code",
        "title": "💻 ACID 위반 사례",
        "content": "### Atomicity 위반 예시\n\n```sql\n-- ❌ 트랜잭션 없이 송금\nUPDATE accounts SET balance = balance - 100000 WHERE id = 1;\n-- 여기서 에러 발생하면?\nUPDATE accounts SET balance = balance + 100000 WHERE id = 2;\n\n-- ✅ 트랜잭션으로 원자성 보장\nSTART TRANSACTION;\nUPDATE accounts SET balance = balance - 100000 WHERE id = 1;\nUPDATE accounts SET balance = balance + 100000 WHERE id = 2;\nCOMMIT;\n```\n\n### Consistency 위반 예시\n\n```sql\n-- 제약조건으로 일관성 보장\nALTER TABLE accounts\nADD CONSTRAINT chk_balance CHECK (balance >= 0);\n\n-- 이제 음수 잔액 불가\nUPDATE accounts SET balance = balance - 200000 WHERE id = 1;\n-- Error: Check constraint 'chk_balance' is violated\n```\n\n### Isolation 문제 예시\n\n```sql\n-- 동시에 같은 상품 주문 시\n-- Transaction A\nSELECT stock FROM products WHERE id = 1;  -- 결과: 1\n-- Transaction B\nSELECT stock FROM products WHERE id = 1;  -- 결과: 1\n\n-- A: 재고 있네? 주문!\nUPDATE products SET stock = 0 WHERE id = 1;\n-- B: 나도 재고 있네? 주문!\nUPDATE products SET stock = -1 WHERE id = 1;  -- 💀 음수 재고!\n\n-- 해결: FOR UPDATE 락\nSELECT stock FROM products WHERE id = 1 FOR UPDATE;\n```"
      },
      {
        "type": "tip",
        "title": "💡 면접 대비",
        "content": "### 자주 묻는 질문\n\n```\nQ: ACID 설명해주세요\nA:\n- Atomicity: 원자성, 전부 성공 or 전부 실패\n- Consistency: 일관성, 규칙 항상 만족\n- Isolation: 격리성, 트랜잭션 간 간섭 없음\n- Durability: 지속성, 커밋 후 영구 보존\n\nQ: ACID 중 가장 중요한 건?\nA: 상황에 따라 다름\n- 금융: Consistency, Durability\n- SNS: Availability (ACID 일부 완화)\n\nQ: NoSQL은 ACID 안 지키나요?\nA: BASE 모델 사용 (Eventually Consistent)\n   최근엔 MongoDB도 트랜잭션 지원\n```"
      }
    ]
  },
  "05_트랜잭션/isolation-level": {
    "id": "05_트랜잭션/isolation-level",
    "title": "격리 수준",
    "category": "db",
    "subCategory": "05_트랜잭션",
    "language": "SQL",
    "description": "트랜잭션 격리 수준의 종류와 특징을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 격리 수준이란?",
        "content": "## 🔥 한 줄 요약\n> **동시 트랜잭션 간 간섭 수준 설정** - 높을수록 안전, 낮을수록 빠름\n\n---\n\n## 🎯 격리 수준 4단계\n\n### 1. READ UNCOMMITTED (가장 낮음)\n```\n커밋 안 된 데이터도 읽음\n→ Dirty Read 발생\n→ 거의 안 씀\n```\n\n### 2. READ COMMITTED (PostgreSQL 기본)\n```\n커밋된 데이터만 읽음\n→ Dirty Read 해결\n→ Non-Repeatable Read 발생\n```\n\n### 3. REPEATABLE READ (MySQL 기본)\n```\n트랜잭션 시작 시점 데이터 읽음\n→ Non-Repeatable Read 해결\n→ Phantom Read 발생 가능\n```\n\n### 4. SERIALIZABLE (가장 높음)\n```\n완전 순차 실행처럼 동작\n→ 모든 문제 해결\n→ 성능 최악\n```\n\n---\n\n## 🎯 발생 가능한 문제\n\n| 격리 수준 | Dirty Read | Non-Repeatable | Phantom |\n|----------|------------|----------------|---------|\n| READ UNCOMMITTED | O | O | O |\n| READ COMMITTED | X | O | O |\n| REPEATABLE READ | X | X | △ |\n| SERIALIZABLE | X | X | X |"
      },
      {
        "type": "code",
        "title": "💻 격리 수준 예제",
        "content": "### Dirty Read (READ UNCOMMITTED)\n\n```sql\n-- 트랜잭션 A\nSTART TRANSACTION;\nUPDATE accounts SET balance = 0 WHERE id = 1;\n-- 아직 COMMIT 안 함\n\n-- 트랜잭션 B (READ UNCOMMITTED)\nSELECT balance FROM accounts WHERE id = 1;\n-- 결과: 0 (커밋 안 된 데이터!)\n\n-- 트랜잭션 A\nROLLBACK;  -- 취소!\n-- B가 읽은 0은 잘못된 데이터였음 (Dirty Read)\n```\n\n### Non-Repeatable Read (READ COMMITTED)\n\n```sql\n-- 트랜잭션 A\nSTART TRANSACTION;\nSELECT balance FROM accounts WHERE id = 1;\n-- 결과: 100만원\n\n-- 트랜잭션 B\nUPDATE accounts SET balance = 50 WHERE id = 1;\nCOMMIT;\n\n-- 트랜잭션 A (같은 트랜잭션)\nSELECT balance FROM accounts WHERE id = 1;\n-- 결과: 50만원 (값이 바뀜!)\n```\n\n### 격리 수준 설정\n\n```sql\n-- 현재 격리 수준 확인\nSELECT @@transaction_isolation;\n-- MySQL 8.0 이전: @@tx_isolation\n\n-- 세션 격리 수준 변경\nSET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\n\n-- 글로벌 격리 수준 변경\nSET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n```\n\n### 실전: 재고 관리\n\n```sql\n-- REPEATABLE READ에서도 안전한 패턴\nSTART TRANSACTION;\n\n-- FOR UPDATE로 락 획득\nSELECT stock FROM products WHERE id = 1 FOR UPDATE;\n\n-- 재고 확인 후 차감\nUPDATE products SET stock = stock - 1 WHERE id = 1 AND stock > 0;\n\n-- 영향받은 행이 0이면 재고 부족\n-- affected_rows == 0 → 롤백\n\nCOMMIT;\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 가이드",
        "content": "### 격리 수준 선택\n\n```\nREAD COMMITTED:\n├── PostgreSQL 기본\n├── 대부분의 웹 애플리케이션\n└── 성능과 안정성 균형\n\nREPEATABLE READ:\n├── MySQL 기본\n├── 금융, 재고 관리\n└── 더 강한 일관성\n\nSERIALIZABLE:\n├── 매우 중요한 데이터\n├── 성능 희생 감수\n└── 거의 안 씀\n```\n\n### 실무 팁\n\n```\n1. DB 기본 격리 수준 사용 (보통 충분)\n2. 중요한 부분은 FOR UPDATE 락\n3. 데드락 대비 코드 작성\n4. 트랜잭션 짧게 유지\n```"
      }
    ]
  },
  "05_트랜잭션/lock": {
    "id": "05_트랜잭션/lock",
    "title": "DB Lock",
    "category": "db",
    "subCategory": "05_트랜잭션",
    "language": "SQL",
    "description": "데이터베이스 락의 종류와 동작을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 Lock이란?",
        "content": "## 🔥 한 줄 요약\n> **동시 접근 충돌 방지 장치** - 화장실 문 잠금과 같음!\n\n---\n\n## 💡 왜 필요한가?\n\n### 실제 사고:\n```\n🔴 코인 거래소 해킹 (2023)\n├── 동시에 같은 코인 출금 요청\n├── 잔액 체크 → 둘 다 통과\n├── 출금 실행 → 둘 다 성공\n├── 잔액 100만원인데 200만원 출금\n└── 하루에 100억 손실!\n\n🟢 Lock 사용\n├── 첫 번째 요청이 Lock 획득\n├── 두 번째 요청 대기\n├── 첫 번째 완료 후 두 번째 처리\n└── 안전!\n```\n\n---\n\n## 🎯 Lock 종류\n\n### Shared Lock (S Lock, 공유 락)\n```\n읽기용 락\n├── 여러 트랜잭션이 동시에 획득 가능\n├── 다른 S Lock과 호환\n└── X Lock과 충돌\n\nSELECT ... LOCK IN SHARE MODE\n```\n\n### Exclusive Lock (X Lock, 배타 락)\n```\n쓰기용 락\n├── 한 트랜잭션만 획득 가능\n├── 모든 락과 충돌\n└── 데이터 수정 시 자동 획득\n\nSELECT ... FOR UPDATE\n```\n\n### 락 호환성\n```\n        | S Lock | X Lock |\n--------|--------|--------|\nS Lock  |   O    |   X    |\nX Lock  |   X    |   X    |\n```"
      },
      {
        "type": "code",
        "title": "💻 Lock 실전",
        "content": "### SELECT FOR UPDATE\n\n```sql\n-- 트랜잭션 A\nSTART TRANSACTION;\nSELECT * FROM products WHERE id = 1 FOR UPDATE;\n-- id=1 행에 X Lock 획득\n\n-- 트랜잭션 B\nSELECT * FROM products WHERE id = 1 FOR UPDATE;\n-- 대기... (A가 Lock 해제할 때까지)\n\n-- 트랜잭션 A\nUPDATE products SET stock = stock - 1 WHERE id = 1;\nCOMMIT;  -- Lock 해제\n\n-- 트랜잭션 B\n-- 이제 진행 가능\n```\n\n### 재고 차감 안전 패턴\n\n```sql\nSTART TRANSACTION;\n\n-- 1. 재고 조회 + Lock\nSELECT stock FROM products WHERE id = 100 FOR UPDATE;\n\n-- 2. 재고 확인 (애플리케이션)\n-- stock >= 주문수량 확인\n\n-- 3. 재고 차감\nUPDATE products SET stock = stock - 1 WHERE id = 100;\n\n-- 4. 주문 생성\nINSERT INTO orders (product_id, quantity) VALUES (100, 1);\n\nCOMMIT;\n```\n\n### 데드락 예방\n\n```sql\n-- ❌ 데드락 발생 가능\n-- 트랜잭션 A: products → users 순서\n-- 트랜잭션 B: users → products 순서\n\n-- ✅ 항상 같은 순서로 Lock\n-- 모든 트랜잭션: products → users 순서\nSTART TRANSACTION;\nSELECT * FROM products WHERE id = 1 FOR UPDATE;\nSELECT * FROM users WHERE id = 1 FOR UPDATE;\n-- ...\nCOMMIT;\n```\n\n### 락 대기 타임아웃\n\n```sql\n-- 락 대기 시간 설정 (초)\nSET innodb_lock_wait_timeout = 5;\n\n-- 타임아웃 시 에러 발생\n-- Error: Lock wait timeout exceeded\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### 데드락 대처\n\n```python\n# Python 예제\nimport mysql.connector\nfrom mysql.connector import errors\n\nMAX_RETRIES = 3\n\nfor attempt in range(MAX_RETRIES):\n    try:\n        # 트랜잭션 실행\n        conn.start_transaction()\n        # ...\n        conn.commit()\n        break\n    except errors.DatabaseError as e:\n        if e.errno == 1213:  # Deadlock\n            conn.rollback()\n            time.sleep(0.1 * attempt)  # 점진적 대기\n            continue\n        raise\n```\n\n### Lock 모니터링\n\n```sql\n-- 현재 락 상태 (MySQL)\nSHOW ENGINE INNODB STATUS;\n\n-- 락 대기 쿼리\nSELECT * FROM information_schema.INNODB_LOCKS;\nSELECT * FROM information_schema.INNODB_LOCK_WAITS;\n```"
      }
    ]
  },
  "05_트랜잭션/mvcc": {
    "id": "05_트랜잭션/mvcc",
    "title": "MVCC",
    "category": "db",
    "subCategory": "05_트랜잭션",
    "language": "SQL",
    "description": "Multi-Version Concurrency Control을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 MVCC란?",
        "content": "## 🔥 한 줄 요약\n> **여러 버전의 데이터를 유지** - 읽기와 쓰기가 서로 안 막힘!\n\n---\n\n## 💡 왜 필요한가?\n\n### Lock 방식의 문제\n```\n❌ Lock만 사용하면\n├── 쓰기 중 → 읽기 대기\n├── 읽기 중 → 쓰기 대기\n└── 동시성 떨어짐\n\n✅ MVCC 사용하면\n├── 쓰기 중 → 읽기는 이전 버전 읽음\n├── 읽기 중 → 쓰기 가능\n└── 동시성 향상!\n```\n\n---\n\n## 🎯 MVCC 동작 원리\n\n```\n1. 데이터 수정 시 새 버전 생성\n2. 이전 버전도 유지 (Undo Log)\n3. 각 트랜잭션은 시작 시점의 스냅샷 읽음\n4. 커밋되면 새 버전이 최신이 됨\n\n시간 →\n[V1] ────┬────────────────────────\n         │ UPDATE\n[V2]     └─────┬──────────────────\n               │ 트랜잭션 A 시작\n               │ (V2 읽음)\n[V3]           └────┬─────────────\n                    │ 트랜잭션 B 시작\n                    │ (V3 읽음)\n\nA는 V2, B는 V3 읽음 → 서로 안 막힘!\n```"
      },
      {
        "type": "code",
        "title": "💻 MVCC 동작",
        "content": "### MVCC 예제\n\n```sql\n-- 초기 데이터\n-- products: id=1, name='iPhone', price=1000000\n\n-- 트랜잭션 A 시작\nSTART TRANSACTION;\nSELECT * FROM products WHERE id = 1;\n-- 결과: price = 1000000\n\n-- 트랜잭션 B (다른 세션)\nSTART TRANSACTION;\nUPDATE products SET price = 1100000 WHERE id = 1;\nCOMMIT;\n\n-- 트랜잭션 A (REPEATABLE READ)\nSELECT * FROM products WHERE id = 1;\n-- 결과: price = 1000000 (여전히!)\n-- MVCC 덕분에 시작 시점 스냅샷 읽음\n\nCOMMIT;\n-- A 종료 후 새로 조회하면 1100000\n```\n\n### 버전 확인 (PostgreSQL)\n\n```sql\n-- PostgreSQL에서 버전 정보 확인\nSELECT xmin, xmax, * FROM products WHERE id = 1;\n-- xmin: 생성 트랜잭션 ID\n-- xmax: 삭제 트랜잭션 ID (0이면 유효)\n```\n\n### Undo Log (MySQL)\n\n```\nUPDATE 실행 시:\n1. 현재 데이터를 Undo Log에 복사\n2. 테이블에 새 데이터 기록\n3. 트랜잭션 정보 기록\n\n롤백 시:\n1. Undo Log에서 이전 데이터 복원\n\n읽기 시 (REPEATABLE READ):\n1. 현재 데이터 확인\n2. 내 트랜잭션 시작 이후 수정이면\n3. Undo Log에서 이전 버전 읽음\n```"
      },
      {
        "type": "tip",
        "title": "💡 MVCC 주의사항",
        "content": "### MVCC 오버헤드\n\n```\n장점:\n├── 읽기/쓰기 동시 처리\n├── 높은 동시성\n└── 데드락 감소\n\n단점:\n├── 저장 공간 증가 (여러 버전)\n├── Vacuum 필요 (PostgreSQL)\n├── Undo Log 관리 (MySQL)\n└── 긴 트랜잭션 주의\n```\n\n### 긴 트랜잭션 문제\n\n```sql\n-- ❌ 긴 트랜잭션\nSTART TRANSACTION;\nSELECT * FROM table1;\n-- ... 5분간 다른 작업 ...\nSELECT * FROM table1;  -- 여전히 5분 전 스냅샷\nCOMMIT;\n\n문제:\n├── Undo Log 계속 쌓임\n├── 저장 공간 증가\n└── 성능 저하\n```"
      }
    ]
  },
  "05_트랜잭션/transaction-concept": {
    "id": "05_트랜잭션/transaction-concept",
    "title": "트랜잭션 개념",
    "category": "db",
    "subCategory": "05_트랜잭션",
    "language": "SQL",
    "description": "트랜잭션의 정의와 필요성을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 트랜잭션이란?",
        "content": "## 🔥 한 줄 요약\n> **쪼갤 수 없는 작업 단위** - \"다 되거나, 다 안 되거나\"\n\n---\n\n## 💡 왜 배워야 하나?\n\n### 실제 사고:\n```\n🔴 은행 송금 시나리오\n1. A 계좌에서 100만원 출금 ✅\n2. 서버 다운! 💥\n3. B 계좌 입금 안 됨 ❌\n→ 100만원 증발!\n\n🟢 트랜잭션 사용\n1. 트랜잭션 시작\n2. A 계좌 출금\n3. B 계좌 입금\n4. 둘 다 성공 → COMMIT (확정)\n   하나라도 실패 → ROLLBACK (취소)\n→ 돈 안전!\n```\n\n---\n\n## 🎯 핵심 개념\n\n### 트랜잭션 흐름\n\n```\nSTART TRANSACTION\n    ↓\n[쿼리 1] INSERT INTO orders ...\n    ↓\n[쿼리 2] UPDATE inventory SET stock = stock - 1 ...\n    ↓\n[쿼리 3] INSERT INTO payments ...\n    ↓\n성공 → COMMIT (DB에 반영)\n실패 → ROLLBACK (모두 취소)\n```\n\n### 트랜잭션 없으면?\n\n```\n❌ 주문 처리 중 에러\n1. orders에 주문 생성 ✅\n2. inventory 재고 차감 ✅\n3. payments 결제 처리 💥 에러!\n\n결과:\n- 주문은 있는데 결제 안 됨\n- 재고는 줄었는데 돈 안 받음\n- 데이터 꼬임 → 수동 복구 필요\n```"
      },
      {
        "type": "code",
        "title": "💻 트랜잭션 사용",
        "content": "### 기본 문법\n\n```sql\n-- 트랜잭션 시작\nSTART TRANSACTION;\n-- 또는\nBEGIN;\n\n-- 쿼리 실행\nINSERT INTO orders (user_id, total_price) VALUES (1, 50000);\nUPDATE products SET stock = stock - 1 WHERE id = 100;\n\n-- 확정 또는 취소\nCOMMIT;    -- 성공: DB에 영구 반영\n-- ROLLBACK;  -- 실패: 모든 변경 취소\n```\n\n### 실전 예제: 주문 처리\n\n```sql\nSTART TRANSACTION;\n\n-- 1. 재고 확인 (FOR UPDATE로 락)\nSELECT stock FROM products WHERE id = 100 FOR UPDATE;\n\n-- 2. 재고 부족하면 롤백\n-- (애플리케이션에서 체크)\n\n-- 3. 주문 생성\nINSERT INTO orders (user_id, total_price, status)\nVALUES (1, 50000, 'pending');\n\nSET @order_id = LAST_INSERT_ID();\n\n-- 4. 주문 상세 생성\nINSERT INTO order_items (order_id, product_id, quantity, price)\nVALUES (@order_id, 100, 1, 50000);\n\n-- 5. 재고 차감\nUPDATE products SET stock = stock - 1 WHERE id = 100;\n\n-- 6. 결제 기록\nINSERT INTO payments (order_id, amount, status)\nVALUES (@order_id, 50000, 'completed');\n\n-- 모두 성공하면 커밋\nCOMMIT;\n```\n\n### Python에서 트랜잭션\n\n```python\nimport mysql.connector\n\nconn = mysql.connector.connect(...)\ncursor = conn.cursor()\n\ntry:\n    # 자동 커밋 비활성화\n    conn.autocommit = False\n\n    cursor.execute(\"INSERT INTO orders ...\")\n    cursor.execute(\"UPDATE products ...\")\n    cursor.execute(\"INSERT INTO payments ...\")\n\n    # 모두 성공\n    conn.commit()\n    print(\"주문 완료!\")\n\nexcept Exception as e:\n    # 에러 발생 시 롤백\n    conn.rollback()\n    print(f\"에러 발생, 롤백: {e}\")\n\nfinally:\n    cursor.close()\n    conn.close()\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### 트랜잭션 범위\n\n```\n❌ 너무 긴 트랜잭션\n├── 락 오래 잡고 있음\n├── 다른 쿼리 대기\n└── 데드락 가능성 증가\n\n✅ 짧게 유지\n├── 필요한 쿼리만 포함\n├── 외부 API 호출 제외\n└── 빠르게 COMMIT\n```\n\n### 자동 커밋 주의\n\n```sql\n-- MySQL 기본: 자동 커밋 ON\n-- 모든 쿼리가 즉시 COMMIT됨\n\n-- 확인\nSHOW VARIABLES LIKE 'autocommit';\n\n-- 자동 커밋 끄기 (세션)\nSET autocommit = 0;\n```"
      }
    ]
  },
  "06_설계/denormalization": {
    "id": "06_설계/denormalization",
    "title": "역정규화",
    "category": "db",
    "subCategory": "06_설계",
    "language": "SQL",
    "description": "성능을 위한 역정규화를 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 역정규화란?",
        "content": "## 🔥 한 줄 요약\n> **성능을 위해 의도적으로 중복 허용** - \"정규화의 반대\"\n\n---\n\n## 💡 왜 필요한가?\n\n```\n❌ 과도한 정규화 문제\n├── 조회 시 JOIN 너무 많음\n├── 성능 저하\n└── 쿼리 복잡\n\n✅ 역정규화로 해결\n├── 자주 함께 조회되는 데이터 합침\n├── 계산된 값 미리 저장\n└── 조회 성능 향상\n```\n\n---\n\n## 🎯 역정규화 기법\n\n### 1. 컬럼 추가 (파생 컬럼)\n```sql\n-- 주문 테이블에 총액 추가\norders.total_price\n-- order_items에서 매번 계산 → 미리 저장\n\n-- 유저 테이블에 주문 수 추가\nusers.order_count\n-- orders 집계 → 미리 저장\n```\n\n### 2. 테이블 합치기\n```sql\n-- users + user_profiles 합침\n-- 1:1 관계이고 항상 함께 조회\n```\n\n### 3. 테이블 복제\n```sql\n-- 읽기 전용 테이블\n-- 원본: OLTP용, 복제: 통계용\n```\n\n### 4. 요약 테이블\n```sql\n-- daily_sales: 일별 매출 요약\n-- monthly_stats: 월별 통계 요약\n```"
      },
      {
        "type": "code",
        "title": "💻 역정규화 예제",
        "content": "### 파생 컬럼 추가\n\n```sql\n-- 정규화: 매번 계산\nSELECT\n    u.id,\n    u.name,\n    COUNT(o.id) AS order_count,\n    SUM(o.total_price) AS total_spent\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nGROUP BY u.id, u.name;\n\n-- 역정규화: 미리 저장\nALTER TABLE users ADD COLUMN order_count INT DEFAULT 0;\nALTER TABLE users ADD COLUMN total_spent DECIMAL(12,2) DEFAULT 0;\n\n-- 주문 생성 시 업데이트 (트리거 또는 애플리케이션)\nUPDATE users\nSET order_count = order_count + 1,\n    total_spent = total_spent + 50000\nWHERE id = 1;\n```\n\n### 요약 테이블\n\n```sql\n-- 일별 매출 요약 테이블\nCREATE TABLE daily_sales (\n    date DATE PRIMARY KEY,\n    total_orders INT,\n    total_revenue DECIMAL(15,2),\n    avg_order_value DECIMAL(10,2),\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n);\n\n-- 매일 집계 (배치)\nINSERT INTO daily_sales (date, total_orders, total_revenue, avg_order_value)\nSELECT\n    DATE(created_at),\n    COUNT(*),\n    SUM(total_price),\n    AVG(total_price)\nFROM orders\nWHERE DATE(created_at) = CURDATE() - INTERVAL 1 DAY\nON DUPLICATE KEY UPDATE\n    total_orders = VALUES(total_orders),\n    total_revenue = VALUES(total_revenue),\n    avg_order_value = VALUES(avg_order_value);\n```\n\n### 트리거로 동기화\n\n```sql\n-- 주문 생성 시 유저 통계 업데이트\nDELIMITER //\nCREATE TRIGGER after_order_insert\nAFTER INSERT ON orders\nFOR EACH ROW\nBEGIN\n    UPDATE users\n    SET order_count = order_count + 1,\n        total_spent = total_spent + NEW.total_price\n    WHERE id = NEW.user_id;\nEND //\nDELIMITER ;\n```"
      },
      {
        "type": "tip",
        "title": "💡 역정규화 가이드",
        "content": "### 언제 역정규화?\n\n```\n✅ 역정규화 고려\n├── 읽기 >> 쓰기 (조회 많음)\n├── JOIN이 너무 많음\n├── 응답 시간 중요\n├── 집계 쿼리 빈번\n\n❌ 역정규화 주의\n├── 쓰기 많으면 동기화 부담\n├── 데이터 불일치 위험\n├── 저장 공간 증가\n```\n\n### 동기화 방법\n\n```\n1. 트리거: 자동, 실시간, DB 부하\n2. 애플리케이션: 명시적, 누락 위험\n3. 배치: 주기적, 지연 있음\n4. CDC: 변경 감지, 복잡\n\n상황에 맞게 선택!\n```"
      }
    ]
  },
  "06_설계/erd-concept": {
    "id": "06_설계/erd-concept",
    "title": "ERD 설계",
    "category": "db",
    "subCategory": "06_설계",
    "language": "SQL",
    "description": "Entity-Relationship Diagram을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 ERD란?",
        "content": "## 🔥 한 줄 요약\n> **테이블 관계를 시각화한 다이어그램** - DB 설계의 청사진!\n\n---\n\n## 🎯 ERD 구성요소\n\n### Entity (엔티티)\n```\n= 테이블\n┌───────────────┐\n│    users      │\n├───────────────┤\n│ id (PK)       │\n│ name          │\n│ email         │\n└───────────────┘\n```\n\n### Attribute (속성)\n```\n= 컬럼\n├── id: Primary Key\n├── name: 필수\n├── email: Unique\n└── phone: 선택\n```\n\n### Relationship (관계)\n```\n1:1  ──────  (일대일)\n1:N  ──────< (일대다)\nN:M  >────< (다대다)\n```\n\n---\n\n## 🎯 표기법 종류\n\n### IE 표기법 (Crow's Foot)\n```\nusers ──────<──── orders\n      1          N (까마귀 발)\n\n| = 1개\n○ = 0 또는 1개\n< = 다수 (까마귀 발)\n```\n\n### Chen 표기법\n```\n[users]──<주문>──[orders]\n  1                N\n```"
      },
      {
        "type": "code",
        "title": "💻 ERD 예제",
        "content": "### 쇼핑몰 ERD (텍스트)\n\n```\n┌─────────────┐       ┌─────────────┐\n│   users     │       │  products   │\n├─────────────┤       ├─────────────┤\n│ *id         │       │ *id         │\n│ email       │       │ name        │\n│ name        │       │ price       │\n│ phone       │       │ stock       │\n└──────┬──────┘       └──────┬──────┘\n       │ 1                   │ 1\n       │                     │\n       │ N                   │ N\n┌──────┴──────┐       ┌──────┴──────┐\n│   orders    │       │ order_items │\n├─────────────┤       ├─────────────┤\n│ *id         │───────│ *id         │\n│ user_id(FK) │  1  N │ order_id(FK)│\n│ total_price │       │ product_id  │\n│ status      │       │ quantity    │\n│ created_at  │       │ price       │\n└─────────────┘       └─────────────┘\n```\n\n### ERD 도구 사용\n\n```sql\n-- MySQL Workbench ERD → SQL 생성\n-- dbdiagram.io, ERDCloud 등\n\n-- 예: dbdiagram.io 문법\nTable users {\n  id bigint [pk, increment]\n  email varchar(100) [not null, unique]\n  name varchar(50) [not null]\n}\n\nTable orders {\n  id bigint [pk, increment]\n  user_id bigint [not null, ref: > users.id]\n  total_price decimal(12,2)\n  status enum('pending','paid','shipped')\n}\n```\n\n### ERD에서 SQL 생성\n\n```sql\n-- ERD 관계를 SQL로 변환\nCREATE TABLE users (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    email VARCHAR(100) NOT NULL UNIQUE,\n    name VARCHAR(50) NOT NULL\n);\n\nCREATE TABLE orders (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    user_id BIGINT NOT NULL,\n    total_price DECIMAL(12,2),\n    status ENUM('pending','paid','shipped'),\n    FOREIGN KEY (user_id) REFERENCES users(id)\n);\n```"
      },
      {
        "type": "tip",
        "title": "💡 ERD 설계 팁",
        "content": "### ERD 도구 추천\n\n```\n무료:\n├── dbdiagram.io (웹, 추천)\n├── ERDCloud (한국어)\n├── draw.io\n└── MySQL Workbench\n\n유료:\n├── DataGrip\n├── Navicat\n└── ERwin\n```\n\n### ERD 설계 순서\n\n```\n1. 엔티티 도출 (명사 추출)\n2. 속성 정의 (각 엔티티의 컬럼)\n3. 관계 파악 (동사로 연결)\n4. 정규화 검토\n5. PK/FK 설정\n6. 인덱스 계획\n```"
      }
    ]
  },
  "06_설계/normalization": {
    "id": "06_설계/normalization",
    "title": "정규화",
    "category": "db",
    "subCategory": "06_설계",
    "language": "SQL",
    "description": "데이터베이스 정규화를 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 정규화란?",
        "content": "## 🔥 한 줄 요약\n> **중복을 제거하고 데이터를 구조화** - \"한 곳에서만 관리\"\n\n---\n\n## 💡 왜 필요한가?\n\n```\n❌ 정규화 안 된 테이블\n┌────┬────────┬──────────┬──────────────┐\n│ 주문 │ 고객명  │ 고객전화  │ 상품명        │\n├────┼────────┼──────────┼──────────────┤\n│ 1  │ 김철수  │ 010-1234 │ 아이폰        │\n│ 2  │ 김철수  │ 010-1234 │ 맥북         │\n│ 3  │ 김철수  │ 010-1234 │ 에어팟        │\n└────┴────────┴──────────┴──────────────┘\n\n문제:\n├── 김철수 정보가 3번 중복\n├── 전화번호 바뀌면 3곳 수정\n├── 수정 누락 시 데이터 불일치\n└── 저장 공간 낭비\n```\n\n---\n\n## 🎯 정규화 단계\n\n### 1NF (제1정규형)\n```\n원자값만 가져야 함 (다중 값 X)\n\n❌ 전화번호: \"010-1234, 010-5678\"\n✅ 전화번호 테이블 분리\n```\n\n### 2NF (제2정규형)\n```\n부분 함수 종속 제거\n\n❌ (주문ID, 상품ID) → 상품명\n   상품명은 상품ID에만 종속\n✅ 상품 테이블 분리\n```\n\n### 3NF (제3정규형)\n```\n이행적 함수 종속 제거\n\n❌ 주문 → 고객ID → 고객명\n   고객명은 고객ID에 종속\n✅ 고객 테이블 분리\n```"
      },
      {
        "type": "code",
        "title": "💻 정규화 예제",
        "content": "### Before: 비정규화\n\n```sql\n-- 모든 정보가 하나의 테이블에\nCREATE TABLE orders_denormalized (\n    order_id INT,\n    customer_name VARCHAR(50),\n    customer_phone VARCHAR(20),\n    customer_email VARCHAR(100),\n    product_name VARCHAR(100),\n    product_price INT,\n    quantity INT\n);\n```\n\n### After: 3NF 정규화\n\n```sql\n-- 고객 테이블\nCREATE TABLE customers (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(50) NOT NULL,\n    phone VARCHAR(20),\n    email VARCHAR(100)\n);\n\n-- 상품 테이블\nCREATE TABLE products (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(100) NOT NULL,\n    price INT NOT NULL\n);\n\n-- 주문 테이블\nCREATE TABLE orders (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    customer_id BIGINT NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (customer_id) REFERENCES customers(id)\n);\n\n-- 주문 상세 테이블\nCREATE TABLE order_items (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    order_id BIGINT NOT NULL,\n    product_id BIGINT NOT NULL,\n    quantity INT NOT NULL,\n    price INT NOT NULL,  -- 주문 시점 가격\n    FOREIGN KEY (order_id) REFERENCES orders(id),\n    FOREIGN KEY (product_id) REFERENCES products(id)\n);\n```\n\n### 정규화 확인\n\n```sql\n-- 데이터 조회 (JOIN 필요)\nSELECT\n    o.id AS order_id,\n    c.name AS customer,\n    p.name AS product,\n    oi.quantity,\n    oi.price\nFROM orders o\nJOIN customers c ON o.customer_id = c.id\nJOIN order_items oi ON o.id = oi.order_id\nJOIN products p ON oi.product_id = p.id;\n```"
      },
      {
        "type": "tip",
        "title": "💡 정규화 가이드",
        "content": "### 어디까지 정규화?\n\n```\n보통 3NF까지 (실무 표준)\n├── 1NF: 원자값\n├── 2NF: 완전 함수 종속\n└── 3NF: 이행 종속 제거\n\nBCNF 이상은 특수 상황에서만\n```\n\n### 정규화 Trade-off\n\n```\n정규화 ↑\n├── 중복 ↓\n├── 무결성 ↑\n├── 저장공간 ↓\n└── JOIN 필요 ↑ (성능 ↓)\n\n역정규화 ↑\n├── 중복 ↑\n├── 조회 성능 ↑\n├── 저장공간 ↑\n└── JOIN 불필요\n```"
      }
    ]
  },
  "06_설계/pk-fk": {
    "id": "06_설계/pk-fk",
    "title": "PK와 FK",
    "category": "db",
    "subCategory": "06_설계",
    "language": "SQL",
    "description": "Primary Key와 Foreign Key의 개념과 사용법을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 PK와 FK",
        "content": "## 🔥 한 줄 요약\n> **PK = 신분증, FK = 연결고리** - 테이블 관계의 핵심!\n\n---\n\n## 🎯 Primary Key (기본키)\n\n```\n특징:\n├── 유일한 식별자 (중복 불가)\n├── NULL 불가\n├── 테이블당 1개만\n└── 자동으로 인덱스 생성\n\n예시:\n├── users.id\n├── orders.id\n└── products.id\n```\n\n### Foreign Key (외래키)\n\n```\n특징:\n├── 다른 테이블의 PK 참조\n├── 관계 형성\n├── 참조 무결성 보장\n└── NULL 가능 (선택적 관계)\n\n예시:\n├── orders.user_id → users.id\n├── order_items.product_id → products.id\n└── comments.post_id → posts.id\n```\n\n---\n\n## 🎯 관계 표현\n\n```\nusers (1) ──────< orders (N)\n  │                  │\n  PK: id             FK: user_id\n                     PK: id\n                        │\n                        ∨\norder_items (N) ──────< orders\n  FK: order_id\n  FK: product_id\n       │\n       ∨\nproducts (1)\n  PK: id\n```"
      },
      {
        "type": "code",
        "title": "💻 PK/FK 설정",
        "content": "### 테이블 생성\n\n```sql\n-- PK 설정\nCREATE TABLE users (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    email VARCHAR(100) NOT NULL UNIQUE,\n    name VARCHAR(50) NOT NULL\n);\n\n-- FK 설정\nCREATE TABLE orders (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    user_id BIGINT NOT NULL,\n    total_price DECIMAL(12,2) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n\n    -- FK 제약조건\n    FOREIGN KEY (user_id) REFERENCES users(id)\n        ON DELETE CASCADE\n        ON UPDATE CASCADE\n);\n```\n\n### ON DELETE / ON UPDATE 옵션\n\n```sql\n-- CASCADE: 부모 삭제 시 자식도 삭제\nFOREIGN KEY (user_id) REFERENCES users(id)\n    ON DELETE CASCADE;\n\n-- SET NULL: 부모 삭제 시 NULL로 설정\nFOREIGN KEY (user_id) REFERENCES users(id)\n    ON DELETE SET NULL;\n\n-- RESTRICT: 자식 있으면 부모 삭제 불가 (기본값)\nFOREIGN KEY (user_id) REFERENCES users(id)\n    ON DELETE RESTRICT;\n\n-- NO ACTION: RESTRICT와 동일\n```\n\n### FK 추가/삭제\n\n```sql\n-- FK 추가\nALTER TABLE orders\nADD CONSTRAINT fk_orders_user\nFOREIGN KEY (user_id) REFERENCES users(id);\n\n-- FK 삭제\nALTER TABLE orders\nDROP FOREIGN KEY fk_orders_user;\n\n-- FK 확인\nSELECT * FROM information_schema.KEY_COLUMN_USAGE\nWHERE TABLE_NAME = 'orders' AND REFERENCED_TABLE_NAME IS NOT NULL;\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 팁",
        "content": "### PK 선택 가이드\n\n```\n✅ 좋은 PK\n├── AUTO_INCREMENT (MySQL)\n├── SERIAL (PostgreSQL)\n├── UUID (분산 시스템)\n\n❌ 나쁜 PK\n├── 변경 가능한 값 (이메일, 전화번호)\n├── 비즈니스 의미 있는 값\n├── 복합 PK (가능하면 피함)\n```\n\n### FK 사용 여부\n\n```\n✅ FK 사용\n├── 데이터 무결성 중요\n├── 명확한 관계\n├── OLTP 시스템\n\n❌ FK 미사용 (대규모 시스템)\n├── 성능 이슈 (FK 체크 오버헤드)\n├── 마이크로서비스 (DB 분리)\n├── 애플리케이션에서 검증\n```"
      }
    ]
  },
  "06_설계/relationship": {
    "id": "06_설계/relationship",
    "title": "테이블 관계",
    "category": "db",
    "subCategory": "06_설계",
    "language": "SQL",
    "description": "1:1, 1:N, N:M 관계를 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 테이블 관계 유형",
        "content": "## 🎯 관계 종류\n\n### 1:1 (일대일)\n```\nusers ──── user_profiles\n한 유저 = 하나의 프로필\n\n예시:\n├── 유저 - 프로필\n├── 직원 - 급여정보\n└── 상품 - 상세설명\n```\n\n### 1:N (일대다) ⭐ 가장 흔함\n```\nusers ────< orders\n한 유저 = 여러 주문\n\n예시:\n├── 유저 - 주문들\n├── 게시글 - 댓글들\n└── 카테고리 - 상품들\n```\n\n### N:M (다대다)\n```\nstudents >───< courses\n여러 학생 = 여러 수업\n\n예시:\n├── 학생 - 수업\n├── 상품 - 태그\n└── 유저 - 역할\n\n→ 중간 테이블 필요!\n```"
      },
      {
        "type": "code",
        "title": "💻 관계 구현",
        "content": "### 1:1 관계\n\n```sql\nCREATE TABLE users (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    email VARCHAR(100) NOT NULL\n);\n\nCREATE TABLE user_profiles (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    user_id BIGINT UNIQUE NOT NULL,  -- UNIQUE로 1:1 보장\n    bio TEXT,\n    avatar_url VARCHAR(255),\n    FOREIGN KEY (user_id) REFERENCES users(id)\n);\n\n-- 또는 같은 테이블에 합치는 것도 방법\n```\n\n### 1:N 관계\n\n```sql\nCREATE TABLE users (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(50)\n);\n\nCREATE TABLE orders (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    user_id BIGINT NOT NULL,  -- FK (중복 가능)\n    total_price DECIMAL(12,2),\n    FOREIGN KEY (user_id) REFERENCES users(id)\n);\n\n-- 조회\nSELECT u.name, o.id, o.total_price\nFROM users u\nJOIN orders o ON u.id = o.user_id;\n```\n\n### N:M 관계 (중간 테이블)\n\n```sql\nCREATE TABLE students (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(50)\n);\n\nCREATE TABLE courses (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(100)\n);\n\n-- 중간 테이블 (연결 테이블)\nCREATE TABLE enrollments (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    student_id BIGINT NOT NULL,\n    course_id BIGINT NOT NULL,\n    enrolled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    grade VARCHAR(2),\n\n    FOREIGN KEY (student_id) REFERENCES students(id),\n    FOREIGN KEY (course_id) REFERENCES courses(id),\n    UNIQUE (student_id, course_id)  -- 중복 방지\n);\n\n-- 조회: 학생별 수강 과목\nSELECT s.name, c.name, e.grade\nFROM students s\nJOIN enrollments e ON s.id = e.student_id\nJOIN courses c ON e.course_id = c.id;\n```"
      },
      {
        "type": "tip",
        "title": "💡 설계 팁",
        "content": "### 관계 선택 가이드\n\n```\n1:1 → 테이블 분리 필요한가?\n├── 분리: 선택적 데이터, 보안, 성능\n└── 합침: 항상 함께 조회\n\n1:N → 가장 일반적\n├── FK는 N 쪽에\n└── 인덱스 필수\n\nN:M → 중간 테이블 필요\n├── 추가 속성 있으면 (등록일, 점수)\n└── 복합 UNIQUE로 중복 방지\n```\n\n### 중간 테이블 네이밍\n\n```\nstudents + courses\n→ enrollments (명사형)\n→ student_courses (연결형)\n\nusers + roles\n→ user_roles (일반적)\n→ permissions (의미 부여)\n```"
      }
    ]
  },
  "07_최적화/explain": {
    "id": "07_최적화/explain",
    "title": "EXPLAIN 실행계획",
    "category": "db",
    "subCategory": "07_최적화",
    "language": "SQL",
    "description": "쿼리 실행계획을 분석하는 방법을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 EXPLAIN이란?",
        "content": "## 🔥 한 줄 요약\n> **쿼리가 어떻게 실행되는지 미리보기** - 성능 튜닝의 시작!\n\n---\n\n## 💡 왜 배워야 하나?\n\n```\n❌ EXPLAIN 없이\n├── 쿼리 느린데 왜 느린지 모름\n├── 인덱스 있는데 안 타는지 모름\n└── 감으로 튜닝 (시간 낭비)\n\n✅ EXPLAIN 사용\n├── 인덱스 사용 여부 확인\n├── 스캔 방식 파악\n├── 병목 지점 발견\n└── 정확한 튜닝 가능\n```\n\n---\n\n## 🎯 EXPLAIN 항목\n\n```\n+----+-------------+-------+------+---------------+------+---------+------+------+-------+\n| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |\n+----+-------------+-------+------+---------------+------+---------+------+------+-------+\n\n주요 항목:\n├── type: 접근 방식 (중요!)\n├── key: 사용된 인덱스\n├── rows: 예상 스캔 행 수\n└── Extra: 추가 정보\n```"
      },
      {
        "type": "code",
        "title": "💻 EXPLAIN 분석",
        "content": "### 기본 사용\n\n```sql\nEXPLAIN SELECT * FROM users WHERE email = 'test@test.com';\n\n-- 결과:\n+----+-------------+-------+-------+---------------+-----------+---------+-------+------+-------+\n| id | select_type | table | type  | possible_keys | key       | key_len | ref   | rows | Extra |\n+----+-------------+-------+-------+---------------+-----------+---------+-------+------+-------+\n|  1 | SIMPLE      | users | ref   | idx_email     | idx_email | 403     | const |    1 |       |\n+----+-------------+-------+-------+---------------+-----------+---------+-------+------+-------+\n```\n\n### type 해석 (좋음 → 나쁨)\n\n```sql\n-- system/const: 1행만 (최고)\nEXPLAIN SELECT * FROM users WHERE id = 1;\n-- type: const\n\n-- eq_ref: 유니크 인덱스로 1행\nEXPLAIN SELECT * FROM orders o\nJOIN users u ON o.user_id = u.id;\n-- type: eq_ref\n\n-- ref: 비유니크 인덱스 (양호)\nEXPLAIN SELECT * FROM orders WHERE user_id = 1;\n-- type: ref\n\n-- range: 범위 스캔 (양호)\nEXPLAIN SELECT * FROM orders WHERE created_at > '2024-01-01';\n-- type: range\n\n-- index: 인덱스 전체 스캔 (주의)\nEXPLAIN SELECT user_id FROM orders;\n-- type: index (커버링)\n\n-- ALL: 풀 테이블 스캔 (최악!)\nEXPLAIN SELECT * FROM orders WHERE YEAR(created_at) = 2024;\n-- type: ALL (인덱스 못 씀)\n```\n\n### Extra 해석\n\n```sql\n-- Using index: 커버링 인덱스 (최고!)\n-- Using where: WHERE 필터링\n-- Using temporary: 임시 테이블 (주의)\n-- Using filesort: 정렬 연산 (주의)\n-- Using index condition: ICP (좋음)\n\nEXPLAIN SELECT * FROM orders ORDER BY total_price;\n-- Extra: Using filesort (인덱스 없이 정렬)\n```"
      },
      {
        "type": "tip",
        "title": "💡 EXPLAIN 팁",
        "content": "### 빠르게 확인\n\n```sql\n-- EXPLAIN ANALYZE (MySQL 8.0+, PostgreSQL)\n-- 실제 실행 시간까지 표시\nEXPLAIN ANALYZE SELECT * FROM orders WHERE user_id = 1;\n\n-- 결과:\n-- -> Index lookup on orders using idx_user_id\n--    (actual time=0.025..0.026 rows=10 loops=1)\n```\n\n### 튜닝 체크리스트\n\n```\n□ type이 ALL인가? → 인덱스 추가\n□ rows가 너무 큰가? → 조건 개선\n□ Using filesort? → ORDER BY 인덱스\n□ Using temporary? → GROUP BY 개선\n□ key가 NULL인가? → 인덱스 설계 확인\n```"
      }
    ]
  },
  "07_최적화/partitioning": {
    "id": "07_최적화/partitioning",
    "title": "파티셔닝",
    "category": "db",
    "subCategory": "07_최적화",
    "language": "SQL",
    "description": "대용량 테이블 파티셔닝을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 파티셔닝이란?",
        "content": "## 🔥 한 줄 요약\n> **큰 테이블을 작은 조각으로 분할** - 관리와 성능 향상!\n\n---\n\n## 💡 왜 필요한가?\n\n```\n1억 건 테이블 문제:\n├── 풀스캔 시 엄청 느림\n├── 인덱스도 거대해짐\n├── 백업/복구 오래 걸림\n└── 오래된 데이터 삭제 어려움\n\n파티셔닝으로 해결:\n├── 2024년 1월 파티션\n├── 2024년 2월 파티션\n├── ...\n└── 필요한 파티션만 스캔!\n```\n\n---\n\n## 🎯 파티셔닝 종류\n\n### RANGE: 범위 기준\n```\n날짜, 숫자 범위로 분할\n├── 2024-01 파티션\n├── 2024-02 파티션\n└── 가장 흔히 사용\n```\n\n### LIST: 목록 기준\n```\n특정 값 목록으로 분할\n├── status = 'active' 파티션\n├── status = 'deleted' 파티션\n└── 값이 정해진 경우\n```\n\n### HASH: 해시 기준\n```\n해시 함수로 균등 분할\n├── user_id % 4 = 0 파티션\n├── user_id % 4 = 1 파티션\n└── 데이터 균등 분산\n```"
      },
      {
        "type": "code",
        "title": "💻 파티셔닝 구현",
        "content": "### RANGE 파티셔닝 (날짜)\n\n```sql\nCREATE TABLE orders (\n    id BIGINT NOT NULL,\n    user_id BIGINT NOT NULL,\n    total_price DECIMAL(12,2),\n    created_at DATE NOT NULL,\n    PRIMARY KEY (id, created_at)  -- 파티션 키 포함 필수\n)\nPARTITION BY RANGE (YEAR(created_at)) (\n    PARTITION p2022 VALUES LESS THAN (2023),\n    PARTITION p2023 VALUES LESS THAN (2024),\n    PARTITION p2024 VALUES LESS THAN (2025),\n    PARTITION p_future VALUES LESS THAN MAXVALUE\n);\n\n-- 쿼리 시 해당 파티션만 스캔\nSELECT * FROM orders WHERE created_at >= '2024-01-01';\n-- p2024, p_future만 스캔\n```\n\n### 파티션 관리\n\n```sql\n-- 파티션 추가\nALTER TABLE orders ADD PARTITION (\n    PARTITION p2025 VALUES LESS THAN (2026)\n);\n\n-- 파티션 삭제 (오래된 데이터 빠른 삭제!)\nALTER TABLE orders DROP PARTITION p2022;\n\n-- 파티션 확인\nSELECT PARTITION_NAME, TABLE_ROWS\nFROM information_schema.PARTITIONS\nWHERE TABLE_NAME = 'orders';\n```\n\n### LIST 파티셔닝\n\n```sql\nCREATE TABLE logs (\n    id BIGINT NOT NULL,\n    level ENUM('DEBUG','INFO','WARN','ERROR') NOT NULL,\n    message TEXT,\n    created_at TIMESTAMP,\n    PRIMARY KEY (id, level)\n)\nPARTITION BY LIST COLUMNS(level) (\n    PARTITION p_debug VALUES IN ('DEBUG'),\n    PARTITION p_info VALUES IN ('INFO'),\n    PARTITION p_warn VALUES IN ('WARN'),\n    PARTITION p_error VALUES IN ('ERROR')\n);\n```"
      },
      {
        "type": "tip",
        "title": "💡 파티셔닝 가이드",
        "content": "### 언제 사용?\n\n```\n✅ 파티셔닝 권장\n├── 테이블 1000만 건 이상\n├── 날짜 기반 조회 빈번\n├── 오래된 데이터 정기 삭제\n├── 특정 범위 쿼리 많음\n\n❌ 파티셔닝 불필요\n├── 작은 테이블\n├── 전체 조회가 대부분\n├── 파티션 키 없이 조회\n```\n\n### 주의사항\n\n```\n1. PK에 파티션 키 포함 필수\n2. 파티션 프루닝 확인 (EXPLAIN PARTITIONS)\n3. 파티션 개수 적절히 (수십~수백)\n4. 유니크 인덱스 제약\n```"
      }
    ]
  },
  "07_최적화/query-optimization": {
    "id": "07_최적화/query-optimization",
    "title": "쿼리 최적화",
    "category": "db",
    "subCategory": "07_최적화",
    "language": "SQL",
    "description": "SQL 쿼리 성능을 개선하는 방법을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 쿼리 최적화 원칙",
        "content": "## 🎯 최적화 순서\n\n```\n1단계: 인덱스 확인/추가\n├── EXPLAIN으로 확인\n├── 적절한 인덱스 설계\n└── 가장 효과적\n\n2단계: 쿼리 리팩토링\n├── 불필요한 연산 제거\n├── 서브쿼리 → JOIN\n└── 조건 최적화\n\n3단계: 데이터 모델 개선\n├── 역정규화 검토\n├── 파티셔닝\n└── 아키텍처 변경\n\n4단계: 하드웨어/설정\n├── DB 설정 튜닝\n├── 메모리 증설\n└── 읽기 복제본\n```"
      },
      {
        "type": "code",
        "title": "💻 최적화 예제",
        "content": "### SELECT 최적화\n\n```sql\n-- ❌ 느림: SELECT *\nSELECT * FROM orders WHERE user_id = 1;\n\n-- ✅ 빠름: 필요 컬럼만\nSELECT id, total_price, created_at FROM orders WHERE user_id = 1;\n```\n\n### WHERE 최적화\n\n```sql\n-- ❌ 느림: 함수 사용\nSELECT * FROM orders WHERE YEAR(created_at) = 2024;\n\n-- ✅ 빠름: 범위 조건\nSELECT * FROM orders\nWHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';\n```\n\n### JOIN 최적화\n\n```sql\n-- ❌ 느림: 서브쿼리\nSELECT * FROM users\nWHERE id IN (SELECT user_id FROM orders WHERE total_price > 100000);\n\n-- ✅ 빠름: JOIN\nSELECT DISTINCT u.*\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE o.total_price > 100000;\n```\n\n### 페이징 최적화\n\n```sql\n-- ❌ 느림: OFFSET 큰 값\nSELECT * FROM products ORDER BY id LIMIT 10 OFFSET 100000;\n-- 100,010행 읽고 100,000행 버림\n\n-- ✅ 빠름: 커서 기반\nSELECT * FROM products\nWHERE id > 100000  -- 마지막 조회 ID\nORDER BY id\nLIMIT 10;\n```\n\n### GROUP BY 최적화\n\n```sql\n-- ❌ 느림: filesort\nSELECT user_id, COUNT(*) FROM orders GROUP BY user_id;\n\n-- ✅ 빠름: 인덱스 활용\nCREATE INDEX idx_user_id ON orders(user_id);\n-- 또는 커버링 인덱스\nCREATE INDEX idx_user_status ON orders(user_id, status);\n```"
      },
      {
        "type": "tip",
        "title": "💡 최적화 체크리스트",
        "content": "### 쿼리 작성 시\n\n```\n□ SELECT * 대신 필요 컬럼만\n□ WHERE에 인덱스 컬럼 사용\n□ 함수로 컬럼 감싸지 않기\n□ LIKE는 앞부분 고정 (abc%)\n□ IN보다 EXISTS (대용량)\n□ OR 대신 UNION (경우에 따라)\n□ LIMIT 항상 사용\n```\n\n### 인덱스 활용\n\n```\n□ WHERE 조건 컬럼에 인덱스\n□ JOIN 컬럼에 인덱스\n□ ORDER BY 컬럼 인덱스 포함\n□ 커버링 인덱스 고려\n□ 복합 인덱스 순서 최적화\n```"
      }
    ]
  },
  "07_최적화/query-tuning": {
    "id": "07_최적화/query-tuning",
    "title": "쿼리 튜닝 실전",
    "category": "db",
    "subCategory": "07_최적화",
    "language": "SQL",
    "description": "실제 쿼리 튜닝 사례를 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 튜닝 프로세스",
        "content": "## 🎯 튜닝 단계\n\n```\n1. 문제 쿼리 식별\n   └── 슬로우 쿼리 로그, 모니터링\n\n2. 현재 상태 분석\n   └── EXPLAIN, 실행 시간 측정\n\n3. 원인 파악\n   └── 풀스캔? 인덱스 미사용? 잘못된 조인?\n\n4. 개선안 적용\n   └── 인덱스, 쿼리 수정, 구조 변경\n\n5. 결과 검증\n   └── EXPLAIN, 실행 시간 비교\n```"
      },
      {
        "type": "code",
        "title": "💻 튜닝 사례",
        "content": "### 사례 1: 인덱스 추가\n\n```sql\n-- Before: 5초\nSELECT * FROM orders WHERE user_id = 100 AND status = 'completed';\n-- EXPLAIN: type=ALL, rows=1000000\n\n-- After: 0.01초\nCREATE INDEX idx_user_status ON orders(user_id, status);\n-- EXPLAIN: type=ref, rows=10\n```\n\n### 사례 2: 쿼리 리팩토링\n\n```sql\n-- Before: 10초\nSELECT * FROM products\nWHERE id IN (\n    SELECT product_id FROM order_items\n    WHERE order_id IN (\n        SELECT id FROM orders WHERE created_at > '2024-01-01'\n    )\n);\n\n-- After: 0.5초\nSELECT DISTINCT p.*\nFROM products p\nJOIN order_items oi ON p.id = oi.product_id\nJOIN orders o ON oi.order_id = o.id\nWHERE o.created_at > '2024-01-01';\n```\n\n### 사례 3: 커버링 인덱스\n\n```sql\n-- Before: 3초\nSELECT user_id, COUNT(*), SUM(total_price)\nFROM orders\nWHERE status = 'completed'\nGROUP BY user_id;\n\n-- After: 0.3초\nCREATE INDEX idx_covering ON orders(status, user_id, total_price);\n-- Extra: Using index (테이블 접근 없음)\n```\n\n### 사례 4: 페이징 개선\n\n```sql\n-- Before: 8초 (OFFSET 100000)\nSELECT * FROM products ORDER BY created_at DESC LIMIT 20 OFFSET 100000;\n\n-- After: 0.05초 (커서 기반)\nSELECT * FROM products\nWHERE created_at < '2024-01-15 10:30:00'  -- 이전 페이지 마지막\nORDER BY created_at DESC\nLIMIT 20;\n```"
      },
      {
        "type": "tip",
        "title": "💡 튜닝 팁",
        "content": "### 측정 방법\n\n```sql\n-- 쿼리 실행 시간 측정\nSET profiling = 1;\nSELECT * FROM orders WHERE user_id = 1;\nSHOW PROFILES;\n\n-- 캐시 무효화 (정확한 측정)\nSELECT SQL_NO_CACHE * FROM orders;\n```\n\n### 튜닝 우선순위\n\n```\n효과 높음:\n├── 적절한 인덱스 추가\n├── 풀스캔 → 인덱스 스캔\n└── N+1 쿼리 해결\n\n효과 중간:\n├── 서브쿼리 → JOIN\n├── SELECT * → 필요 컬럼\n└── 커버링 인덱스\n\n효과 낮음 (복잡도 높음):\n├── 파티셔닝\n├── 샤딩\n└── 캐싱 레이어\n```"
      }
    ]
  },
  "07_최적화/sharding": {
    "id": "07_최적화/sharding",
    "title": "샤딩",
    "category": "db",
    "subCategory": "07_최적화",
    "language": "SQL",
    "description": "데이터베이스 샤딩 전략을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 샤딩이란?",
        "content": "## 🔥 한 줄 요약\n> **여러 DB 서버에 데이터 분산** - 수평 확장의 핵심!\n\n---\n\n## 💡 왜 필요한가?\n\n```\n단일 DB 한계:\n├── CPU/메모리 한계\n├── 디스크 I/O 한계\n├── 커넥션 수 한계\n└── Scale-up 비용 급증\n\n샤딩으로 해결:\n├── DB1: 유저 1~100만\n├── DB2: 유저 100만~200만\n├── DB3: 유저 200만~300만\n└── Scale-out (서버 추가)\n```\n\n---\n\n## 🎯 샤딩 전략\n\n### 1. Range 샤딩\n```\nuser_id 1~100만 → Shard1\nuser_id 100만~200만 → Shard2\n\n장점: 구현 단순\n단점: 불균형 가능\n```\n\n### 2. Hash 샤딩\n```\nuser_id % 3 = 0 → Shard1\nuser_id % 3 = 1 → Shard2\nuser_id % 3 = 2 → Shard3\n\n장점: 균등 분산\n단점: 리샤딩 어려움\n```\n\n### 3. Directory 샤딩\n```\n매핑 테이블로 관리\nuser_id → shard_id 조회 후 접근\n\n장점: 유연함\n단점: 매핑 관리 필요\n```"
      },
      {
        "type": "code",
        "title": "💻 샤딩 구현",
        "content": "### 애플리케이션 레벨 샤딩\n\n```python\n# Python 예제: Hash 샤딩\nclass ShardRouter:\n    def __init__(self, shard_count=3):\n        self.shard_count = shard_count\n        self.connections = {\n            0: connect('shard0.db'),\n            1: connect('shard1.db'),\n            2: connect('shard2.db'),\n        }\n\n    def get_shard(self, user_id):\n        shard_id = user_id % self.shard_count\n        return self.connections[shard_id]\n\n    def execute(self, user_id, query, params):\n        conn = self.get_shard(user_id)\n        return conn.execute(query, params)\n\n# 사용\nrouter = ShardRouter()\nrouter.execute(user_id=12345, query=\"SELECT * FROM orders WHERE user_id = %s\", params=(12345,))\n```\n\n### Cross-Shard 쿼리\n\n```python\n# 모든 샤드에서 집계\ndef get_total_revenue():\n    total = 0\n    for shard_conn in router.connections.values():\n        result = shard_conn.execute(\"SELECT SUM(total_price) FROM orders\")\n        total += result[0] or 0\n    return total\n```\n\n### 샤딩 키 선택\n\n```\n✅ 좋은 샤딩 키\n├── user_id: 유저별 데이터 격리\n├── tenant_id: 멀티테넌트\n└── region: 지역별 데이터\n\n❌ 나쁜 샤딩 키\n├── created_at: 최신 샤드만 핫\n├── status: 불균형\n└── 자주 바뀌는 값\n```"
      },
      {
        "type": "tip",
        "title": "💡 샤딩 주의사항",
        "content": "### 샤딩의 어려움\n\n```\n1. Cross-Shard JOIN 불가\n   → 애플리케이션에서 조합\n\n2. Cross-Shard 트랜잭션 복잡\n   → 분산 트랜잭션, Saga 패턴\n\n3. 리샤딩 어려움\n   → 초기 설계 중요\n\n4. 운영 복잡도 증가\n   → 모니터링, 백업, 마이그레이션\n```\n\n### 샤딩 전 체크\n\n```\n□ 정말 샤딩이 필요한가?\n□ 읽기 복제본으로 해결 가능?\n□ 캐싱으로 해결 가능?\n□ 쿼리 최적화로 해결 가능?\n□ 파티셔닝으로 충분한가?\n\n→ 샤딩은 최후의 수단!\n```"
      }
    ]
  },
  "07_최적화/slow-query": {
    "id": "07_최적화/slow-query",
    "title": "슬로우 쿼리 분석",
    "category": "db",
    "subCategory": "07_최적화",
    "language": "SQL",
    "description": "느린 쿼리를 찾고 분석하는 방법을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 슬로우 쿼리란?",
        "content": "## 🔥 한 줄 요약\n> **설정 시간보다 오래 걸리는 쿼리** - 성능 병목의 원인!\n\n---\n\n## 💡 왜 중요한가?\n\n```\n🔴 슬로우 쿼리 1개의 영향\n├── DB 커넥션 점유 (다른 쿼리 대기)\n├── CPU/메모리 과다 사용\n├── 전체 서비스 응답 지연\n└── 최악의 경우 서버 다운\n\n일반적으로:\n├── 1초 이상: 슬로우\n├── 5초 이상: 심각\n└── 10초 이상: 장애 수준\n```\n\n---\n\n## 🎯 슬로우 쿼리 설정\n\n### MySQL 설정\n\n```sql\n-- 슬로우 쿼리 로그 활성화\nSET GLOBAL slow_query_log = 'ON';\nSET GLOBAL long_query_time = 1;  -- 1초 이상\nSET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';\n\n-- 확인\nSHOW VARIABLES LIKE 'slow%';\nSHOW VARIABLES LIKE 'long_query_time';\n```"
      },
      {
        "type": "code",
        "title": "💻 슬로우 쿼리 분석",
        "content": "### 슬로우 쿼리 로그 확인\n\n```bash\n# 로그 파일 확인\ntail -f /var/log/mysql/slow.log\n\n# pt-query-digest로 분석 (Percona Toolkit)\npt-query-digest /var/log/mysql/slow.log > slow_report.txt\n```\n\n### 실시간 모니터링\n\n```sql\n-- 현재 실행 중인 쿼리\nSHOW PROCESSLIST;\n\n-- 긴 쿼리만\nSELECT * FROM information_schema.PROCESSLIST\nWHERE TIME > 5 AND COMMAND != 'Sleep';\n\n-- 쿼리 강제 종료\nKILL [PROCESS_ID];\n```\n\n### 문제 쿼리 패턴\n\n```sql\n-- 1. 인덱스 없는 풀스캔\nSELECT * FROM orders WHERE DATE(created_at) = '2024-01-15';\n-- 해결: 범위 조건으로 변경\n\n-- 2. LIKE '%keyword%'\nSELECT * FROM products WHERE name LIKE '%아이폰%';\n-- 해결: Full-Text 인덱스 또는 검색 엔진\n\n-- 3. 큰 결과셋 SELECT *\nSELECT * FROM logs;  -- 100만 행\n-- 해결: LIMIT, 필요 컬럼만\n\n-- 4. 복잡한 서브쿼리\nSELECT * FROM users\nWHERE id IN (SELECT user_id FROM orders GROUP BY user_id HAVING COUNT(*) > 10);\n-- 해결: JOIN으로 변경\n\n-- 5. N+1 쿼리 (애플리케이션)\nfor user in users:\n    SELECT * FROM orders WHERE user_id = user.id\n-- 해결: JOIN으로 한 번에\n```"
      },
      {
        "type": "tip",
        "title": "💡 슬로우 쿼리 대응",
        "content": "### 즉시 대응\n\n```\n1. SHOW PROCESSLIST로 확인\n2. 문제 쿼리 KILL\n3. 원인 분석 (EXPLAIN)\n4. 인덱스 추가 또는 쿼리 수정\n```\n\n### 예방\n\n```\n□ 개발 시 EXPLAIN 습관화\n□ 슬로우 쿼리 로그 활성화\n□ 모니터링 대시보드 설정\n□ 쿼리 실행 시간 제한 (ORM)\n□ 정기 쿼리 리뷰\n```"
      }
    ]
  },
  "08_NoSQL/mongodb": {
    "id": "08_NoSQL/mongodb",
    "title": "MongoDB",
    "category": "db",
    "subCategory": "08_NoSQL",
    "language": "C",
    "description": "MongoDB의 특징과 기본 사용법을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 MongoDB란?",
        "content": "## 🔥 한 줄 요약\n> **문서 지향 NoSQL 데이터베이스** - JSON처럼 저장!\n\n---\n\n## 💡 왜 인기 있나?\n\n```\n장점:\n├── 유연한 스키마 (필드 자유롭게)\n├── JSON 직관적 저장\n├── 수평 확장 용이\n├── 개발 속도 빠름\n└── 강력한 쿼리 기능\n\n사용처:\n├── 콘텐츠 관리\n├── IoT 데이터\n├── 실시간 분석\n├── 모바일 앱\n└── 게임 백엔드\n```\n\n---\n\n## 🎯 용어 매핑\n\n```\nRDBMS        →  MongoDB\n─────────────────────────\nDatabase     →  Database\nTable        →  Collection\nRow          →  Document\nColumn       →  Field\nPrimary Key  →  _id\nIndex        →  Index\nJOIN         →  $lookup (제한적)\n```"
      },
      {
        "type": "code",
        "title": "💻 MongoDB CRUD",
        "content": "### Create (삽입)\n\n```javascript\n// 단일 문서\ndb.users.insertOne({\n    name: \"김철수\",\n    email: \"kim@test.com\",\n    age: 30,\n    hobbies: [\"코딩\", \"게임\"]\n});\n\n// 다중 문서\ndb.users.insertMany([\n    { name: \"이영희\", age: 25 },\n    { name: \"박민수\", age: 35 }\n]);\n```\n\n### Read (조회)\n\n```javascript\n// 전체 조회\ndb.users.find();\n\n// 조건 조회\ndb.users.find({ age: { $gte: 30 } });\n\n// 특정 필드만\ndb.users.find({}, { name: 1, email: 1 });\n\n// 정렬, 제한\ndb.users.find().sort({ age: -1 }).limit(10);\n\n// 복잡한 조건\ndb.users.find({\n    $or: [\n        { age: { $lt: 20 } },\n        { age: { $gt: 50 } }\n    ],\n    status: \"active\"\n});\n```\n\n### Update (수정)\n\n```javascript\n// 단일 수정\ndb.users.updateOne(\n    { email: \"kim@test.com\" },\n    { $set: { age: 31 } }\n);\n\n// 다중 수정\ndb.users.updateMany(\n    { status: \"inactive\" },\n    { $set: { deleted: true } }\n);\n\n// 배열 추가\ndb.users.updateOne(\n    { email: \"kim@test.com\" },\n    { $push: { hobbies: \"독서\" } }\n);\n```\n\n### Delete (삭제)\n\n```javascript\ndb.users.deleteOne({ email: \"kim@test.com\" });\ndb.users.deleteMany({ status: \"deleted\" });\n```"
      },
      {
        "type": "tip",
        "title": "💡 MongoDB 팁",
        "content": "### 인덱스\n\n```javascript\n// 단일 인덱스\ndb.users.createIndex({ email: 1 });\n\n// 복합 인덱스\ndb.users.createIndex({ status: 1, created_at: -1 });\n\n// 유니크 인덱스\ndb.users.createIndex({ email: 1 }, { unique: true });\n```\n\n### 집계 파이프라인\n\n```javascript\ndb.orders.aggregate([\n    { $match: { status: \"completed\" } },\n    { $group: {\n        _id: \"$user_id\",\n        total: { $sum: \"$amount\" },\n        count: { $sum: 1 }\n    }},\n    { $sort: { total: -1 } },\n    { $limit: 10 }\n]);\n```\n\n### Python 연동\n\n```python\nfrom pymongo import MongoClient\n\nclient = MongoClient('mongodb://localhost:27017')\ndb = client['mydb']\ncollection = db['users']\n\n# 삽입\ncollection.insert_one({\"name\": \"홍길동\"})\n\n# 조회\nusers = collection.find({\"age\": {\"$gte\": 20}})\n```"
      }
    ]
  },
  "08_NoSQL/nosql-concept": {
    "id": "08_NoSQL/nosql-concept",
    "title": "NoSQL 개념",
    "category": "db",
    "subCategory": "08_NoSQL",
    "language": "C",
    "description": "NoSQL 데이터베이스의 개념과 특징을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 NoSQL이란?",
        "content": "## 🔥 한 줄 요약\n> **Not Only SQL** - 관계형이 아닌 다양한 데이터 저장 방식\n\n---\n\n## 💡 왜 등장했나?\n\n```\nRDBMS의 한계:\n├── 스키마 변경 어려움\n├── Scale-out 어려움\n├── 비정형 데이터 저장 어려움\n└── 대용량 처리 한계\n\nNoSQL로 해결:\n├── 유연한 스키마\n├── 수평 확장 용이\n├── 다양한 데이터 모델\n└── 높은 성능\n```\n\n---\n\n## 🎯 NoSQL 유형\n\n### 1. 문서형 (Document)\n```\nMongoDB, CouchDB\n├── JSON/BSON 문서 저장\n├── 유연한 스키마\n└── 예: 상품, 게시글, 로그\n```\n\n### 2. 키-값 (Key-Value)\n```\nRedis, Memcached\n├── 단순한 키-값 저장\n├── 초고속 읽기/쓰기\n└── 예: 캐시, 세션, 장바구니\n```\n\n### 3. 컬럼형 (Column-Family)\n```\nCassandra, HBase\n├── 컬럼 기반 저장\n├── 대용량 분석\n└── 예: 시계열, 로그, 분석\n```\n\n### 4. 그래프 (Graph)\n```\nNeo4j, Amazon Neptune\n├── 노드와 관계 저장\n├── 복잡한 관계 탐색\n└── 예: SNS, 추천, 사기탐지\n```"
      },
      {
        "type": "code",
        "title": "💻 NoSQL 예시",
        "content": "### MongoDB (문서형)\n\n```javascript\n// 유연한 스키마\ndb.products.insertOne({\n    name: \"아이폰 15\",\n    price: 1500000,\n    specs: {  // 중첩 객체\n        color: [\"블랙\", \"화이트\"],\n        storage: [128, 256, 512]\n    },\n    reviews: [  // 배열\n        { user: \"김철수\", rating: 5 },\n        { user: \"이영희\", rating: 4 }\n    ]\n});\n\n// 쿼리\ndb.products.find({ \"specs.storage\": 256 });\n```\n\n### Redis (키-값)\n\n```python\nimport redis\nr = redis.Redis()\n\n# 캐싱\nr.set(\"user:1:name\", \"김철수\", ex=3600)  # 1시간 만료\nname = r.get(\"user:1:name\")\n\n# 해시\nr.hset(\"user:1\", mapping={\"name\": \"김철수\", \"email\": \"kim@test.com\"})\nr.hget(\"user:1\", \"name\")\n\n# 리스트 (최근 본 상품)\nr.lpush(\"user:1:recent\", \"product:100\")\nr.lrange(\"user:1:recent\", 0, 9)  # 최근 10개\n```\n\n### Cassandra (컬럼형)\n\n```sql\n-- 시계열 데이터\nCREATE TABLE sensor_data (\n    sensor_id UUID,\n    timestamp TIMESTAMP,\n    temperature FLOAT,\n    humidity FLOAT,\n    PRIMARY KEY (sensor_id, timestamp)\n) WITH CLUSTERING ORDER BY (timestamp DESC);\n\n-- 최근 데이터 조회 (매우 빠름)\nSELECT * FROM sensor_data\nWHERE sensor_id = ? AND timestamp > '2024-01-01';\n```"
      },
      {
        "type": "tip",
        "title": "💡 선택 가이드",
        "content": "### 언제 뭘 쓸까?\n\n```\nMongoDB:\n├── 유연한 스키마 필요\n├── 문서 구조 데이터\n└── 빠른 개발 속도\n\nRedis:\n├── 캐싱\n├── 세션 관리\n├── 실시간 랭킹\n\nCassandra:\n├── 대용량 쓰기\n├── 시계열 데이터\n├── 고가용성 필수\n\nRDBMS:\n├── 트랜잭션 중요\n├── 복잡한 JOIN\n├── 데이터 무결성\n```"
      }
    ]
  },
  "08_NoSQL/redis-data-type": {
    "id": "08_NoSQL/redis-data-type",
    "title": "Redis 자료구조",
    "category": "db",
    "subCategory": "08_NoSQL",
    "language": "C",
    "description": "Redis의 다양한 자료구조 활용법을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 Redis 자료구조 총정리",
        "content": "## 🎯 자료구조별 용도\n\n| 타입 | 용도 | 예시 |\n|------|------|------|\n| String | 캐싱, 카운터 | 세션, 조회수 |\n| Hash | 객체 저장 | 유저 정보 |\n| List | 순서 있는 목록 | 최근 본 상품 |\n| Set | 중복 없는 집합 | 태그, 팔로워 |\n| Sorted Set | 점수 기반 정렬 | 랭킹, 타임라인 |\n| Bitmap | 비트 연산 | 출석 체크 |\n| HyperLogLog | 카디널리티 추정 | UV 카운트 |"
      },
      {
        "type": "code",
        "title": "💻 자료구조 실전",
        "content": "### Set (집합 연산)\n\n```python\n# 팔로워/팔로잉\nr.sadd('user:1:following', 'user:2', 'user:3', 'user:4')\nr.sadd('user:2:following', 'user:1', 'user:3', 'user:5')\n\n# 공통 팔로우 (교집합)\ncommon = r.sinter('user:1:following', 'user:2:following')\n# {'user:3'}\n\n# 추천 친구 (차집합)\nrecommend = r.sdiff('user:2:following', 'user:1:following')\n# {'user:5'} - user:1이 팔로우 안 한 사람\n```\n\n### Sorted Set (타임라인)\n\n```python\nimport time\n\n# 타임라인 추가 (timestamp를 score로)\nr.zadd('user:1:timeline', {\n    'post:100': time.time(),\n    'post:101': time.time() + 1,\n})\n\n# 최신순 조회\nposts = r.zrevrange('user:1:timeline', 0, 19)  # 최근 20개\n\n# 특정 시간 이후 게시물\nrecent = r.zrangebyscore('user:1:timeline',\n    time.time() - 3600,  # 1시간 전\n    time.time()\n)\n```\n\n### Bitmap (출석 체크)\n\n```python\n# 출석 체크 (일자별 비트)\nuser_id = 1\nday_of_year = 15  # 1월 15일\n\nr.setbit(f'attendance:2024:{user_id}', day_of_year, 1)\n\n# 출석 확인\nattended = r.getbit(f'attendance:2024:{user_id}', day_of_year)\n\n# 이번 달 출석 일수\nr.bitcount(f'attendance:2024:{user_id}', 0, 30)\n```\n\n### Pub/Sub (실시간 메시징)\n\n```python\n# Publisher\nr.publish('chat:room:1', json.dumps({\n    'user': 'kim',\n    'message': '안녕하세요!'\n}))\n\n# Subscriber\npubsub = r.pubsub()\npubsub.subscribe('chat:room:1')\n\nfor message in pubsub.listen():\n    if message['type'] == 'message':\n        data = json.loads(message['data'])\n        print(f\"{data['user']}: {data['message']}\")\n```"
      },
      {
        "type": "tip",
        "title": "💡 선택 가이드",
        "content": "### 자료구조 선택\n\n```\n단순 값 저장 → String\n객체 저장 → Hash\n순서 있는 목록 → List\n중복 없는 집합 → Set\n점수 기반 정렬 → Sorted Set\n비트 플래그 → Bitmap\n대략적 카운트 → HyperLogLog\n```\n\n### 성능 고려\n\n```\nO(1): GET, SET, HGET, SADD\nO(N): LRANGE, SMEMBERS\nO(log N): ZADD, ZRANGE\n\n→ 큰 컬렉션은 페이징 필수!\n→ KEYS * 명령 금지 (SCAN 사용)\n```"
      }
    ]
  },
  "08_NoSQL/redis": {
    "id": "08_NoSQL/redis",
    "title": "Redis",
    "category": "db",
    "subCategory": "08_NoSQL",
    "language": "C",
    "description": "Redis의 특징과 기본 사용법을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 Redis란?",
        "content": "## 🔥 한 줄 요약\n> **인메모리 키-값 저장소** - 초고속 캐시의 왕!\n\n---\n\n## 💡 왜 Redis인가?\n\n```\n성능:\n├── 메모리 기반 → 초고속 (1ms 미만)\n├── 단일 스레드 → 원자성 보장\n├── 100,000+ 요청/초\n└── DB 부하 90% 감소 가능\n\n사용처:\n├── 캐싱 (가장 흔함)\n├── 세션 저장\n├── 실시간 랭킹\n├── Pub/Sub 메시징\n├── 분산 락\n└── Rate Limiting\n```\n\n---\n\n## 🎯 데이터 타입\n\n```\nString: 단순 키-값\nHash: 객체 (필드-값)\nList: 순서 있는 목록\nSet: 중복 없는 집합\nSorted Set: 점수 기반 정렬\n```"
      },
      {
        "type": "code",
        "title": "💻 Redis 사용법",
        "content": "### String (캐싱)\n\n```python\nimport redis\nr = redis.Redis(host='localhost', port=6379)\n\n# 캐싱 기본\nr.set('user:1:name', '김철수')\nr.get('user:1:name')  # b'김철수'\n\n# TTL 설정 (초)\nr.setex('session:abc', 3600, 'user_data')\n\n# 카운터\nr.incr('page:home:views')\nr.incrby('product:100:stock', -1)\n```\n\n### Hash (객체)\n\n```python\n# 유저 정보 저장\nr.hset('user:1', mapping={\n    'name': '김철수',\n    'email': 'kim@test.com',\n    'age': 30\n})\n\n# 단일 필드 조회\nr.hget('user:1', 'name')\n\n# 전체 조회\nr.hgetall('user:1')\n\n# 필드 수정\nr.hincrby('user:1', 'age', 1)\n```\n\n### List (최근 목록)\n\n```python\n# 최근 본 상품\nr.lpush('user:1:recent', 'product:100')\nr.lpush('user:1:recent', 'product:101')\n\n# 최근 10개만 유지\nr.ltrim('user:1:recent', 0, 9)\n\n# 조회\nr.lrange('user:1:recent', 0, -1)\n```\n\n### Sorted Set (랭킹)\n\n```python\n# 점수 추가\nr.zadd('leaderboard', {'user:1': 1500, 'user:2': 2000, 'user:3': 1800})\n\n# 상위 10명\nr.zrevrange('leaderboard', 0, 9, withscores=True)\n\n# 특정 유저 순위\nr.zrevrank('leaderboard', 'user:1')  # 0부터 시작\n```\n\n### 실전: 캐시 패턴\n\n```python\ndef get_user(user_id):\n    # 1. 캐시 확인\n    cache_key = f'user:{user_id}'\n    cached = r.get(cache_key)\n    if cached:\n        return json.loads(cached)\n\n    # 2. DB 조회\n    user = db.query(f\"SELECT * FROM users WHERE id = {user_id}\")\n\n    # 3. 캐시 저장 (1시간)\n    r.setex(cache_key, 3600, json.dumps(user))\n\n    return user\n```"
      },
      {
        "type": "tip",
        "title": "💡 Redis 팁",
        "content": "### 메모리 관리\n\n```\n# 최대 메모리 설정\nmaxmemory 2gb\nmaxmemory-policy allkeys-lru\n\n정책:\n├── noeviction: 메모리 초과 시 에러\n├── allkeys-lru: 가장 오래된 키 삭제\n├── volatile-lru: TTL 있는 것 중 삭제\n└── allkeys-random: 랜덤 삭제\n```\n\n### 영속성 옵션\n\n```\nRDB: 주기적 스냅샷\n├── 빠른 복구\n├── 데이터 손실 가능\n\nAOF: 모든 쓰기 로그\n├── 데이터 손실 최소화\n├── 파일 크기 큼\n\n권장: 둘 다 사용\n```"
      }
    ]
  },
  "08_NoSQL/sql-vs-nosql": {
    "id": "08_NoSQL/sql-vs-nosql",
    "title": "SQL vs NoSQL",
    "category": "db",
    "subCategory": "08_NoSQL",
    "language": "C",
    "description": "SQL과 NoSQL의 차이점과 선택 기준을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 SQL vs NoSQL",
        "content": "## 🎯 비교표\n\n| 항목 | SQL (RDBMS) | NoSQL |\n|------|-------------|-------|\n| 스키마 | 고정 스키마 | 유연한 스키마 |\n| 확장 | Scale-up | Scale-out |\n| 트랜잭션 | ACID | BASE (대부분) |\n| 조인 | 지원 | 제한적/없음 |\n| 쿼리 | SQL 표준 | DB마다 다름 |\n| 일관성 | 강한 일관성 | 최종 일관성 |\n\n---\n\n## 🎯 ACID vs BASE\n\n### ACID (SQL)\n```\nAtomicity: 원자성\nConsistency: 일관성\nIsolation: 격리성\nDurability: 지속성\n→ 강한 일관성, 트랜잭션 보장\n```\n\n### BASE (NoSQL)\n```\nBasically Available: 기본 가용성\nSoft state: 일시적 비일관\nEventually consistent: 최종 일관성\n→ 가용성 우선, 일관성은 나중에\n```"
      },
      {
        "type": "code",
        "title": "💻 사용 사례",
        "content": "### SQL이 좋은 경우\n\n```sql\n-- 금융 거래 (트랜잭션 필수)\nSTART TRANSACTION;\nUPDATE accounts SET balance = balance - 100000 WHERE id = 1;\nUPDATE accounts SET balance = balance + 100000 WHERE id = 2;\nCOMMIT;\n\n-- 복잡한 JOIN 쿼리\nSELECT u.name, o.total_price, p.name\nFROM users u\nJOIN orders o ON u.id = o.user_id\nJOIN order_items oi ON o.id = oi.order_id\nJOIN products p ON oi.product_id = p.id\nWHERE o.created_at > '2024-01-01';\n```\n\n### NoSQL이 좋은 경우\n\n```javascript\n// 빠르게 변하는 스키마 (MongoDB)\n// 오늘: 기본 필드\n{ name: \"상품A\", price: 10000 }\n\n// 내일: 새 필드 추가 (마이그레이션 불필요)\n{ name: \"상품A\", price: 10000, discount: 0.1, tags: [\"신상\", \"인기\"] }\n\n// 캐싱 (Redis)\nredis.set(\"user:1:cart\", JSON.stringify(cartItems), \"EX\", 3600);\n\n// 대용량 로그 (Cassandra)\n// 초당 수만 건 쓰기\nINSERT INTO logs (id, timestamp, message) VALUES (...);\n```\n\n### 하이브리드 아키텍처\n\n```\n실무에서는 둘 다 사용!\n\n┌─────────────────────────────────────────┐\n│              Application                │\n├──────────────────┬──────────────────────┤\n│     MySQL        │       Redis          │\n│  (메인 데이터)    │      (캐시)          │\n├──────────────────┼──────────────────────┤\n│    MongoDB       │    Elasticsearch     │\n│   (로그/문서)     │      (검색)          │\n└──────────────────┴──────────────────────┘\n```"
      },
      {
        "type": "tip",
        "title": "💡 선택 가이드",
        "content": "### 결정 체크리스트\n\n```\nSQL 선택:\n□ 트랜잭션 필수 (금융, 결제)\n□ 복잡한 관계/JOIN\n□ 데이터 무결성 중요\n□ 정형화된 데이터\n□ 스키마 변경 적음\n\nNoSQL 선택:\n□ 빠른 개발/프로토타이핑\n□ 유연한 스키마 필요\n□ 대용량/고성능\n□ 수평 확장 필요\n□ 비정형 데이터\n```\n\n### 실무 조언\n\n```\n1. 기본은 RDBMS로 시작\n2. 특정 요구사항에 NoSQL 추가\n3. \"은탄환\"은 없음\n4. 요구사항에 맞게 선택\n```"
      }
    ]
  },
  "09_실무/backup-restore": {
    "id": "09_실무/backup-restore",
    "title": "백업과 복구",
    "category": "db",
    "subCategory": "09_실무",
    "language": "SQL",
    "description": "데이터베이스 백업 전략을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 백업의 중요성",
        "content": "## 🔥 한 줄 요약\n> **데이터 손실 대비 안전장치** - 백업 없으면 복구 불가!\n\n---\n\n## 💡 백업이 필요한 상황\n\n```\n데이터 손실 원인:\n├── 하드웨어 장애\n├── 사람 실수 (DELETE 잘못)\n├── 소프트웨어 버그\n├── 해킹/랜섬웨어\n├── 자연재해\n└── 데이터 센터 장애\n\n백업 없으면:\n└── 복구 불가능! 사업 종료 가능\n```\n\n---\n\n## 🎯 백업 종류\n\n### Full Backup (전체)\n```\n모든 데이터 백업\n├── 장점: 복구 간단\n├── 단점: 시간/용량 큼\n└── 주기: 주 1회\n```\n\n### Incremental (증분)\n```\n마지막 백업 이후 변경분만\n├── 장점: 빠름, 용량 적음\n├── 단점: 복구 복잡\n└── 주기: 매일\n```\n\n### Differential (차등)\n```\n마지막 Full 이후 변경분\n├── 장점: 복구 비교적 간단\n├── 단점: 점점 커짐\n└── 주기: 매일\n```"
      },
      {
        "type": "code",
        "title": "💻 백업 실전",
        "content": "### MySQL 백업\n\n```bash\n# mysqldump (논리적 백업)\nmysqldump -u root -p --single-transaction --routines --triggers --events mydb > backup_$(date +%Y%m%d).sql\n\n# 압축\nmysqldump mydb | gzip > backup_$(date +%Y%m%d).sql.gz\n\n# 특정 테이블만\nmysqldump mydb users orders > partial_backup.sql\n```\n\n### MySQL 복구\n\n```bash\n# 복구\nmysql -u root -p mydb < backup_20240115.sql\n\n# 압축 파일 복구\ngunzip < backup_20240115.sql.gz | mysql -u root -p mydb\n```\n\n### 자동 백업 스크립트\n\n```bash\n#!/bin/bash\n# /etc/cron.daily/mysql-backup\n\nBACKUP_DIR=\"/backup/mysql\"\nDATE=$(date +%Y%m%d_%H%M%S)\nRETENTION_DAYS=7\n\n# 백업 실행\nmysqldump --single-transaction --all-databases | gzip > $BACKUP_DIR/backup_$DATE.sql.gz\n\n# 오래된 백업 삭제\nfind $BACKUP_DIR -name \"*.sql.gz\" -mtime +$RETENTION_DAYS -delete\n\n# S3 업로드 (선택)\naws s3 cp $BACKUP_DIR/backup_$DATE.sql.gz s3://my-backups/\n```\n\n### Point-in-Time Recovery\n\n```bash\n# binlog 활성화 (my.cnf)\nlog_bin = /var/log/mysql/mysql-bin\nbinlog_format = ROW\nexpire_logs_days = 7\n\n# 특정 시점 복구\nmysqlbinlog --stop-datetime=\"2024-01-15 14:00:00\" mysql-bin.000001 | mysql -u root -p\n```"
      },
      {
        "type": "tip",
        "title": "💡 백업 체크리스트",
        "content": "### 3-2-1 백업 규칙\n\n```\n3: 3개의 백업 복사본\n2: 2개의 다른 미디어 (디스크, 테이프)\n1: 1개는 오프사이트 (클라우드)\n```\n\n### 백업 검증\n\n```\n□ 정기적으로 복구 테스트\n□ 백업 파일 무결성 확인\n□ 복구 시간 측정 (RTO)\n□ 데이터 손실 범위 확인 (RPO)\n□ 백업 성공 알림 설정\n```\n\n### RTO/RPO\n\n```\nRTO (Recovery Time Objective):\n└── 복구까지 허용 시간 (예: 1시간)\n\nRPO (Recovery Point Objective):\n└── 손실 허용 데이터량 (예: 1시간치)\n\n백업 주기 = RPO\n복구 목표 시간 = RTO\n```"
      }
    ]
  },
  "09_실무/caching-strategy": {
    "id": "09_실무/caching-strategy",
    "title": "캐싱 전략",
    "category": "db",
    "subCategory": "09_실무",
    "language": "SQL",
    "description": "데이터베이스 캐싱 전략을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 캐싱 전략",
        "content": "## 🔥 한 줄 요약\n> **자주 쓰는 데이터를 빠른 저장소에** - DB 부하 90% 감소!\n\n---\n\n## 🎯 캐싱 패턴\n\n### 1. Cache-Aside (Look-Aside)\n```\n가장 일반적인 패턴\n\n1. 캐시 확인\n2. 없으면 DB 조회\n3. 캐시에 저장\n4. 반환\n```\n\n### 2. Write-Through\n```\n쓰기 시 캐시도 함께 갱신\n\n1. 데이터 쓰기\n2. 캐시 + DB 동시 저장\n3. 일관성 보장\n```\n\n### 3. Write-Behind (Write-Back)\n```\n캐시에만 쓰고 나중에 DB 반영\n\n1. 캐시에 쓰기\n2. 비동기로 DB 저장\n3. 빠르지만 데이터 손실 위험\n```\n\n### 4. Read-Through\n```\n캐시가 DB 조회 담당\n\n1. 캐시에 요청\n2. 캐시가 없으면 DB 조회\n3. 캐시가 저장 후 반환\n```"
      },
      {
        "type": "code",
        "title": "💻 캐싱 구현",
        "content": "### Cache-Aside 패턴\n\n```python\nimport redis\nimport json\n\nr = redis.Redis()\nCACHE_TTL = 3600  # 1시간\n\ndef get_user(user_id):\n    cache_key = f\"user:{user_id}\"\n\n    # 1. 캐시 확인\n    cached = r.get(cache_key)\n    if cached:\n        return json.loads(cached)\n\n    # 2. DB 조회\n    user = db.query(\"SELECT * FROM users WHERE id = %s\", user_id)\n\n    # 3. 캐시 저장\n    r.setex(cache_key, CACHE_TTL, json.dumps(user))\n\n    return user\n\ndef update_user(user_id, data):\n    # 1. DB 업데이트\n    db.execute(\"UPDATE users SET ... WHERE id = %s\", user_id)\n\n    # 2. 캐시 무효화\n    r.delete(f\"user:{user_id}\")\n```\n\n### 캐시 무효화 전략\n\n```python\n# 1. Time-based (TTL)\nr.setex(key, 3600, value)  # 1시간 후 만료\n\n# 2. Event-based\ndef on_user_update(user_id):\n    r.delete(f\"user:{user_id}\")\n    r.delete(f\"user_profile:{user_id}\")\n\n# 3. Version-based\ndef get_cached(key, version):\n    cached = r.hgetall(key)\n    if cached.get('version') == version:\n        return cached['data']\n    return None\n```\n\n### 캐시 Warming\n\n```python\n# 자주 조회되는 데이터 미리 캐싱\ndef warm_cache():\n    query = 'SELECT * FROM products ORDER BY view_count DESC LIMIT 100'\n    popular_products = db.query(query)\n\n    for product in popular_products:\n        cache_key = f\"product:{product['id']}\"\n        r.setex(cache_key, 3600, json.dumps(product))\n```"
      },
      {
        "type": "tip",
        "title": "💡 캐싱 주의사항",
        "content": "### 캐싱 대상\n\n```\n✅ 캐싱 적합\n├── 읽기 빈번, 쓰기 적음\n├── 계산 비용 큰 데이터\n├── 동일 요청 반복\n└── 잠시 오래된 데이터 허용\n\n❌ 캐싱 부적합\n├── 실시간 정확성 필요\n├── 자주 변경되는 데이터\n├── 개인화된 데이터\n```\n\n### 캐시 문제\n\n```\nCache Stampede:\n├── 캐시 만료 시 동시 DB 요청\n├── 해결: Lock, 미리 갱신\n\nCache Penetration:\n├── 없는 데이터 반복 조회\n├── 해결: Null 캐싱, Bloom Filter\n\nCache Avalanche:\n├── 동시에 대량 캐시 만료\n├── 해결: TTL 분산, 배치 갱신\n```"
      }
    ]
  },
  "09_실무/connection-pool": {
    "id": "09_실무/connection-pool",
    "title": "커넥션 풀",
    "category": "db",
    "subCategory": "09_실무",
    "language": "SQL",
    "description": "데이터베이스 커넥션 풀 관리를 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 커넥션 풀이란?",
        "content": "## 🔥 한 줄 요약\n> **미리 만들어둔 DB 연결 재사용** - 연결 비용 절약!\n\n---\n\n## 💡 왜 필요한가?\n\n```\n❌ 커넥션 풀 없이\n1. 요청마다 새 연결 생성 (50~100ms)\n2. 쿼리 실행 (5ms)\n3. 연결 종료\n→ 연결 비용이 쿼리보다 큼!\n→ 동시 요청 시 DB 연결 폭주\n\n✅ 커넥션 풀 사용\n1. 미리 연결 10개 생성\n2. 요청 시 기존 연결 빌려줌 (1ms)\n3. 쿼리 실행 후 반환\n→ 연결 재사용으로 성능 향상\n```\n\n---\n\n## 🎯 풀 설정\n\n```\n최소 연결 수 (min): 기본 유지 연결\n최대 연결 수 (max): 동시 최대 연결\n대기 타임아웃: 연결 기다리는 시간\n유휴 타임아웃: 안 쓰는 연결 정리\n```"
      },
      {
        "type": "code",
        "title": "💻 커넥션 풀 설정",
        "content": "### Python (SQLAlchemy)\n\n```python\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\n    \"mysql+pymysql://user:pass@localhost/db\",\n    pool_size=10,          # 기본 풀 크기\n    max_overflow=20,       # 추가 허용 연결\n    pool_timeout=30,       # 연결 대기 시간 (초)\n    pool_recycle=3600,     # 1시간마다 재연결\n    pool_pre_ping=True,    # 연결 유효성 체크\n)\n\n# 사용\nwith engine.connect() as conn:\n    result = conn.execute(\"SELECT * FROM users\")\n    # 자동으로 연결 반환\n```\n\n### Java (HikariCP)\n\n```java\nHikariConfig config = new HikariConfig();\nconfig.setJdbcUrl(\"jdbc:mysql://localhost/db\");\nconfig.setUsername(\"user\");\nconfig.setPassword(\"pass\");\n\n// 풀 설정\nconfig.setMinimumIdle(5);       // 최소 유휴 연결\nconfig.setMaximumPoolSize(20);  // 최대 연결\nconfig.setConnectionTimeout(30000);  // 30초\nconfig.setIdleTimeout(600000);  // 10분\nconfig.setMaxLifetime(1800000); // 30분\n\nHikariDataSource ds = new HikariDataSource(config);\n```\n\n### Node.js (mysql2)\n\n```javascript\nconst mysql = require('mysql2');\n\nconst pool = mysql.createPool({\n    host: 'localhost',\n    user: 'root',\n    database: 'mydb',\n    waitForConnections: true,\n    connectionLimit: 10,      // 최대 연결\n    queueLimit: 0,            // 대기열 제한 없음\n    enableKeepAlive: true,\n    keepAliveInitialDelay: 0\n});\n\n// 사용\npool.query('SELECT * FROM users', (err, results) => {\n    // 자동 반환\n});\n```"
      },
      {
        "type": "tip",
        "title": "💡 커넥션 풀 튜닝",
        "content": "### 적정 풀 크기\n\n```\n공식: 연결 수 = (코어 수 * 2) + 유효 디스크 수\n\n예시:\n├── 4코어 서버\n├── SSD 1개\n└── 권장: (4 * 2) + 1 = 9~10개\n\n주의:\n├── 너무 많으면: DB 부하 증가\n├── 너무 적으면: 대기 발생\n└── 모니터링으로 조정\n```\n\n### 모니터링 포인트\n\n```\n□ 활성 연결 수 (active)\n□ 유휴 연결 수 (idle)\n□ 대기 요청 수 (pending)\n□ 타임아웃 발생 횟수\n□ 연결 생성/해제 빈도\n```"
      }
    ]
  },
  "09_실무/n-plus-1": {
    "id": "09_실무/n-plus-1",
    "title": "N+1 문제",
    "category": "db",
    "subCategory": "09_실무",
    "language": "SQL",
    "description": "ORM의 N+1 쿼리 문제와 해결법을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 N+1 문제란?",
        "content": "## 🔥 한 줄 요약\n> **1개 조회 후 N개 추가 쿼리** - ORM의 대표적 성능 문제!\n\n---\n\n## 💡 문제 상황\n\n```python\n# 유저 10명 조회\nusers = User.query.all()  # 쿼리 1개\n\nfor user in users:\n    print(user.orders)  # 쿼리 10개 추가!\n\n# 총 11개 쿼리 (1 + N)\n```\n\n```sql\n-- 실제 실행되는 쿼리\nSELECT * FROM users;                    -- 1번\nSELECT * FROM orders WHERE user_id = 1; -- 2번\nSELECT * FROM orders WHERE user_id = 2; -- 3번\n...\nSELECT * FROM orders WHERE user_id = 10; -- 11번\n```\n\n---\n\n## 🎯 해결 방법\n\n### 1. Eager Loading (즉시 로딩)\n```python\n# 처음부터 관계 데이터 함께 로드\nusers = User.query.options(joinedload(User.orders)).all()\n```\n\n### 2. Batch Loading (배치 로딩)\n```python\n# ID 목록으로 한 번에 로드\nuser_ids = [u.id for u in users]\norders = Order.query.filter(Order.user_id.in_(user_ids)).all()\n```\n\n### 3. JOIN으로 직접 조회\n```sql\nSELECT u.*, o.*\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id;\n```"
      },
      {
        "type": "code",
        "title": "💻 N+1 해결",
        "content": "### SQLAlchemy 해결\n\n```python\nfrom sqlalchemy.orm import joinedload, subqueryload\n\n# ❌ N+1 발생\nusers = session.query(User).all()\nfor user in users:\n    print(user.orders)  # 매번 쿼리!\n\n# ✅ Joined Load (1개 쿼리, JOIN)\nusers = session.query(User).options(\n    joinedload(User.orders)\n).all()\n\n# ✅ Subquery Load (2개 쿼리)\nusers = session.query(User).options(\n    subqueryload(User.orders)\n).all()\n```\n\n### Django ORM 해결\n\n```python\n# ❌ N+1 발생\nusers = User.objects.all()\nfor user in users:\n    print(user.order_set.all())  # 매번 쿼리!\n\n# ✅ select_related (1:1, FK - JOIN)\nusers = User.objects.select_related('profile').all()\n\n# ✅ prefetch_related (1:N, M:N - IN 쿼리)\nusers = User.objects.prefetch_related('order_set').all()\n\n# ✅ 복합 사용\nusers = User.objects.select_related('profile').prefetch_related('order_set', 'order_set__items').all()\n```\n\n### JPA 해결\n\n```java\n// ❌ N+1 발생\nList<User> users = userRepository.findAll();\nusers.forEach(u -> u.getOrders().size());  // Lazy loading\n\n// ✅ Fetch Join\n@Query(\"SELECT u FROM User u JOIN FETCH u.orders\")\nList<User> findAllWithOrders();\n\n// ✅ EntityGraph\n@EntityGraph(attributePaths = {\"orders\"})\nList<User> findAll();\n\n// ✅ Batch Size 설정\n@BatchSize(size = 100)\n@OneToMany(mappedBy = \"user\")\nprivate List<Order> orders;\n```"
      },
      {
        "type": "tip",
        "title": "💡 N+1 예방",
        "content": "### 탐지 방법\n\n```python\n# 쿼리 로깅 활성화\nlogging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)\n\n# Django\nLOGGING = {\n    'loggers': {\n        'django.db.backends': {'level': 'DEBUG'}\n    }\n}\n```\n\n### 예방 체크리스트\n\n```\n□ 루프 내 관계 접근 확인\n□ ORM 쿼리 로그 확인\n□ Eager Loading 적용\n□ 필요한 관계만 로드\n□ API 응답에 관계 데이터 포함 시 주의\n```"
      }
    ]
  },
  "09_실무/replication": {
    "id": "09_실무/replication",
    "title": "복제 (Replication)",
    "category": "db",
    "subCategory": "09_실무",
    "language": "SQL",
    "description": "데이터베이스 복제 전략을 학습합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 Replication이란?",
        "content": "## 🔥 한 줄 요약\n> **DB를 여러 대로 복제** - 읽기 성능 향상 + 장애 대비!\n\n---\n\n## 💡 왜 필요한가?\n\n```\n단일 DB 한계:\n├── 읽기 부하 집중\n├── 장애 시 서비스 중단\n├── 백업 중 성능 저하\n\nReplication으로:\n├── Master: 쓰기 담당\n├── Slave: 읽기 담당 (여러 대)\n├── 장애 시 Slave → Master 승격\n└── 읽기 성능 N배 향상\n```\n\n---\n\n## 🎯 복제 방식\n\n### 비동기 복제 (Async)\n```\nMaster 쓰기 완료 → 응답 → Slave 복제\n\n장점: 빠름\n단점: 복제 지연 (lag)\n```\n\n### 동기 복제 (Sync)\n```\nMaster 쓰기 → Slave 복제 완료 → 응답\n\n장점: 데이터 일관성\n단점: 느림\n```\n\n### 반동기 복제 (Semi-Sync)\n```\n최소 1대 Slave 복제 완료 → 응답\n\n장점: 균형잡힌 선택\n```"
      },
      {
        "type": "code",
        "title": "💻 복제 설정",
        "content": "### 읽기/쓰기 분리 (Python)\n\n```python\nfrom sqlalchemy import create_engine\n\n# Master (쓰기)\nmaster_engine = create_engine(\"mysql://master-host/db\")\n\n# Slave (읽기) - 여러 대 가능\nslave_engines = [\n    create_engine(\"mysql://slave1-host/db\"),\n    create_engine(\"mysql://slave2-host/db\"),\n]\n\nclass DatabaseRouter:\n    def __init__(self):\n        self.slave_index = 0\n\n    def get_read_engine(self):\n        # Round-robin\n        engine = slave_engines[self.slave_index]\n        self.slave_index = (self.slave_index + 1) % len(slave_engines)\n        return engine\n\n    def get_write_engine(self):\n        return master_engine\n\nrouter = DatabaseRouter()\n\n# 사용\ndef get_user(user_id):\n    engine = router.get_read_engine()  # Slave에서 읽기\n    return engine.execute(\"SELECT * FROM users WHERE id = %s\", user_id)\n\ndef create_user(data):\n    engine = router.get_write_engine()  # Master에 쓰기\n    engine.execute(\"INSERT INTO users ...\", data)\n```\n\n### Django 설정\n\n```python\n# settings.py\nDATABASES = {\n    'default': {  # Master\n        'ENGINE': 'django.db.backends.mysql',\n        'HOST': 'master-host',\n    },\n    'replica': {  # Slave\n        'ENGINE': 'django.db.backends.mysql',\n        'HOST': 'slave-host',\n    }\n}\n\n# Router\nclass PrimaryReplicaRouter:\n    def db_for_read(self, model, **hints):\n        return 'replica'\n\n    def db_for_write(self, model, **hints):\n        return 'default'\n\nDATABASE_ROUTERS = ['path.to.PrimaryReplicaRouter']\n```"
      },
      {
        "type": "tip",
        "title": "💡 복제 주의사항",
        "content": "### 복제 지연 (Lag) 문제\n\n```python\n# 문제: 쓰기 직후 읽기\ncreate_user(data)\nuser = get_user(user_id)  # Slave에서 아직 없을 수 있음!\n\n# 해결: 쓰기 직후는 Master에서 읽기\ndef get_user(user_id, from_master=False):\n    if from_master:\n        engine = router.get_write_engine()\n    else:\n        engine = router.get_read_engine()\n    ...\n\n# 사용\ncreate_user(data)\nuser = get_user(user_id, from_master=True)\n```\n\n### 모니터링\n\n```sql\n-- MySQL Slave 상태 확인\nSHOW SLAVE STATUS;\n\n-- 복제 지연 확인\nSeconds_Behind_Master: 0  -- 0이면 정상\n```"
      }
    ]
  },
  "10_면접/interview-db": {
    "id": "10_면접/interview-db",
    "title": "DB 면접 질문",
    "category": "db",
    "subCategory": "10_면접",
    "language": "SQL",
    "description": "데이터베이스 면접 대비 핵심 질문을 정리합니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 필수 면접 질문",
        "content": "## 🎯 기초 질문\n\n### Q: RDBMS와 NoSQL의 차이?\n```\nRDBMS:\n├── 정형화된 스키마\n├── ACID 트랜잭션\n├── SQL 표준\n├── 수직 확장\n\nNoSQL:\n├── 유연한 스키마\n├── BASE (최종 일관성)\n├── 다양한 쿼리\n├── 수평 확장\n```\n\n### Q: 인덱스란? 왜 필요한가?\n```\n인덱스 = 데이터 검색 속도 향상 자료구조\n├── B-Tree 구조로 O(log N) 검색\n├── WHERE, JOIN, ORDER BY 성능 향상\n├── 단점: 쓰기 성능 저하, 저장공간 필요\n```\n\n### Q: 정규화란?\n```\n데이터 중복 제거 + 무결성 보장\n├── 1NF: 원자값\n├── 2NF: 부분 함수 종속 제거\n├── 3NF: 이행 함수 종속 제거\n└── 실무: 3NF까지, 필요시 역정규화\n```"
      },
      {
        "type": "code",
        "title": "💻 심화 질문",
        "content": "### Q: 트랜잭션 격리 수준 설명\n\n```\nREAD UNCOMMITTED: 커밋 안 된 데이터 읽음 (Dirty Read)\nREAD COMMITTED: 커밋된 것만 읽음\nREPEATABLE READ: 트랜잭션 내 일관된 읽기 (MySQL 기본)\nSERIALIZABLE: 완전 격리 (가장 느림)\n\n→ 높을수록 안전하지만 성능 저하\n```\n\n### Q: 인덱스가 안 타는 경우?\n\n```sql\n-- 1. 함수 사용\nWHERE YEAR(created_at) = 2024  -- ❌\n\n-- 2. LIKE '%keyword'\nWHERE name LIKE '%철수'  -- ❌\n\n-- 3. 타입 불일치\nWHERE string_column = 123  -- ❌\n\n-- 4. OR 조건\nWHERE col1 = 'A' OR col2 = 'B'  -- ❌\n\n-- 5. 부정 조건\nWHERE status != 'deleted'  -- ❌\n```\n\n### Q: N+1 문제란?\n\n```python\n# 문제: 1 + N개 쿼리\nusers = User.query.all()  # 1개\nfor user in users:\n    print(user.orders)  # N개\n\n# 해결: Eager Loading\nusers = User.query.options(\n    joinedload(User.orders)\n).all()  # 1개로 해결\n```\n\n### Q: 데드락이란? 해결법?\n\n```\n데드락 = 서로가 서로의 락 대기\n\n해결:\n1. 항상 같은 순서로 락 획득\n2. 락 타임아웃 설정\n3. 재시도 로직 구현\n4. 트랜잭션 짧게 유지\n```"
      },
      {
        "type": "tip",
        "title": "💡 실무 질문",
        "content": "### Q: 슬로우 쿼리 대응?\n\n```\n1. 슬로우 쿼리 로그로 식별\n2. EXPLAIN으로 실행계획 분석\n3. 인덱스 추가/수정\n4. 쿼리 리팩토링\n5. 필요시 캐싱/샤딩\n```\n\n### Q: DB 확장 전략?\n\n```\n1단계: 쿼리 최적화, 인덱스\n2단계: 읽기 복제본 (Read Replica)\n3단계: 캐싱 (Redis)\n4단계: 파티셔닝\n5단계: 샤딩 (최후의 수단)\n```\n\n### Q: 경험한 DB 장애와 해결?\n\n```\n(준비해야 할 답변 예시)\n\"피크 시간에 슬로우 쿼리로 커넥션 풀 고갈\n→ SHOW PROCESSLIST로 문제 쿼리 확인\n→ 인덱스 추가로 즉시 해결\n→ 이후 슬로우 쿼리 모니터링 도입\"\n```"
      }
    ]
  },
  "index": {
    "id": "index",
    "title": "Database",
    "category": "db",
    "subCategory": null,
    "language": "Text",
    "description": "데이터베이스 학습 로드맵입니다",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "🔥 데이터베이스 학습 로드맵",
        "content": "## 🎯 학습 순서\n\n### 1단계: 기초 (1-2주)\n```\n├── DB 개념, RDBMS\n├── SQL 기초 (SELECT, INSERT, UPDATE, DELETE)\n├── WHERE, ORDER BY, LIMIT\n└── 기본 자료형\n```\n\n### 2단계: SQL 심화 (2-3주)\n```\n├── JOIN (INNER, LEFT, RIGHT)\n├── GROUP BY, HAVING\n├── 서브쿼리\n├── 집계 함수\n└── 날짜/문자열 함수\n```\n\n### 3단계: 설계 (1-2주)\n```\n├── 정규화 (1NF~3NF)\n├── ERD 설계\n├── PK, FK, 관계\n└── 제약조건\n```\n\n### 4단계: 성능 (2-3주)\n```\n├── 인덱스 원리와 설계\n├── EXPLAIN 분석\n├── 쿼리 최적화\n└── 슬로우 쿼리 해결\n```\n\n### 5단계: 트랜잭션 (1-2주)\n```\n├── ACID\n├── 격리 수준\n├── 락 (Lock)\n└── MVCC\n```\n\n### 6단계: 실무/심화 (2-3주)\n```\n├── 커넥션 풀\n├── 복제 (Replication)\n├── 파티셔닝/샤딩\n├── NoSQL (Redis, MongoDB)\n└── 백업/복구\n```"
      },
      {
        "type": "tip",
        "title": "💡 학습 팁",
        "content": "### 실습 권장\n\n```\n1. 로컬에 MySQL 설치\n2. 쇼핑몰 DB 직접 설계\n3. 100만건 데이터로 최적화 실습\n4. ORM과 함께 사용해보기\n```\n\n### 추천 리소스\n\n```\n무료:\n├── MySQL 공식 문서\n├── SQLZoo (온라인 실습)\n├── LeetCode SQL 문제\n└── 프로그래머스 SQL\n\n도서:\n├── Real MySQL (한국어)\n├── SQL 첫걸음\n├── 데이터베이스 개론\n```"
      }
    ]
  }
}