{
  "01_ê¸°ì´ˆ/algorithm-intro": {
    "id": "01_ê¸°ì´ˆ/algorithm-intro",
    "title": "Algorithm Intro",
    "category": "algorithm",
    "subCategory": "01_ê¸°ì´ˆ",
    "language": "Python",
    "description": "ì•Œê³ ë¦¬ì¦˜ì˜ ì •ì˜ì™€ ì¤‘ìš”ì„±, ì¢‹ì€ ì•Œê³ ë¦¬ì¦˜ì˜ ì¡°ê±´ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì•Œê³ ë¦¬ì¦˜ì´ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë‹¨ê³„ë³„ ì ˆì°¨** - ìš”ë¦¬ ë ˆì‹œí”¼ì²˜ëŸ¼ ì…ë ¥ì„ ì¶œë ¥ìœ¼ë¡œ ë°”ê¾¸ëŠ” ëª…í™•í•œ ê·œì¹™\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì‹¤ë¬´ì—ì„œ:\n- **ì„±ëŠ¥ ìµœì í™”**: ê°™ì€ ê¸°ëŠ¥ë„ ì•Œê³ ë¦¬ì¦˜ì— ë”°ë¼ 1ì´ˆ vs 1ì‹œê°„ ì°¨ì´\n- **ë¹„ìš© ì ˆê°**: AWS ì„œë²„ ë¹„ìš©ì´ ì•Œê³ ë¦¬ì¦˜ íš¨ìœ¨ì— ì§ê²°\n- **í™•ì¥ì„±**: ì‚¬ìš©ì 100ëª… â†’ 100ë§Œëª… ë  ë•Œ ë²„í‹°ëŠ” ì½”ë“œ\n\n### ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ:\n- ì¶œì œ ë¹ˆë„: â­â­â­â­â­ (ëª¨ë“  ë¬¸ì œì˜ ê¸°ë³¸)\n- ëŒ€í‘œ ê¸°ì—…: ì‚¼ì„±, ì¹´ì¹´ì˜¤, ë„¤ì´ë²„, ë¼ì¸ **ì „ë¶€**\n\n### ì´ê±¸ ëª¨ë¥´ë©´:\n- âŒ \"ì™œ ë‚´ ì½”ë“œëŠ” ì‹œê°„ì´ˆê³¼ì§€?\" í‰ìƒ ì˜ë¬¸\n- âŒ ë©´ì ‘ì—ì„œ \"ì‹œê°„ë³µì¡ë„ê°€ ë­ì˜ˆìš”?\" ëŒ€ë‹µ ëª»í•¨\n- âŒ ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ ë¶ˆê°€ëŠ¥\n\n---\n\n## ğŸ¯ í•µì‹¬ ê°œë… (5ë¶„ ì»·)\n\n### ğŸ“š ìš”ë¦¬ ë ˆì‹œí”¼ë¡œ ì´í•´í•˜ê¸°\n\n**ë¼ë©´ ë“ì´ê¸° ì•Œê³ ë¦¬ì¦˜:**\n```\nì…ë ¥: ë¼ë©´, ë¬¼ 500ml, ìŠ¤í”„\nì¶œë ¥: ë§›ìˆëŠ” ë¼ë©´\n\n1. ëƒ„ë¹„ì— ë¬¼ 500mlë¥¼ ë„£ëŠ”ë‹¤\n2. ë¬¼ì´ ë“ìœ¼ë©´ ë©´ê³¼ ìŠ¤í”„ë¥¼ ë„£ëŠ”ë‹¤\n3. 4ë¶„ 30ì´ˆ ê¸°ë‹¤ë¦°ë‹¤\n4. ë¶ˆì„ ë„ê³  ê·¸ë¦‡ì— ë‹´ëŠ”ë‹¤\n```\n\n**í•µì‹¬ í¬ì¸íŠ¸ 3ê°€ì§€:**\n1. **ì…ë ¥(Input)**: ë¬¸ì œì—ì„œ ì£¼ì–´ì§€ëŠ” ë°ì´í„°\n2. **ì¶œë ¥(Output)**: ìš°ë¦¬ê°€ êµ¬í•´ì•¼ í•˜ëŠ” ë‹µ\n3. **ê³¼ì •(Process)**: ì…ë ¥ì„ ì¶œë ¥ìœ¼ë¡œ ë°”ê¾¸ëŠ” ë‹¨ê³„\n\n### ì¢‹ì€ ì•Œê³ ë¦¬ì¦˜ì˜ ì¡°ê±´\n| ì¡°ê±´ | ì„¤ëª… | ì˜ˆì‹œ |\n|-----|------|-----|\n| **ì •í™•ì„±** | ì˜¬ë°”ë¥¸ ê²°ê³¼ ë„ì¶œ | 1+1=2 (O), 1+1=3 (X) |\n| **íš¨ìœ¨ì„±** | ë¹ ë¥´ê³  ë©”ëª¨ë¦¬ ì ê²Œ | O(n) vs O(nÂ²) |\n| **ëª…í™•ì„±** | ëˆ„êµ¬ë‚˜ ì´í•´ ê°€ëŠ¥ | ì£¼ì„ ì˜ ë‹¬ë¦° ì½”ë“œ |"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ì•Œê³ ë¦¬ì¦˜ì˜ ê¸°ë³¸ êµ¬ì¡° ì˜ˆì‹œ\n# ë¬¸ì œ: 1ë¶€í„° Nê¹Œì§€ì˜ í•© êµ¬í•˜ê¸°\n\ndef sum_basic(n):\n    \"\"\"ë°©ë²• 1: ë°˜ë³µë¬¸ - O(n)\"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        total += i\n    return total\n\ndef sum_formula(n):\n    \"\"\"ë°©ë²• 2: ìˆ˜í•™ ê³µì‹ - O(1)\"\"\"\n    return n * (n + 1) // 2\n\n# í…ŒìŠ¤íŠ¸\nprint(sum_basic(100))   # 5050\nprint(sum_formula(100)) # 5050\n\n# ê°™ì€ ê²°ê³¼, ë‹¤ë¥¸ íš¨ìœ¨!\n# n = 1ì–µì¼ ë•Œ:\n# - sum_basic: ìˆ˜ ì´ˆ ì†Œìš”\n# - sum_formula: ì¦‰ì‹œ ì™„ë£Œ"
      },
      {
        "type": "best-practice",
        "title": "âœ… Good vs âŒ Bad",
        "content": "**1ï¸âƒ£ ë¬¸ì œ ì´í•´**\n\nâŒ **Bad:** ë°”ë¡œ ì½”ë”© ì‹œì‘\n```python\n# ë¬¸ì œ ì•ˆ ì½ê³  ì½”ë”© ì‹œì‘...\ndef solve():\n    pass  # ë­˜ í•´ì•¼ í•˜ì§€?\n```\n\nâœ… **Good:** ì…ë ¥/ì¶œë ¥ ë¨¼ì € íŒŒì•…\n```python\n# ì…ë ¥: ì •ìˆ˜ N (1 â‰¤ N â‰¤ 100)\n# ì¶œë ¥: 1ë¶€í„° Nê¹Œì§€ì˜ í•©\ndef solve(n):\n    return n * (n + 1) // 2\n```\n\n---\n\n**2ï¸âƒ£ ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„**\n\nâŒ **Bad:** ë¬´ì‘ì • ì½”ë”©\n```python\n# ì¼ë‹¨ í•´ë³´ì...\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            # O(nÂ³) ì§€ì˜¥\n```\n\nâœ… **Good:** ì‹œê°„ë³µì¡ë„ ë¨¼ì € ê³„ì‚°\n```python\n# N = 10ë§Œì´ë©´ O(nÂ²)ì€ 100ì–µ ì—°ì‚° = ì‹œê°„ì´ˆê³¼\n# O(n log n) ì´í•˜ë¡œ ì„¤ê³„í•´ì•¼ í•¨\n```"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "### Level 1: ê¸°ì´ˆ\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| A+B (1000) | ë°±ì¤€ | ì…ì¶œë ¥ ê¸°ì´ˆ |\n| Hello World (2557) | ë°±ì¤€ | ì²« ì œì¶œ ì—°ìŠµ |\n\n### Level 2: ì‘ìš©\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| í•© êµ¬í•˜ê¸° (11720) | ë°±ì¤€ | ë¬¸ìì—´ â†’ ìˆ«ì |\n| ìµœëŒ“ê°’ (2562) | ë°±ì¤€ | ë°°ì—´ ìˆœíšŒ |\n\n### âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸\n- [ ] ì•Œê³ ë¦¬ì¦˜ = ë¬¸ì œ í•´ê²° ì ˆì°¨ì„ì„ ì•ˆë‹¤\n- [ ] ì…ë ¥/ì¶œë ¥ì„ ë¨¼ì € íŒŒì•…í•œë‹¤\n- [ ] ì‹œê°„ë³µì¡ë„ ê°œë…ì„ ì•ˆë‹¤"
      }
    ]
  },
  "01_ê¸°ì´ˆ/quiz-complexity": {
    "id": "01_ê¸°ì´ˆ/quiz-complexity",
    "title": "Quiz Complexity",
    "category": "algorithm",
    "subCategory": "01_ê¸°ì´ˆ",
    "language": "Python",
    "description": "ì‹œê°„/ê³µê°„ ë³µì¡ë„ ë¶„ì„ ì‹¤ì „ ì—°ìŠµ ë¬¸ì œì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ¯ ë³µì¡ë„ í€´ì¦ˆ",
        "content": "## ğŸ”¥ ë³µì¡ë„ ë§ˆìŠ¤í„° í€´ì¦ˆ\n\nì´ í€´ì¦ˆë¥¼ í†µí•´ ì‹œê°„/ê³µê°„ ë³µì¡ë„ ë¶„ì„ ëŠ¥ë ¥ì„ í…ŒìŠ¤íŠ¸í•˜ì„¸ìš”!\n\n---\n\n### í€´ì¦ˆ 1: ê¸°ë³¸ ë°˜ë³µë¬¸\n\n```python\ndef mystery1(n):\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            count += 1\n    return count\n```\n**ì‹œê°„ë³µì¡ë„?** <details><summary>ì •ë‹µ</summary>O(nÂ²)</details>\n\n---\n\n### í€´ì¦ˆ 2: ì¤‘ì²© ì¡°ê±´\n\n```python\ndef mystery2(n):\n    count = 0\n    for i in range(n):\n        for j in range(i):\n            count += 1\n    return count\n```\n**ì‹œê°„ë³µì¡ë„?** <details><summary>ì •ë‹µ</summary>O(nÂ²) - n*(n-1)/2 â‰ˆ nÂ²/2</details>\n\n---\n\n### í€´ì¦ˆ 3: ë¡œê·¸ ì‹œê°„\n\n```python\ndef mystery3(n):\n    count = 0\n    while n > 0:\n        count += 1\n        n //= 2\n    return count\n```\n**ì‹œê°„ë³µì¡ë„?** <details><summary>ì •ë‹µ</summary>O(log n)</details>"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ë³µì¡ë„ ë¶„ì„ ì—°ìŠµ ì½”ë“œ\n\n# í€´ì¦ˆ 4: ì´ í•¨ìˆ˜ì˜ ì‹œê°„ë³µì¡ë„ëŠ”?\ndef find_pairs(arr):\n    n = len(arr)\n    pairs = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            pairs.append((arr[i], arr[j]))\n    return pairs\n# ì •ë‹µ: O(nÂ²)\n\n# í€´ì¦ˆ 5: ì´ í•¨ìˆ˜ì˜ ì‹œê°„ë³µì¡ë„ëŠ”?\ndef binary_search_count(arr, target):\n    left, right = 0, len(arr) - 1\n    count = 0\n    while left <= right:\n        mid = (left + right) // 2\n        count += 1\n        if arr[mid] == target:\n            return count\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return count\n# ì •ë‹µ: O(log n)\n\n# í€´ì¦ˆ 6: ì´ í•¨ìˆ˜ì˜ ê³µê°„ë³µì¡ë„ëŠ”?\ndef create_spiral(n):\n    matrix = [[0] * n for _ in range(n)]\n    # ë‚˜ì„ í˜•ìœ¼ë¡œ ì±„ìš°ëŠ” ë¡œì§...\n    return matrix\n# ì •ë‹µ: O(nÂ²)\n\n# í€´ì¦ˆ 7: ì¬ê·€ì˜ ì‹œê°„ë³µì¡ë„ëŠ”?\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)\n# ì •ë‹µ: O(2â¿) - ì§€ìˆ˜ ì‹œê°„!\n\n# í€´ì¦ˆ 8: ì´ê±´?\ndef fib_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)\n    return memo[n]\n# ì •ë‹µ: O(n) - ë©”ëª¨ì´ì œì´ì…˜ìœ¼ë¡œ ê°œì„ "
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì‹¤ì „ ë¬¸ì œ",
        "content": "### ë‚œì´ë„ë³„ ë³µì¡ë„ ë¶„ì„\n\n**Level 1: ë¹ˆì¹¸ ì±„ìš°ê¸°**\n\n| ì½”ë“œ íŒ¨í„´ | ì‹œê°„ë³µì¡ë„ |\n|----------|----------|\n| `for i in range(n): O(1)` | O(___) |\n| `for i in range(n): for j in range(n):` | O(___) |\n| `while n > 0: n //= 2` | O(___) |\n| `arr.sort()` | O(___) |\n| `set.add(x)` | O(___) |\n\n<details><summary>ì •ë‹µ</summary>\nO(n), O(nÂ²), O(log n), O(n log n), O(1)\n</details>\n\n---\n\n**Level 2: ì½”ë“œ ë¶„ì„**\n\n```python\ndef process(arr):\n    arr.sort()  # ?\n    for x in arr:  # ?\n        if x in arr:  # ?\n            print(x)\n```\n**ì´ ì‹œê°„ë³µì¡ë„?**\n<details><summary>ì •ë‹µ</summary>\nO(n log n) + O(n) Ã— O(n) = O(nÂ²)\n(in ì—°ì‚°ì´ ë¦¬ìŠ¤íŠ¸ì—ì„œ O(n))\n</details>\n\n---\n\n**Level 3: ìµœì í™” ë¬¸ì œ**\n\n\"Nê°œ ìˆ«ì ì¤‘ ì¤‘ë³µì„ ì œê±°í•˜ë¼\"\n- ë°©ë²• 1: ì´ì¤‘ ë£¨í”„ ë¹„êµ â†’ O(?)\n- ë°©ë²• 2: ì •ë ¬ í›„ ì¸ì ‘ ë¹„êµ â†’ O(?)\n- ë°©ë²• 3: Set ì‚¬ìš© â†’ O(?)\n\n<details><summary>ì •ë‹µ</summary>\nO(nÂ²), O(n log n), O(n)\n</details>"
      }
    ]
  },
  "01_ê¸°ì´ˆ/recursion-advanced": {
    "id": "01_ê¸°ì´ˆ/recursion-advanced",
    "title": "Recursion Advanced",
    "category": "algorithm",
    "subCategory": "01_ê¸°ì´ˆ",
    "language": "Python",
    "description": "ê¼¬ë¦¬ ì¬ê·€, ë©”ëª¨ì´ì œì´ì…˜ ë“± ì¬ê·€ ìµœì í™” ê¸°ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì¬ê·€ ìµœì í™”",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì¬ê·€ì˜ ë‹¨ì ì„ ê·¹ë³µí•˜ëŠ” ê¸°ë²•ë“¤** - ë©”ëª¨ì´ì œì´ì…˜, ê¼¬ë¦¬ ì¬ê·€, ë°˜ë³µë¬¸ ë³€í™˜\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì¬ê·€ì˜ ë¬¸ì œì :\n1. **ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš°**: ê¹Šì€ ì¬ê·€ ì‹œ ì—ëŸ¬\n2. **ì¤‘ë³µ ê³„ì‚°**: ê°™ì€ ê°’ ë°˜ë³µ ê³„ì‚°\n3. **ëŠë¦° ì†ë„**: í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë²„í—¤ë“œ\n\n### í•´ê²°ì±…:\n- **ë©”ëª¨ì´ì œì´ì…˜**: ê³„ì‚° ê²°ê³¼ ì €ì¥ â†’ O(2â¿) â†’ O(n)\n- **ê¼¬ë¦¬ ì¬ê·€**: ìŠ¤íƒ ì‚¬ìš© ìµœì†Œí™”\n- **ë°˜ë³µë¬¸ ë³€í™˜**: ì¬ê·€ë¥¼ ë£¨í”„ë¡œ\n\n---\n\n## ğŸ¯ í•µì‹¬ ê°œë…\n\n### 1. ë©”ëª¨ì´ì œì´ì…˜ (Memoization)\n```\nfib(5)ë¥¼ êµ¬í•˜ë©´:\n- ì¼ë°˜ ì¬ê·€: fib(3) 2ë²ˆ, fib(2) 3ë²ˆ ì¤‘ë³µ ê³„ì‚°\n- ë©”ëª¨ì´ì œì´ì…˜: í•œ ë²ˆ ê³„ì‚°í•œ ê±´ ì €ì¥í•´ì„œ ì¬ì‚¬ìš©\n```\n\n### 2. ê¼¬ë¦¬ ì¬ê·€ (Tail Recursion)\n```\nì¼ë°˜ ì¬ê·€: return n * factorial(n-1)\n          â†’ ëŒì•„ì™€ì„œ ê³±ì…ˆ í•„ìš” (ìŠ¤íƒ ìœ ì§€)\n\nê¼¬ë¦¬ ì¬ê·€: return factorial(n-1, acc * n)\n          â†’ ë°”ë¡œ ë°˜í™˜ ê°€ëŠ¥ (ìŠ¤íƒ ìµœì í™” ê°€ëŠ¥)\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ì¬ê·€ ìµœì í™” ê¸°ë²•\n\n# 1. ë©”ëª¨ì´ì œì´ì…˜ - ë°ì½”ë ˆì´í„° ì‚¬ìš©\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib_memo(n):\n    if n <= 1:\n        return n\n    return fib_memo(n - 1) + fib_memo(n - 2)\n\nprint(fib_memo(100))  # ì¦‰ì‹œ ê³„ì‚°!\n\n# 2. ë©”ëª¨ì´ì œì´ì…˜ - ë”•ì…”ë„ˆë¦¬ ì‚¬ìš©\ndef fib_dict(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fib_dict(n - 1, memo) + fib_dict(n - 2, memo)\n    return memo[n]\n\n# 3. ê¼¬ë¦¬ ì¬ê·€ (Pythonì€ ìµœì í™” ì•ˆ í•˜ì§€ë§Œ ê°œë… ì´í•´ìš©)\ndef factorial_tail(n, accumulator=1):\n    if n <= 1:\n        return accumulator\n    return factorial_tail(n - 1, accumulator * n)\n\n# 4. ë°˜ë³µë¬¸ìœ¼ë¡œ ë³€í™˜ (ê°€ì¥ íš¨ìœ¨ì )\ndef fib_iterative(n):\n    if n <= 1:\n        return n\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n    return curr\n\n# 5. íƒ€ë·¸ë ˆì´ì…˜ (Bottom-Up DP)\ndef fib_tabulation(n):\n    if n <= 1:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n\n# ì„±ëŠ¥ ë¹„êµ\nimport time\n\nn = 35\n# ì¼ë°˜ ì¬ê·€: ìˆ˜ ì´ˆ ì†Œìš”\n# ë©”ëª¨ì´ì œì´ì…˜: ì¦‰ì‹œ\n# ë°˜ë³µë¬¸: ì¦‰ì‹œ"
      },
      {
        "type": "tip",
        "title": "ğŸ’¡ ì¬ê·€ vs ë°˜ë³µë¬¸ ì„ íƒ ê°€ì´ë“œ",
        "content": "### ì–¸ì œ ì¬ê·€ë¥¼ ì“¸ê¹Œ?\n\nâœ… **ì¬ê·€ê°€ ì¢‹ì€ ê²½ìš°:**\n- íŠ¸ë¦¬/ê·¸ë˜í”„ íƒìƒ‰ (DFS)\n- ë¶„í•  ì •ë³µ (í€µì •ë ¬, ë³‘í•©ì •ë ¬)\n- ë°±íŠ¸ë˜í‚¹ (ìˆœì—´, ì¡°í•©)\n- ì½”ë“œ ê°€ë…ì„±ì´ ì¤‘ìš”í•  ë•Œ\n\nâŒ **ë°˜ë³µë¬¸ì´ ì¢‹ì€ ê²½ìš°:**\n- ë‹¨ìˆœ ë°˜ë³µ ì‘ì—…\n- ê¹Šì´ê°€ ë§¤ìš° ê¹Šì„ ë•Œ (N > 1000)\n- ì„±ëŠ¥ì´ ì¤‘ìš”í•  ë•Œ\n- ë©”ëª¨ë¦¬ê°€ ì œí•œì ì¼ ë•Œ\n\n### ë³€í™˜ íŒ¨í„´\n```python\n# ì¬ê·€ â†’ ë°˜ë³µë¬¸ ë³€í™˜ ê³µì‹\ndef recursive(n):\n    if base_condition:\n        return base_value\n    return combine(recursive(n-1))\n\n# â†“ ë³€í™˜\n\ndef iterative(n):\n    result = base_value\n    for i in range(appropriate_range):\n        result = combine(result)\n    return result\n```"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "### ìµœì í™” ì—°ìŠµ\n\n**Q1.** ë©”ëª¨ì´ì œì´ì…˜ìœ¼ë¡œ ê°œì„ í•˜ê¸°\n```python\n# ì´ ì½”ë“œë¥¼ ìµœì í™”í•˜ì„¸ìš”\ndef count_ways(n):\n    if n <= 1:\n        return 1\n    return count_ways(n-1) + count_ways(n-2) + count_ways(n-3)\n```\n\n**Q2.** ë°˜ë³µë¬¸ìœ¼ë¡œ ë³€í™˜í•˜ê¸°\n```python\n# ì´ ì¬ê·€ë¥¼ ë°˜ë³µë¬¸ìœ¼ë¡œ ë°”ê¾¸ì„¸ìš”\ndef sum_recursive(n):\n    if n <= 0:\n        return 0\n    return n + sum_recursive(n - 1)\n```\n\n### ë°±ì¤€ ì¶”ì²œ ë¬¸ì œ\n| ë‚œì´ë„ | ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-------|-----|-------|\n| â­â­ | í”¼ë³´ë‚˜ì¹˜ í•¨ìˆ˜ (1003) | ì¬ê·€ í˜¸ì¶œ íšŸìˆ˜ |\n| â­â­â­ | íƒ€ì¼ ì±„ìš°ê¸° (2133) | DPë¡œ ë³€í™˜ |\n| â­â­â­ | íŒŒë„ë°˜ ìˆ˜ì—´ (9461) | ë©”ëª¨ì´ì œì´ì…˜ |"
      }
    ]
  },
  "01_ê¸°ì´ˆ/recursion-basic": {
    "id": "01_ê¸°ì´ˆ/recursion-basic",
    "title": "Recursion Basic",
    "category": "algorithm",
    "subCategory": "01_ê¸°ì´ˆ",
    "language": "Python",
    "description": "ì¬ê·€ í•¨ìˆ˜ì˜ ê°œë…ê³¼ ê¸°ë³¸ íŒ¨í„´ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì¬ê·€ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **í•¨ìˆ˜ê°€ ìê¸° ìì‹ ì„ í˜¸ì¶œí•˜ëŠ” ê²ƒ** - í° ë¬¸ì œë¥¼ ê°™ì€ í˜•íƒœì˜ ì‘ì€ ë¬¸ì œë¡œ ìª¼ê°œê¸°\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì‹¤ë¬´ì—ì„œ:\n- **íŠ¸ë¦¬/ê·¸ë˜í”„ íƒìƒ‰**: í´ë” êµ¬ì¡°, DOM íƒìƒ‰, ì¡°ì§ë„\n- **ë¶„í•  ì •ë³µ**: ë³‘í•© ì •ë ¬, í€µ ì •ë ¬\n- **JSON íŒŒì‹±**: ì¤‘ì²©ëœ ê°ì²´ ì²˜ë¦¬\n\n### ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ:\n- ì¶œì œ ë¹ˆë„: â­â­â­â­â­ (DFS, ë°±íŠ¸ë˜í‚¹ í•„ìˆ˜)\n- ëŒ€í‘œ ìœ í˜•: ìˆœì—´/ì¡°í•©, íŠ¸ë¦¬ ìˆœíšŒ, ê·¸ë˜í”„ íƒìƒ‰\n\n---\n\n## ğŸ¯ í•µì‹¬ ê°œë… (5ë¶„ ì»·)\n\n### ğŸ“š ëŸ¬ì‹œì•„ ì¸í˜•(ë§ˆíŠ¸ë£Œì‹œì¹´)ë¡œ ì´í•´í•˜ê¸°\n\n```\ní° ì¸í˜•ì„ ì—´ë©´ â†’ ì‘ì€ ì¸í˜•ì´ ë‚˜ì˜¤ê³ \nì‘ì€ ì¸í˜•ì„ ì—´ë©´ â†’ ë” ì‘ì€ ì¸í˜•ì´ ë‚˜ì˜¤ê³ \n...\nê°€ì¥ ì‘ì€ ì¸í˜• â†’ ë” ì´ìƒ ì—´ ìˆ˜ ì—†ìŒ (ê¸°ì € ì¡°ê±´!)\n```\n\n### ì¬ê·€ì˜ 3ìš”ì†Œ\n1. **ê¸°ì € ì¡°ê±´(Base Case)**: ì¬ê·€ë¥¼ ë©ˆì¶”ëŠ” ì¡°ê±´ âš ï¸ í•„ìˆ˜!\n2. **ì¬ê·€ í˜¸ì¶œ(Recursive Call)**: ìê¸° ìì‹  í˜¸ì¶œ\n3. **ë¬¸ì œ ì¶•ì†Œ**: ë§¤ í˜¸ì¶œë§ˆë‹¤ ë¬¸ì œê°€ ì‘ì•„ì ¸ì•¼ í•¨\n\n### íŒ©í† ë¦¬ì–¼ë¡œ ì´í•´í•˜ê¸°\n```\n5! = 5 Ã— 4!\n   = 5 Ã— 4 Ã— 3!\n   = 5 Ã— 4 Ã— 3 Ã— 2!\n   = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1!\n   = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1  â† ê¸°ì € ì¡°ê±´: 1! = 1\n   = 120\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ì¬ê·€ ê¸°ë³¸ íŒ¨í„´\n\n# 1. íŒ©í† ë¦¬ì–¼\ndef factorial(n):\n    # ê¸°ì € ì¡°ê±´: nì´ 1 ì´í•˜ë©´ 1 ë°˜í™˜\n    if n <= 1:\n        return 1\n    # ì¬ê·€ í˜¸ì¶œ: n Ã— (n-1)!\n    return n * factorial(n - 1)\n\nprint(factorial(5))  # 120\n\n# 2. í”¼ë³´ë‚˜ì¹˜ (ë¹„íš¨ìœ¨ì  ë²„ì „ - ì´í•´ìš©)\ndef fibonacci(n):\n    # ê¸°ì € ì¡°ê±´\n    if n <= 1:\n        return n\n    # ì¬ê·€ í˜¸ì¶œ\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(10))  # 55\n\n# 3. ë°°ì—´ì˜ í•©\ndef array_sum(arr):\n    # ê¸°ì € ì¡°ê±´: ë¹ˆ ë°°ì—´\n    if not arr:\n        return 0\n    # ì²« ìš”ì†Œ + ë‚˜ë¨¸ì§€ ë°°ì—´ì˜ í•©\n    return arr[0] + array_sum(arr[1:])\n\nprint(array_sum([1, 2, 3, 4, 5]))  # 15\n\n# 4. ë¬¸ìì—´ ë’¤ì§‘ê¸°\ndef reverse_string(s):\n    # ê¸°ì € ì¡°ê±´\n    if len(s) <= 1:\n        return s\n    # ë§ˆì§€ë§‰ ë¬¸ì + ë‚˜ë¨¸ì§€ ë’¤ì§‘ê¸°\n    return s[-1] + reverse_string(s[:-1])\n\nprint(reverse_string(\"hello\"))  # \"olleh\"\n\n# 5. ê±°ë“­ì œê³± (ë¶„í•  ì •ë³µ)\ndef power(base, exp):\n    if exp == 0:\n        return 1\n    if exp % 2 == 0:\n        half = power(base, exp // 2)\n        return half * half\n    else:\n        return base * power(base, exp - 1)\n\nprint(power(2, 10))  # 1024"
      },
      {
        "type": "common-mistake",
        "title": "âš ï¸ ì¬ê·€ ì´ˆë³´ì ì‹¤ìˆ˜ TOP 3",
        "content": "**1ï¸âƒ£ ê¸°ì € ì¡°ê±´ ëˆ„ë½ â†’ ë¬´í•œ ì¬ê·€**\n\nâŒ **Bad:**\n```python\ndef countdown(n):\n    print(n)\n    countdown(n - 1)  # ì–¸ì œ ë©ˆì¶°?! â†’ RecursionError\n```\n\nâœ… **Good:**\n```python\ndef countdown(n):\n    if n <= 0:  # ê¸°ì € ì¡°ê±´!\n        return\n    print(n)\n    countdown(n - 1)\n```\n\n---\n\n**2ï¸âƒ£ ë¬¸ì œê°€ ì¶•ì†Œë˜ì§€ ì•ŠìŒ**\n\nâŒ **Bad:**\n```python\ndef wrong_factorial(n):\n    if n <= 1:\n        return 1\n    return n * wrong_factorial(n)  # nì´ ê·¸ëŒ€ë¡œ!\n```\n\nâœ… **Good:**\n```python\ndef factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)  # n-1ë¡œ ì¶•ì†Œ\n```\n\n---\n\n**3ï¸âƒ£ ì¬ê·€ ê¹Šì´ ì´ˆê³¼**\n\n```python\nimport sys\nsys.setrecursionlimit(10000)  # Python ê¸°ë³¸: 1000\n\n# ê¹Šì€ ì¬ê·€ê°€ í•„ìš”í•˜ë©´ ë°˜ë³µë¬¸ìœ¼ë¡œ ë³€í™˜ ê³ ë ¤\ndef factorial_iterative(n):\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n```"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "### Level 1: ê¸°ì´ˆ\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| íŒ©í† ë¦¬ì–¼ (10872) | ë°±ì¤€ | ê¸°ë³¸ ì¬ê·€ |\n| í”¼ë³´ë‚˜ì¹˜ ìˆ˜ 5 (10870) | ë°±ì¤€ | ë‘ ê°ˆë˜ ì¬ê·€ |\n\n### Level 2: ì‘ìš©\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| í•˜ë…¸ì´ íƒ‘ ì´ë™ ìˆœì„œ (11729) | ë°±ì¤€ | ì¬ê·€ ì‚¬ê³ ë ¥ |\n| ë³„ ì°ê¸° - 10 (2447) | ë°±ì¤€ | ë¶„í•  ì •ë³µ |\n\n### ì§ì ‘ êµ¬í˜„í•´ë³´ê¸°\n1. 1ë¶€í„° Nê¹Œì§€ í•©ì„ ì¬ê·€ë¡œ êµ¬í˜„\n2. ë°°ì—´ì—ì„œ ìµœëŒ“ê°’ì„ ì¬ê·€ë¡œ ì°¾ê¸°\n3. ì´ì§„ìˆ˜ ë³€í™˜ì„ ì¬ê·€ë¡œ êµ¬í˜„"
      }
    ]
  },
  "01_ê¸°ì´ˆ/space-complexity": {
    "id": "01_ê¸°ì´ˆ/space-complexity",
    "title": "Space Complexity",
    "category": "algorithm",
    "subCategory": "01_ê¸°ì´ˆ",
    "language": "Python",
    "description": "ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë¶„ì„ê³¼ ê³µê°„ ë³µì¡ë„ ìµœì í™” ë°©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ê³µê°„ ë³µì¡ë„ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì•Œê³ ë¦¬ì¦˜ì´ ì‚¬ìš©í•˜ëŠ” ë©”ëª¨ë¦¬ì˜ ì–‘** - \"ì–¼ë§ˆë‚˜ ë§ì€ ë³€ìˆ˜/ë°°ì—´ì„ ë§Œë“œë‚˜?\"\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì‹¤ë¬´ì—ì„œ:\n- **ì„œë²„ ë©”ëª¨ë¦¬ ì œí•œ**: EC2 ì¸ìŠ¤í„´ìŠ¤ ë©”ëª¨ë¦¬ ì´ˆê³¼ ì‹œ OOM ì—ëŸ¬\n- **ëª¨ë°”ì¼ ì•±**: ë©”ëª¨ë¦¬ ë¶€ì¡±í•˜ë©´ ì•± ê°•ì œ ì¢…ë£Œ\n- **ì„ë² ë””ë“œ**: IoT ê¸°ê¸°ëŠ” ë©”ëª¨ë¦¬ KB ë‹¨ìœ„\n\n### ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ:\n- ë©”ëª¨ë¦¬ ì œí•œ: ë³´í†µ 256MB ~ 512MB\n- int ë°°ì—´ 1ì–µ ê°œ = ì•½ 400MB\n- ì¬ê·€ ê¹Šì´ ì œí•œ = ìŠ¤íƒ ë©”ëª¨ë¦¬\n\n---\n\n## ğŸ¯ í•µì‹¬ ê°œë… (5ë¶„ ì»·)\n\n### ğŸ“š ì‚¬ë¬´ì‹¤ ì±…ìƒìœ¼ë¡œ ì´í•´í•˜ê¸°\n\n**O(1) - ìƒìˆ˜ ê³µê°„**: ì±…ìƒ ìœ„ ë©”ëª¨ì§€ 1ì¥\n> \"ë³€ìˆ˜ ëª‡ ê°œë§Œ ì‚¬ìš©\" - ì…ë ¥ í¬ê¸° ë¬´ê´€\n\n**O(n) - ì„ í˜• ê³µê°„**: íŒŒì¼ ìºë¹„ë‹›\n> \"ì…ë ¥ë§Œí¼ ì €ì¥\" - Nê°œ ë°ì´í„° â†’ Nì¹¸ í•„ìš”\n\n**O(nÂ²) - ì œê³± ê³µê°„**: ì°½ê³ \n> \"2ì°¨ì› ë°°ì—´\" - NÃ—N í‘œ ì €ì¥\n\n### ê³µê°„ ë³µì¡ë„ ê³„ì‚°\n```\në©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ = ê³ ì • ê³µê°„ + ê°€ë³€ ê³µê°„\n\nê³ ì • ê³µê°„: ì½”ë“œ, ìƒìˆ˜, ê³ ì • ë³€ìˆ˜\nê°€ë³€ ê³µê°„: ì…ë ¥ì— ë”°ë¼ ë‹¬ë¼ì§€ëŠ” ê³µê°„ (ì´ê²Œ ì¤‘ìš”!)\n```\n\n### ìë£Œí˜•ë³„ ë©”ëª¨ë¦¬\n| ìë£Œí˜• | Python | Java | C++ |\n|-------|--------|------|-----|\n| int | 28 bytes | 4 bytes | 4 bytes |\n| float | 24 bytes | 8 bytes | 8 bytes |\n| ë°°ì—´[N] | N Ã— 28 | N Ã— 4 | N Ã— 4 |"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ê³µê°„ ë³µì¡ë„ë³„ ì½”ë“œ ì˜ˆì‹œ\n\n# O(1) - ìƒìˆ˜ ê³µê°„\ndef sum_formula(n):\n    # ë³€ìˆ˜ 1ê°œë§Œ ì‚¬ìš©\n    return n * (n + 1) // 2\n\n# O(n) - ì„ í˜• ê³µê°„\ndef create_list(n):\n    # Nê°œ ìš”ì†Œë¥¼ ê°€ì§„ ë¦¬ìŠ¤íŠ¸ ìƒì„±\n    return [i for i in range(n)]\n\n# O(n) - ì¬ê·€ë„ ê³µê°„ ì‚¬ìš©!\ndef factorial_recursive(n):\n    # ì¬ê·€ ê¹Šì´ N = ìŠ¤íƒ í”„ë ˆì„ Nê°œ\n    if n <= 1:\n        return 1\n    return n * factorial_recursive(n - 1)\n\n# O(1) - ë°˜ë³µë¬¸ìœ¼ë¡œ ê³µê°„ ì ˆì•½\ndef factorial_iterative(n):\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\n# O(nÂ²) - 2ì°¨ì› ë°°ì—´\ndef create_matrix(n):\n    # N Ã— N í¬ê¸° í–‰ë ¬\n    return [[0] * n for _ in range(n)]\n\n# ê³µê°„ ë³µì¡ë„ ê°œì„  ì˜ˆì‹œ\n# âŒ O(n) ê³µê°„\ndef fibonacci_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci_memo(n-1) + fibonacci_memo(n-2)\n    return memo[n]\n\n# âœ… O(1) ê³µê°„\ndef fibonacci_optimized(n):\n    if n <= 1:\n        return n\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n    return curr"
      },
      {
        "type": "best-practice",
        "title": "âœ… ê³µê°„ ìµœì í™” ê¸°ë²•",
        "content": "**1ï¸âƒ£ ë¶ˆí•„ìš”í•œ ë³µì‚¬ í”¼í•˜ê¸°**\n\nâŒ **Bad:**\n```python\ndef process(arr):\n    new_arr = arr.copy()  # O(n) ì¶”ê°€ ê³µê°„\n    # ì²˜ë¦¬...\n    return new_arr\n```\n\nâœ… **Good:**\n```python\ndef process(arr):\n    # ì›ë³¸ ìˆ˜ì •ì´ ê°€ëŠ¥í•˜ë©´ in-placeë¡œ\n    for i in range(len(arr)):\n        arr[i] *= 2\n    return arr\n```\n\n---\n\n**2ï¸âƒ£ ì œë„ˆë ˆì´í„° í™œìš©**\n\nâŒ **Bad:**\n```python\ndef get_squares(n):\n    return [i**2 for i in range(n)]  # O(n) ê³µê°„\n```\n\nâœ… **Good:**\n```python\ndef get_squares(n):\n    for i in range(n):\n        yield i**2  # O(1) ê³µê°„\n```\n\n---\n\n**3ï¸âƒ£ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°**\n\nâŒ **Bad:**\n```python\n# ëª¨ë“  ë¶€ë¶„í•© ì €ì¥\nprefix = [0] * (n + 1)\nfor i in range(n):\n    prefix[i+1] = prefix[i] + arr[i]\n```\n\nâœ… **Good:**\n```python\n# í˜„ì¬ ìœˆë„ìš°ë§Œ ìœ ì§€\nwindow_sum = sum(arr[:k])\nfor i in range(k, n):\n    window_sum += arr[i] - arr[i-k]\n```"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "### ê³µê°„ ë³µì¡ë„ ë¶„ì„ í€´ì¦ˆ\n\n**Q1.** ë‹¤ìŒ ì½”ë“œì˜ ê³µê°„ë³µì¡ë„ëŠ”?\n```python\ndef mystery(n):\n    arr = [0] * n\n    for i in range(n):\n        arr[i] = i * 2\n    return arr\n```\n<details><summary>ì •ë‹µ</summary>O(n) - í¬ê¸° nì¸ ë°°ì—´ ìƒì„±</details>\n\n**Q2.** ì¬ê·€ í˜¸ì¶œ ê¹Šì´ê°€ Nì¸ í•¨ìˆ˜ì˜ ê³µê°„ë³µì¡ë„ëŠ”?\n<details><summary>ì •ë‹µ</summary>O(n) - ìŠ¤íƒ í”„ë ˆì„ Nê°œ ì‚¬ìš©</details>\n\n### ìµœì í™” ì—°ìŠµ\n| ë¬¸ì œ | íŒíŠ¸ |\n|-----|-----|\n| í”¼ë³´ë‚˜ì¹˜ë¥¼ O(1) ê³µê°„ìœ¼ë¡œ | ë³€ìˆ˜ 2ê°œë§Œ ì‚¬ìš© |\n| í–‰ë ¬ íšŒì „ì„ in-placeë¡œ | swap í™œìš© |\n| ì—°ì† ë¶€ë¶„í•© O(1) ê³µê°„ | ìŠ¬ë¼ì´ë”© ìœˆë„ìš° |"
      }
    ]
  },
  "01_ê¸°ì´ˆ/time-complexity": {
    "id": "01_ê¸°ì´ˆ/time-complexity",
    "title": "Time Complexity",
    "category": "algorithm",
    "subCategory": "01_ê¸°ì´ˆ",
    "language": "Python",
    "description": "Big-O í‘œê¸°ë²•ê³¼ ì‹œê°„ ë³µì¡ë„ ë¶„ì„ ë°©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì‹œê°„ ë³µì¡ë„ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì…ë ¥ í¬ê¸°ì— ë”°ë¥¸ ì—°ì‚° íšŸìˆ˜ì˜ ì¦ê°€ìœ¨** - \"Nì´ ì»¤ì§€ë©´ ì–¼ë§ˆë‚˜ ëŠë ¤ì§€ë‚˜?\"\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì‹¤ë¬´ì—ì„œ:\n- **ì„œë²„ ë¹„ìš©**: O(nÂ²) ì½”ë“œ í•˜ë‚˜ê°€ ì›” ì„œë²„ë¹„ 10ë°° ì¦ê°€ì‹œí‚´\n- **ì‚¬ìš©ì ê²½í—˜**: 3ì´ˆ ì´ìƒ ê±¸ë¦¬ë©´ ì‚¬ìš©ì ì´íƒˆ\n- **ì½”ë“œ ë¦¬ë·°**: \"ì´ê±° ì‹œê°„ë³µì¡ë„ ì–¼ë§ˆì˜ˆìš”?\" í•„ìˆ˜ ì§ˆë¬¸\n\n### ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ:\n- ì¶œì œ ë¹ˆë„: â­â­â­â­â­ (ë§¤ ë¬¸ì œ í•„ìˆ˜ ê³ ë ¤)\n- ì‹œê°„ ì œí•œ 1ì´ˆ = ì•½ 1ì–µ ì—°ì‚°\n- N â‰¤ 10ë§Œ â†’ O(n log n) ì´í•˜ í•„ìš”\n\n---\n\n## ğŸ¯ í•µì‹¬ ê°œë… (5ë¶„ ì»·)\n\n### ğŸ“š íƒë°° ë°°ì†¡ìœ¼ë¡œ ì´í•´í•˜ê¸°\n\n**O(1) - ìƒìˆ˜ ì‹œê°„**: ë“œë¡  ë°°ì†¡\n> \"ì–´ë””ë“  1ì‹œê°„\" - ê±°ë¦¬ ë¬´ê´€\n\n**O(log n) - ë¡œê·¸ ì‹œê°„**: ì´ì§„ íƒìƒ‰ ë°°ì†¡\n> \"ì ˆë°˜ì”© ì¢í˜€ì„œ ì°¾ê¸°\" - 1024ê°œ ì¤‘ 10ë²ˆë§Œì— ì°¾ìŒ\n\n**O(n) - ì„ í˜• ì‹œê°„**: ì¼ë°˜ íƒë°°\n> \"ì§‘ì§‘ë§ˆë‹¤ ë°©ë¬¸\" - 100ì§‘ì´ë©´ 100ë²ˆ\n\n**O(nÂ²) - ì œê³± ì‹œê°„**: ëª¨ë“  ì§‘ ì„œë¡œ ë¹„êµ\n> \"100ì§‘ Ã— 100ì§‘ = 10,000ë²ˆ\"\n\n### Big-O ë¹„êµí‘œ\n| í‘œê¸°ë²• | N=10 | N=100 | N=1000 | íŠ¹ì§• |\n|-------|------|-------|--------|-----|\n| O(1) | 1 | 1 | 1 | í•´ì‹œ ì¡°íšŒ |\n| O(log n) | 3 | 7 | 10 | ì´ì§„ íƒìƒ‰ |\n| O(n) | 10 | 100 | 1000 | ë‹¨ìˆœ ë°˜ë³µ |\n| O(n log n) | 30 | 700 | 10000 | ì •ë ¬ |\n| O(nÂ²) | 100 | 10000 | 1000000 | ì´ì¤‘ ë°˜ë³µ |\n| O(2â¿) | 1024 | ğŸ’€ | ğŸ’€ | ë¶€ë¶„ì§‘í•© |"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ì‹œê°„ ë³µì¡ë„ë³„ ì½”ë“œ ì˜ˆì‹œ\n\n# O(1) - ìƒìˆ˜ ì‹œê°„\ndef get_first(arr):\n    return arr[0]  # í•­ìƒ 1ë²ˆ ì—°ì‚°\n\n# O(log n) - ë¡œê·¸ ì‹œê°„\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:  # ë§¤ë²ˆ ì ˆë°˜ìœ¼ë¡œ ì¤„ì–´ë“¦\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n# O(n) - ì„ í˜• ì‹œê°„\ndef find_max(arr):\n    max_val = arr[0]\n    for num in arr:  # Në²ˆ ë°˜ë³µ\n        if num > max_val:\n            max_val = num\n    return max_val\n\n# O(nÂ²) - ì œê³± ì‹œê°„\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):        # Në²ˆ\n        for j in range(n-1):  # Ã— Në²ˆ = NÂ²\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\n# O(2â¿) - ì§€ìˆ˜ ì‹œê°„ (í”¼í•˜ì!)\ndef fibonacci_recursive(n):\n    if n <= 1:\n        return n\n    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)"
      },
      {
        "type": "tip",
        "title": "ğŸ’¡ ì‹œê°„ë³µì¡ë„ ë¹ ë¥´ê²Œ ê³„ì‚°í•˜ëŠ” íŒ",
        "content": "### 1ì´ˆ = 1ì–µ ì—°ì‚° ë²•ì¹™\n\n| Nì˜ ë²”ìœ„ | í—ˆìš© ì‹œê°„ë³µì¡ë„ | ëŒ€í‘œ ì•Œê³ ë¦¬ì¦˜ |\n|---------|--------------|-------------|\n| N â‰¤ 10 | O(N!) | ìˆœì—´ ì™„ì „íƒìƒ‰ |\n| N â‰¤ 20 | O(2á´º) | ë¹„íŠ¸ë§ˆìŠ¤í‚¹ |\n| N â‰¤ 500 | O(NÂ³) | í”Œë¡œì´ë“œ ì›Œì…œ |\n| N â‰¤ 5,000 | O(NÂ²) | ë²„ë¸”/ì„ íƒ ì •ë ¬ |\n| N â‰¤ 100,000 | O(N log N) | í€µ/ë³‘í•© ì •ë ¬ |\n| N â‰¤ 10,000,000 | O(N) | íˆ¬ í¬ì¸í„°, í•´ì‹œ |\n\n### ê¿€íŒ\n```python\n# ì‹œê°„ë³µì¡ë„ ë¹ ë¥´ê²Œ íŒŒì•…í•˜ê¸°\nfor i in range(n):           # O(n)\n    for j in range(n):       # O(nÂ²)\n        for k in range(n):   # O(nÂ³)\n\nfor i in range(n):\n    for j in range(i):       # O(nÂ²/2) = O(nÂ²)\n\nwhile n > 0:\n    n //= 2                  # O(log n)\n```"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "### ì‹œê°„ë³µì¡ë„ ë§ì¶”ê¸° í€´ì¦ˆ\n\n**Q1.** ë‹¤ìŒ ì½”ë“œì˜ ì‹œê°„ë³µì¡ë„ëŠ”?\n```python\nfor i in range(n):\n    for j in range(n, 0, -1):\n        print(i, j)\n```\n<details><summary>ì •ë‹µ</summary>O(nÂ²) - iê°€ në²ˆ, jë„ në²ˆ</details>\n\n**Q2.** N=100,000ì¼ ë•Œ 1ì´ˆ ì•ˆì— í†µê³¼ ê°€ëŠ¥í•œ ê²ƒì€?\n- A) O(nÂ²)\n- B) O(n log n)\n- C) O(nÂ³)\n\n<details><summary>ì •ë‹µ</summary>B) O(n log n) = ì•½ 170ë§Œ ì—°ì‚°</details>\n\n### ë°±ì¤€ ì¶”ì²œ ë¬¸ì œ\n| ë‚œì´ë„ | ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-------|-----|-------|\n| â­ | ì•Œê³ ë¦¬ì¦˜ ìˆ˜ì—… - ì ê·¼ì  í‘œê¸° 1 (24313) | Big-O ê°œë… |\n| â­â­ | ìˆ˜ ì •ë ¬í•˜ê¸° (2750) | O(nÂ²) ì •ë ¬ |\n| â­â­â­ | ìˆ˜ ì •ë ¬í•˜ê¸° 2 (2751) | O(n log n) í•„ìš” |"
      }
    ]
  },
  "02_ë°°ì—´/array-basic": {
    "id": "02_ë°°ì—´/array-basic",
    "title": "Array Basic",
    "category": "algorithm",
    "subCategory": "02_ë°°ì—´",
    "language": "Python",
    "description": "ë°°ì—´ì˜ ê°œë…, ë©”ëª¨ë¦¬ êµ¬ì¡°, ê¸°ë³¸ ì—°ì‚°ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ë°°ì—´ì´ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ê°™ì€ íƒ€ì…ì˜ ë°ì´í„°ë¥¼ ì—°ì†ëœ ë©”ëª¨ë¦¬ì— ì €ì¥í•˜ëŠ” ìë£Œêµ¬ì¡°** - ì¸ë±ìŠ¤ë¡œ O(1) ì ‘ê·¼!\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì‹¤ë¬´ì—ì„œ:\n- **ëª¨ë“  ë°ì´í„° ì²˜ë¦¬ì˜ ê¸°ë³¸**: ë¦¬ìŠ¤íŠ¸, ë²¡í„°, ArrayList ì „ë¶€ ë°°ì—´ ê¸°ë°˜\n- **DB ê²°ê³¼ ì €ì¥**: SELECT ê²°ê³¼ â†’ ë°°ì—´ë¡œ ë°˜í™˜\n- **API ì‘ë‹µ**: JSON ë°°ì—´ í˜•íƒœë¡œ ë°ì´í„° ì „ì†¡\n\n### ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ:\n- ì¶œì œ ë¹ˆë„: â­â­â­â­â­ (ê±°ì˜ ëª¨ë“  ë¬¸ì œì— ë“±ì¥)\n- ë°°ì—´ ì—†ì´ í’€ ìˆ˜ ìˆëŠ” ë¬¸ì œê°€ ê±°ì˜ ì—†ìŒ\n\n---\n\n## ğŸ¯ í•µì‹¬ ê°œë… (5ë¶„ ì»·)\n\n### ğŸ“š ì‚¬ë¬¼í•¨ìœ¼ë¡œ ì´í•´í•˜ê¸°\n```\ní•™êµ ì‚¬ë¬¼í•¨ì„ ìƒê°í•´ë´:\n- 1ë²ˆë¶€í„° 100ë²ˆê¹Œì§€ ë²ˆí˜¸ê°€ ë¶™ì–´ìˆìŒ (ì¸ë±ìŠ¤)\n- ê° ì¹¸ì€ ê°™ì€ í¬ê¸° (ê°™ì€ íƒ€ì…)\n- ë²ˆí˜¸ë§Œ ì•Œë©´ ë°”ë¡œ ì°¾ì•„ê° (O(1) ì ‘ê·¼)\n```\n\n### ë°°ì—´ì˜ íŠ¹ì§•\n| íŠ¹ì§• | ì„¤ëª… | ì‹œê°„ë³µì¡ë„ |\n|-----|------|----------|\n| **ì¸ë±ìŠ¤ ì ‘ê·¼** | arr[i]ë¡œ ë°”ë¡œ ì ‘ê·¼ | O(1) |\n| **ì‚½ì… (ë)** | append | O(1) |\n| **ì‚½ì… (ì¤‘ê°„)** | ë’¤ì˜ ìš”ì†Œ ì´ë™ í•„ìš” | O(n) |\n| **ì‚­ì œ (ì¤‘ê°„)** | ë’¤ì˜ ìš”ì†Œ ì´ë™ í•„ìš” | O(n) |\n| **ê²€ìƒ‰** | í•˜ë‚˜ì”© í™•ì¸ | O(n) |\n\n### ë©”ëª¨ë¦¬ êµ¬ì¡°\n```\nì¸ë±ìŠ¤:  [0]  [1]  [2]  [3]  [4]\nê°’:      10   20   30   40   50\nì£¼ì†Œ:   100  104  108  112  116  (int = 4ë°”ì´íŠ¸)\n\narr[2]ì˜ ì£¼ì†Œ = ì‹œì‘ì£¼ì†Œ + (2 Ã— 4) = 108\nâ†’ ë°”ë¡œ ê³„ì‚° ê°€ëŠ¥! = O(1)\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ë°°ì—´ ê¸°ë³¸ ì—°ì‚°\n\n# 1. ë°°ì—´ ìƒì„±\narr = [1, 2, 3, 4, 5]           # ë¦¬í„°ëŸ´\narr = list(range(1, 6))         # range ì‚¬ìš©\narr = [0] * 5                   # 0ìœ¼ë¡œ ì´ˆê¸°í™”\narr = [i**2 for i in range(5)]  # ì»´í”„ë¦¬í—¨ì…˜\n\n# 2. ì ‘ê·¼ ë° ìˆ˜ì • - O(1)\nprint(arr[0])      # ì²« ë²ˆì§¸ ìš”ì†Œ\nprint(arr[-1])     # ë§ˆì§€ë§‰ ìš”ì†Œ\narr[2] = 100       # ìˆ˜ì •\n\n# 3. ì‚½ì…\narr.append(6)      # ëì— ì¶”ê°€ - O(1)\narr.insert(0, 0)   # ë§¨ ì•ì— ì¶”ê°€ - O(n)\n\n# 4. ì‚­ì œ\narr.pop()          # ë§ˆì§€ë§‰ ì œê±° - O(1)\narr.pop(0)         # ì²« ë²ˆì§¸ ì œê±° - O(n)\narr.remove(3)      # ê°’ìœ¼ë¡œ ì œê±° - O(n)\n\n# 5. ê²€ìƒ‰\nif 4 in arr:       # ì¡´ì¬ í™•ì¸ - O(n)\n    idx = arr.index(4)  # ì¸ë±ìŠ¤ ì°¾ê¸°\n\n# 6. ìŠ¬ë¼ì´ì‹±\nsub = arr[1:4]     # 1~3ë²ˆ ì¸ë±ìŠ¤\nrev = arr[::-1]    # ë’¤ì§‘ê¸°\n\n# 7. ìˆœíšŒ\nfor i, val in enumerate(arr):\n    print(f\"arr[{i}] = {val}\")\n\n# 8. ì •ë ¬\narr.sort()              # ì˜¤ë¦„ì°¨ìˆœ (in-place)\narr.sort(reverse=True)  # ë‚´ë¦¼ì°¨ìˆœ\nsorted_arr = sorted(arr)  # ìƒˆ ë°°ì—´ ë°˜í™˜"
      },
      {
        "type": "best-practice",
        "title": "âœ… ë°°ì—´ Best Practice",
        "content": "**1ï¸âƒ£ ë¦¬ìŠ¤íŠ¸ ì»´í”„ë¦¬í—¨ì…˜ í™œìš©**\n\nâŒ **Bad:**\n```python\nsquares = []\nfor i in range(10):\n    squares.append(i ** 2)\n```\n\nâœ… **Good:**\n```python\nsquares = [i ** 2 for i in range(10)]\n```\n\n---\n\n**2ï¸âƒ£ ë¶ˆí•„ìš”í•œ ì¸ë±ìŠ¤ ì ‘ê·¼ í”¼í•˜ê¸°**\n\nâŒ **Bad:**\n```python\nfor i in range(len(arr)):\n    print(arr[i])\n```\n\nâœ… **Good:**\n```python\nfor item in arr:\n    print(item)\n\n# ì¸ë±ìŠ¤ê°€ í•„ìš”í•˜ë©´\nfor i, item in enumerate(arr):\n    print(i, item)\n```\n\n---\n\n**3ï¸âƒ£ ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ì´ˆê¸°í™”**\n\nâŒ **Bad:**\n```python\n# 2ì°¨ì› ë°°ì—´ ì˜ëª»ëœ ì´ˆê¸°í™”\nmatrix = [[0] * n] * m  # ê°™ì€ ë¦¬ìŠ¤íŠ¸ ì°¸ì¡°!\nmatrix[0][0] = 1\nprint(matrix)  # [[1,0,0], [1,0,0], [1,0,0]] ğŸ˜±\n```\n\nâœ… **Good:**\n```python\nmatrix = [[0] * n for _ in range(m)]\nmatrix[0][0] = 1\nprint(matrix)  # [[1,0,0], [0,0,0], [0,0,0]] âœ…\n```"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "### Level 1: ê¸°ì´ˆ\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ìµœëŒ“ê°’ (2562) | ë°±ì¤€ | ìˆœíšŒ, ìµœëŒ€ |\n| ìˆ«ìì˜ í•© (11720) | ë°±ì¤€ | ë¬¸ìâ†’ìˆ«ì |\n| í‰ê·  (1546) | ë°±ì¤€ | í‰ê·  ê³„ì‚° |\n\n### Level 2: ì‘ìš©\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ë‚˜ë¨¸ì§€ (3052) | ë°±ì¤€ | Set í™œìš© |\n| OXí€´ì¦ˆ (8958) | ë°±ì¤€ | ì—°ì† ì¹´ìš´íŠ¸ |\n\n### ì§ì ‘ êµ¬í˜„\n1. ë°°ì—´ì—ì„œ ë‘ ë²ˆì§¸ë¡œ í° ìˆ˜ ì°¾ê¸°\n2. ë°°ì—´ íšŒì „ (ì˜¤ë¥¸ìª½ìœ¼ë¡œ kì¹¸)\n3. ì¤‘ë³µ ì œê±°"
      }
    ]
  },
  "02_ë°°ì—´/kadane": {
    "id": "02_ë°°ì—´/kadane",
    "title": "Kadane",
    "category": "algorithm",
    "subCategory": "02_ë°°ì—´",
    "language": "Python",
    "description": "ìµœëŒ€ ë¶€ë¶„ ë°°ì—´ í•©ì„ O(n)ì— êµ¬í•˜ëŠ” ì¹´ë°ì¸ ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì¹´ë°ì¸ ì•Œê³ ë¦¬ì¦˜ì´ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì—°ì† ë¶€ë¶„ ë°°ì—´ì˜ ìµœëŒ€ í•©ì„ O(n)ì— ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜** - DPì˜ êµê³¼ì„œì  ì˜ˆì œ\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì‹¤ë¬´ì—ì„œ:\n- **ì£¼ì‹ ë¶„ì„**: ìµœëŒ€ ìˆ˜ìµ êµ¬ê°„ ì°¾ê¸°\n- **ë°ì´í„° ë¶„ì„**: ì—°ì†ëœ ì´ìƒì¹˜ êµ¬ê°„ íƒì§€\n- **ì‹ í˜¸ ì²˜ë¦¬**: ìµœëŒ€ ì—ë„ˆì§€ êµ¬ê°„\n\n### ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ:\n- ì¶œì œ ë¹ˆë„: â­â­â­â­\n- \"ìµœëŒ€ ë¶€ë¶„ ë°°ì—´\", \"ì—°ì† í•©\" í‚¤ì›Œë“œ\n- DP ì…ë¬¸ í•„ìˆ˜ ë¬¸ì œ\n\n---\n\n## ğŸ¯ í•µì‹¬ ê°œë… (5ë¶„ ì»·)\n\n### ğŸ“š ë“±ì‚°ìœ¼ë¡œ ì´í•´í•˜ê¸°\n```\nê³ ë„ ë³€í™”: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\nì§ˆë¬¸: \"ê°€ì¥ ë†’ì´ ì˜¬ë¼ê°ˆ ìˆ˜ ìˆëŠ” ì—°ì† êµ¬ê°„ì€?\"\n\ní•µì‹¬ ì•„ì´ë””ì–´:\n- í˜„ì¬ ìœ„ì¹˜ì—ì„œ \"ì´ì „ê¹Œì§€ì˜ í•© + ë‚˜\" vs \"ë‚˜ë§Œ\"\n- ì´ì „ì´ ë§ˆì´ë„ˆìŠ¤ë©´ ë²„ë¦¬ê³  ìƒˆë¡œ ì‹œì‘!\n```\n\n### í•µì‹¬ ê³µì‹\n```\ndp[i] = max(dp[i-1] + arr[i], arr[i])\n\ní•´ì„:\n- dp[i-1] + arr[i]: ì´ì „ êµ¬ê°„ì„ ì´ì–´ê°\n- arr[i]: ì—¬ê¸°ì„œ ìƒˆë¡œ ì‹œì‘\n\nì´ì „ í•©ì´ ìŒìˆ˜ë©´ ë²„ë¦¬ëŠ” ê²Œ ì´ë“!\n```\n\n### ë™ì‘ ì˜ˆì‹œ\n```\në°°ì—´: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\ni=0: max(-2, -2) = -2\ni=1: max(-2+1, 1) = 1    â† ìƒˆë¡œ ì‹œì‘!\ni=2: max(1-3, -3) = -2\ni=3: max(-2+4, 4) = 4    â† ìƒˆë¡œ ì‹œì‘!\ni=4: max(4-1, -1) = 3\ni=5: max(3+2, 2) = 5\ni=6: max(5+1, 1) = 6     â† ìµœëŒ€!\ni=7: max(6-5, -5) = 1\ni=8: max(1+4, 4) = 5\n\nìµœëŒ€ í•© = 6 (êµ¬ê°„: [4, -1, 2, 1])\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ì¹´ë°ì¸ ì•Œê³ ë¦¬ì¦˜\n\n# 1. ê¸°ë³¸ ë²„ì „\ndef max_subarray_sum(arr):\n    if not arr:\n        return 0\n\n    max_ending_here = arr[0]  # í˜„ì¬ ìœ„ì¹˜ê¹Œì§€ì˜ ìµœëŒ€ í•©\n    max_so_far = arr[0]       # ì „ì²´ ìµœëŒ€ í•©\n\n    for i in range(1, len(arr)):\n        # ì´ì–´ê°ˆì§€ vs ìƒˆë¡œ ì‹œì‘í• ì§€\n        max_ending_here = max(max_ending_here + arr[i], arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n\narr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]\nprint(max_subarray_sum(arr))  # 6\n\n# 2. êµ¬ê°„ ì¸ë±ìŠ¤ë„ ë°˜í™˜\ndef max_subarray_with_indices(arr):\n    if not arr:\n        return 0, -1, -1\n\n    max_ending_here = arr[0]\n    max_so_far = arr[0]\n    start = end = temp_start = 0\n\n    for i in range(1, len(arr)):\n        if arr[i] > max_ending_here + arr[i]:\n            max_ending_here = arr[i]\n            temp_start = i  # ìƒˆë¡œ ì‹œì‘\n        else:\n            max_ending_here = max_ending_here + arr[i]\n\n        if max_ending_here > max_so_far:\n            max_so_far = max_ending_here\n            start = temp_start\n            end = i\n\n    return max_so_far, start, end\n\nsum_val, start, end = max_subarray_with_indices(arr)\nprint(f\"ìµœëŒ€ í•©: {sum_val}, êµ¬ê°„: [{start}, {end}]\")\n# ìµœëŒ€ í•©: 6, êµ¬ê°„: [3, 6]\n\n# 3. ëª¨ë“  ìš”ì†Œê°€ ìŒìˆ˜ì¸ ê²½ìš° ì²˜ë¦¬\ndef max_subarray_sum_v2(arr):\n    # ëª¨ë‘ ìŒìˆ˜ë©´ ê°€ì¥ í° ìŒìˆ˜ ë°˜í™˜\n    if max(arr) < 0:\n        return max(arr)\n\n    max_ending_here = 0\n    max_so_far = 0\n\n    for num in arr:\n        max_ending_here = max(0, max_ending_here + num)\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n\n# 4. ì›í˜• ë°°ì—´ì—ì„œ ìµœëŒ€ ë¶€ë¶„ í•©\ndef max_circular_subarray_sum(arr):\n    # ì¼ë°˜ ì¹´ë°ì¸\n    max_kadane = max_subarray_sum(arr)\n\n    # ì›í˜• ê³ ë ¤: ì „ì²´ í•© - ìµœì†Œ ë¶€ë¶„ í•©\n    total = sum(arr)\n    # ë°°ì—´ ë¶€í˜¸ ë°˜ì „ í›„ ì¹´ë°ì¸ = ìµœì†Œ ë¶€ë¶„ í•©\n    min_kadane = -max_subarray_sum([-x for x in arr])\n\n    # ëª¨ë“  ìš”ì†Œê°€ ìŒìˆ˜ë©´ ì¼ë°˜ ì¹´ë°ì¸ ê²°ê³¼ ë°˜í™˜\n    if min_kadane == total:\n        return max_kadane\n\n    return max(max_kadane, total - min_kadane)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "### Level 1: ê¸°ì´ˆ\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ì—°ì†í•© (1912) | ë°±ì¤€ | ê¸°ë³¸ ì¹´ë°ì¸ |\n| Maximum Subarray | LeetCode | ë™ì¼ |\n\n### Level 2: ì‘ìš©\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ìµœëŒ€ ë¶€ë¶„ ë°°ì—´ í•© ì°¾ê¸° | í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ | êµ¬ê°„ ë°˜í™˜ |\n| ì—°ì†í•© 2 (13398) | ë°±ì¤€ | í•˜ë‚˜ ì œê±° |\n\n### Level 3: ì‹¬í™”\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| Maximum Sum Circular Subarray | LeetCode | ì›í˜• ë°°ì—´ |\n| Maximum Product Subarray | LeetCode | ê³± ë²„ì „ |"
      }
    ]
  },
  "02_ë°°ì—´/practice-array": {
    "id": "02_ë°°ì—´/practice-array",
    "title": "Practice Array",
    "category": "algorithm",
    "subCategory": "02_ë°°ì—´",
    "language": "Python",
    "description": "ë°°ì—´ ê´€ë ¨ ì‹¤ì „ ë¬¸ì œ í’€ì´ íŒ¨í„´ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ¯ ë°°ì—´ ë¬¸ì œ íŒ¨í„´",
        "content": "## ë°°ì—´ ë¬¸ì œ ìœ í˜• ì •ë¦¬\n\n### 1ï¸âƒ£ ìˆœíšŒ íŒ¨í„´\n- ë‹¨ìˆœ ìˆœíšŒ: O(n)\n- ì´ì¤‘ ìˆœíšŒ: O(nÂ²)\n- ì—­ìˆœ ìˆœíšŒ: `arr[::-1]` ë˜ëŠ” `reversed(arr)`\n\n### 2ï¸âƒ£ íˆ¬ í¬ì¸í„° íŒ¨í„´\n- ì–‘ëì—ì„œ: ì •ë ¬ëœ ë°°ì—´ì˜ í•©\n- ê°™ì€ ë°©í–¥: ìŠ¬ë¼ì´ë”© ìœˆë„ìš°, ì¤‘ë³µ ì œê±°\n\n### 3ï¸âƒ£ ì •ë ¬ í™œìš© íŒ¨í„´\n- ì •ë ¬ í›„ ì´ì›ƒ ë¹„êµ\n- Kë²ˆì§¸ ìˆ˜ ì°¾ê¸°\n- ì¤‘ë³µ ê²€ì‚¬\n\n### 4ï¸âƒ£ í•´ì‹œ í™œìš© íŒ¨í„´\n- ë¹ˆë„ìˆ˜ ì¹´ìš´íŒ…\n- ì¡´ì¬ ì—¬ë¶€ O(1) í™•ì¸\n- ê·¸ë£¹í•‘\n\n### 5ï¸âƒ£ ëˆ„ì í•© íŒ¨í„´\n- êµ¬ê°„ í•© ì¿¼ë¦¬\n- ì°¨ë¶„ ë°°ì—´ (êµ¬ê°„ ì—…ë°ì´íŠ¸)"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ë°°ì—´ ì‹¤ì „ ë¬¸ì œ íŒ¨í„´\n\n# íŒ¨í„´ 1: ë‘ ìˆ˜ì˜ í•© (í•´ì‹œ í™œìš©)\ndef two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n\n# íŒ¨í„´ 2: ë°°ì—´ íšŒì „\ndef rotate_array(nums, k):\n    n = len(nums)\n    k = k % n  # kê°€ në³´ë‹¤ í´ ê²½ìš°\n\n    # ë°©ë²• 1: ìŠ¬ë¼ì´ì‹±\n    return nums[-k:] + nums[:-k]\n\n    # ë°©ë²• 2: ì—­ì „ ê¸°ë²• (in-place)\n    def reverse(arr, start, end):\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n\n    reverse(nums, 0, n - 1)\n    reverse(nums, 0, k - 1)\n    reverse(nums, k, n - 1)\n\n# íŒ¨í„´ 3: ê³¼ë°˜ìˆ˜ ìš”ì†Œ (ë³´ì´ì–´-ë¬´ì–´ íˆ¬í‘œ)\ndef majority_element(nums):\n    candidate = None\n    count = 0\n\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += 1 if num == candidate else -1\n\n    return candidate\n\n# íŒ¨í„´ 4: ì¤‘ë³µ ì°¾ê¸° (ê³µê°„ O(1))\ndef find_duplicate(nums):\n    # Floyd's Cycle Detection\n    slow = fast = nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n\n# íŒ¨í„´ 5: ë°°ì—´ ë³‘í•© (ì •ë ¬ëœ ë‘ ë°°ì—´)\ndef merge_sorted_arrays(nums1, m, nums2, n):\n    # ë’¤ì—ì„œë¶€í„° ì±„ìš°ê¸°\n    p1, p2, p = m - 1, n - 1, m + n - 1\n\n    while p1 >= 0 and p2 >= 0:\n        if nums1[p1] > nums2[p2]:\n            nums1[p] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[p] = nums2[p2]\n            p2 -= 1\n        p -= 1\n\n    # nums2 ë‚¨ì€ ê²ƒ ë³µì‚¬\n    nums1[:p2 + 1] = nums2[:p2 + 1]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ í•„ìˆ˜ ì—°ìŠµ ë¬¸ì œ",
        "content": "### Must-Solve ë¬¸ì œ (ë©´ì ‘ í•„ìˆ˜)\n\n| ë¬¸ì œ | í”Œë«í¼ | íŒ¨í„´ |\n|-----|-------|-----|\n| Two Sum | LeetCode | í•´ì‹œ |\n| Best Time to Buy and Sell Stock | LeetCode | ë‹¨ìˆœ ìˆœíšŒ |\n| Contains Duplicate | LeetCode | í•´ì‹œ/ì •ë ¬ |\n| Product of Array Except Self | LeetCode | ëˆ„ì ê³± |\n| Maximum Subarray | LeetCode | ì¹´ë°ì¸ |\n| Merge Intervals | LeetCode | ì •ë ¬ |\n| Rotate Array | LeetCode | ì—­ì „ ê¸°ë²• |\n| Move Zeroes | LeetCode | íˆ¬ í¬ì¸í„° |\n\n### ì²´í¬ë¦¬ìŠ¤íŠ¸\n- [ ] íˆ¬ í¬ì¸í„° O(nÂ²) â†’ O(n) ìµœì í™”\n- [ ] í•´ì‹œë§µìœ¼ë¡œ O(n) â†’ O(1) ì¡°íšŒ\n- [ ] ì •ë ¬ë¡œ ë¬¸ì œ ë‹¨ìˆœí™”\n- [ ] ëˆ„ì í•©ìœ¼ë¡œ êµ¬ê°„ ì¿¼ë¦¬ O(1)\n- [ ] ìŠ¬ë¼ì´ë”© ìœˆë„ìš° í™œìš©"
      }
    ]
  },
  "02_ë°°ì—´/prefix-sum": {
    "id": "02_ë°°ì—´/prefix-sum",
    "title": "Prefix Sum",
    "category": "algorithm",
    "subCategory": "02_ë°°ì—´",
    "language": "Python",
    "description": "êµ¬ê°„ í•©ì„ O(1)ì— ê³„ì‚°í•˜ëŠ” ëˆ„ì í•© ê¸°ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ëˆ„ì í•©ì´ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ë¯¸ë¦¬ í•©ì„ ì €ì¥í•´ë‘ê³  êµ¬ê°„ í•©ì„ O(1)ì— ê³„ì‚°** - ì „ì²˜ë¦¬ O(n), ì¿¼ë¦¬ O(1)\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì‹¤ë¬´ì—ì„œ:\n- **ë°ì´í„° ë¶„ì„**: ì¼ë³„ ë§¤ì¶œì˜ ì›”ë³„ í•©ê³„\n- **ê²Œì„ ê°œë°œ**: ë°ë¯¸ì§€ ëˆ„ì , ì ìˆ˜ ê³„ì‚°\n- **ì´ë¯¸ì§€ ì²˜ë¦¬**: ì ë¶„ ì´ë¯¸ì§€ (SAT)\n\n### ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ:\n- ì¶œì œ ë¹ˆë„: â­â­â­â­â­\n- \"êµ¬ê°„ í•©\", \"ë¶€ë¶„ í•©\" í‚¤ì›Œë“œ = ë¬´ì¡°ê±´ ëˆ„ì í•©\n\n---\n\n## ğŸ¯ í•µì‹¬ ê°œë… (5ë¶„ ì»·)\n\n### ğŸ“š í†µì¥ ì”ì•¡ìœ¼ë¡œ ì´í•´í•˜ê¸°\n```\ní†µì¥ ê±°ë˜ ë‚´ì—­:\n1ì›”: +100ë§Œ\n2ì›”: +50ë§Œ\n3ì›”: -30ë§Œ\n4ì›”: +80ë§Œ\n\nëˆ„ì  ì”ì•¡:\nprefix[1] = 100\nprefix[2] = 150\nprefix[3] = 120\nprefix[4] = 200\n\n\"2ì›”~4ì›” ì´ ì…ì¶œê¸ˆ?\" = prefix[4] - prefix[1] = 100ë§Œì›\nâ†’ í•œ ë²ˆì˜ ë¹¼ê¸°ë¡œ ë!\n```\n\n### í•µì‹¬ ê³µì‹\n```\nprefix[i] = arr[0] + arr[1] + ... + arr[i]\n\nêµ¬ê°„ í•© (i ~ j) = prefix[j] - prefix[i-1]\n```\n\n### ì‹œê°„ë³µì¡ë„ ë¹„êµ\n| ë°©ë²• | ì „ì²˜ë¦¬ | ì¿¼ë¦¬ 1íšŒ | QíšŒ ì¿¼ë¦¬ |\n|-----|-------|---------|---------|\n| ë¸Œë£¨íŠ¸í¬ìŠ¤ | O(1) | O(n) | O(QÃ—n) |\n| ëˆ„ì í•© | O(n) | O(1) | O(Q) |"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ëˆ„ì í•© ê¸°ë³¸ íŒ¨í„´\n\n# 1. 1ì°¨ì› ëˆ„ì í•©\ndef build_prefix_sum(arr):\n    n = len(arr)\n    prefix = [0] * (n + 1)  # 1-indexed (í¸ì˜ìƒ)\n\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + arr[i]\n\n    return prefix\n\ndef range_sum(prefix, left, right):\n    \"\"\"arr[left] ~ arr[right] í•©ê³„ (0-indexed)\"\"\"\n    return prefix[right + 1] - prefix[left]\n\n# ì‚¬ìš© ì˜ˆì‹œ\narr = [1, 2, 3, 4, 5]\nprefix = build_prefix_sum(arr)\nprint(prefix)  # [0, 1, 3, 6, 10, 15]\n\nprint(range_sum(prefix, 1, 3))  # 2+3+4 = 9\nprint(range_sum(prefix, 0, 4))  # 1+2+3+4+5 = 15\n\n# 2. 2ì°¨ì› ëˆ„ì í•©\ndef build_prefix_sum_2d(matrix):\n    if not matrix:\n        return []\n\n    m, n = len(matrix), len(matrix[0])\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n        for j in range(n):\n            prefix[i+1][j+1] = (matrix[i][j]\n                               + prefix[i][j+1]\n                               + prefix[i+1][j]\n                               - prefix[i][j])\n\n    return prefix\n\ndef range_sum_2d(prefix, r1, c1, r2, c2):\n    \"\"\"(r1,c1) ~ (r2,c2) ì§ì‚¬ê°í˜• í•©ê³„\"\"\"\n    return (prefix[r2+1][c2+1]\n            - prefix[r1][c2+1]\n            - prefix[r2+1][c1]\n            + prefix[r1][c1])\n\n# 3. ì‘ìš©: í•©ì´ Kì¸ ë¶€ë¶„ ë°°ì—´ ê°œìˆ˜\nfrom collections import defaultdict\n\ndef subarray_sum_equals_k(arr, k):\n    count = 0\n    current_sum = 0\n    prefix_counts = defaultdict(int)\n    prefix_counts[0] = 1  # ë¹ˆ prefix\n\n    for num in arr:\n        current_sum += num\n        # current_sum - kê°€ ì´ì „ì— ë‚˜ì™”ë‹¤ë©´\n        # ê·¸ ì§€ì ë¶€í„° í˜„ì¬ê¹Œì§€ì˜ í•©ì´ k\n        count += prefix_counts[current_sum - k]\n        prefix_counts[current_sum] += 1\n\n    return count\n\nprint(subarray_sum_equals_k([1, 1, 1], 2))  # 2"
      },
      {
        "type": "tip",
        "title": "ğŸ’¡ ëˆ„ì í•© í™œìš© íŒ",
        "content": "### 1-indexed vs 0-indexed\n\n```python\n# 0-indexed (ì§ê´€ì ì´ì§€ë§Œ ê²½ê³„ ì²˜ë¦¬ í•„ìš”)\nprefix[0] = arr[0]\nfor i in range(1, n):\n    prefix[i] = prefix[i-1] + arr[i]\n\n# êµ¬ê°„í•©: prefix[right] - prefix[left-1]\n# left=0ì¼ ë•Œ ì˜ˆì™¸ ì²˜ë¦¬ í•„ìš”!\n\n# 1-indexed (ì¶”ì²œ!)\nprefix[0] = 0\nfor i in range(n):\n    prefix[i+1] = prefix[i] + arr[i]\n\n# êµ¬ê°„í•©: prefix[right+1] - prefix[left]\n# ì˜ˆì™¸ ì²˜ë¦¬ ë¶ˆí•„ìš”!\n```\n\n### ì°¨ë¶„ ë°°ì—´ (Difference Array)\n```python\n# êµ¬ê°„ [l, r]ì— ê°’ vë¥¼ ë”í•˜ê¸°\n# ë§¤ë²ˆ O(n) ëŒ€ì‹  O(1)ë¡œ!\n\ndiff = [0] * (n + 1)\n\n# êµ¬ê°„ ì—…ë°ì´íŠ¸\ndiff[l] += v\ndiff[r + 1] -= v\n\n# ìµœì¢… ë°°ì—´ ë³µì›\narr = []\ncurrent = 0\nfor d in diff[:-1]:\n    current += d\n    arr.append(current)\n```"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "### Level 1: ê¸°ì´ˆ\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| êµ¬ê°„ í•© êµ¬í•˜ê¸° 4 (11659) | ë°±ì¤€ | 1ì°¨ì› ëˆ„ì í•© |\n| êµ¬ê°„ í•© êµ¬í•˜ê¸° 5 (11660) | ë°±ì¤€ | 2ì°¨ì› ëˆ„ì í•© |\n\n### Level 2: ì‘ìš©\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ë‚˜ë¨¸ì§€ í•© (10986) | ë°±ì¤€ | ëª¨ë“ˆëŸ¬ ëˆ„ì í•© |\n| Subarray Sum Equals K | LeetCode | í•´ì‹œë§µ í™œìš© |\n\n### Level 3: ì‹¬í™”\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| Range Sum Query 2D | LeetCode | 2D ì‘ìš© |\n| êµ¬ê°„ í•© êµ¬í•˜ê¸° (2042) | ë°±ì¤€ | ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ |"
      }
    ]
  },
  "02_ë°°ì—´/sliding-window": {
    "id": "02_ë°°ì—´/sliding-window",
    "title": "Sliding Window",
    "category": "algorithm",
    "subCategory": "02_ë°°ì—´",
    "language": "Python",
    "description": "ê³ ì •/ê°€ë³€ í¬ê¸° ìœˆë„ìš°ë¡œ ì—°ì† êµ¬ê°„ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì°½ë¬¸ì„ ë°€ë©´ì„œ ë³´ëŠ” ê²ƒì²˜ëŸ¼ ì—°ì† êµ¬ê°„ì„ ì²˜ë¦¬** - O(nÂ²)ë¥¼ O(n)ìœ¼ë¡œ!\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì‹¤ë¬´ì—ì„œ:\n- **ì‹¤ì‹œê°„ ë°ì´í„° ë¶„ì„**: ìµœê·¼ Në¶„ê°„ í‰ê·  íŠ¸ë˜í”½\n- **ë„¤íŠ¸ì›Œí¬**: TCP ìŠ¬ë¼ì´ë”© ìœˆë„ìš° í”„ë¡œí† ì½œ\n- **ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬**: Kafka, Flinkì˜ ìœˆë„ìš° ì—°ì‚°\n\n### ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ:\n- ì¶œì œ ë¹ˆë„: â­â­â­â­â­\n- \"ì—°ì† Kê°œ\", \"ë¶€ë¶„ ë°°ì—´\", \"ë¶€ë¶„ ë¬¸ìì—´\" í‚¤ì›Œë“œ\n\n---\n\n## ğŸ¯ í•µì‹¬ ê°œë… (5ë¶„ ì»·)\n\n### ğŸ“š ê¸°ì°¨ ì°½ë¬¸ìœ¼ë¡œ ì´í•´í•˜ê¸°\n```\nê¸°ì°¨ ì°½ë¬¸(ìœˆë„ìš°)ìœ¼ë¡œ í’ê²½(ë°°ì—´)ì„ ë³¸ë‹¤:\n- ì°½ë¬¸ í¬ê¸°ëŠ” ê³ ì • (ë˜ëŠ” ê°€ë³€)\n- ê¸°ì°¨ê°€ ì´ë™í•˜ë©´ ìƒˆ í’ê²½ì´ ë“¤ì–´ì˜¤ê³  ì˜› í’ê²½ì€ ë‚˜ê°\n- ëª¨ë“  í’ê²½ì„ ë‹¤ì‹œ ë³¼ í•„ìš” ì—†ì´ ë³€í™”ë§Œ ë°˜ì˜!\n```\n\n### ìœ í˜• 2ê°€ì§€\n\n**1. ê³ ì • í¬ê¸° ìœˆë„ìš°**\n```\në°°ì—´: [1, 3, 2, 6, -1, 4, 1, 8, 2]\ní¬ê¸°: 3\n\n[1, 3, 2] â†’ sum = 6\n   [3, 2, 6] â†’ sum = 6 - 1 + 6 = 11  (ë¹ ì§€ê³  ë“¤ì–´ì˜¨ ê²ƒë§Œ!)\n      [2, 6, -1] â†’ sum = 11 - 3 + (-1) = 7\n```\n\n**2. ê°€ë³€ í¬ê¸° ìœˆë„ìš°**\n```\nì¡°ê±´ì„ ë§Œì¡±í•  ë•Œê¹Œì§€ í™•ì¥\nì¡°ê±´ ì´ˆê³¼í•˜ë©´ ì¶•ì†Œ\nâ†’ íˆ¬ í¬ì¸í„°ì™€ ìœ ì‚¬\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ìŠ¬ë¼ì´ë”© ìœˆë„ìš° íŒ¨í„´\n\n# 1. ê³ ì • í¬ê¸°: ì—°ì† Kê°œ ìµœëŒ€ í•©\ndef max_sum_subarray(arr, k):\n    n = len(arr)\n    if n < k:\n        return -1\n\n    # ì²« ìœˆë„ìš° í•© ê³„ì‚°\n    window_sum = sum(arr[:k])\n    max_sum = window_sum\n\n    # ìœˆë„ìš° ìŠ¬ë¼ì´ë”©\n    for i in range(k, n):\n        window_sum += arr[i] - arr[i - k]  # ë“¤ì–´ì˜¨ ê²ƒ + ë‚˜ê°„ ê²ƒ -\n        max_sum = max(max_sum, window_sum)\n\n    return max_sum\n\narr = [1, 4, 2, 10, 2, 3, 1, 0, 20]\nprint(max_sum_subarray(arr, 4))  # 24 (10+2+3+1... ì•„ë‹ˆ 2+10+2+3=17? ë‹¤ì‹œ: 3+1+0+20=24)\n\n# 2. ê³ ì • í¬ê¸°: ì—°ì† Kê°œ í‰ê· \ndef moving_average(arr, k):\n    n = len(arr)\n    result = []\n    window_sum = sum(arr[:k])\n    result.append(window_sum / k)\n\n    for i in range(k, n):\n        window_sum += arr[i] - arr[i - k]\n        result.append(window_sum / k)\n\n    return result\n\n# 3. ê°€ë³€ í¬ê¸°: í•©ì´ target ì´ìƒì¸ ìµœì†Œ ê¸¸ì´\ndef min_length_subarray(arr, target):\n    n = len(arr)\n    min_len = float('inf')\n    window_sum = 0\n    left = 0\n\n    for right in range(n):\n        window_sum += arr[right]\n\n        while window_sum >= target:\n            min_len = min(min_len, right - left + 1)\n            window_sum -= arr[left]\n            left += 1\n\n    return min_len if min_len != float('inf') else 0\n\n# 4. ê°€ë³€ í¬ê¸°: ì¤‘ë³µ ì—†ëŠ” ìµœì¥ ë¶€ë¶„ ë¬¸ìì—´\ndef longest_unique_substring(s):\n    char_set = set()\n    left = 0\n    max_len = 0\n\n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n\n        char_set.add(s[right])\n        max_len = max(max_len, right - left + 1)\n\n    return max_len\n\nprint(longest_unique_substring(\"abcabcbb\"))  # 3 (\"abc\")"
      },
      {
        "type": "tip",
        "title": "ğŸ’¡ ìŠ¬ë¼ì´ë”© ìœˆë„ìš° vs íˆ¬ í¬ì¸í„°",
        "content": "### ì–¸ì œ ë­˜ ì“¸ê¹Œ?\n\n| ìƒí™© | ê¸°ë²• | ì˜ˆì‹œ |\n|-----|-----|-----|\n| ì—°ì† êµ¬ê°„ì˜ í•©/í‰ê·  | ìŠ¬ë¼ì´ë”© ìœˆë„ìš° | ì—°ì† Kê°œ ìµœëŒ€í•© |\n| ë‘ ê°’ì˜ ì¡°í•© | íˆ¬ í¬ì¸í„° | í•©ì´ Kì¸ ë‘ ìˆ˜ |\n| ì¡°ê±´ ë§Œì¡± êµ¬ê°„ | ë‘˜ ë‹¤ ê°€ëŠ¥ | í•©ì´ K ì´ìƒì¸ ìµœì†Œ êµ¬ê°„ |\n| ì •ë ¬ëœ ë°°ì—´ | íˆ¬ í¬ì¸í„° | ì´ì§„ íƒìƒ‰ ëŒ€ì•ˆ |\n\n### ìŠ¬ë¼ì´ë”© ìœˆë„ìš° í‚¤ì›Œë“œ\n- \"ì—°ì†\", \"ë¶€ë¶„ ë°°ì—´\", \"ë¶€ë¶„ ë¬¸ìì—´\"\n- \"Kê°œ\", \"ê¸¸ì´ê°€ Kì¸\"\n- \"ìµœëŒ€/ìµœì†Œ êµ¬ê°„\"\n\n### ì‹œê°„ë³µì¡ë„ ë¹„êµ\n```python\n# ë¸Œë£¨íŠ¸í¬ìŠ¤: O(n Ã— k)\nfor i in range(n - k + 1):\n    window_sum = sum(arr[i:i+k])  # ë§¤ë²ˆ kê°œ ë”í•¨\n\n# ìŠ¬ë¼ì´ë”© ìœˆë„ìš°: O(n)\nwindow_sum = sum(arr[:k])\nfor i in range(k, n):\n    window_sum += arr[i] - arr[i-k]  # O(1)\n```"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "### Level 1: ê³ ì • ìœˆë„ìš°\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| êµ¬ê°„ í•© êµ¬í•˜ê¸° 4 (11659) | ë°±ì¤€ | ëˆ„ì í•© ê¸°ì´ˆ |\n| Maximum Average Subarray I | LeetCode | ê³ ì • ìœˆë„ìš° |\n\n### Level 2: ê°€ë³€ ìœˆë„ìš°\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ë¶€ë¶„í•© (1806) | ë°±ì¤€ | ìµœì†Œ ê¸¸ì´ |\n| Longest Substring Without Repeating | LeetCode | ë¬¸ìì—´ ìœˆë„ìš° |\n\n### Level 3: ì‹¬í™”\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| Sliding Window Maximum | LeetCode | ë± í™œìš© |\n| Minimum Window Substring | LeetCode | í•´ì‹œë§µ+ìœˆë„ìš° |"
      }
    ]
  },
  "02_ë°°ì—´/two-pointer": {
    "id": "02_ë°°ì—´/two-pointer",
    "title": "Two Pointer",
    "category": "algorithm",
    "subCategory": "02_ë°°ì—´",
    "language": "Python",
    "description": "ë‘ ê°œì˜ í¬ì¸í„°ë¡œ ë°°ì—´ì„ íš¨ìœ¨ì ìœ¼ë¡œ íƒìƒ‰í•˜ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ íˆ¬ í¬ì¸í„°ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ë‘ ê°œì˜ í¬ì¸í„°ë¥¼ ì´ë™ì‹œí‚¤ë©° ì›í•˜ëŠ” ì¡°ê±´ì„ ì°¾ëŠ” ê¸°ë²•** - O(nÂ²)ë¥¼ O(n)ìœ¼ë¡œ!\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì‹¤ë¬´ì—ì„œ:\n- **ë‘ ë°°ì—´ ë³‘í•©**: ì •ë ¬ëœ ë‘ ë¦¬ìŠ¤íŠ¸ í•©ì¹˜ê¸°\n- **êµ¬ê°„ ê²€ìƒ‰**: ì—°ì† êµ¬ê°„ì—ì„œ ì¡°ê±´ ë§Œì¡±í•˜ëŠ” ê²½ìš°\n- **ë¬¸ìì—´ ì²˜ë¦¬**: íšŒë¬¸ ê²€ì‚¬, ì•„ë‚˜ê·¸ë¨\n\n### ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ:\n- ì¶œì œ ë¹ˆë„: â­â­â­â­â­\n- ëŒ€í‘œ ê¸°ì—…: ì¹´ì¹´ì˜¤, ë„¤ì´ë²„ **í•„ìˆ˜ ìœ í˜•**\n- \"í•©ì´ Kì¸ ìŒ\", \"ì—°ì† ë¶€ë¶„ ë°°ì—´\" ë¬¸ì œ\n\n---\n\n## ğŸ¯ í•µì‹¬ ê°œë… (5ë¶„ ì»·)\n\n### ğŸ“š ì±… ì–‘ìª½ì—ì„œ ì ‘ê·¼í•˜ê¸°\n```\në‘êº¼ìš´ ì±…ì—ì„œ íŠ¹ì • í˜ì´ì§€ë¥¼ ì°¾ì„ ë•Œ:\n- í•œ ì‚¬ëŒì€ ì•ì—ì„œë¶€í„° (left)\n- í•œ ì‚¬ëŒì€ ë’¤ì—ì„œë¶€í„° (right)\n- ë§Œë‚˜ë©´ ë!\n```\n\n### íˆ¬ í¬ì¸í„° ìœ í˜•\n\n**1. ì–‘ëì—ì„œ ì‹œì‘ (Opposite Direction)**\n```\n[1, 2, 3, 4, 5, 6, 7]\n â†‘                 â†‘\nleft             right\n```\n- ì‚¬ìš©: ì •ë ¬ëœ ë°°ì—´ì—ì„œ í•© ì°¾ê¸°\n\n**2. ê°™ì€ ë°©í–¥ (Same Direction)**\n```\n[1, 2, 3, 4, 5, 6, 7]\n â†‘  â†‘\nslow fast\n```\n- ì‚¬ìš©: ìŠ¬ë¼ì´ë”© ìœˆë„ìš°, ì¤‘ë³µ ì œê±°"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° íˆ¬ í¬ì¸í„° ê¸°ë³¸ íŒ¨í„´\n\n# 1. ì–‘ëì—ì„œ ì‹œì‘: ì •ë ¬ëœ ë°°ì—´ì—ì„œ í•©ì´ targetì¸ ìŒ ì°¾ê¸°\ndef two_sum_sorted(arr, target):\n    left, right = 0, len(arr) - 1\n\n    while left < right:\n        current_sum = arr[left] + arr[right]\n\n        if current_sum == target:\n            return [left, right]  # ì°¾ì•˜ë‹¤!\n        elif current_sum < target:\n            left += 1   # í•©ì´ ì‘ìœ¼ë©´ ì™¼ìª½ ì¦ê°€\n        else:\n            right -= 1  # í•©ì´ í¬ë©´ ì˜¤ë¥¸ìª½ ê°ì†Œ\n\n    return [-1, -1]  # ëª» ì°¾ìŒ\n\n# í…ŒìŠ¤íŠ¸\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(two_sum_sorted(arr, 10))  # [0, 8] (1+9=10)\n\n# 2. ê°™ì€ ë°©í–¥: ì—°ì† ë¶€ë¶„ ë°°ì—´ì˜ í•©\ndef min_subarray_len(arr, target):\n    \"\"\"í•©ì´ target ì´ìƒì¸ ìµœì†Œ ê¸¸ì´ ë¶€ë¶„ ë°°ì—´\"\"\"\n    n = len(arr)\n    left = 0\n    current_sum = 0\n    min_len = float('inf')\n\n    for right in range(n):\n        current_sum += arr[right]\n\n        while current_sum >= target:\n            min_len = min(min_len, right - left + 1)\n            current_sum -= arr[left]\n            left += 1\n\n    return min_len if min_len != float('inf') else 0\n\n# 3. ì¤‘ë³µ ì œê±° (ì •ë ¬ëœ ë°°ì—´)\ndef remove_duplicates(arr):\n    if not arr:\n        return 0\n\n    slow = 0\n    for fast in range(1, len(arr)):\n        if arr[fast] != arr[slow]:\n            slow += 1\n            arr[slow] = arr[fast]\n\n    return slow + 1  # ìœ ì¼í•œ ìš”ì†Œ ê°œìˆ˜\n\n# 4. íšŒë¬¸ ê²€ì‚¬\ndef is_palindrome(s):\n    left, right = 0, len(s) - 1\n\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n\n    return True\n\nprint(is_palindrome(\"racecar\"))  # True"
      },
      {
        "type": "common-mistake",
        "title": "âš ï¸ íˆ¬ í¬ì¸í„° ì‹¤ìˆ˜ TOP 3",
        "content": "**1ï¸âƒ£ ì •ë ¬ ì•ˆ í•˜ê³  ì‚¬ìš©**\n\nâŒ **Bad:**\n```python\narr = [3, 1, 4, 1, 5]  # ì •ë ¬ ì•ˆ ë¨!\ntwo_sum_sorted(arr, 6)  # ì˜ëª»ëœ ê²°ê³¼\n```\n\nâœ… **Good:**\n```python\narr = [3, 1, 4, 1, 5]\narr.sort()  # ë¨¼ì € ì •ë ¬!\ntwo_sum_sorted(arr, 6)\n```\n\n---\n\n**2ï¸âƒ£ í¬ì¸í„° ì´ë™ ì¡°ê±´ ì‹¤ìˆ˜**\n\nâŒ **Bad:**\n```python\nwhile left <= right:  # ê°™ì„ ë•Œë„ ì‹¤í–‰ â†’ ë¬´í•œë£¨í”„ ê°€ëŠ¥\n    if condition:\n        left += 1\n        right -= 1\n```\n\nâœ… **Good:**\n```python\nwhile left < right:  # ì—‡ê°ˆë¦¬ë©´ ì¢…ë£Œ\n    if condition:\n        left += 1\n    else:\n        right -= 1\n```\n\n---\n\n**3ï¸âƒ£ ê²½ê³„ ì¡°ê±´ ë¬´ì‹œ**\n\n```python\n# ë¹ˆ ë°°ì—´ì´ë‚˜ ê¸¸ì´ 1ì¸ ê²½ìš° ì²´í¬\ndef two_pointer_func(arr):\n    if len(arr) < 2:\n        return -1  # ì˜ˆì™¸ ì²˜ë¦¬\n\n    left, right = 0, len(arr) - 1\n    # ...\n```"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "### Level 1: ê¸°ì´ˆ\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ìˆ˜ë“¤ì˜ í•© 2 (2003) | ë°±ì¤€ | ê¸°ë³¸ íˆ¬í¬ì¸í„° |\n| Two Sum II | LeetCode | ì •ë ¬ëœ ë°°ì—´ |\n\n### Level 2: ì‘ìš©\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ë¶€ë¶„í•© (1806) | ë°±ì¤€ | ìµœì†Œ ê¸¸ì´ |\n| ì†Œìˆ˜ì˜ ì—°ì†í•© (1644) | ë°±ì¤€ | ëˆ„ì í•©+íˆ¬í¬ |\n| 3Sum | LeetCode | ì„¸ ìˆ˜ì˜ í•© |\n\n### Level 3: ì‹¬í™”\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| Container With Most Water | LeetCode | ìµœì í™” |\n| Trapping Rain Water | LeetCode | ì–´ë ¤ì›€ |"
      }
    ]
  },
  "03_ë¬¸ìì—´/kmp": {
    "id": "03_ë¬¸ìì—´/kmp",
    "title": "Kmp",
    "category": "algorithm",
    "subCategory": "03_ë¬¸ìì—´",
    "language": "Python",
    "description": "ì‹¤íŒ¨ í•¨ìˆ˜ë¥¼ ì´ìš©í•œ O(n+m) ë¬¸ìì—´ ê²€ìƒ‰ ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ KMPë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì‹¤íŒ¨ í•¨ìˆ˜ë¡œ ë¶ˆí•„ìš”í•œ ë¹„êµë¥¼ ê±´ë„ˆë›°ëŠ” ë¬¸ìì—´ ê²€ìƒ‰** - O(nÃ—m) â†’ O(n+m)\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì‹¤ë¬´ì—ì„œ:\n- **í…ìŠ¤íŠ¸ ì—ë””í„°**: Ctrl+F ê²€ìƒ‰ ê¸°ëŠ¥\n- **DNA ì„œì—´ ë¶„ì„**: íŒ¨í„´ ë§¤ì¹­\n- **ë„¤íŠ¸ì›Œí¬**: íŒ¨í‚· í•„í„°ë§\n\n### í•µì‹¬ ì•„ì´ë””ì–´\n```\níŒ¨í„´: ABABC\nì‹¤íŒ¨ í•¨ìˆ˜: [0, 0, 1, 2, 0]\n\në¶ˆì¼ì¹˜ ì‹œ, ì²˜ìŒë¶€í„° ë‹¤ì‹œ ë¹„êµí•˜ì§€ ì•Šê³ \nì´ë¯¸ ì¼ì¹˜í•œ ì ‘ë‘ì‚¬ ì •ë³´ë¥¼ í™œìš©í•´ ê±´ë„ˆë›°ê¸°!\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° KMP ì•Œê³ ë¦¬ì¦˜\n\ndef build_failure(pattern):\n    \"\"\"ì‹¤íŒ¨ í•¨ìˆ˜ (ë¶€ë¶„ ì¼ì¹˜ í…Œì´ë¸”) ìƒì„±\"\"\"\n    m = len(pattern)\n    failure = [0] * m\n    j = 0\n\n    for i in range(1, m):\n        while j > 0 and pattern[i] != pattern[j]:\n            j = failure[j - 1]\n\n        if pattern[i] == pattern[j]:\n            j += 1\n            failure[i] = j\n\n    return failure\n\ndef kmp_search(text, pattern):\n    \"\"\"KMPë¡œ íŒ¨í„´ ê²€ìƒ‰\"\"\"\n    n, m = len(text), len(pattern)\n    failure = build_failure(pattern)\n    results = []\n    j = 0\n\n    for i in range(n):\n        while j > 0 and text[i] != pattern[j]:\n            j = failure[j - 1]\n\n        if text[i] == pattern[j]:\n            j += 1\n            if j == m:  # íŒ¨í„´ ì°¾ìŒ\n                results.append(i - m + 1)\n                j = failure[j - 1]\n\n    return results\n\n# í…ŒìŠ¤íŠ¸\ntext = \"ABABDABACDABABCABAB\"\npattern = \"ABABC\"\nprint(kmp_search(text, pattern))  # [10]\nprint(build_failure(pattern))  # [0, 0, 1, 2, 0]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ì°¾ê¸° (1786) | ë°±ì¤€ | KMP ê¸°ë³¸ |\n| ë¶€ë¶„ ë¬¸ìì—´ (16916) | ë°±ì¤€ | KMP ì‘ìš© |\n| Implement strStr() | LeetCode | ê¸°ë³¸ |"
      }
    ]
  },
  "03_ë¬¸ìì—´/string-basic": {
    "id": "03_ë¬¸ìì—´/string-basic",
    "title": "String Basic",
    "category": "algorithm",
    "subCategory": "03_ë¬¸ìì—´",
    "language": "Python",
    "description": "ë¬¸ìì—´ ì²˜ë¦¬ì˜ ê¸°ë³¸ ê°œë…ê³¼ ì£¼ìš” ì—°ì‚°ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ë¬¸ìì—´ì´ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ë¬¸ìë“¤ì˜ ë°°ì—´** - í…ìŠ¤íŠ¸ ì²˜ë¦¬ì˜ ëª¨ë“  ê²ƒ\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì‹¤ë¬´ì—ì„œ:\n- **ì…ë ¥ ê²€ì¦**: ì´ë©”ì¼, ì „í™”ë²ˆí˜¸, ë¹„ë°€ë²ˆí˜¸ í˜•ì‹ ê²€ì‚¬\n- **ë°ì´í„° íŒŒì‹±**: JSON, CSV, ë¡œê·¸ íŒŒì¼ ì²˜ë¦¬\n- **ê²€ìƒ‰ ì—”ì§„**: í…ìŠ¤íŠ¸ ë§¤ì¹­, ìë™ì™„ì„±\n\n### ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ:\n- ì¶œì œ ë¹ˆë„: â­â­â­â­â­\n- ë¬¸ìì—´ ì²˜ë¦¬ëŠ” ê±°ì˜ ëª¨ë“  ë¬¸ì œì— ë“±ì¥\n\n---\n\n## ğŸ¯ í•µì‹¬ ê°œë…\n\n### Python ë¬¸ìì—´ íŠ¹ì§•\n- **ë¶ˆë³€(Immutable)**: í•œë²ˆ ìƒì„±í•˜ë©´ ìˆ˜ì • ë¶ˆê°€\n- **ì‹œí€€ìŠ¤ íƒ€ì…**: ì¸ë±ì‹±, ìŠ¬ë¼ì´ì‹± ê°€ëŠ¥\n- **ìœ ë‹ˆì½”ë“œ ì§€ì›**: í•œê¸€, ì´ëª¨ì§€ ë“± ì²˜ë¦¬ ê°€ëŠ¥\n\n### ì£¼ìš” ì‹œê°„ë³µì¡ë„\n| ì—°ì‚° | ì‹œê°„ë³µì¡ë„ |\n|-----|----------|\n| ì¸ë±ìŠ¤ ì ‘ê·¼ s[i] | O(1) |\n| ìŠ¬ë¼ì´ì‹± s[i:j] | O(j-i) |\n| ì—°ê²° s + t | O(len(s) + len(t)) |\n| in ì—°ì‚° | O(n) |\n| ê¸¸ì´ len(s) | O(1) |"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ë¬¸ìì—´ ê¸°ë³¸ ì—°ì‚°\n\ns = \"Hello, World!\"\n\n# 1. ê¸°ë³¸ ì—°ì‚°\nprint(len(s))           # 13\nprint(s[0])             # 'H'\nprint(s[-1])            # '!'\nprint(s[0:5])           # 'Hello'\nprint(s[::-1])          # '!dlroW ,olleH' (ë’¤ì§‘ê¸°)\n\n# 2. ê²€ìƒ‰\nprint('World' in s)     # True\nprint(s.find('o'))      # 4 (ì²« ë²ˆì§¸ ìœ„ì¹˜)\nprint(s.count('o'))     # 2 (ê°œìˆ˜)\n\n# 3. ë³€í™˜\nprint(s.lower())        # ì†Œë¬¸ì\nprint(s.upper())        # ëŒ€ë¬¸ì\nprint(s.replace('World', 'Python'))  # ì¹˜í™˜\n\n# 4. ë¶„í• ê³¼ ê²°í•©\nwords = s.split(', ')   # ['Hello', 'World!']\njoined = '-'.join(words)  # 'Hello-World!'\n\n# 5. ê³µë°± ì²˜ë¦¬\ntext = \"  hello  \"\nprint(text.strip())     # 'hello'\nprint(text.lstrip())    # 'hello  '\nprint(text.rstrip())    # '  hello'\n\n# 6. ë¬¸ìì—´ ê²€ì‚¬\nprint(\"123\".isdigit())  # True\nprint(\"abc\".isalpha())  # True\nprint(\"abc123\".isalnum())  # True\n\n# 7. íš¨ìœ¨ì ì¸ ë¬¸ìì—´ ì—°ê²°\n# âŒ Bad: O(nÂ²)\nresult = \"\"\nfor i in range(1000):\n    result += str(i)\n\n# âœ… Good: O(n)\nresult = ''.join(str(i) for i in range(1000))\n\n# 8. ì•„ìŠ¤í‚¤ ì½”ë“œ\nprint(ord('A'))  # 65\nprint(chr(65))   # 'A'"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "### í•„ìˆ˜ ë¬¸ì œ\n| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ë¬¸ìì—´ ë°˜ë³µ (2675) | ë°±ì¤€ | ê¸°ì´ˆ |\n| ë‹¨ì–´ì˜ ê°œìˆ˜ (1152) | ë°±ì¤€ | split |\n| Valid Palindrome | LeetCode | íšŒë¬¸ |\n| Reverse String | LeetCode | ë’¤ì§‘ê¸° |"
      }
    ]
  },
  "03_ì—°ê²°ë¦¬ìŠ¤íŠ¸/linkedlist-concept": {
    "id": "03_ì—°ê²°ë¦¬ìŠ¤íŠ¸/linkedlist-concept",
    "title": "Linkedlist Concept",
    "category": "algorithm",
    "subCategory": "03_ì—°ê²°ë¦¬ìŠ¤íŠ¸",
    "language": "Python",
    "description": "ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ êµ¬ì¡°ì™€ ë°°ì—´ê³¼ì˜ ì°¨ì´ì ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ë…¸ë“œë“¤ì´ í¬ì¸í„°ë¡œ ì—°ê²°ëœ ì„ í˜• ìë£Œêµ¬ì¡°** - ì‚½ì…/ì‚­ì œ O(1), ì ‘ê·¼ O(n)\n\n---\n\n## ğŸ’¡ ë°°ì—´ vs ì—°ê²° ë¦¬ìŠ¤íŠ¸\n\n| ì—°ì‚° | ë°°ì—´ | ì—°ê²° ë¦¬ìŠ¤íŠ¸ |\n|-----|-----|-----------|\n| ì¸ë±ìŠ¤ ì ‘ê·¼ | O(1) âœ… | O(n) |\n| ë§¨ ì• ì‚½ì… | O(n) | O(1) âœ… |\n| ë§¨ ë’¤ ì‚½ì… | O(1) | O(1)* |\n| ì¤‘ê°„ ì‚½ì… | O(n) | O(1)* |\n| ë©”ëª¨ë¦¬ | ì—°ì† | ë¶„ì‚° |\n\n*ìœ„ì¹˜ë¥¼ ì•Œê³  ìˆì„ ë•Œ\n\n### ì¢…ë¥˜\n1. **ë‹¨ì¼ ì—°ê²° ë¦¬ìŠ¤íŠ¸**: ë‹¤ìŒ ë…¸ë“œë§Œ ê°€ë¦¬í‚´\n2. **ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸**: ì•/ë’¤ ë…¸ë“œ ëª¨ë‘ ê°€ë¦¬í‚´\n3. **ì›í˜• ì—°ê²° ë¦¬ìŠ¤íŠ¸**: ë§ˆì§€ë§‰ì´ ì²˜ìŒì„ ê°€ë¦¬í‚´"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ì—°ê²° ë¦¬ìŠ¤íŠ¸ êµ¬í˜„\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, val):\n        if not self.head:\n            self.head = ListNode(val)\n            return\n\n        curr = self.head\n        while curr.next:\n            curr = curr.next\n        curr.next = ListNode(val)\n\n    def prepend(self, val):\n        new_node = ListNode(val)\n        new_node.next = self.head\n        self.head = new_node\n\n    def delete(self, val):\n        if not self.head:\n            return\n\n        if self.head.val == val:\n            self.head = self.head.next\n            return\n\n        curr = self.head\n        while curr.next and curr.next.val != val:\n            curr = curr.next\n\n        if curr.next:\n            curr.next = curr.next.next\n\n    def display(self):\n        result = []\n        curr = self.head\n        while curr:\n            result.append(curr.val)\n            curr = curr.next\n        return result\n\n# í…ŒìŠ¤íŠ¸\nll = LinkedList()\nll.append(1)\nll.append(2)\nll.append(3)\nprint(ll.display())  # [1, 2, 3]\nll.prepend(0)\nprint(ll.display())  # [0, 1, 2, 3]\nll.delete(2)\nprint(ll.display())  # [0, 1, 3]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| Reverse Linked List | LeetCode | ë’¤ì§‘ê¸° |\n| Merge Two Sorted Lists | LeetCode | ë³‘í•© |\n| Remove Nth Node From End | LeetCode | íˆ¬í¬ì¸í„° |"
      }
    ]
  },
  "03_ì—°ê²°ë¦¬ìŠ¤íŠ¸/linkedlist-cycle": {
    "id": "03_ì—°ê²°ë¦¬ìŠ¤íŠ¸/linkedlist-cycle",
    "title": "Linkedlist Cycle",
    "category": "algorithm",
    "subCategory": "03_ì—°ê²°ë¦¬ìŠ¤íŠ¸",
    "language": "Python",
    "description": "Floydì˜ í† ë¼ì™€ ê±°ë¶ì´ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì‚¬ì´í´ì„ ê°ì§€í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì‚¬ì´í´ ê°ì§€",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ë‘ í¬ì¸í„°ê°€ ë§Œë‚˜ë©´ ì‚¬ì´í´ ì¡´ì¬** - í† ë¼ì™€ ê±°ë¶ì´ ì•Œê³ ë¦¬ì¦˜\n\n---\n\n## Floyd's Cycle Detection\n\n### ì›ë¦¬\n```\nslow: 1ì¹¸ì”© ì´ë™\nfast: 2ì¹¸ì”© ì´ë™\n\nì‚¬ì´í´ì´ ìˆìœ¼ë©´ â†’ ê²°êµ­ ë§Œë‚¨\nì‚¬ì´í´ì´ ì—†ìœ¼ë©´ â†’ fastê°€ ëì— ë„ë‹¬\n```\n\n### ì‚¬ì´í´ ì‹œì‘ì  ì°¾ê¸°\n1. slow, fastê°€ ë§Œë‚˜ëŠ” ì§€ì  ì°¾ê¸°\n2. slowë¥¼ headë¡œ ì´ë™\n3. slow, fast ëª¨ë‘ 1ì¹¸ì”© ì´ë™\n4. ë‹¤ì‹œ ë§Œë‚˜ëŠ” ì§€ì  = ì‚¬ì´í´ ì‹œì‘ì "
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ì‚¬ì´í´ ê°ì§€ ë° ì‹œì‘ì  ì°¾ê¸°\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# 1. ì‚¬ì´í´ ì¡´ì¬ ì—¬ë¶€\ndef has_cycle(head):\n    slow = fast = head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            return True\n\n    return False\n\n# 2. ì‚¬ì´í´ ì‹œì‘ì  ì°¾ê¸°\ndef detect_cycle(head):\n    slow = fast = head\n\n    # 1ë‹¨ê³„: ë§Œë‚˜ëŠ” ì§€ì  ì°¾ê¸°\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            # 2ë‹¨ê³„: ì‹œì‘ì  ì°¾ê¸°\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow  # ì‚¬ì´í´ ì‹œì‘ì \n\n    return None  # ì‚¬ì´í´ ì—†ìŒ\n\n# 3. ì‚¬ì´í´ ê¸¸ì´\ndef cycle_length(head):\n    slow = fast = head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n        if slow == fast:\n            # í•œ ë°”í€´ ëŒì•„ì„œ ê¸¸ì´ ì¸¡ì •\n            length = 1\n            current = slow.next\n            while current != slow:\n                length += 1\n                current = current.next\n            return length\n\n    return 0"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| Linked List Cycle | LeetCode | ì¡´ì¬ ì—¬ë¶€ |\n| Linked List Cycle II | LeetCode | ì‹œì‘ì  |\n| Find the Duplicate Number | LeetCode | ì‘ìš© |"
      }
    ]
  },
  "03_ì—°ê²°ë¦¬ìŠ¤íŠ¸/linkedlist-operation": {
    "id": "03_ì—°ê²°ë¦¬ìŠ¤íŠ¸/linkedlist-operation",
    "title": "Linkedlist Operation",
    "category": "algorithm",
    "subCategory": "03_ì—°ê²°ë¦¬ìŠ¤íŠ¸",
    "language": "Python",
    "description": "ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ ì£¼ìš” ì—°ì‚°ê³¼ êµ¬í˜„ ë°©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì£¼ìš” ì—°ì‚°",
        "content": "## í•„ìˆ˜ ì—°ì‚°ë“¤\n\n### 1. ë’¤ì§‘ê¸° (Reverse)\n```\n1 â†’ 2 â†’ 3 â†’ NULL\n3 â†’ 2 â†’ 1 â†’ NULL\n```\n\n### 2. ì¤‘ê°„ ë…¸ë“œ ì°¾ê¸°\n- íˆ¬ í¬ì¸í„°: slowëŠ” 1ì¹¸, fastëŠ” 2ì¹¸\n- fastê°€ ëì— ë„ë‹¬í•˜ë©´ slowê°€ ì¤‘ê°„\n\n### 3. ë³‘í•© (Merge)\n- ë‘ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ë¥¼ í•˜ë‚˜ë¡œ\n\n### 4. ì‚¬ì´í´ ê°ì§€\n- Floyd's Cycle Detection (í† ë¼ì™€ ê±°ë¶ì´)"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ì—°ê²° ë¦¬ìŠ¤íŠ¸ í•„ìˆ˜ ì—°ì‚°\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# 1. ë’¤ì§‘ê¸°\ndef reverse_list(head):\n    prev = None\n    curr = head\n\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n\n    return prev\n\n# 2. ì¤‘ê°„ ë…¸ë“œ ì°¾ê¸°\ndef find_middle(head):\n    slow = fast = head\n\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    return slow\n\n# 3. ë‘ ì •ë ¬ ë¦¬ìŠ¤íŠ¸ ë³‘í•©\ndef merge_two_lists(l1, l2):\n    dummy = ListNode(0)\n    curr = dummy\n\n    while l1 and l2:\n        if l1.val < l2.val:\n            curr.next = l1\n            l1 = l1.next\n        else:\n            curr.next = l2\n            l2 = l2.next\n        curr = curr.next\n\n    curr.next = l1 or l2\n    return dummy.next\n\n# 4. Në²ˆì§¸ ë…¸ë“œ ì‚­ì œ (ë’¤ì—ì„œ)\ndef remove_nth_from_end(head, n):\n    dummy = ListNode(0, head)\n    slow = fast = dummy\n\n    # fastë¥¼ n+1ì¹¸ ì´ë™\n    for _ in range(n + 1):\n        fast = fast.next\n\n    # slowì™€ fast ë™ì‹œ ì´ë™\n    while fast:\n        slow = slow.next\n        fast = fast.next\n\n    # slow.nextê°€ ì‚­ì œí•  ë…¸ë“œ\n    slow.next = slow.next.next\n    return dummy.next"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| Palindrome Linked List | LeetCode | ì¤‘ê°„+ë’¤ì§‘ê¸° |\n| Add Two Numbers | LeetCode | ìë¦¬ì˜¬ë¦¼ |\n| Intersection of Two Linked Lists | LeetCode | ê¸¸ì´ ë§ì¶”ê¸° |"
      }
    ]
  },
  "04_ìŠ¤íƒí/deque": {
    "id": "04_ìŠ¤íƒí/deque",
    "title": "Deque",
    "category": "algorithm",
    "subCategory": "04_ìŠ¤íƒí",
    "language": "Python",
    "description": "ì–‘ìª½ì—ì„œ ì‚½ì…/ì‚­ì œ ê°€ëŠ¥í•œ ë±ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ë±ì´ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **Double-Ended Queue** - ì–‘ìª½ì—ì„œ ì‚½ì…/ì‚­ì œ ê°€ëŠ¥í•œ ìë£Œêµ¬ì¡°\n\n---\n\n## ë± = ìŠ¤íƒ + í\n\n| ì—°ì‚° | ì‹œê°„ë³µì¡ë„ |\n|-----|----------|\n| appendleft | O(1) |\n| append | O(1) |\n| popleft | O(1) |\n| pop | O(1) |\n\n### í™œìš© ì‚¬ë¡€\n- ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœëŒ€/ìµœì†Œ\n- íšŒë¬¸ ê²€ì‚¬\n- ì‘ì—… ìŠ¤ì¼€ì¤„ë§"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "from collections import deque\n\n# ê¸°ë³¸ ì—°ì‚°\ndq = deque()\n\ndq.append(1)       # ì˜¤ë¥¸ìª½ ì¶”ê°€\ndq.appendleft(0)   # ì™¼ìª½ ì¶”ê°€\ndq.append(2)\nprint(list(dq))    # [0, 1, 2]\n\ndq.pop()           # ì˜¤ë¥¸ìª½ ì œê±°\ndq.popleft()       # ì™¼ìª½ ì œê±°\nprint(list(dq))    # [1]\n\n# ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìµœëŒ“ê°’ (ë± í™œìš©)\ndef max_sliding_window(nums, k):\n    dq = deque()  # ì¸ë±ìŠ¤ ì €ì¥\n    result = []\n\n    for i in range(len(nums)):\n        # ìœˆë„ìš° ë²—ì–´ë‚œ ìš”ì†Œ ì œê±°\n        if dq and dq[0] < i - k + 1:\n            dq.popleft()\n\n        # í˜„ì¬ ê°’ë³´ë‹¤ ì‘ì€ ê°’ë“¤ ì œê±°\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n\n        dq.append(i)\n\n        # ìœˆë„ìš° ì™„ì„± í›„ ìµœëŒ“ê°’ ê¸°ë¡\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n\n    return result\n\nprint(max_sliding_window([1,3,-1,-3,5,3,6,7], 3))\n# [3, 3, 5, 5, 6, 7]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ë± (10866) | ë°±ì¤€ | ê¸°ë³¸ êµ¬í˜„ |\n| AC (5430) | ë°±ì¤€ | ë± í™œìš© |\n| Sliding Window Maximum | LeetCode | ëª¨ë…¸í† ë‹‰ ë± |"
      }
    ]
  },
  "04_ìŠ¤íƒí/monotonic-stack": {
    "id": "04_ìŠ¤íƒí/monotonic-stack",
    "title": "Monotonic Stack",
    "category": "algorithm",
    "subCategory": "04_ìŠ¤íƒí",
    "language": "Python",
    "description": "ë‹¨ì¡° ì¦ê°€/ê°ì†Œë¥¼ ìœ ì§€í•˜ëŠ” ìŠ¤íƒ ê¸°ë²•ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ëª¨ë…¸í† ë‹‰ ìŠ¤íƒì´ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ë‹¨ì¡° ì¦ê°€/ê°ì†Œ ìˆœì„œë¥¼ ìœ ì§€í•˜ëŠ” ìŠ¤íƒ** - O(nÂ²) â†’ O(n)\n\n---\n\n## í™œìš© ì‚¬ë¡€\n- ë‹¤ìŒ í°/ì‘ì€ ìˆ˜ ì°¾ê¸° (NGE, NLE)\n- íˆìŠ¤í† ê·¸ë¨ ìµœëŒ€ ë„“ì´\n- ë¹—ë¬¼ ë°›ê¸°\n\n### í•µì‹¬ ì•„ì´ë””ì–´\n```\ní˜„ì¬ ê°’ë³´ë‹¤ ì‘ì€(ë˜ëŠ” í°) ê°’ë“¤ì„ ìŠ¤íƒì—ì„œ ì œê±°\nâ†’ ìŠ¤íƒ ë§¨ ìœ„ = í˜„ì¬ ê°’ì˜ \"ë‹¤ìŒ í° ìˆ˜\"\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ë‹¤ìŒ í° ìˆ˜ (Next Greater Element)\ndef next_greater_element(nums):\n    n = len(nums)\n    result = [-1] * n\n    stack = []  # ì¸ë±ìŠ¤ ì €ì¥\n\n    for i in range(n):\n        # í˜„ì¬ ê°’ì´ ìŠ¤íƒ topë³´ë‹¤ í¬ë©´\n        while stack and nums[i] > nums[stack[-1]]:\n            idx = stack.pop()\n            result[idx] = nums[i]\n        stack.append(i)\n\n    return result\n\nprint(next_greater_element([2,1,2,4,3]))\n# [4, 2, 4, -1, -1]\n\n# íˆìŠ¤í† ê·¸ë¨ ìµœëŒ€ ë„“ì´\ndef largest_rectangle(heights):\n    stack = []  # (ì¸ë±ìŠ¤, ë†’ì´)\n    max_area = 0\n    heights.append(0)  # ë§ˆì§€ë§‰ ì²˜ë¦¬ìš©\n\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] > h:\n            idx, height = stack.pop()\n            max_area = max(max_area, height * (i - idx))\n            start = idx\n        stack.append((start, h))\n\n    return max_area\n\nprint(largest_rectangle([2,1,5,6,2,3]))  # 10"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ì˜¤í°ìˆ˜ (17298) | ë°±ì¤€ | NGE |\n| íˆìŠ¤í† ê·¸ë¨ (6549) | ë°±ì¤€ | ìµœëŒ€ ë„“ì´ |\n| Daily Temperatures | LeetCode | NGE ì‘ìš© |\n| Trapping Rain Water | LeetCode | ìŠ¤íƒ/íˆ¬í¬ |"
      }
    ]
  },
  "04_ìŠ¤íƒí/practice-stack-queue": {
    "id": "04_ìŠ¤íƒí/practice-stack-queue",
    "title": "Practice Stack Queue",
    "category": "algorithm",
    "subCategory": "04_ìŠ¤íƒí",
    "language": "Python",
    "description": "ìŠ¤íƒê³¼ íë¥¼ í™œìš©í•œ ì‹¤ì „ ë¬¸ì œ í’€ì´ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ¯ ì‹¤ì „ íŒ¨í„´ ì •ë¦¬",
        "content": "## ìŠ¤íƒ vs í ì„ íƒ ê¸°ì¤€\n\n### ìŠ¤íƒ ì‚¬ìš©\n- ì—­ìˆœ ì²˜ë¦¬\n- ì§ ë§ì¶”ê¸° (ê´„í˜¸)\n- ê°€ì¥ ìµœê·¼ ê²ƒ ì²˜ë¦¬\n- DFS, ì¬ê·€ ì‹œë®¬ë ˆì´ì…˜\n\n### í ì‚¬ìš©\n- ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬\n- BFS\n- ì‹œê°„ìˆœ ì²˜ë¦¬\n- ë²„í¼, ëŒ€ê¸°ì—´"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "from collections import deque\n\n# ë¬¸ì œ 1: ìŠ¤íƒìœ¼ë¡œ í êµ¬í˜„\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out.pop()\n\n# ë¬¸ì œ 2: íë¡œ ìŠ¤íƒ êµ¬í˜„\nclass MyStack:\n    def __init__(self):\n        self.queue = deque()\n\n    def push(self, x):\n        self.queue.append(x)\n        for _ in range(len(self.queue) - 1):\n            self.queue.append(self.queue.popleft())\n\n    def pop(self):\n        return self.queue.popleft()\n\n# ë¬¸ì œ 3: í”„ë¦°í„° í\ndef printer_queue(priorities, location):\n    queue = deque(enumerate(priorities))\n    order = 0\n\n    while queue:\n        idx, priority = queue.popleft()\n        if any(p > priority for _, p in queue):\n            queue.append((idx, priority))\n        else:\n            order += 1\n            if idx == location:\n                return order"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ í•„ìˆ˜ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| í”„ë¦°í„° í (1966) | ë°±ì¤€ | ì‹œë®¬ë ˆì´ì…˜ |\n| Implement Queue using Stacks | LeetCode | ìŠ¤íƒâ†’í |\n| Implement Stack using Queues | LeetCode | íâ†’ìŠ¤íƒ |\n| ì¹´ë“œ2 (2164) | ë°±ì¤€ | í ì‹œë®¬ |"
      }
    ]
  },
  "04_ìŠ¤íƒí/priority-queue": {
    "id": "04_ìŠ¤íƒí/priority-queue",
    "title": "Priority Queue",
    "category": "algorithm",
    "subCategory": "04_ìŠ¤íƒí",
    "language": "Python",
    "description": "í™ ê¸°ë°˜ì˜ ìš°ì„ ìˆœìœ„ íë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ìš°ì„ ìˆœìœ„ íë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ê²ƒì´ ë¨¼ì € ë‚˜ì˜¤ëŠ” í** - í™ìœ¼ë¡œ êµ¬í˜„\n\n---\n\n## í™ vs ì •ë ¬\n\n| ì—°ì‚° | ìš°ì„ ìˆœìœ„ í(í™) | ì •ë ¬ |\n|-----|--------------|-----|\n| ì‚½ì… | O(log n) | O(n) |\n| ìµœì†Ÿê°’ ì¶”ì¶œ | O(log n) | O(1) |\n| ìµœì†Ÿê°’ í™•ì¸ | O(1) | O(1) |\n\n### í™œìš©\n- ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œ\n- ì‘ì—… ìŠ¤ì¼€ì¤„ë§\n- Kë²ˆì§¸ í°/ì‘ì€ ìˆ˜"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "import heapq\n\n# ìµœì†Œ í™ (ê¸°ë³¸)\nmin_heap = []\nheapq.heappush(min_heap, 3)\nheapq.heappush(min_heap, 1)\nheapq.heappush(min_heap, 2)\nprint(heapq.heappop(min_heap))  # 1 (ìµœì†Ÿê°’)\n\n# ìµœëŒ€ í™ (ë¶€í˜¸ ë°˜ì „)\nmax_heap = []\nheapq.heappush(max_heap, -3)\nheapq.heappush(max_heap, -1)\nheapq.heappush(max_heap, -2)\nprint(-heapq.heappop(max_heap))  # 3 (ìµœëŒ“ê°’)\n\n# Kë²ˆì§¸ í° ìˆ˜\ndef kth_largest(nums, k):\n    heap = nums[:k]\n    heapq.heapify(heap)  # O(k)\n\n    for num in nums[k:]:\n        if num > heap[0]:\n            heapq.heapreplace(heap, num)  # O(log k)\n\n    return heap[0]\n\nprint(kth_largest([3,2,1,5,6,4], 2))  # 5\n\n# í™ ì •ë ¬\ndef heap_sort(arr):\n    heapq.heapify(arr)\n    return [heapq.heappop(arr) for _ in range(len(arr))]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ìµœì†Œ í™ (1927) | ë°±ì¤€ | ê¸°ë³¸ |\n| ìµœëŒ€ í™ (11279) | ë°±ì¤€ | ë¶€í˜¸ ë°˜ì „ |\n| Kth Largest Element | LeetCode | Kë²ˆì§¸ |\n| Top K Frequent Elements | LeetCode | ë¹ˆë„ |"
      }
    ]
  },
  "04_ìŠ¤íƒí/queue-concept": {
    "id": "04_ìŠ¤íƒí/queue-concept",
    "title": "Queue Concept",
    "category": "algorithm",
    "subCategory": "04_ìŠ¤íƒí",
    "language": "Python",
    "description": "FIFO êµ¬ì¡°ì˜ íì™€ ì£¼ìš” í™œìš© ì‚¬ë¡€ë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ íë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **First In First Out (FIFO)** - ë¨¼ì € ë“¤ì–´ì˜¨ ê²ƒì´ ë¨¼ì € ë‚˜ê°\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì‹¤ë¬´ì—ì„œ:\n- **ë©”ì‹œì§€ í**: Kafka, RabbitMQ\n- **ì‘ì—… ìŠ¤ì¼€ì¤„ë§**: í”„ë¦°í„° ëŒ€ê¸°ì—´\n- **BFS**: ê·¸ë˜í”„ íƒìƒ‰\n- **ìºì‹œ**: LRU êµ¬í˜„\n\n### ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ:\n- ì¶œì œ ë¹ˆë„: â­â­â­â­â­\n- BFS í•„ìˆ˜, \"ìˆœì„œëŒ€ë¡œ\", \"ëŒ€ê¸°ì—´\" í‚¤ì›Œë“œ\n\n---\n\n## ğŸ¯ í•µì‹¬ ì—°ì‚°\n\n| ì—°ì‚° | ì„¤ëª… | ì‹œê°„ë³µì¡ë„ |\n|-----|------|----------|\n| enqueue | ë’¤ì— ì¶”ê°€ | O(1) |\n| dequeue | ì•ì—ì„œ ì œê±° | O(1) |\n| front | ì• ìš”ì†Œ í™•ì¸ | O(1) |\n| isEmpty | ë¹„ì–´ìˆëŠ”ì§€ | O(1) |"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° í êµ¬í˜„ ë° í™œìš©\n\nfrom collections import deque\n\n# Pythonì—ì„œëŠ” deque ì‚¬ìš© (ë¦¬ìŠ¤íŠ¸ì˜ pop(0)ì€ O(n)!)\nqueue = deque()\n\n# ê¸°ë³¸ ì—°ì‚°\nqueue.append(1)     # enqueue\nqueue.append(2)\nqueue.append(3)\nprint(list(queue))  # [1, 2, 3]\n\nfront = queue.popleft()  # dequeue\nprint(front)        # 1\nprint(list(queue))  # [2, 3]\n\npeek = queue[0]     # front (peek)\nprint(peek)         # 2\n\n# í™œìš© 1: BFS ê¸°ë³¸ êµ¬ì¡°\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    result = []\n\n    while queue:\n        node = queue.popleft()\n        result.append(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n    return result\n\n# í™œìš© 2: ìµœê·¼ Nê°œ ìš”ì†Œë§Œ ìœ ì§€\nclass RecentCounter:\n    def __init__(self, n):\n        self.queue = deque()\n        self.n = n\n\n    def add(self, val):\n        self.queue.append(val)\n        if len(self.queue) > self.n:\n            self.queue.popleft()\n\n    def get_recent(self):\n        return list(self.queue)\n\n# í™œìš© 3: ì›í˜• í\nclass CircularQueue:\n    def __init__(self, k):\n        self.queue = [None] * k\n        self.size = k\n        self.front = self.rear = -1\n\n    def enqueue(self, val):\n        if self.is_full():\n            return False\n        if self.is_empty():\n            self.front = 0\n        self.rear = (self.rear + 1) % self.size\n        self.queue[self.rear] = val\n        return True\n\n    def dequeue(self):\n        if self.is_empty():\n            return None\n        val = self.queue[self.front]\n        if self.front == self.rear:\n            self.front = self.rear = -1\n        else:\n            self.front = (self.front + 1) % self.size\n        return val\n\n    def is_empty(self):\n        return self.front == -1\n\n    def is_full(self):\n        return (self.rear + 1) % self.size == self.front"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| í (10845) | ë°±ì¤€ | ê¸°ë³¸ êµ¬í˜„ |\n| ìš”ì„¸í‘¸ìŠ¤ ë¬¸ì œ (1158) | ë°±ì¤€ | ì›í˜• í |\n| Design Circular Queue | LeetCode | ì›í˜• í |\n| Number of Recent Calls | LeetCode | ì‹œê°„ ìœˆë„ìš° |"
      }
    ]
  },
  "04_ìŠ¤íƒí/stack-concept": {
    "id": "04_ìŠ¤íƒí/stack-concept",
    "title": "Stack Concept",
    "category": "algorithm",
    "subCategory": "04_ìŠ¤íƒí",
    "language": "Python",
    "description": "LIFO êµ¬ì¡°ì˜ ìŠ¤íƒê³¼ ì£¼ìš” í™œìš© ì‚¬ë¡€ë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ìŠ¤íƒì´ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **Last In First Out (LIFO)** - ê°€ì¥ ë‚˜ì¤‘ì— ë“¤ì–´ì˜¨ ê²ƒì´ ë¨¼ì € ë‚˜ê°\n\n---\n\n## ğŸ’¡ ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n\n### ì‹¤ë¬´ì—ì„œ:\n- **Undo ê¸°ëŠ¥**: ìµœê·¼ ì‘ì—…ë¶€í„° ì·¨ì†Œ\n- **ë¸Œë¼ìš°ì € ë’¤ë¡œê°€ê¸°**: ë°©ë¬¸ ê¸°ë¡ ìŠ¤íƒ\n- **í•¨ìˆ˜ í˜¸ì¶œ ìŠ¤íƒ**: ì¬ê·€, ì½œìŠ¤íƒ\n- **ê´„í˜¸ ë§¤ì¹­**: ì½”ë“œ ì—ë””í„°, ì»´íŒŒì¼ëŸ¬\n\n### ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ:\n- ì¶œì œ ë¹ˆë„: â­â­â­â­â­\n- \"ê´„í˜¸\", \"ì—­ìˆœ\", \"ê°€ì¥ ìµœê·¼\" í‚¤ì›Œë“œ\n\n---\n\n## ğŸ¯ í•µì‹¬ ì—°ì‚°\n\n| ì—°ì‚° | ì„¤ëª… | ì‹œê°„ë³µì¡ë„ |\n|-----|------|----------|\n| push | ë§¨ ìœ„ì— ì¶”ê°€ | O(1) |\n| pop | ë§¨ ìœ„ ì œê±° ë° ë°˜í™˜ | O(1) |\n| peek/top | ë§¨ ìœ„ í™•ì¸ | O(1) |\n| isEmpty | ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸ | O(1) |"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ğŸ”° ìŠ¤íƒ êµ¬í˜„ ë° í™œìš©\n\n# Pythonì—ì„œëŠ” ë¦¬ìŠ¤íŠ¸ë¥¼ ìŠ¤íƒìœ¼ë¡œ ì‚¬ìš©\nstack = []\n\n# ê¸°ë³¸ ì—°ì‚°\nstack.append(1)    # push\nstack.append(2)\nstack.append(3)\nprint(stack)       # [1, 2, 3]\n\ntop = stack.pop()  # pop\nprint(top)         # 3\nprint(stack)       # [1, 2]\n\npeek = stack[-1]   # peek\nprint(peek)        # 2\n\nis_empty = len(stack) == 0\n\n# í™œìš© 1: ê´„í˜¸ ë§¤ì¹­\ndef is_valid_parentheses(s):\n    stack = []\n    pairs = {')': '(', '}': '{', ']': '['}\n\n    for char in s:\n        if char in '({[':\n            stack.append(char)\n        elif char in ')}]':\n            if not stack or stack.pop() != pairs[char]:\n                return False\n\n    return len(stack) == 0\n\nprint(is_valid_parentheses(\"()[]{}\"))  # True\nprint(is_valid_parentheses(\"([)]\"))    # False\n\n# í™œìš© 2: ë¬¸ìì—´ ë’¤ì§‘ê¸°\ndef reverse_string(s):\n    stack = list(s)\n    result = \"\"\n    while stack:\n        result += stack.pop()\n    return result\n\n# í™œìš© 3: 10ì§„ìˆ˜ â†’ 2ì§„ìˆ˜ ë³€í™˜\ndef decimal_to_binary(n):\n    stack = []\n    while n > 0:\n        stack.append(n % 2)\n        n //= 2\n\n    result = \"\"\n    while stack:\n        result += str(stack.pop())\n    return result or \"0\"\n\nprint(decimal_to_binary(10))  # \"1010\" "
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| ìŠ¤íƒ (10828) | ë°±ì¤€ | ê¸°ë³¸ êµ¬í˜„ |\n| ê´„í˜¸ (9012) | ë°±ì¤€ | ê´„í˜¸ ë§¤ì¹­ |\n| Valid Parentheses | LeetCode | ì„¸ ì¢…ë¥˜ ê´„í˜¸ |\n| Min Stack | LeetCode | ìµœì†Ÿê°’ O(1) |"
      }
    ]
  },
  "04_ìŠ¤íƒí/stack-problem": {
    "id": "04_ìŠ¤íƒí/stack-problem",
    "title": "Stack Problem",
    "category": "algorithm",
    "subCategory": "04_ìŠ¤íƒí",
    "language": "Python",
    "description": "ìŠ¤íƒì„ í™œìš©í•œ ë‹¤ì–‘í•œ ë¬¸ì œ íŒ¨í„´ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ¯ ìŠ¤íƒ ë¬¸ì œ íŒ¨í„´",
        "content": "## ìŠ¤íƒ ë¬¸ì œ ìœ í˜•\n\n### 1. ê´„í˜¸ ë§¤ì¹­\n- ì—¬ëŠ” ê´„í˜¸: push\n- ë‹«ëŠ” ê´„í˜¸: pop í›„ ë§¤ì¹­ í™•ì¸\n\n### 2. ìˆ˜ì‹ ê³„ì‚°\n- í›„ìœ„ í‘œê¸°ë²• ê³„ì‚°\n- ì¤‘ìœ„ â†’ í›„ìœ„ ë³€í™˜\n\n### 3. ë¬¸ìì—´ ì²˜ë¦¬\n- ì—­ìˆœ ì¶œë ¥\n- ë’¤ì§‘ê¸°\n\n### 4. ë‹¤ìŒ/ì´ì „ í°/ì‘ì€ ìˆ˜\n- ëª¨ë…¸í† ë‹‰ ìŠ¤íƒ"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# í›„ìœ„ í‘œê¸°ë²• ê³„ì‚°\ndef eval_postfix(expression):\n    stack = []\n    operators = {'+', '-', '*', '/'}\n\n    for token in expression.split():\n        if token not in operators:\n            stack.append(int(token))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            if token == '+': stack.append(a + b)\n            elif token == '-': stack.append(a - b)\n            elif token == '*': stack.append(a * b)\n            elif token == '/': stack.append(int(a / b))\n\n    return stack[0]\n\nprint(eval_postfix(\"2 3 + 4 *\"))  # (2+3)*4 = 20\n\n# ì¤‘ìœ„ â†’ í›„ìœ„ ë³€í™˜\ndef infix_to_postfix(expression):\n    precedence = {'+': 1, '-': 1, '*': 2, '/': 2}\n    stack = []\n    result = []\n\n    for token in expression.split():\n        if token.isdigit():\n            result.append(token)\n        elif token == '(':\n            stack.append(token)\n        elif token == ')':\n            while stack and stack[-1] != '(':\n                result.append(stack.pop())\n            stack.pop()  # '(' ì œê±°\n        else:  # ì—°ì‚°ì\n            while (stack and stack[-1] != '(' and\n                   stack[-1] in precedence and\n                   precedence[stack[-1]] >= precedence[token]):\n                result.append(stack.pop())\n            stack.append(token)\n\n    while stack:\n        result.append(stack.pop())\n\n    return ' '.join(result)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| í›„ìœ„ í‘œê¸°ì‹2 (1935) | ë°±ì¤€ | í›„ìœ„ ê³„ì‚° |\n| í›„ìœ„ í‘œê¸°ì‹ (1918) | ë°±ì¤€ | ì¤‘ìœ„â†’í›„ìœ„ |\n| Basic Calculator | LeetCode | ìˆ˜ì‹ ê³„ì‚° |\n| Decode String | LeetCode | ì¤‘ì²© ì²˜ë¦¬ |"
      }
    ]
  },
  "05_í•´ì‹œ/hash-basic": {
    "id": "05_í•´ì‹œ/hash-basic",
    "title": "Hash Basic",
    "category": "algorithm",
    "subCategory": "05_í•´ì‹œ",
    "language": "Python",
    "description": "í•´ì‹œì˜ ê¸°ë³¸ ì—°ì‚°ê³¼ í™œìš©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ í•´ì‹œ ê¸°ì´ˆ",
        "content": "## Python í•´ì‹œ ìë£Œêµ¬ì¡°\n\n### dict (ë”•ì…”ë„ˆë¦¬)\n- í‚¤-ê°’ ìŒ ì €ì¥\n- í‚¤ë¡œ ë¹ ë¥¸ ì¡°íšŒ\n\n### set (ì§‘í•©)\n- ì¤‘ë³µ ì—†ëŠ” ê°’ ì €ì¥\n- ì¡´ì¬ í™•ì¸ O(1)\n- ì§‘í•© ì—°ì‚° (í•©ì§‘í•©, êµì§‘í•©)"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# Set í™œìš©\ns = {1, 2, 3}\ns.add(4)           # ì¶”ê°€\ns.remove(1)        # ì‚­ì œ\nprint(2 in s)      # ì¡´ì¬ í™•ì¸ O(1)\n\n# ì¤‘ë³µ ì œê±°\narr = [1, 1, 2, 2, 3]\nunique = list(set(arr))  # [1, 2, 3]\n\n# ì§‘í•© ì—°ì‚°\na = {1, 2, 3}\nb = {2, 3, 4}\nprint(a | b)  # í•©ì§‘í•© {1, 2, 3, 4}\nprint(a & b)  # êµì§‘í•© {2, 3}\nprint(a - b)  # ì°¨ì§‘í•© {1}\n\n# defaultdict\nfrom collections import defaultdict\ngraph = defaultdict(list)\ngraph[1].append(2)\ngraph[1].append(3)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ |\n|-----|-------|\n| Contains Duplicate | LeetCode |\n| ì „í™”ë²ˆí˜¸ ëª©ë¡ | í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ |"
      }
    ]
  },
  "05_í•´ì‹œ/hash-collision": {
    "id": "05_í•´ì‹œ/hash-collision",
    "title": "Hash Collision",
    "category": "algorithm",
    "subCategory": "05_í•´ì‹œ",
    "language": "Python",
    "description": "í•´ì‹œ ì¶©ëŒ í•´ê²° ë°©ë²•ê³¼ ì¢‹ì€ í•´ì‹œ í•¨ìˆ˜ì˜ ì¡°ê±´ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì¶©ëŒì´ë€?",
        "content": "## ë‹¤ë¥¸ í‚¤ â†’ ê°™ì€ í•´ì‹œê°’\n```\nhash(\"apple\") = 3\nhash(\"grape\") = 3  â† ì¶©ëŒ!\n```\n\n### í•´ê²° ë°©ë²•\n1. **ì²´ì´ë‹ (Chaining)**: ê°™ì€ ë²„í‚·ì— ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥\n2. **ê°œë°© ì£¼ì†Œë²• (Open Addressing)**: ë‹¤ë¥¸ ë¹ˆ ì¹¸ ì°¾ê¸°\n   - ì„ í˜• íƒì‚¬: ìˆœì„œëŒ€ë¡œ ì°¾ê¸°\n   - ì´ì°¨ íƒì‚¬: ì œê³±ìœ¼ë¡œ ì°¾ê¸°\n   - ì´ì¤‘ í•´ì‹±: ë‹¤ë¥¸ í•´ì‹œ í•¨ìˆ˜ë¡œ ì°¾ê¸°"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ì²´ì´ë‹ êµ¬í˜„\nclass HashTableChaining:\n    def __init__(self, size=10):\n        self.size = size\n        self.table = [[] for _ in range(size)]\n\n    def _hash(self, key):\n        return hash(key) % self.size\n\n    def put(self, key, value):\n        idx = self._hash(key)\n        for i, (k, v) in enumerate(self.table[idx]):\n            if k == key:\n                self.table[idx][i] = (key, value)\n                return\n        self.table[idx].append((key, value))\n\n    def get(self, key):\n        idx = self._hash(key)\n        for k, v in self.table[idx]:\n            if k == key:\n                return v\n        return None"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "í•´ì‹œ ì¶©ëŒ ìƒí™©ì„ ì´í•´í•˜ê³  ì ì ˆí•œ í…Œì´ë¸” í¬ê¸°ë¥¼ ì„ íƒí•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.\n- ì ì¬ìœ¨(Load Factor) = ìš”ì†Œ ìˆ˜ / í…Œì´ë¸” í¬ê¸°\n- ë³´í†µ 0.75 ì´í•˜ ìœ ì§€ ê¶Œì¥"
      }
    ]
  },
  "05_í•´ì‹œ/hash-concept": {
    "id": "05_í•´ì‹œ/hash-concept",
    "title": "Hash Concept",
    "category": "algorithm",
    "subCategory": "05_í•´ì‹œ",
    "language": "Python",
    "description": "í•´ì‹œ í•¨ìˆ˜ì™€ í•´ì‹œ í…Œì´ë¸”ì˜ ì›ë¦¬ë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ í•´ì‹œë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **í‚¤ë¥¼ ìˆ«ìë¡œ ë³€í™˜í•´ì„œ O(1)ì— ì ‘ê·¼** - ë”•ì…”ë„ˆë¦¬ì˜ ë¹„ë°€\n\n### ì™œ ë°°ì›Œì•¼ í•˜ë‚˜?\n- ì¡°íšŒ/ì‚½ì…/ì‚­ì œ ëª¨ë‘ **O(1)** í‰ê· \n- ì½”í…Œì—ì„œ O(nÂ²) â†’ O(n) ìµœì í™”ì˜ í•µì‹¬\n- ì‹¤ë¬´: ìºì‹œ, ì„¸ì…˜, ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ìŠ¤\n\n### í•´ì‹œ í•¨ìˆ˜\n```\ní•´ì‹œ í•¨ìˆ˜: í‚¤ â†’ ìˆ«ì (ì¸ë±ìŠ¤)\n\"apple\" â†’ 3\n\"banana\" â†’ 7\n```\n\n### ì‹œê°„ë³µì¡ë„\n| ì—°ì‚° | í‰ê·  | ìµœì•… |\n|-----|-----|-----|\n| ì‚½ì… | O(1) | O(n) |\n| ê²€ìƒ‰ | O(1) | O(n) |\n| ì‚­ì œ | O(1) | O(n) |"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# Python ë”•ì…”ë„ˆë¦¬ = í•´ì‹œ í…Œì´ë¸”\nhash_map = {}\n\n# ì‚½ì… O(1)\nhash_map[\"apple\"] = 100\nhash_map[\"banana\"] = 200\n\n# ì¡°íšŒ O(1)\nprint(hash_map[\"apple\"])  # 100\nprint(hash_map.get(\"grape\", 0))  # 0 (ê¸°ë³¸ê°’)\n\n# ì¡´ì¬ í™•ì¸ O(1)\nif \"apple\" in hash_map:\n    print(\"exists!\")\n\n# ì‚­ì œ O(1)\ndel hash_map[\"apple\"]\n\n# í™œìš©: ë¹ˆë„ìˆ˜ ì¹´ìš´íŒ…\nfrom collections import Counter\nnums = [1, 1, 2, 2, 2, 3]\ncount = Counter(nums)\nprint(count)  # {2: 3, 1: 2, 3: 1}\n\n# í™œìš©: Two Sum O(n)\ndef two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ | í¬ì¸íŠ¸ |\n|-----|-------|-------|\n| Two Sum | LeetCode | ê¸°ë³¸ í•´ì‹œ |\n| ì™„ì£¼í•˜ì§€ ëª»í•œ ì„ ìˆ˜ | í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ | Counter |\n| ìˆ«ìì˜ í‘œí˜„ (1152) | ë°±ì¤€ | í•´ì‹œ ì…‹ |"
      }
    ]
  },
  "05_í•´ì‹œ/hash-problem": {
    "id": "05_í•´ì‹œ/hash-problem",
    "title": "Hash Problem",
    "category": "algorithm",
    "subCategory": "05_í•´ì‹œ",
    "language": "Python",
    "description": "í•´ì‹œë¥¼ í™œìš©í•œ ë‹¤ì–‘í•œ ë¬¸ì œ íŒ¨í„´ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ¯ í•´ì‹œ ë¬¸ì œ íŒ¨í„´",
        "content": "## íŒ¨í„´ ì •ë¦¬\n\n1. **ë¹ˆë„ ì¹´ìš´íŒ…**: Counter í™œìš©\n2. **ì¡´ì¬ í™•ì¸**: Set í™œìš©\n3. **ë§¤í•‘**: Dict í™œìš©\n4. **ê·¸ë£¹í•‘**: defaultdict(list)\n5. **ìºì‹±**: ê³„ì‚° ê²°ê³¼ ì €ì¥"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "from collections import Counter, defaultdict\n\n# íŒ¨í„´ 1: ì•„ë‚˜ê·¸ë¨ ê·¸ë£¹\ndef group_anagrams(strs):\n    groups = defaultdict(list)\n    for s in strs:\n        key = tuple(sorted(s))\n        groups[key].append(s)\n    return list(groups.values())\n\n# íŒ¨í„´ 2: ì„œë¡œ ë‹¤ë¥¸ ë¬¸ì í™•ì¸\ndef first_unique_char(s):\n    count = Counter(s)\n    for i, char in enumerate(s):\n        if count[char] == 1:\n            return i\n    return -1\n\n# íŒ¨í„´ 3: ì—°ì† ë¶€ë¶„ ë°°ì—´ (í•©ì´ k)\ndef subarray_sum(nums, k):\n    count = 0\n    prefix_sum = 0\n    seen = {0: 1}\n    for num in nums:\n        prefix_sum += num\n        count += seen.get(prefix_sum - k, 0)\n        seen[prefix_sum] = seen.get(prefix_sum, 0) + 1\n    return count"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í”Œë«í¼ |\n|-----|-------|\n| Group Anagrams | LeetCode |\n| First Unique Character | LeetCode |\n| Subarray Sum Equals K | LeetCode |"
      }
    ]
  },
  "05_í•´ì‹œ/hashset-hashmap": {
    "id": "05_í•´ì‹œ/hashset-hashmap",
    "title": "Hashset Hashmap",
    "category": "algorithm",
    "subCategory": "05_í•´ì‹œ",
    "language": "Python",
    "description": "Setê³¼ Mapì˜ ì°¨ì´ì™€ í™œìš©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ Set vs Map",
        "content": "## ì°¨ì´ì \n\n| íŠ¹ì§• | Set (ì§‘í•©) | Map (ë”•ì…”ë„ˆë¦¬) |\n|-----|----------|--------------|\n| ì €ì¥ | ê°’ë§Œ | í‚¤-ê°’ ìŒ |\n| ìš©ë„ | ì¡´ì¬ ì—¬ë¶€ | ë§¤í•‘ ê´€ê³„ |\n| ì˜ˆì‹œ | ë°©ë¬¸ ì²´í¬ | ë¹ˆë„ ì¹´ìš´íŠ¸ |\n\n### ì–¸ì œ ë­˜ ì“¸ê¹Œ?\n- ìˆë‹¤/ì—†ë‹¤ í™•ì¸ â†’ Set\n- ê°’ì„ ì €ì¥í•˜ê³  ì¡°íšŒ â†’ Map"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# Set í™œìš©: ë°©ë¬¸ ì²´í¬\nvisited = set()\nvisited.add(node)\nif node in visited:\n    pass  # ì´ë¯¸ ë°©ë¬¸\n\n# Map í™œìš©: ë¹ˆë„ ì¹´ìš´íŠ¸\nfreq = {}\nfor char in \"hello\":\n    freq[char] = freq.get(char, 0) + 1\n# {'h': 1, 'e': 1, 'l': 2, 'o': 1}\n\n# Map í™œìš©: ì¸ë±ìŠ¤ ì €ì¥\nindices = {}\nfor i, val in enumerate(arr):\n    indices[val] = i"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ìœ„ì¥ | Map |\n| ë² ìŠ¤íŠ¸ì•¨ë²” | Map + ì •ë ¬ |"
      }
    ]
  },
  "05_í™/heap-concept": {
    "id": "05_í™/heap-concept",
    "title": "Heap Concept",
    "category": "algorithm",
    "subCategory": "05_í™",
    "language": "Python",
    "description": "ì™„ì „ ì´ì§„ íŠ¸ë¦¬ ê¸°ë°˜ì˜ í™ êµ¬ì¡°ë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ í™ì´ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì™„ì „ ì´ì§„ íŠ¸ë¦¬ + í™ ì†ì„±** - ìµœëŒ“ê°’/ìµœì†Ÿê°’ì„ O(log n)ì— ì¶”ì¶œ\n\n### í™ ì†ì„±\n- **ìµœì†Œ í™**: ë¶€ëª¨ â‰¤ ìì‹\n- **ìµœëŒ€ í™**: ë¶€ëª¨ â‰¥ ìì‹\n\n### ë°°ì—´ë¡œ í‘œí˜„\n```\në¶€ëª¨ ì¸ë±ìŠ¤: (i - 1) // 2\nì™¼ìª½ ìì‹: 2 * i + 1\nì˜¤ë¥¸ìª½ ìì‹: 2 * i + 2\n```\n\n### ì‹œê°„ë³µì¡ë„\n| ì—°ì‚° | ë³µì¡ë„ |\n|-----|-------|\n| ì‚½ì… | O(log n) |\n| ìµœì†Œ/ìµœëŒ€ ì¶”ì¶œ | O(log n) |\n| ìµœì†Œ/ìµœëŒ€ í™•ì¸ | O(1) |"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "import heapq\n\n# ìµœì†Œ í™\nmin_heap = []\nheapq.heappush(min_heap, 3)\nheapq.heappush(min_heap, 1)\nheapq.heappush(min_heap, 2)\nprint(heapq.heappop(min_heap))  # 1\n\n# ìµœëŒ€ í™ (ë¶€í˜¸ ë°˜ì „)\nmax_heap = []\nfor num in [3, 1, 2]:\n    heapq.heappush(max_heap, -num)\nprint(-heapq.heappop(max_heap))  # 3\n\n# ë¦¬ìŠ¤íŠ¸ë¥¼ í™ìœ¼ë¡œ\narr = [3, 1, 4, 1, 5]\nheapq.heapify(arr)  # O(n)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ìµœì†Œ í™ (1927) | ê¸°ë³¸ |\n| ìµœëŒ€ í™ (11279) | ë¶€í˜¸ ë°˜ì „ |"
      }
    ]
  },
  "05_í™/heap-operation": {
    "id": "05_í™/heap-operation",
    "title": "Heap Operation",
    "category": "algorithm",
    "subCategory": "05_í™",
    "language": "Python",
    "description": "í™ì˜ ì‚½ì…, ì‚­ì œ, heapify ì—°ì‚°ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ í™ ì—°ì‚°",
        "content": "## í•µì‹¬ ì—°ì‚°\n\n### 1. ì‚½ì… (push)\n1. ë§¨ ëì— ì¶”ê°€\n2. ìœ„ë¡œ ì˜¬ë¼ê°€ë©° êµí™˜ (heapify up)\n\n### 2. ì¶”ì¶œ (pop)\n1. ë£¨íŠ¸ ì œê±°, ë§¨ ë ìš”ì†Œë¥¼ ë£¨íŠ¸ë¡œ\n2. ì•„ë˜ë¡œ ë‚´ë ¤ê°€ë©° êµí™˜ (heapify down)\n\n### 3. heapify\n- ë°°ì—´ì„ í™ìœ¼ë¡œ ë§Œë“¤ê¸°\n- O(n) ì‹œê°„ë³µì¡ë„"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "import heapq\n\n# heappushì™€ heappop ì¡°í•©\nheap = []\nfor num in [5, 3, 8, 1, 2]:\n    heapq.heappush(heap, num)\n\nsorted_arr = []\nwhile heap:\n    sorted_arr.append(heapq.heappop(heap))\nprint(sorted_arr)  # [1, 2, 3, 5, 8]\n\n# heapreplace: pop í›„ push (ë” íš¨ìœ¨ì )\nheap = [1, 2, 3]\nheapq.heapreplace(heap, 4)  # 1 pop, 4 push\nprint(heap)  # [2, 4, 3]\n\n# nlargest, nsmallest\nnums = [3, 1, 4, 1, 5, 9, 2, 6]\nprint(heapq.nlargest(3, nums))   # [9, 6, 5]\nprint(heapq.nsmallest(3, nums))  # [1, 1, 2]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ì ˆëŒ“ê°’ í™ (11286) | ì»¤ìŠ¤í…€ ì •ë ¬ |\n| ê°€ìš´ë°ë¥¼ ë§í•´ìš” (1655) | ë‘ ê°œ í™ |"
      }
    ]
  },
  "05_í™/top-k": {
    "id": "05_í™/top-k",
    "title": "Top K",
    "category": "algorithm",
    "subCategory": "05_í™",
    "language": "Python",
    "description": "í™ì„ í™œìš©í•œ Kë²ˆì§¸ í°/ì‘ì€ ìˆ˜ ì°¾ê¸°ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ Top K íŒ¨í„´",
        "content": "## ì ‘ê·¼ë²•\n\n### ë°©ë²• 1: ì •ë ¬\n- O(n log n)\n- ê°„ë‹¨í•˜ì§€ë§Œ ë¹„íš¨ìœ¨\n\n### ë°©ë²• 2: í™ (í¬ê¸° K ìœ ì§€)\n- O(n log k)\n- Kê°€ ì‘ìœ¼ë©´ ë§¤ìš° íš¨ìœ¨ì \n\n### ë°©ë²• 3: Quick Select\n- O(n) í‰ê· \n- êµ¬í˜„ ë³µì¡"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "import heapq\nfrom collections import Counter\n\n# Kë²ˆì§¸ í° ìˆ˜\ndef kth_largest(nums, k):\n    heap = nums[:k]\n    heapq.heapify(heap)\n    for num in nums[k:]:\n        if num > heap[0]:\n            heapq.heapreplace(heap, num)\n    return heap[0]\n\n# Kë²ˆì§¸ ì‘ì€ ìˆ˜\ndef kth_smallest(nums, k):\n    heap = [-x for x in nums[:k]]\n    heapq.heapify(heap)\n    for num in nums[k:]:\n        if num < -heap[0]:\n            heapq.heapreplace(heap, -num)\n    return -heap[0]\n\n# Top K ë¹ˆë„ìˆ˜\ndef top_k_frequent(nums, k):\n    count = Counter(nums)\n    return heapq.nlargest(k, count.keys(), key=count.get)\n\nprint(top_k_frequent([1,1,1,2,2,3], 2))  # [1, 2]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Kth Largest Element | LeetCode |\n| Top K Frequent Elements | LeetCode |\n| K Closest Points to Origin | LeetCode |"
      }
    ]
  },
  "06_ì •ë ¬/merge-sort": {
    "id": "06_ì •ë ¬/merge-sort",
    "title": "Merge Sort",
    "category": "algorithm",
    "subCategory": "06_ì •ë ¬",
    "language": "Python",
    "description": "ë¶„í•  ì •ë³µ ê¸°ë°˜ì˜ O(n log n) ì•ˆì • ì •ë ¬ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ë³‘í•© ì •ë ¬",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ê³ , ì •ë ¬í•˜ë©° í•©ì¹œë‹¤** - ë¶„í•  ì •ë³µì˜ ëŒ€í‘œ\n\n### íŠ¹ì§•\n- ì‹œê°„: O(n log n) **í•­ìƒ**\n- ê³µê°„: O(n) ì¶”ê°€ í•„ìš”\n- ì•ˆì • ì •ë ¬\n\n### ê³¼ì •\n```\n[38, 27, 43, 3, 9, 82, 10]\n       â†“ ë¶„í• \n[38, 27, 43] [3, 9, 82, 10]\n       â†“ ë¶„í• \n[38] [27, 43] [3, 9] [82, 10]\n       â†“ ë³‘í•©\n[27, 38, 43] [3, 9, 10, 82]\n       â†“ ë³‘í•©\n[3, 9, 10, 27, 38, 43, 82]\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n\nprint(merge_sort([38, 27, 43, 3, 9, 82, 10]))"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ìˆ˜ ì •ë ¬í•˜ê¸° 2 (2751) | O(n log n) í•„ìš” |\n| ë²„ë¸” ì†ŒíŠ¸ (1517) | ì—­ì „ ê°œìˆ˜ (merge sort ì‘ìš©) |"
      }
    ]
  },
  "06_ì •ë ¬/practice-sort": {
    "id": "06_ì •ë ¬/practice-sort",
    "title": "Practice Sort",
    "category": "algorithm",
    "subCategory": "06_ì •ë ¬",
    "language": "Python",
    "description": "ì •ë ¬ì„ í™œìš©í•œ ì‹¤ì „ ë¬¸ì œ íŒ¨í„´ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ¯ ì •ë ¬ íŒ¨í„´",
        "content": "## ì •ë ¬ í™œìš© íŒ¨í„´\n\n1. **ì •ë ¬ í›„ íƒìƒ‰**: ì´ì§„ íƒìƒ‰ ê°€ëŠ¥\n2. **ì •ë ¬ í›„ íˆ¬ í¬ì¸í„°**: ì–‘ëì—ì„œ íƒìƒ‰\n3. **ì»¤ìŠ¤í…€ ì •ë ¬**: key í•¨ìˆ˜ í™œìš©\n4. **êµ¬ê°„ ì •ë ¬**: ì‹œì‘/ë ê¸°ì¤€\n5. **ìœ„ìƒ ì •ë ¬**: ì„ í›„ ê´€ê³„"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# êµ¬ê°„ í•©ì¹˜ê¸°\ndef merge_intervals(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        if start <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], end)\n        else:\n            merged.append([start, end])\n    return merged\n\n# ê°€ì¥ í° ìˆ˜ ë§Œë“¤ê¸°\ndef largest_number(nums):\n    from functools import cmp_to_key\n    def compare(x, y):\n        if x + y > y + x:\n            return -1\n        elif x + y < y + x:\n            return 1\n        return 0\n\n    nums = list(map(str, nums))\n    nums.sort(key=cmp_to_key(compare))\n    return str(int(''.join(nums)))\n\nprint(largest_number([3, 30, 34, 5, 9]))  # \"9534330\" "
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Merge Intervals | LeetCode |\n| ê°€ì¥ í° ìˆ˜ | í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ |\n| H-Index | í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ |"
      }
    ]
  },
  "06_ì •ë ¬/quick-sort": {
    "id": "06_ì •ë ¬/quick-sort",
    "title": "Quick Sort",
    "category": "algorithm",
    "subCategory": "06_ì •ë ¬",
    "language": "Python",
    "description": "í”¼ë²— ê¸°ë°˜ì˜ ë¶„í•  ì •ë³µ ì •ë ¬ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ í€µ ì •ë ¬",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **í”¼ë²— ê¸°ì¤€ìœ¼ë¡œ ì‘ì€ ê²ƒ/í° ê²ƒ ë¶„ë¦¬** - í‰ê·  O(n log n), ìµœì•… O(nÂ²)\n\n### íŠ¹ì§•\n- í‰ê· : O(n log n)\n- ìµœì•…: O(nÂ²) (ì´ë¯¸ ì •ë ¬ëœ ê²½ìš°)\n- ë¶ˆì•ˆì • ì •ë ¬\n- ì‹¤ì „ì—ì„œ ê°€ì¥ ë¹ ë¦„ (ìºì‹œ íš¨ìœ¨)"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n\n    return quick_sort(left) + middle + quick_sort(right)\n\n# in-place ë²„ì „\ndef quick_sort_inplace(arr, low, high):\n    if low < high:\n        pi = partition(arr, low, high)\n        quick_sort_inplace(arr, low, pi - 1)\n        quick_sort_inplace(arr, pi + 1, high)\n\ndef partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] < pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Kë²ˆì§¸ ìˆ˜ (11004) | Quick Select |\n| ì†ŒíŠ¸ì¸ì‚¬ì´ë“œ (1427) | ë‚´ë¦¼ì°¨ìˆœ |"
      }
    ]
  },
  "06_ì •ë ¬/sort-compare": {
    "id": "06_ì •ë ¬/sort-compare",
    "title": "Sort Compare",
    "category": "algorithm",
    "subCategory": "06_ì •ë ¬",
    "language": "Python",
    "description": "ë‹¤ì–‘í•œ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì˜ íŠ¹ì§•ì„ ë¹„êµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì •ë ¬ ë¹„êµ",
        "content": "## ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ë¹„êµ\n\n| ì •ë ¬ | í‰ê·  | ìµœì•… | ê³µê°„ | ì•ˆì • |\n|-----|-----|-----|-----|-----|\n| ë²„ë¸” | O(nÂ²) | O(nÂ²) | O(1) | âœ… |\n| ì„ íƒ | O(nÂ²) | O(nÂ²) | O(1) | âŒ |\n| ì‚½ì… | O(nÂ²) | O(nÂ²) | O(1) | âœ… |\n| ë³‘í•© | O(n log n) | O(n log n) | O(n) | âœ… |\n| í€µ | O(n log n) | O(nÂ²) | O(log n) | âŒ |\n| í™ | O(n log n) | O(n log n) | O(1) | âŒ |\n| ê³„ìˆ˜ | O(n+k) | O(n+k) | O(k) | âœ… |\n\n### ì„ íƒ ê°€ì´ë“œ\n- ê±°ì˜ ì •ë ¬ë¨: **ì‚½ì… ì •ë ¬**\n- ì•ˆì • í•„ìš”: **ë³‘í•© ì •ë ¬**\n- ë©”ëª¨ë¦¬ ì œí•œ: **í™ ì •ë ¬**\n- ì¼ë°˜ì : **í€µ ì •ë ¬** or Python ë‚´ì¥"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# Python ë‚´ì¥ ì •ë ¬ ì‚¬ìš©ì´ ëŒ€ë¶€ë¶„ ìµœì„ !\narr.sort()  # Timsort: ì•ˆì •, O(n log n)\n\n# íŠ¹ìˆ˜í•œ ê²½ìš°ë§Œ ì§ì ‘ êµ¬í˜„\n# 1. ì—­ì „ ê°œìˆ˜ ì„¸ê¸° â†’ merge sort ë³€í˜•\n# 2. Kë²ˆì§¸ ìˆ˜ ì°¾ê¸° â†’ quick select\n# 3. ë²”ìœ„ ì œí•œ â†’ counting sort"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ì„ íƒ í€´ì¦ˆ:\n- N=10ë§Œ, ë©”ëª¨ë¦¬ ì œí•œ â†’ í™ ì •ë ¬\n- ê±°ì˜ ì •ë ¬ëœ ë°ì´í„° â†’ ì‚½ì… ì •ë ¬\n- ì¼ë°˜ì ì¸ ê²½ìš° â†’ Python sort()"
      }
    ]
  },
  "06_ì •ë ¬/sort-intro": {
    "id": "06_ì •ë ¬/sort-intro",
    "title": "Sort Intro",
    "category": "algorithm",
    "subCategory": "06_ì •ë ¬",
    "language": "Python",
    "description": "ì •ë ¬ì˜ ê¸°ë³¸ ê°œë…ê³¼ Python ì •ë ¬ í•¨ìˆ˜ë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì •ë ¬ì´ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ë°ì´í„°ë¥¼ íŠ¹ì • ìˆœì„œë¡œ ë°°ì¹˜** - íƒìƒ‰, ì¤‘ë³µ ì œê±°, ë¹„êµì˜ ê¸°ì´ˆ\n\n### Python ì •ë ¬\n- `sort()`: ì›ë³¸ ìˆ˜ì •, ë°˜í™˜ None\n- `sorted()`: ìƒˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜\n\n### ì‹œê°„ë³µì¡ë„\n- Python ì •ë ¬: **O(n log n)** (Timsort)\n- ì•ˆì • ì •ë ¬ (ê°™ì€ ê°’ì˜ ìˆœì„œ ìœ ì§€)"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ê¸°ë³¸ ì •ë ¬\narr = [3, 1, 4, 1, 5]\narr.sort()              # ì˜¤ë¦„ì°¨ìˆœ, ì›ë³¸ ìˆ˜ì •\nsorted_arr = sorted(arr)  # ìƒˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜\n\n# ë‚´ë¦¼ì°¨ìˆœ\narr.sort(reverse=True)\n\n# key í•¨ìˆ˜\nwords = [\"banana\", \"apple\", \"cherry\"]\nwords.sort(key=len)  # ê¸¸ì´ìˆœ\n\n# íŠœí”Œ ì •ë ¬ (ë‹¤ì¤‘ ì¡°ê±´)\ndata = [(1, 'b'), (2, 'a'), (1, 'a')]\ndata.sort(key=lambda x: (x[0], x[1]))\n# [(1, 'a'), (1, 'b'), (2, 'a')]\n\n# ë‚´ë¦¼ì°¨ìˆœ + ì˜¤ë¦„ì°¨ìˆœ í˜¼í•©\ndata.sort(key=lambda x: (-x[0], x[1]))\n\n# ë”•ì…”ë„ˆë¦¬ ì •ë ¬\nd = {'b': 2, 'a': 3, 'c': 1}\nsorted(d.items(), key=lambda x: x[1])  # ê°’ ê¸°ì¤€"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ìˆ˜ ì •ë ¬í•˜ê¸° (2750) | ê¸°ë³¸ |\n| ì¢Œí‘œ ì •ë ¬í•˜ê¸° (11650) | íŠœí”Œ |\n| ë‹¨ì–´ ì •ë ¬ (1181) | ë‹¤ì¤‘ ì¡°ê±´ |"
      }
    ]
  },
  "06_íŠ¸ë¦¬/balanced-tree": {
    "id": "06_íŠ¸ë¦¬/balanced-tree",
    "title": "Balanced Tree",
    "category": "algorithm",
    "subCategory": "06_íŠ¸ë¦¬",
    "language": "Python",
    "description": "AVL íŠ¸ë¦¬, ë ˆë“œ-ë¸”ë™ íŠ¸ë¦¬ ë“± ê· í˜• ìœ ì§€ ì›ë¦¬ë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ê· í˜• íŠ¸ë¦¬",
        "content": "## ì™œ ê· í˜•ì´ í•„ìš”í•œê°€?\n\n### ë¶ˆê· í˜• BSTì˜ ë¬¸ì œ\n```\n1 â†’ 2 â†’ 3 â†’ 4 â†’ 5  (í¸í–¥ íŠ¸ë¦¬)\níƒìƒ‰: O(n) â† ë°°ì—´ê³¼ ê°™ìŒ!\n```\n\n### ê· í˜• ìœ ì§€ ì‹œ\n```\n    3\n   / \\\n  2   4\n /     \\\n1       5\n\níƒìƒ‰: O(log n)\n```\n\n### ê· í˜• íŠ¸ë¦¬ ì¢…ë¥˜\n- **AVL íŠ¸ë¦¬**: ë†’ì´ ì°¨ì´ â‰¤ 1\n- **ë ˆë“œ-ë¸”ë™ íŠ¸ë¦¬**: ìƒ‰ìƒ ê·œì¹™\n- **B-íŠ¸ë¦¬**: DB ì¸ë±ìŠ¤ (ë””ìŠ¤í¬ ìµœì í™”)"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ê· í˜• í™•ì¸\ndef is_balanced(root):\n    def check(node):\n        if not node:\n            return 0\n\n        left = check(node.left)\n        if left == -1:\n            return -1\n\n        right = check(node.right)\n        if right == -1:\n            return -1\n\n        if abs(left - right) > 1:\n            return -1\n\n        return max(left, right) + 1\n\n    return check(root) != -1\n\n# Pythonì—ì„œëŠ” ë³´í†µ ë‚´ì¥ ìë£Œêµ¬ì¡° ì‚¬ìš©\n# - dict: í•´ì‹œ ê¸°ë°˜\n# - sortedcontainers.SortedList: ê· í˜• íŠ¸ë¦¬ ê¸°ë°˜"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Balanced Binary Tree | LeetCode |\n| Convert Sorted Array to BST | LeetCode |"
      }
    ]
  },
  "06_íŠ¸ë¦¬/tree-concept": {
    "id": "06_íŠ¸ë¦¬/tree-concept",
    "title": "Tree Concept",
    "category": "algorithm",
    "subCategory": "06_íŠ¸ë¦¬",
    "language": "Python",
    "description": "íŠ¸ë¦¬ì˜ ê¸°ë³¸ ê°œë…ê³¼ ìš©ì–´ë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ íŠ¸ë¦¬ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ê³„ì¸µì  ìë£Œêµ¬ì¡°** - ë¶€ëª¨-ìì‹ ê´€ê³„, ì‚¬ì´í´ ì—†ìŒ\n\n### íŠ¸ë¦¬ ìš©ì–´\n- **ë£¨íŠ¸ (Root)**: ìµœìƒìœ„ ë…¸ë“œ\n- **ë¦¬í”„ (Leaf)**: ìì‹ ì—†ëŠ” ë…¸ë“œ\n- **ê¹Šì´ (Depth)**: ë£¨íŠ¸ë¶€í„° ê±°ë¦¬\n- **ë†’ì´ (Height)**: ë¦¬í”„ê¹Œì§€ ê±°ë¦¬\n- **ì°¨ìˆ˜ (Degree)**: ìì‹ ìˆ˜\n\n### ì´ì§„ íŠ¸ë¦¬ ì¢…ë¥˜\n- **ì™„ì „ ì´ì§„ íŠ¸ë¦¬**: ì™¼ìª½ë¶€í„° ì±„ì›€\n- **í¬í™” ì´ì§„ íŠ¸ë¦¬**: ëª¨ë“  ë ˆë²¨ ê½‰ ì°¸\n- **ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬**: ì™¼ìª½ < ë¶€ëª¨ < ì˜¤ë¥¸ìª½"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# íŠ¸ë¦¬ ë†’ì´\ndef height(node):\n    if not node:\n        return 0\n    return 1 + max(height(node.left), height(node.right))\n\n# ë…¸ë“œ ê°œìˆ˜\ndef count_nodes(node):\n    if not node:\n        return 0\n    return 1 + count_nodes(node.left) + count_nodes(node.right)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Maximum Depth of Binary Tree | LeetCode |\n| Count Complete Tree Nodes | LeetCode |"
      }
    ]
  },
  "06_íŠ¸ë¦¬/tree-traversal": {
    "id": "06_íŠ¸ë¦¬/tree-traversal",
    "title": "Tree Traversal",
    "category": "algorithm",
    "subCategory": "06_íŠ¸ë¦¬",
    "language": "Python",
    "description": "ì „ìœ„, ì¤‘ìœ„, í›„ìœ„, ë ˆë²¨ ìˆœíšŒë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ìˆœíšŒ ë°©ë²•",
        "content": "## ìˆœíšŒ ì¢…ë¥˜\n\n### DFS (ê¹Šì´ ìš°ì„ )\n- **ì „ìœ„ (Preorder)**: ë£¨íŠ¸ â†’ ì™¼ìª½ â†’ ì˜¤ë¥¸ìª½\n- **ì¤‘ìœ„ (Inorder)**: ì™¼ìª½ â†’ ë£¨íŠ¸ â†’ ì˜¤ë¥¸ìª½\n- **í›„ìœ„ (Postorder)**: ì™¼ìª½ â†’ ì˜¤ë¥¸ìª½ â†’ ë£¨íŠ¸\n\n### BFS (ë„ˆë¹„ ìš°ì„ )\n- **ë ˆë²¨ ìˆœíšŒ**: ì¸µë³„ë¡œ ì™¼â†’ì˜¤\n\n### ì–¸ì œ ì–´ë–¤ ìˆœíšŒ?\n- ë³µì‚¬: ì „ìœ„\n- BST ì •ë ¬ëœ ê²°ê³¼: ì¤‘ìœ„\n- ì‚­ì œ: í›„ìœ„\n- ìµœë‹¨ ê²½ë¡œ: ë ˆë²¨"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "from collections import deque\n\n# ì „ìœ„ ìˆœíšŒ (ì¬ê·€)\ndef preorder(node):\n    if not node:\n        return []\n    return [node.val] + preorder(node.left) + preorder(node.right)\n\n# ì¤‘ìœ„ ìˆœíšŒ (ì¬ê·€)\ndef inorder(node):\n    if not node:\n        return []\n    return inorder(node.left) + [node.val] + inorder(node.right)\n\n# í›„ìœ„ ìˆœíšŒ (ì¬ê·€)\ndef postorder(node):\n    if not node:\n        return []\n    return postorder(node.left) + postorder(node.right) + [node.val]\n\n# ë ˆë²¨ ìˆœíšŒ (BFS)\ndef level_order(root):\n    if not root:\n        return []\n    result = []\n    queue = deque([root])\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level)\n    return result"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Binary Tree Inorder Traversal | LeetCode |\n| Binary Tree Level Order Traversal | LeetCode |\n| íŠ¸ë¦¬ ìˆœíšŒ (1991) | ë°±ì¤€ |"
      }
    ]
  },
  "07_ì •ë ¬/bubble-sort": {
    "id": "07_ì •ë ¬/bubble-sort",
    "title": "Bubble Sort",
    "category": "algorithm",
    "subCategory": "07_ì •ë ¬",
    "language": "Python",
    "description": "ì¸ì ‘ ìš”ì†Œë¥¼ ë¹„êµí•˜ë©° ì •ë ¬í•˜ëŠ” O(nÂ²) ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ë²„ë¸” ì •ë ¬",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì¸ì ‘í•œ ë‘ ìš”ì†Œë¥¼ ë¹„êµí•´ì„œ êµí™˜** - ê±°í’ˆì²˜ëŸ¼ í° ê°’ì´ ìœ„ë¡œ\n\n### íŠ¹ì§•\n- ì‹œê°„: O(nÂ²)\n- ê³µê°„: O(1)\n- ì•ˆì • ì •ë ¬\n- ì‹¤ì „ì—ì„œ ê±°ì˜ ì•ˆ ì”€ (êµìœ¡ìš©)"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(n - 1 - i):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:  # ìµœì í™”: êµí™˜ ì—†ìœ¼ë©´ ì¢…ë£Œ\n            break\n    return arr"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "ë²„ë¸” ì •ë ¬ì€ ê°œë… ì´í•´ìš©. ì‹¤ì „ì—ì„œëŠ” Python sort() ì‚¬ìš©!"
      }
    ]
  },
  "07_ì •ë ¬/counting-sort": {
    "id": "07_ì •ë ¬/counting-sort",
    "title": "Counting Sort",
    "category": "algorithm",
    "subCategory": "07_ì •ë ¬",
    "language": "Python",
    "description": "ë²”ìœ„ê°€ ì œí•œëœ ì •ìˆ˜ë¥¼ O(n+k)ì— ì •ë ¬í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ê³„ìˆ˜ ì •ë ¬",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ê°’ì˜ ê°œìˆ˜ë¥¼ ì„¸ì„œ ì •ë ¬** - ë¹„êµ ì—†ì´ O(n+k)\n\n### íŠ¹ì§•\n- ì‹œê°„: O(n + k)\n- ê³µê°„: O(k)\n- ì•ˆì • ì •ë ¬ ê°€ëŠ¥\n- ì •ìˆ˜, ë²”ìœ„ ì œí•œ í•„ìš”"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def counting_sort(arr):\n    if not arr:\n        return arr\n\n    min_val, max_val = min(arr), max(arr)\n    count = [0] * (max_val - min_val + 1)\n\n    for num in arr:\n        count[num - min_val] += 1\n\n    result = []\n    for i, c in enumerate(count):\n        result.extend([i + min_val] * c)\n\n    return result\n\n# ë²”ìœ„ê°€ ì‘ì„ ë•Œ ë§¤ìš° íš¨ìœ¨ì \n# ì˜ˆ: ì„±ì  (0-100), ë‚˜ì´ (0-150)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "ê³„ìˆ˜ ì •ë ¬ì€ ë²”ìœ„ê°€ ì œí•œëœ ì •ìˆ˜ ì •ë ¬ì— ìµœì .\nì˜ˆ: ìˆ˜ ì •ë ¬í•˜ê¸° 3 (10989)"
      }
    ]
  },
  "07_ì •ë ¬/heap-sort": {
    "id": "07_ì •ë ¬/heap-sort",
    "title": "Heap Sort",
    "category": "algorithm",
    "subCategory": "07_ì •ë ¬",
    "language": "Python",
    "description": "í™ì„ ì´ìš©í•œ O(n log n) in-place ì •ë ¬ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ í™ ì •ë ¬",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ìµœëŒ€ í™ì—ì„œ í•˜ë‚˜ì”© ì¶”ì¶œ** - O(n log n), O(1) ê³µê°„\n\n### íŠ¹ì§•\n- ì‹œê°„: O(n log n) í•­ìƒ\n- ê³µê°„: O(1)\n- ë¶ˆì•ˆì • ì •ë ¬\n- ë©”ëª¨ë¦¬ ì œí•œ ì‹œ ìœ ìš©"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def heap_sort(arr):\n    def heapify(arr, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    n = len(arr)\n\n    # Build max heap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # Extract elements\n    for i in range(n - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heapify(arr, i, 0)\n\n    return arr"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ìˆ˜ ì •ë ¬í•˜ê¸° 2 (2751) | ì§ì ‘ êµ¬í˜„ |"
      }
    ]
  },
  "07_ì •ë ¬/insertion-sort": {
    "id": "07_ì •ë ¬/insertion-sort",
    "title": "Insertion Sort",
    "category": "algorithm",
    "subCategory": "07_ì •ë ¬",
    "language": "Python",
    "description": "ì •ë ¬ëœ ë¶€ë¶„ì— ìƒˆ ìš”ì†Œë¥¼ ì‚½ì…í•˜ëŠ” O(nÂ²) ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì‚½ì… ì •ë ¬",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì¹´ë“œ ì •ë ¬í•˜ë“¯ ì•Œë§ì€ ìœ„ì¹˜ì— ì‚½ì…** - ê±°ì˜ ì •ë ¬ëœ ë°ì´í„°ì— íš¨ìœ¨ì \n\n### íŠ¹ì§•\n- ì‹œê°„: O(nÂ²), ê±°ì˜ ì •ë ¬ëœ ê²½ìš° O(n)\n- ê³µê°„: O(1)\n- ì•ˆì • ì •ë ¬\n- ì‘ì€ ë°ì´í„°ì— íš¨ìœ¨ì "
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\n# ê±°ì˜ ì •ë ¬ëœ ë°ì´í„°ì—ì„œ O(n)ì— ê°€ê¹Œìš´ ì„±ëŠ¥"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "ì‚½ì… ì •ë ¬ì€ ì‘ì€ ë°ì´í„°ë‚˜ ê±°ì˜ ì •ë ¬ëœ ë°ì´í„°ì— ì¢‹ìŒ.\nTimsortë„ ë¶€ë¶„ì ìœ¼ë¡œ ì‚½ì… ì •ë ¬ ì‚¬ìš©."
      }
    ]
  },
  "07_ì •ë ¬/radix-sort": {
    "id": "07_ì •ë ¬/radix-sort",
    "title": "Radix Sort",
    "category": "algorithm",
    "subCategory": "07_ì •ë ¬",
    "language": "Python",
    "description": "ìë¦¿ìˆ˜ë³„ë¡œ ì •ë ¬í•˜ëŠ” O(dÃ—n) ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ê¸°ìˆ˜ ì •ë ¬",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ìë¦¿ìˆ˜ë³„ë¡œ ì•ˆì • ì •ë ¬** - O(d Ã— n)\n\n### íŠ¹ì§•\n- ì‹œê°„: O(d Ã— n)\n- ê³µê°„: O(n + k)\n- ì•ˆì • ì •ë ¬\n- ìë¦¿ìˆ˜ê°€ ì ì„ ë•Œ íš¨ìœ¨ì "
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def radix_sort(arr):\n    if not arr:\n        return arr\n\n    max_val = max(arr)\n    exp = 1\n\n    while max_val // exp > 0:\n        counting_sort_by_digit(arr, exp)\n        exp *= 10\n\n    return arr\n\ndef counting_sort_by_digit(arr, exp):\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10\n\n    for num in arr:\n        digit = (num // exp) % 10\n        count[digit] += 1\n\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n\n    for i in range(n - 1, -1, -1):\n        digit = (arr[i] // exp) % 10\n        output[count[digit] - 1] = arr[i]\n        count[digit] -= 1\n\n    for i in range(n):\n        arr[i] = output[i]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "ê¸°ìˆ˜ ì •ë ¬ì€ ìë¦¿ìˆ˜ê°€ ì ê³  ìˆ˜ê°€ ë§ì„ ë•Œ ìœ ë¦¬.\nì˜ˆ: ì „í™”ë²ˆí˜¸ ì •ë ¬"
      }
    ]
  },
  "07_ì •ë ¬/selection-sort": {
    "id": "07_ì •ë ¬/selection-sort",
    "title": "Selection Sort",
    "category": "algorithm",
    "subCategory": "07_ì •ë ¬",
    "language": "Python",
    "description": "ìµœì†Ÿê°’ì„ ì°¾ì•„ ì•ìœ¼ë¡œ ë³´ë‚´ëŠ” O(nÂ²) ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì„ íƒ ì •ë ¬",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ìµœì†Ÿê°’ì„ ì°¾ì•„ì„œ ë§¨ ì•ìœ¼ë¡œ** - êµí™˜ íšŸìˆ˜ ìµœì†Œ\n\n### íŠ¹ì§•\n- ì‹œê°„: O(nÂ²)\n- ê³µê°„: O(1)\n- ë¶ˆì•ˆì • ì •ë ¬\n- êµí™˜ íšŸìˆ˜ O(n)ìœ¼ë¡œ ì ìŒ"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "ì„ íƒ ì •ë ¬ë„ ê°œë… ì´í•´ìš©. êµí™˜ ë¹„ìš©ì´ í´ ë•Œ ê³ ë ¤í•  ìˆ˜ ìˆìŒ."
      }
    ]
  },
  "07_íƒìƒ‰/binary-search": {
    "id": "07_íƒìƒ‰/binary-search",
    "title": "Binary Search",
    "category": "algorithm",
    "subCategory": "07_íƒìƒ‰",
    "language": "Python",
    "description": "ì •ë ¬ëœ ë°°ì—´ì—ì„œ O(log n)ì— ì›ì†Œë¥¼ ì°¾ìŠµë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì´ì§„ íƒìƒ‰",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì ˆë°˜ì”© ë²„ë¦¬ë©° ì°¾ê¸°** - O(n) â†’ O(log n)\n\n### ì „ì œ ì¡°ê±´\n- ë°ì´í„°ê°€ **ì •ë ¬**ë˜ì–´ ìˆì–´ì•¼ í•¨\n\n### ì‹œê°„ë³µì¡ë„\n- O(log n)\n- 10ì–µ ê°œ ë°ì´í„°ë„ 30ë²ˆì´ë©´ ì°¾ìŒ"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\n# bisect ëª¨ë“ˆ í™œìš©\nfrom bisect import bisect_left, bisect_right\n\narr = [1, 2, 3, 3, 3, 4, 5]\nprint(bisect_left(arr, 3))   # 2 (3ì´ ë“¤ì–´ê°ˆ ê°€ì¥ ì™¼ìª½)\nprint(bisect_right(arr, 3))  # 5 (3ì´ ë“¤ì–´ê°ˆ ê°€ì¥ ì˜¤ë¥¸ìª½)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ìˆ˜ ì°¾ê¸° (1920) | ê¸°ë³¸ |\n| ìˆ«ì ì¹´ë“œ 2 (10816) | bisect |\n| Binary Search | LeetCode |"
      }
    ]
  },
  "07_íƒìƒ‰/parametric-search": {
    "id": "07_íƒìƒ‰/parametric-search",
    "title": "Parametric Search",
    "category": "algorithm",
    "subCategory": "07_íƒìƒ‰",
    "language": "Python",
    "description": "ìµœì í™” ë¬¸ì œë¥¼ ê²°ì • ë¬¸ì œë¡œ ë°”ê¿” ì´ì§„ íƒìƒ‰í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ íŒŒë¼ë©”íŠ¸ë¦­ ì„œì¹˜",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **\"ìµœì†Ÿê°’ì˜ ìµœëŒ“ê°’\" ê°™ì€ ìµœì í™” ë¬¸ì œë¥¼ ì´ì§„ íƒìƒ‰ìœ¼ë¡œ í’€ê¸°**\n\n### íŒ¨í„´\n1. \"Xê°€ ê°€ëŠ¥í•œê°€?\" ê²°ì • í•¨ìˆ˜ ë§Œë“¤ê¸°\n2. ê°€ëŠ¥í•œ Xì˜ ë²”ìœ„ì—ì„œ ì´ì§„ íƒìƒ‰\n3. ì¡°ê±´ ë§Œì¡±í•˜ëŠ” ìµœëŒ€/ìµœì†Œ X ì°¾ê¸°\n\n### í‚¤ì›Œë“œ\n- \"ìµœì†Ÿê°’ì˜ ìµœëŒ“ê°’\"\n- \"ìµœëŒ“ê°’ì˜ ìµœì†Ÿê°’\"\n- \"Mê°œ ì´í•˜ë¡œ ë‚˜ëˆ„ê¸°\" "
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ì˜ˆ: ëœì„  ìë¥´ê¸° - Nê°œì˜ ëœì„ ì„ Kê°œ ì´ìƒ ë§Œë“¤ ë•Œ ìµœëŒ€ ê¸¸ì´\ndef max_length(cables, k):\n    def can_make(length):\n        if length == 0:\n            return True\n        return sum(c // length for c in cables) >= k\n\n    left, right = 1, max(cables)\n    answer = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_make(mid):\n            answer = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return answer\n\n# ì˜ˆ: ê³µìœ ê¸° ì„¤ì¹˜ - Nê°œ ì§‘ì— Cê°œ ê³µìœ ê¸°, ìµœì†Œ ê±°ë¦¬ì˜ ìµœëŒ€\ndef max_distance(houses, c):\n    houses.sort()\n\n    def can_install(dist):\n        count = 1\n        last = houses[0]\n        for house in houses[1:]:\n            if house - last >= dist:\n                count += 1\n                last = house\n        return count >= c\n\n    left, right = 1, houses[-1] - houses[0]\n    answer = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_install(mid):\n            answer = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return answer"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ëœì„  ìë¥´ê¸° (1654) | ìµœëŒ€ ê¸¸ì´ |\n| ë‚˜ë¬´ ìë¥´ê¸° (2805) | ë†’ì´ |\n| ê³µìœ ê¸° ì„¤ì¹˜ (2110) | ìµœì†Œ ê±°ë¦¬ì˜ ìµœëŒ€ |\n| ì…êµ­ì‹¬ì‚¬ | í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ |"
      }
    ]
  },
  "07_íƒìƒ‰/practice-search": {
    "id": "07_íƒìƒ‰/practice-search",
    "title": "Practice Search",
    "category": "algorithm",
    "subCategory": "07_íƒìƒ‰",
    "language": "Python",
    "description": "ì´ì§„ íƒìƒ‰ í™œìš© ì‹¤ì „ ë¬¸ì œ íŒ¨í„´ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ¯ íƒìƒ‰ íŒ¨í„´",
        "content": "## ì´ì§„ íƒìƒ‰ ë¬¸ì œ ì¸ì‹\n\n### í‚¤ì›Œë“œ\n- \"ì •ë ¬ëœ ë°°ì—´ì—ì„œ...\"\n- \"ìµœì†Ÿê°’ì˜ ìµœëŒ“ê°’\"\n- \"ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìµœëŒ€/ìµœì†Œ\"\n- \"~ì•ˆì— ê°€ëŠ¥í•œê°€?\"\n\n### ì£¼ì˜ì‚¬í•­\n- left, right ì´ˆê¸°ê°’ ë²”ìœ„\n- mid ê³„ì‚° ì‹œ ì˜¤ë²„í”Œë¡œìš°\n- ì¢…ë£Œ ì¡°ê±´ left <= right vs left < right"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# Lower Bound: target ì´ìƒì¸ ì²« ìœ„ì¹˜\ndef lower_bound(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Upper Bound: target ì´ˆê³¼ì¸ ì²« ìœ„ì¹˜\ndef upper_bound(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# ê°œìˆ˜ ì„¸ê¸°\ndef count_occurrences(arr, target):\n    return upper_bound(arr, target) - lower_bound(arr, target)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ìˆ«ì ì¹´ë“œ 2 (10816) | ê°œìˆ˜ ì„¸ê¸° |\n| Kë²ˆì§¸ ìˆ˜ (1300) | ì´ì§„ íƒìƒ‰ ì‹¬í™” |"
      }
    ]
  },
  "08_íƒìƒ‰/binary-search-variant": {
    "id": "08_íƒìƒ‰/binary-search-variant",
    "title": "Binary Search Variant",
    "category": "algorithm",
    "subCategory": "08_íƒìƒ‰",
    "language": "Python",
    "description": "Lower Bound, Upper Bound ë“± ì´ì§„ íƒìƒ‰ ë³€í˜•ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì´ì§„ íƒìƒ‰ ë³€í˜•",
        "content": "## ë³€í˜• ì¢…ë¥˜\n\n### Lower Bound\n- target **ì´ìƒ**ì¸ ì²« ìœ„ì¹˜\n- `bisect_left`\n\n### Upper Bound\n- target **ì´ˆê³¼**ì¸ ì²« ìœ„ì¹˜\n- `bisect_right`\n\n### í™œìš©\n- ë²”ìœ„ ë‚´ ê°œìˆ˜ = upper - lower\n- ì‚½ì… ìœ„ì¹˜ ì°¾ê¸°"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "from bisect import bisect_left, bisect_right\n\narr = [1, 2, 2, 2, 3, 4]\n\n# Lower Bound: 2 ì´ìƒì¸ ì²« ìœ„ì¹˜\nprint(bisect_left(arr, 2))   # 1\n\n# Upper Bound: 2 ì´ˆê³¼ì¸ ì²« ìœ„ì¹˜\nprint(bisect_right(arr, 2))  # 4\n\n# 2ì˜ ê°œìˆ˜\ncount = bisect_right(arr, 2) - bisect_left(arr, 2)  # 3\n\n# ì§ì ‘ êµ¬í˜„\ndef lower_bound(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ìˆ«ì ì¹´ë“œ 2 (10816) | ê°œìˆ˜ |\n| ëœì„  ìë¥´ê¸° (1654) | íŒŒë¼ë©”íŠ¸ë¦­ |"
      }
    ]
  },
  "08_íƒìƒ‰/linear-search": {
    "id": "08_íƒìƒ‰/linear-search",
    "title": "Linear Search",
    "category": "algorithm",
    "subCategory": "08_íƒìƒ‰",
    "language": "Python",
    "description": "ì²˜ìŒë¶€í„° ëê¹Œì§€ ìˆœì°¨ì ìœ¼ë¡œ íƒìƒ‰í•˜ëŠ” O(n) ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì„ í˜• íƒìƒ‰",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì²˜ìŒë¶€í„° í•˜ë‚˜ì”© í™•ì¸** - ê°€ì¥ ë‹¨ìˆœ, O(n)\n\n### íŠ¹ì§•\n- ì •ë ¬ ë¶ˆí•„ìš”\n- ì‹œê°„: O(n)\n- ë°ì´í„°ê°€ ì ê±°ë‚˜ ì •ë ¬ ë¹„ìš©ì´ í´ ë•Œ ì‚¬ìš©"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def linear_search(arr, target):\n    for i, val in enumerate(arr):\n        if val == target:\n            return i\n    return -1\n\n# Python ë‚´ì¥\narr = [3, 1, 4, 1, 5]\nif target in arr:\n    idx = arr.index(target)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "ì„ í˜• íƒìƒ‰ì€ ê¸°ë³¸. ë°ì´í„°ê°€ ë§ìœ¼ë©´ ì´ì§„ íƒìƒ‰ì´ë‚˜ í•´ì‹œ ì‚¬ìš©."
      }
    ]
  },
  "08_íŠ¸ë¦¬/binary-tree": {
    "id": "08_íŠ¸ë¦¬/binary-tree",
    "title": "Binary Tree",
    "category": "algorithm",
    "subCategory": "08_íŠ¸ë¦¬",
    "language": "Python",
    "description": "ìì‹ì´ ìµœëŒ€ 2ê°œì¸ ì´ì§„ íŠ¸ë¦¬ë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì´ì§„ íŠ¸ë¦¬",
        "content": "## ì´ì§„ íŠ¸ë¦¬ ì¢…ë¥˜\n\n### ì™„ì „ ì´ì§„ íŠ¸ë¦¬\n- ì™¼ìª½ë¶€í„° ì°¨ë¡€ë¡œ ì±„ì›€\n- í™ì— ì‚¬ìš©\n\n### í¬í™” ì´ì§„ íŠ¸ë¦¬\n- ëª¨ë“  ë ˆë²¨ì´ ê½‰ ì°¸\n- ë…¸ë“œ ìˆ˜ = 2^h - 1\n\n### ë†’ì´ h ì´ì§„ íŠ¸ë¦¬\n- ìµœì†Œ ë…¸ë“œ: hê°œ (í¸í–¥)\n- ìµœëŒ€ ë…¸ë“œ: 2^h - 1ê°œ"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# ë†’ì´ ê³„ì‚°\ndef height(node):\n    if not node:\n        return 0\n    return 1 + max(height(node.left), height(node.right))\n\n# ë…¸ë“œ ìˆ˜ ê³„ì‚°\ndef count(node):\n    if not node:\n        return 0\n    return 1 + count(node.left) + count(node.right)\n\n# ì™„ì „ ì´ì§„ íŠ¸ë¦¬: ë°°ì—´ë¡œ í‘œí˜„\n# ë¶€ëª¨ iì˜ ì™¼ìª½ ìì‹: 2*i+1, ì˜¤ë¥¸ìª½ ìì‹: 2*i+2\narr = [1, 2, 3, 4, 5]  # ë ˆë²¨ ìˆœì„œ"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Invert Binary Tree | LeetCode |\n| Symmetric Tree | LeetCode |"
      }
    ]
  },
  "08_íŠ¸ë¦¬/bst": {
    "id": "08_íŠ¸ë¦¬/bst",
    "title": "Bst",
    "category": "algorithm",
    "subCategory": "08_íŠ¸ë¦¬",
    "language": "Python",
    "description": "ì™¼ìª½ < ë¶€ëª¨ < ì˜¤ë¥¸ìª½ ì†ì„±ì˜ BSTë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ BSTë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì™¼ìª½ ìì‹ < ë¶€ëª¨ < ì˜¤ë¥¸ìª½ ìì‹** - íƒìƒ‰/ì‚½ì…/ì‚­ì œ O(log n)\n\n### íŠ¹ì§•\n- ì¤‘ìœ„ ìˆœíšŒ = ì •ë ¬ëœ ìˆœì„œ\n- í‰ê·  O(log n), ìµœì•… O(n)\n\n### ì£¼ì˜\n- ê· í˜• ìœ ì§€ ì•ˆ í•˜ë©´ í¸í–¥ë  ìˆ˜ ìˆìŒ"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "class TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef search(root, target):\n    if not root or root.val == target:\n        return root\n    if target < root.val:\n        return search(root.left, target)\n    return search(root.right, target)\n\ndef insert(root, val):\n    if not root:\n        return TreeNode(val)\n    if val < root.val:\n        root.left = insert(root.left, val)\n    else:\n        root.right = insert(root.right, val)\n    return root\n\n# ì¤‘ìœ„ ìˆœíšŒ = ì •ë ¬ ê²°ê³¼\ndef inorder(root):\n    if not root:\n        return []\n    return inorder(root.left) + [root.val] + inorder(root.right)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Validate BST | LeetCode |\n| Kth Smallest Element in BST | LeetCode |\n| ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ (5639) | ë°±ì¤€ |"
      }
    ]
  },
  "08_íŠ¸ë¦¬/tree-basic": {
    "id": "08_íŠ¸ë¦¬/tree-basic",
    "title": "Tree Basic",
    "category": "algorithm",
    "subCategory": "08_íŠ¸ë¦¬",
    "language": "Python",
    "description": "íŠ¸ë¦¬ì˜ ê¸°ë³¸ ì†ì„±ê³¼ êµ¬í˜„ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ íŠ¸ë¦¬ ê¸°ì´ˆ",
        "content": "## íŠ¸ë¦¬ ì†ì„±\n\n- ë…¸ë“œ Nê°œ â†’ ê°„ì„  N-1ê°œ\n- ë£¨íŠ¸ì—ì„œ ëª¨ë“  ë…¸ë“œê¹Œì§€ ê²½ë¡œ ìœ ì¼\n- ì‚¬ì´í´ ì—†ìŒ\n\n### ìš©ì–´\n- ë¶€ëª¨, ìì‹, í˜•ì œ\n- ì¡°ìƒ, ìì†\n- ë ˆë²¨, ë†’ì´, ê¹Šì´"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "class TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\n# ë¶€ëª¨ ë°°ì—´ë¡œ íŠ¸ë¦¬ í‘œí˜„\n# parent[i] = iì˜ ë¶€ëª¨ ë…¸ë“œ\nparent = [-1, 0, 0, 1, 1]  # 0ì´ ë£¨íŠ¸\n\n# ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ íŠ¸ë¦¬ í‘œí˜„\ntree = {\n    0: [1, 2],\n    1: [3, 4],\n    2: [],\n    3: [],\n    4: []\n}"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| íŠ¸ë¦¬ì˜ ë¶€ëª¨ ì°¾ê¸° (11725) | BFS/DFS |\n| íŠ¸ë¦¬ì˜ ì§€ë¦„ (1167) | DFS 2íšŒ |"
      }
    ]
  },
  "09_ê·¸ë˜í”„/bfs": {
    "id": "09_ê·¸ë˜í”„/bfs",
    "title": "Bfs",
    "category": "algorithm",
    "subCategory": "09_ê·¸ë˜í”„",
    "language": "Python",
    "description": "íë¥¼ ì´ìš©í•œ ë„ˆë¹„ ìš°ì„  íƒìƒ‰ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ BFSë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ê°€ê¹Œìš´ ê²ƒë¶€í„° ì°¨ë¡€ë¡œ íƒìƒ‰** - í ì‚¬ìš©, ìµœë‹¨ ê²½ë¡œ!\n\n### íŠ¹ì§•\n- ì‹œê°„: O(V+E)\n- ê³µê°„: O(V)\n- **ë¹„ê°€ì¤‘ì¹˜ ìµœë‹¨ ê²½ë¡œ ë³´ì¥**\n\n### í™œìš©\n- ìµœë‹¨ ê²½ë¡œ (ë¹„ê°€ì¤‘ì¹˜)\n- ë ˆë²¨ë³„ íƒìƒ‰\n- ì—°ê²° í™•ì¸"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "from collections import deque\n\ndef bfs(graph, start):\n    visited = set([start])\n    queue = deque([start])\n\n    while queue:\n        node = queue.popleft()\n        print(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n# ìµœë‹¨ ê±°ë¦¬ êµ¬í•˜ê¸°\ndef bfs_distance(graph, start, end):\n    visited = set([start])\n    queue = deque([(start, 0)])  # (ë…¸ë“œ, ê±°ë¦¬)\n\n    while queue:\n        node, dist = queue.popleft()\n        if node == end:\n            return dist\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, dist + 1))\n\n    return -1  # ë„ë‹¬ ë¶ˆê°€"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| DFSì™€ BFS (1260) | ê¸°ë³¸ |\n| ë¯¸ë¡œ íƒìƒ‰ (2178) | ìµœë‹¨ ê±°ë¦¬ |\n| í† ë§ˆí†  (7576) | ë‹¤ì¤‘ ì‹œì‘ì  |\n| ìˆ¨ë°”ê¼­ì§ˆ (1697) | ìƒíƒœ ê³µê°„ |"
      }
    ]
  },
  "09_ê·¸ë˜í”„/connected-component": {
    "id": "09_ê·¸ë˜í”„/connected-component",
    "title": "Connected Component",
    "category": "algorithm",
    "subCategory": "09_ê·¸ë˜í”„",
    "language": "Python",
    "description": "ê·¸ë˜í”„ì—ì„œ ì—°ê²°ëœ ì»´í¬ë„ŒíŠ¸ë¥¼ ì°¾ìŠµë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì—°ê²° ìš”ì†Œ",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì„œë¡œ ì—°ê²°ëœ ë…¸ë“œë“¤ì˜ ê·¸ë£¹** - DFS/BFSë¡œ ê°œìˆ˜ ì„¸ê¸°\n\n### ê°œìˆ˜ ì„¸ê¸° ì•Œê³ ë¦¬ì¦˜\n1. ëª¨ë“  ë…¸ë“œ ìˆœíšŒ\n2. ë°©ë¬¸ ì•ˆ í•œ ë…¸ë“œì—ì„œ DFS/BFS\n3. íƒìƒ‰ ì‹œì‘í•  ë•Œë§ˆë‹¤ ì¹´ìš´íŠ¸ +1"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def count_components(n, graph):\n    visited = [False] * (n + 1)\n    count = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i)\n            count += 1\n\n    return count\n\n# Union-Findë¡œë„ ê°€ëŠ¥\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px != py:\n            self.parent[px] = py"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜ (11724) | ê¸°ë³¸ |\n| ì„¬ì˜ ê°œìˆ˜ (4963) | 2D ê·¸ë¦¬ë“œ |\n| Number of Islands | LeetCode |"
      }
    ]
  },
  "09_ê·¸ë˜í”„/cycle-detection": {
    "id": "09_ê·¸ë˜í”„/cycle-detection",
    "title": "Cycle Detection",
    "category": "algorithm",
    "subCategory": "09_ê·¸ë˜í”„",
    "language": "Python",
    "description": "ê·¸ë˜í”„ì—ì„œ ì‚¬ì´í´ ì¡´ì¬ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì‚¬ì´í´ íƒì§€",
        "content": "## ë°©ë²•\n\n### ë¬´ë°©í–¥ ê·¸ë˜í”„\n- DFSë¡œ ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œë¥¼ ë‹¤ì‹œ ë§Œë‚¨ (ë¶€ëª¨ ì œì™¸)\n\n### ë°©í–¥ ê·¸ë˜í”„\n- ë°©ë¬¸ ìƒíƒœ 3ê°€ì§€ë¡œ ê´€ë¦¬\n  - 0: ë¯¸ë°©ë¬¸\n  - 1: í˜„ì¬ ê²½ë¡œì—ì„œ ë°©ë¬¸ ì¤‘\n  - 2: ì™„ì „ íƒìƒ‰ ì™„ë£Œ"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ë¬´ë°©í–¥ ê·¸ë˜í”„ ì‚¬ì´í´\ndef has_cycle_undirected(n, graph):\n    visited = [False] * (n + 1)\n\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, -1):\n                return True\n    return False\n\n# ë°©í–¥ ê·¸ë˜í”„ ì‚¬ì´í´\ndef has_cycle_directed(n, graph):\n    state = [0] * (n + 1)  # 0: ë¯¸ë°©ë¬¸, 1: ë°©ë¬¸ì¤‘, 2: ì™„ë£Œ\n\n    def dfs(node):\n        state[node] = 1\n        for neighbor in graph[node]:\n            if state[neighbor] == 1:  # ì‚¬ì´í´!\n                return True\n            if state[neighbor] == 0:\n                if dfs(neighbor):\n                    return True\n        state[node] = 2\n        return False\n\n    for i in range(1, n + 1):\n        if state[i] == 0:\n            if dfs(i):\n                return True\n    return False"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Course Schedule | LeetCode |\n| í…€ í”„ë¡œì íŠ¸ (9466) | ë°±ì¤€ |"
      }
    ]
  },
  "09_ê·¸ë˜í”„/dfs-bfs-compare": {
    "id": "09_ê·¸ë˜í”„/dfs-bfs-compare",
    "title": "Dfs Bfs Compare",
    "category": "algorithm",
    "subCategory": "09_ê·¸ë˜í”„",
    "language": "Python",
    "description": "DFSì™€ BFSì˜ ì°¨ì´ì ê³¼ ì„ íƒ ê¸°ì¤€ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ DFS vs BFS",
        "content": "## ë¹„êµ\n\n| íŠ¹ì„± | DFS | BFS |\n|-----|-----|-----|\n| ìë£Œêµ¬ì¡° | ìŠ¤íƒ/ì¬ê·€ | í |\n| íƒìƒ‰ ìˆœì„œ | ê¹Šì´ ìš°ì„  | ë„ˆë¹„ ìš°ì„  |\n| ìµœë‹¨ ê²½ë¡œ | âŒ | âœ… (ë¹„ê°€ì¤‘ì¹˜) |\n| ë©”ëª¨ë¦¬ | ê²½ë¡œ ê¸¸ì´ | ë„ˆë¹„ |\n\n### ì„ íƒ ê¸°ì¤€\n- **ìµœë‹¨ ê²½ë¡œ** í•„ìš” â†’ BFS\n- **ëª¨ë“  ê²½ë¡œ íƒìƒ‰** â†’ DFS\n- **ê²½ë¡œ ì¡°ê±´** (ë°±íŠ¸ë˜í‚¹) â†’ DFS\n- **ê·¸ë˜í”„ê°€ ë„“ìŒ** â†’ DFS\n- **ê·¸ë˜í”„ê°€ ê¹ŠìŒ** â†’ BFS"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# DFS: ëª¨ë“  ê²½ë¡œ ì°¾ê¸°\ndef all_paths(graph, start, end, path=[]):\n    path = path + [start]\n    if start == end:\n        return [path]\n    paths = []\n    for node in graph[start]:\n        if node not in path:\n            paths.extend(all_paths(graph, node, end, path))\n    return paths\n\n# BFS: ìµœë‹¨ ê²½ë¡œ (ë¹„ê°€ì¤‘ì¹˜)\nfrom collections import deque\ndef shortest_path(graph, start, end):\n    queue = deque([(start, [start])])\n    visited = {start}\n    while queue:\n        node, path = queue.popleft()\n        if node == end:\n            return path\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, path + [neighbor]))\n    return []"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "ë¬¸ì œ ìœ í˜• íŒŒì•…:\n- \"ìµœë‹¨\", \"ìµœì†Œ ì´ë™\" â†’ BFS\n- \"ëª¨ë“  ê²½ìš°\", \"ì¡°ê±´ ë§Œì¡±\" â†’ DFS"
      }
    ]
  },
  "09_ê·¸ë˜í”„/dfs": {
    "id": "09_ê·¸ë˜í”„/dfs",
    "title": "Dfs",
    "category": "algorithm",
    "subCategory": "09_ê·¸ë˜í”„",
    "language": "Python",
    "description": "ìŠ¤íƒ/ì¬ê·€ë¥¼ ì´ìš©í•œ ê¹Šì´ ìš°ì„  íƒìƒ‰ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ DFSë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **í•œ ë°©í–¥ìœ¼ë¡œ ëê¹Œì§€ ê°€ê³ , ë§‰íˆë©´ ëŒì•„ì™€ì„œ ë‹¤ë¥¸ ê¸¸** - ìŠ¤íƒ/ì¬ê·€ ì‚¬ìš©\n\n### íŠ¹ì§•\n- ì‹œê°„: O(V+E)\n- ê³µê°„: O(V) ì¬ê·€ ê¹Šì´\n- ëª¨ë“  ê²½ë¡œ íƒìƒ‰, ë°±íŠ¸ë˜í‚¹\n\n### í™œìš©\n- ê²½ë¡œ ì°¾ê¸°\n- ì‚¬ì´í´ ê²€ì¶œ\n- ì—°ê²° ìš”ì†Œ\n- ìœ„ìƒ ì •ë ¬"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ì¬ê·€ DFS\ndef dfs_recursive(graph, node, visited):\n    visited.add(node)\n    print(node)  # ë°©ë¬¸ ì²˜ë¦¬\n\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs_recursive(graph, neighbor, visited)\n\n# ìŠ¤íƒ DFS\ndef dfs_stack(graph, start):\n    visited = set()\n    stack = [start]\n\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            print(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    stack.append(neighbor)\n\n# ì‚¬ìš©\ngraph = {\n    1: [2, 3],\n    2: [4, 5],\n    3: [],\n    4: [],\n    5: []\n}\ndfs_recursive(graph, 1, set())"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| DFSì™€ BFS (1260) | ê¸°ë³¸ |\n| ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜ (11724) | ê°œìˆ˜ ì„¸ê¸° |\n| íƒ€ê²Ÿ ë„˜ë²„ | í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ |"
      }
    ]
  },
  "09_ê·¸ë˜í”„/graph-concept": {
    "id": "09_ê·¸ë˜í”„/graph-concept",
    "title": "Graph Concept",
    "category": "algorithm",
    "subCategory": "09_ê·¸ë˜í”„",
    "language": "Python",
    "description": "ê·¸ë˜í”„ì˜ ê¸°ë³¸ ê°œë…ê³¼ ìš©ì–´ë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ê·¸ë˜í”„ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì •ì (Vertex)ê³¼ ê°„ì„ (Edge)ìœ¼ë¡œ ì—°ê²°ëœ ìë£Œêµ¬ì¡°**\n\n### ê·¸ë˜í”„ ì¢…ë¥˜\n- **ë¬´ë°©í–¥ vs ë°©í–¥**\n- **ê°€ì¤‘ì¹˜ vs ë¹„ê°€ì¤‘ì¹˜**\n- **ì—°ê²° vs ë¹„ì—°ê²°**\n- **ì‚¬ì´í´ ìˆìŒ vs ì—†ìŒ (DAG)**\n\n### ìš©ì–´\n- ì •ì  (Vertex, Node)\n- ê°„ì„  (Edge)\n- ì°¨ìˆ˜ (Degree): ì—°ê²°ëœ ê°„ì„  ìˆ˜\n- ê²½ë¡œ (Path): ì •ì ë“¤ì˜ ë‚˜ì—´\n- ì‚¬ì´í´ (Cycle): ì‹œì‘=ëì¸ ê²½ë¡œ"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ê·¸ë˜í”„ í‘œí˜„\n\n# 1. ì¸ì ‘ í–‰ë ¬ (2ì°¨ì› ë°°ì—´)\n# ì¥ì : O(1) ì—°ê²° í™•ì¸\n# ë‹¨ì : O(VÂ²) ê³µê°„\nadj_matrix = [\n    [0, 1, 1, 0],\n    [1, 0, 0, 1],\n    [1, 0, 0, 1],\n    [0, 1, 1, 0]\n]\n\n# 2. ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ (ëŒ€ë¶€ë¶„ ì´ê±¸ ì‚¬ìš©)\n# ì¥ì : O(V+E) ê³µê°„\n# ë‹¨ì : O(V) ì—°ê²° í™•ì¸\nfrom collections import defaultdict\nadj_list = defaultdict(list)\nadj_list[0] = [1, 2]\nadj_list[1] = [0, 3]\nadj_list[2] = [0, 3]\nadj_list[3] = [1, 2]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "ê·¸ë˜í”„ ë¬¸ì œëŠ” DFS/BFSë¡œ íƒìƒ‰í•˜ëŠ” ê²ƒì´ ê¸°ë³¸!"
      }
    ]
  },
  "09_ê·¸ë˜í”„/graph-representation": {
    "id": "09_ê·¸ë˜í”„/graph-representation",
    "title": "Graph Representation",
    "category": "algorithm",
    "subCategory": "09_ê·¸ë˜í”„",
    "language": "Python",
    "description": "ì¸ì ‘ í–‰ë ¬ê³¼ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ ê·¸ë˜í”„ë¥¼ í‘œí˜„í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ê·¸ë˜í”„ í‘œí˜„ë²•",
        "content": "## ì¸ì ‘ í–‰ë ¬ vs ì¸ì ‘ ë¦¬ìŠ¤íŠ¸\n\n| íŠ¹ì„± | ì¸ì ‘ í–‰ë ¬ | ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ |\n|-----|---------|-----------|\n| ê³µê°„ | O(VÂ²) | O(V+E) |\n| ì—°ê²° í™•ì¸ | O(1) | O(V) |\n| ëª¨ë“  ê°„ì„  ìˆœíšŒ | O(VÂ²) | O(V+E) |\n| ì í•©í•œ ê²½ìš° | ë°€ì§‘ ê·¸ë˜í”„ | í¬ì†Œ ê·¸ë˜í”„ |\n\n### ì½”í…Œì—ì„œëŠ” ê±°ì˜ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©!"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ì…ë ¥ ì²˜ë¦¬ íŒ¨í„´\nn, m = map(int, input().split())  # ì •ì , ê°„ì„  ìˆ˜\n\n# ì¸ì ‘ ë¦¬ìŠ¤íŠ¸\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)  # ë¬´ë°©í–¥ì´ë©´\n\n# ê°€ì¤‘ì¹˜ ê·¸ë˜í”„\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    a, b, w = map(int, input().split())\n    graph[a].append((b, w))\n    graph[b].append((a, w))"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "ê·¸ë˜í”„ ì…ë ¥ ì²˜ë¦¬ëŠ” ìˆ™ë‹¬ í•„ìˆ˜!"
      }
    ]
  },
  "09_ê·¸ë˜í”„/practice-graph": {
    "id": "09_ê·¸ë˜í”„/practice-graph",
    "title": "Practice Graph",
    "category": "algorithm",
    "subCategory": "09_ê·¸ë˜í”„",
    "language": "Python",
    "description": "ê·¸ë˜í”„ ë¬¸ì œ í’€ì´ íŒ¨í„´ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ¯ ê·¸ë˜í”„ íŒ¨í„´",
        "content": "## ë¬¸ì œ ìœ í˜•ë³„ ì ‘ê·¼\n\n### 1. íƒìƒ‰\n- ì—°ê²° í™•ì¸ â†’ DFS/BFS\n- ìµœë‹¨ ê±°ë¦¬ â†’ BFS\n\n### 2. ì—°ê²° ìš”ì†Œ\n- ê°œìˆ˜ ì„¸ê¸° â†’ DFS + ì¹´ìš´íŠ¸\n- ê·¸ë£¹í™” â†’ Union-Find\n\n### 3. ìµœë‹¨ ê²½ë¡œ\n- ë¹„ê°€ì¤‘ì¹˜ â†’ BFS\n- ê°€ì¤‘ì¹˜ â†’ ë‹¤ìµìŠ¤íŠ¸ë¼/ë²¨ë§Œí¬ë“œ\n\n### 4. ìˆœì„œ\n- ì„ í›„ ê´€ê³„ â†’ ìœ„ìƒ ì •ë ¬"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# 2D ê·¸ë¦¬ë“œ íƒìƒ‰ íŒ¨í„´\ndx = [-1, 1, 0, 0]  # ìƒí•˜ì¢Œìš°\ndy = [0, 0, -1, 1]\n\ndef bfs_grid(grid, start_x, start_y):\n    n, m = len(grid), len(grid[0])\n    visited = [[False] * m for _ in range(n)]\n    queue = deque([(start_x, start_y)])\n    visited[start_x][start_y] = True\n\n    while queue:\n        x, y = queue.popleft()\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n            if 0 <= nx < n and 0 <= ny < m:\n                if not visited[nx][ny] and grid[nx][ny] == 1:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ í•„ìˆ˜ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | ìœ í˜• |\n|-----|-----|\n| ë¯¸ë¡œ íƒìƒ‰ (2178) | BFS ìµœë‹¨ |\n| í† ë§ˆí†  (7576) | ë‹¤ì¤‘ ì‹œì‘ |\n| ì—°ê²° ìš”ì†Œ (11724) | ì»´í¬ë„ŒíŠ¸ |\n| ì¤„ ì„¸ìš°ê¸° (2252) | ìœ„ìƒ ì •ë ¬ |"
      }
    ]
  },
  "09_ê·¸ë˜í”„/topological-sort": {
    "id": "09_ê·¸ë˜í”„/topological-sort",
    "title": "Topological Sort",
    "category": "algorithm",
    "subCategory": "09_ê·¸ë˜í”„",
    "language": "Python",
    "description": "DAGì—ì„œ ì„ í›„ ê´€ê³„ë¥¼ ì§€í‚¤ë©° ì •ë ¬í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ìœ„ìƒ ì •ë ¬",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì„ í–‰ ì¡°ê±´ì„ ì§€í‚¤ë©° ìˆœì„œëŒ€ë¡œ ë‚˜ì—´** - DAG(ë¹„ìˆœí™˜ ë°©í–¥ ê·¸ë˜í”„)ì—ì„œë§Œ ê°€ëŠ¥\n\n### í™œìš©\n- ê°•ì˜ ìˆ˜ê°• ìˆœì„œ\n- ë¹Œë“œ ì˜ì¡´ì„±\n- ì‘ì—… ìŠ¤ì¼€ì¤„ë§\n\n### ë°©ë²•\n1. **Kahn's Algorithm**: ì§„ì…ì°¨ìˆ˜ 0ì¸ ê²ƒë¶€í„°\n2. **DFS**: í›„ìœ„ ìˆœíšŒ ì—­ìˆœ"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "from collections import deque\n\n# Kahn's Algorithm (BFS ê¸°ë°˜)\ndef topological_sort(n, graph):\n    indegree = [0] * (n + 1)\n    for node in range(1, n + 1):\n        for neighbor in graph[node]:\n            indegree[neighbor] += 1\n\n    queue = deque()\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            queue.append(i)\n\n    result = []\n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(result) != n:\n        return []  # ì‚¬ì´í´ ì¡´ì¬\n    return result\n\n# DFS ê¸°ë°˜\ndef topological_sort_dfs(n, graph):\n    visited = [False] * (n + 1)\n    result = []\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        result.append(node)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i)\n\n    return result[::-1]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ì¤„ ì„¸ìš°ê¸° (2252) | ê¸°ë³¸ |\n| ì‘ì—… (2056) | DPì™€ ê²°í•© |\n| Course Schedule II | LeetCode |"
      }
    ]
  },
  "10_ìµœë‹¨ê²½ë¡œ/bellman-ford": {
    "id": "10_ìµœë‹¨ê²½ë¡œ/bellman-ford",
    "title": "Bellman Ford",
    "category": "algorithm",
    "subCategory": "10_ìµœë‹¨ê²½ë¡œ",
    "language": "Python",
    "description": "ìŒìˆ˜ ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ê·¸ë˜í”„ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ O(VE)ì— êµ¬í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ë²¨ë§Œ-í¬ë“œ",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ëª¨ë“  ê°„ì„ ì„ V-1ë²ˆ ë°˜ë³µ** - ìŒìˆ˜ ê°€ì¤‘ì¹˜ OK, ìŒìˆ˜ ì‚¬ì´í´ íƒì§€\n\n### íŠ¹ì§•\n- ìŒìˆ˜ ê°€ì¤‘ì¹˜ âœ…\n- ìŒìˆ˜ ì‚¬ì´í´ íƒì§€ ê°€ëŠ¥\n- O(VE) - ë‹¤ìµìŠ¤íŠ¸ë¼ë³´ë‹¤ ëŠë¦¼"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def bellman_ford(n, edges, start):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n\n    # V-1ë²ˆ ë°˜ë³µ\n    for _ in range(n - 1):\n        for u, v, w in edges:\n            if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n\n    # ìŒìˆ˜ ì‚¬ì´í´ ì²´í¬ (í•œ ë²ˆ ë”)\n    for u, v, w in edges:\n        if dist[u] != float('inf') and dist[u] + w < dist[v]:\n            return None  # ìŒìˆ˜ ì‚¬ì´í´ ì¡´ì¬\n\n    return dist"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| íƒ€ì„ë¨¸ì‹  (11657) | ìŒìˆ˜ ì‚¬ì´í´ |\n| ì›œí™€ (1865) | ìŒìˆ˜ ì‚¬ì´í´ |"
      }
    ]
  },
  "10_ìµœë‹¨ê²½ë¡œ/dijkstra": {
    "id": "10_ìµœë‹¨ê²½ë¡œ/dijkstra",
    "title": "Dijkstra",
    "category": "algorithm",
    "subCategory": "10_ìµœë‹¨ê²½ë¡œ",
    "language": "Python",
    "description": "ìŒì´ ì•„ë‹Œ ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ O((V+E)log V)ì— êµ¬í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ë‹¤ìµìŠ¤íŠ¸ë¼",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° í™•ì •** - ê·¸ë¦¬ë”” + ìš°ì„ ìˆœìœ„ í\n\n### ì¡°ê±´\n- ìŒìˆ˜ ê°€ì¤‘ì¹˜ âŒ\n- í•œ ì •ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ê¹Œì§€\n\n### ì‹œê°„ë³µì¡ë„\n- í™ ì‚¬ìš©: O((V+E) log V)\n- ë°°ì—´ ì‚¬ìš©: O(VÂ²)"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "import heapq\n\ndef dijkstra(graph, start, n):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    heap = [(0, start)]  # (ê±°ë¦¬, ë…¸ë“œ)\n\n    while heap:\n        d, node = heapq.heappop(heap)\n\n        if d > dist[node]:\n            continue\n\n        for neighbor, weight in graph[node]:\n            new_dist = d + weight\n            if new_dist < dist[neighbor]:\n                dist[neighbor] = new_dist\n                heapq.heappush(heap, (new_dist, neighbor))\n\n    return dist\n\n# ì‚¬ìš©\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    graph[u].append((v, w))\n\ndistances = dijkstra(graph, 1, n)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ìµœë‹¨ê²½ë¡œ (1753) | ê¸°ë³¸ |\n| íŠ¹ì •í•œ ìµœë‹¨ ê²½ë¡œ (1504) | ê²½ìœ  |\n| ìµœì†Œë¹„ìš© êµ¬í•˜ê¸° (1916) | ì‘ìš© |"
      }
    ]
  },
  "10_ìµœë‹¨ê²½ë¡œ/floyd-warshall": {
    "id": "10_ìµœë‹¨ê²½ë¡œ/floyd-warshall",
    "title": "Floyd Warshall",
    "category": "algorithm",
    "subCategory": "10_ìµœë‹¨ê²½ë¡œ",
    "language": "Python",
    "description": "ëª¨ë“  ìŒì˜ ìµœë‹¨ ê²½ë¡œë¥¼ O(VÂ³)ì— êµ¬í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ í”Œë¡œì´ë“œ-ì›Œì…œ",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ëª¨ë“  ë…¸ë“œë¥¼ ê²½ìœ ì§€ë¡œ ì‹œë„** - ëª¨ë“  ìŒ ìµœë‹¨ ê±°ë¦¬\n\n### íŠ¹ì§•\n- ì‹œê°„: O(VÂ³)\n- ê³µê°„: O(VÂ²)\n- ìŒìˆ˜ ê°€ì¤‘ì¹˜ OK (ìŒìˆ˜ ì‚¬ì´í´ ì œì™¸)\n- V â‰¤ 500 ì •ë„ì—ì„œ ì‚¬ìš©"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def floyd_warshall(n, graph):\n    INF = float('inf')\n    dist = [[INF] * (n + 1) for _ in range(n + 1)]\n\n    # ì´ˆê¸°í™”\n    for i in range(1, n + 1):\n        dist[i][i] = 0\n    for u, v, w in graph:\n        dist[u][v] = w\n\n    # kë¥¼ ê²½ìœ ì§€ë¡œ\n    for k in range(1, n + 1):\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| í”Œë¡œì´ë“œ (11404) | ê¸°ë³¸ |\n| ì¼€ë¹ˆ ë² ì´ì»¨ì˜ 6ë‹¨ê³„ ë²•ì¹™ (1389) | ì‘ìš© |"
      }
    ]
  },
  "10_ìµœë‹¨ê²½ë¡œ/practice-shortest": {
    "id": "10_ìµœë‹¨ê²½ë¡œ/practice-shortest",
    "title": "Practice Shortest",
    "category": "algorithm",
    "subCategory": "10_ìµœë‹¨ê²½ë¡œ",
    "language": "Python",
    "description": "ìµœë‹¨ ê²½ë¡œ ë¬¸ì œ í’€ì´ íŒ¨í„´ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ¯ íŒ¨í„´",
        "content": "## ìì£¼ ë‚˜ì˜¤ëŠ” ë³€í˜•\n\n### 1. ê²½ìœ ì§€ ì§€ì •\n- A â†’ B â†’ C ìµœë‹¨ = dist(A,B) + dist(B,C)\n\n### 2. ê°„ì„  í•˜ë‚˜ ì œê±°\n- ëª¨ë“  ê°„ì„  ì œê±°í•´ë³´ë©° ìµœë‹¨ ê³„ì‚°\n\n### 3. ìµœë‹¨ ê²½ë¡œ ê°œìˆ˜\n- ë‹¤ìµìŠ¤íŠ¸ë¼ + ì¹´ìš´íŠ¸ ë°°ì—´\n\n### 4. ìµœë‹¨ ê²½ë¡œ ì—­ì¶”ì \n- ì´ì „ ë…¸ë“œ ì €ì¥"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ê²½ìœ ì§€ ìˆëŠ” ìµœë‹¨ ê²½ë¡œ\ndef via_shortest(graph, n, start, via, end):\n    dist1 = dijkstra(graph, start, n)\n    dist2 = dijkstra(graph, via, n)\n    return dist1[via] + dist2[end]\n\n# ê²½ë¡œ ì—­ì¶”ì \ndef dijkstra_with_path(graph, start, end, n):\n    dist = [float('inf')] * (n + 1)\n    prev = [-1] * (n + 1)\n    dist[start] = 0\n    heap = [(0, start)]\n\n    while heap:\n        d, node = heapq.heappop(heap)\n        if d > dist[node]:\n            continue\n        for neighbor, weight in graph[node]:\n            if d + weight < dist[neighbor]:\n                dist[neighbor] = d + weight\n                prev[neighbor] = node\n                heapq.heappush(heap, (dist[neighbor], neighbor))\n\n    # ê²½ë¡œ ë³µì›\n    path = []\n    node = end\n    while node != -1:\n        path.append(node)\n        node = prev[node]\n    return path[::-1]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| íŠ¹ì •í•œ ìµœë‹¨ ê²½ë¡œ (1504) | ê²½ìœ  |\n| ìµœë‹¨ê²½ë¡œ (1753) | ê¸°ë³¸ |\n| ìˆ¨ë°”ê¼­ì§ˆ 4 (13913) | ê²½ë¡œ ì¶œë ¥ |"
      }
    ]
  },
  "10_ìµœë‹¨ê²½ë¡œ/shortest-path-compare": {
    "id": "10_ìµœë‹¨ê²½ë¡œ/shortest-path-compare",
    "title": "Shortest Path Compare",
    "category": "algorithm",
    "subCategory": "10_ìµœë‹¨ê²½ë¡œ",
    "language": "Python",
    "description": "ë‹¤ìµìŠ¤íŠ¸ë¼, ë²¨ë§Œ-í¬ë“œ, í”Œë¡œì´ë“œ-ì›Œì…œì„ ë¹„êµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì•Œê³ ë¦¬ì¦˜ ì„ íƒ",
        "content": "## ë¹„êµí‘œ\n\n| ì•Œê³ ë¦¬ì¦˜ | ì‹œê°„ | ìŒìˆ˜ | ìŒìˆ˜ì‚¬ì´í´ | ìš©ë„ |\n|---------|-----|-----|----------|-----|\n| ë‹¤ìµìŠ¤íŠ¸ë¼ | O((V+E)logV) | âŒ | âŒ | ë‹¨ì¼ ì¶œë°œ |\n| ë²¨ë§Œí¬ë“œ | O(VE) | âœ… | íƒì§€ | ìŒìˆ˜ ìˆì„ ë•Œ |\n| í”Œë¡œì´ë“œ | O(VÂ³) | âœ… | âŒ | ëª¨ë“  ìŒ |\n\n### ì„ íƒ ê°€ì´ë“œ\n- ìŒìˆ˜ ì—†ìŒ + í•œ ì ì—ì„œ â†’ **ë‹¤ìµìŠ¤íŠ¸ë¼**\n- ìŒìˆ˜ ìˆìŒ + í•œ ì ì—ì„œ â†’ **ë²¨ë§Œ-í¬ë“œ**\n- ëª¨ë“  ìŒ í•„ìš” + Vì‘ìŒ â†’ **í”Œë¡œì´ë“œ**"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ë¬¸ì œ ì¡°ê±´ í™•ì¸í•˜ê³  ì„ íƒ\n# 1. V, E í¬ê¸° í™•ì¸\n# 2. ìŒìˆ˜ ê°€ì¤‘ì¹˜ ì—¬ë¶€\n# 3. ë‹¨ì¼ ì¶œë°œ vs ëª¨ë“  ìŒ\n\n# V = 10ë§Œ â†’ ë‹¤ìµìŠ¤íŠ¸ë¼\n# V = 500, ëª¨ë“  ìŒ â†’ í”Œë¡œì´ë“œ\n# ìŒìˆ˜ ìˆìŒ â†’ ë²¨ë§Œí¬ë“œ"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "ë¬¸ì œ ì½ê³  ì ì ˆí•œ ì•Œê³ ë¦¬ì¦˜ ì„ íƒì´ í•µì‹¬!"
      }
    ]
  },
  "11_DP/dp-bitmask": {
    "id": "11_DP/dp-bitmask",
    "title": "Dp Bitmask",
    "category": "algorithm",
    "subCategory": "11_DP",
    "language": "Python",
    "description": "ì§‘í•©ì„ ë¹„íŠ¸ë¡œ í‘œí˜„í•˜ëŠ” DP ê¸°ë²•ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ë¹„íŠ¸ë§ˆìŠ¤í¬ DP",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì§‘í•©ì˜ ìƒíƒœë¥¼ ë¹„íŠ¸ë¡œ í‘œí˜„** - ë¶€ë¶„ì§‘í•© DP\n\n### ë¹„íŠ¸ ì—°ì‚°\n- ië²ˆì§¸ ì›ì†Œ í¬í•¨? `(state >> i) & 1`\n- ië²ˆì§¸ ì¶”ê°€: `state | (1 << i)`\n- ië²ˆì§¸ ì œê±°: `state & ~(1 << i)`\n\n### í™œìš©\n- ì™¸íŒì› ë¬¸ì œ (TSP)\n- í• ë‹¹ ë¬¸ì œ\n- ë¶€ë¶„ì§‘í•© í•©"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ì™¸íŒì› ë¬¸ì œ (TSP)\ndef tsp(dist):\n    n = len(dist)\n    INF = float('inf')\n    dp = [[INF] * n for _ in range(1 << n)]\n    dp[1][0] = 0  # ì‹œì‘ì  ë°©ë¬¸\n\n    for state in range(1 << n):\n        for u in range(n):\n            if not (state & (1 << u)):\n                continue\n            for v in range(n):\n                if state & (1 << v):\n                    continue\n                next_state = state | (1 << v)\n                dp[next_state][v] = min(dp[next_state][v], dp[state][u] + dist[u][v])\n\n    # ëª¨ë“  ë…¸ë“œ ë°©ë¬¸ í›„ ì‹œì‘ì ìœ¼ë¡œ\n    full = (1 << n) - 1\n    result = INF\n    for u in range(1, n):\n        if dist[u][0] > 0:\n            result = min(result, dp[full][u] + dist[u][0])\n\n    return result"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ì™¸íŒì› ìˆœíšŒ (2098) | TSP ê¸°ë³¸ |\n| ë°œì „ì†Œ (1102) | ë¹„íŠ¸ë§ˆìŠ¤í¬ |"
      }
    ]
  },
  "11_DP/dp-coin": {
    "id": "11_DP/dp-coin",
    "title": "Dp Coin",
    "category": "algorithm",
    "subCategory": "11_DP",
    "language": "Python",
    "description": "ë™ì „ êµí™˜ ë¬¸ì œë¡œ DPë¥¼ ì—°ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ë™ì „ ë¬¸ì œ",
        "content": "## ìœ í˜•\n\n### 1. ìµœì†Œ ë™ì „ ê°œìˆ˜\n- dp[i] = iì›ì„ ë§Œë“œëŠ” ìµœì†Œ ë™ì „ ìˆ˜\n\n### 2. ê²½ìš°ì˜ ìˆ˜\n- dp[i] = iì›ì„ ë§Œë“œëŠ” ë°©ë²• ìˆ˜\n\n### ì í™”ì‹\n```\ndp[i] = min(dp[i], dp[i - coin] + 1)\ndp[i] += dp[i - coin]\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ìµœì†Œ ë™ì „ ê°œìˆ˜\ndef min_coins(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i and dp[i - coin] != float('inf'):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] != float('inf') else -1\n\n# ê²½ìš°ì˜ ìˆ˜\ndef count_ways(coins, amount):\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n\n    for coin in coins:  # ìˆœì„œ ì¤‘ìš”! (ì¤‘ë³µ ë°©ì§€)\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n\n    return dp[amount]\n\nprint(min_coins([1, 5, 10], 15))  # 2 (10+5)\nprint(count_ways([1, 5, 10], 15))  # ?"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ë™ì „ 1 (2293) | ê²½ìš°ì˜ ìˆ˜ |\n| ë™ì „ 2 (2294) | ìµœì†Œ ê°œìˆ˜ |\n| Coin Change | LeetCode |"
      }
    ]
  },
  "11_DP/dp-concept": {
    "id": "11_DP/dp-concept",
    "title": "Dp Concept",
    "category": "algorithm",
    "subCategory": "11_DP",
    "language": "Python",
    "description": "ë™ì  í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ ì›ë¦¬ì™€ ì ‘ê·¼ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ DPë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ„ê³ , ê²°ê³¼ë¥¼ ì €ì¥í•´ì„œ ì¬ì‚¬ìš©** - ì¤‘ë³µ ê³„ì‚° ì œê±°\n\n### ì¡°ê±´ (DP ì‚¬ìš© ê°€ëŠ¥í•œ ë¬¸ì œ)\n1. **ìµœì  ë¶€ë¶„ êµ¬ì¡°**: í° ë¬¸ì œì˜ í•´ê°€ ì‘ì€ ë¬¸ì œì˜ í•´ë¡œ êµ¬ì„±\n2. **ì¤‘ë³µ ë¶€ë¶„ ë¬¸ì œ**: ê°™ì€ ì‘ì€ ë¬¸ì œê°€ ë°˜ë³µ\n\n### ë°©ì‹\n- **Top-down (ë©”ëª¨ì´ì œì´ì…˜)**: ì¬ê·€ + ì €ì¥\n- **Bottom-up (íƒ€ë·¸ë ˆì´ì…˜)**: ì‘ì€ ê²ƒë¶€í„° ì±„ìš°ê¸°\n\n### ì‹œê°„ë³µì¡ë„\n- ë¶€ë¶„ ë¬¸ì œ ìˆ˜ Ã— ë¶€ë¶„ ë¬¸ì œë‹¹ ì—°ì‚°"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# Top-down (ë©”ëª¨ì´ì œì´ì…˜)\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n-1) + fib(n-2)\n\n# Bottom-up (íƒ€ë·¸ë ˆì´ì…˜)\ndef fib_bottom_up(n):\n    if n <= 1:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]\n\n# ê³µê°„ ìµœì í™”\ndef fib_optimized(n):\n    if n <= 1:\n        return n\n    prev, curr = 0, 1\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n    return curr"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| í”¼ë³´ë‚˜ì¹˜ í•¨ìˆ˜ (1003) | ê¸°ë³¸ |\n| 1ë¡œ ë§Œë“¤ê¸° (1463) | DP ì…ë¬¸ |\n| ê³„ë‹¨ ì˜¤ë¥´ê¸° (2579) | ì¡°ê±´ ìˆëŠ” DP |"
      }
    ]
  },
  "11_DP/dp-fibonacci": {
    "id": "11_DP/dp-fibonacci",
    "title": "Dp Fibonacci",
    "category": "algorithm",
    "subCategory": "11_DP",
    "language": "Python",
    "description": "í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ë¡œ DP ê°œë…ì„ ì´í•´í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ í”¼ë³´ë‚˜ì¹˜ ìµœì í™”",
        "content": "## ë°©ë²•ë³„ ë¹„êµ\n\n| ë°©ë²• | ì‹œê°„ | ê³µê°„ |\n|-----|-----|-----|\n| ì¬ê·€ | O(2â¿) | O(n) |\n| ë©”ëª¨ì´ì œì´ì…˜ | O(n) | O(n) |\n| íƒ€ë·¸ë ˆì´ì…˜ | O(n) | O(n) |\n| ê³µê°„ ìµœì í™” | O(n) | O(1) |\n| í–‰ë ¬ ê±°ë“­ì œê³± | O(log n) | O(1) |"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# í–‰ë ¬ ê±°ë“­ì œê³± O(log n)\ndef matrix_mult(A, B):\n    return [\n        [A[0][0]*B[0][0] + A[0][1]*B[1][0], A[0][0]*B[0][1] + A[0][1]*B[1][1]],\n        [A[1][0]*B[0][0] + A[1][1]*B[1][0], A[1][0]*B[0][1] + A[1][1]*B[1][1]]\n    ]\n\ndef matrix_pow(M, n):\n    if n == 1:\n        return M\n    if n % 2 == 0:\n        half = matrix_pow(M, n // 2)\n        return matrix_mult(half, half)\n    return matrix_mult(M, matrix_pow(M, n - 1))\n\ndef fib_matrix(n):\n    if n <= 1:\n        return n\n    M = [[1, 1], [1, 0]]\n    result = matrix_pow(M, n)\n    return result[0][1]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| í”¼ë³´ë‚˜ì¹˜ ìˆ˜ (2747) | ê¸°ë³¸ |\n| í”¼ë³´ë‚˜ì¹˜ ìˆ˜ 6 (11444) | í–‰ë ¬ ê±°ë“­ì œê³± |"
      }
    ]
  },
  "11_DP/dp-knapsack": {
    "id": "11_DP/dp-knapsack",
    "title": "Dp Knapsack",
    "category": "algorithm",
    "subCategory": "11_DP",
    "language": "Python",
    "description": "0/1 ë°°ë‚­ ë¬¸ì œì™€ ë³€í˜•ë“¤ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ë°°ë‚­ ë¬¸ì œ",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì œí•œëœ ìš©ëŸ‰ì—ì„œ ìµœëŒ€ ê°€ì¹˜ ë‹´ê¸°** - DPì˜ ëŒ€í‘œ ë¬¸ì œ\n\n### ìœ í˜•\n- **0/1 ë°°ë‚­**: ë¬¼ê±´ì„ ìª¼ê°¤ ìˆ˜ ì—†ìŒ â†’ DP\n- **ë¶„í•  ë°°ë‚­**: ë¬¼ê±´ì„ ìª¼ê°¤ ìˆ˜ ìˆìŒ â†’ ê·¸ë¦¬ë””\n\n### ì í™”ì‹\n```\ndp[i][w] = max(dp[i-1][w], dp[i-1][w-wi] + vi)\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# 0/1 ë°°ë‚­ - 2ì°¨ì› DP\ndef knapsack_2d(W, weights, values):\n    n = len(weights)\n    dp = [[0] * (W + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for w in range(W + 1):\n            if weights[i-1] <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w - weights[i-1]] + values[i-1])\n            else:\n                dp[i][w] = dp[i-1][w]\n\n    return dp[n][W]\n\n# 0/1 ë°°ë‚­ - 1ì°¨ì› DP (ê³µê°„ ìµœì í™”)\ndef knapsack_1d(W, weights, values):\n    n = len(weights)\n    dp = [0] * (W + 1)\n\n    for i in range(n):\n        for w in range(W, weights[i] - 1, -1):  # ì—­ìˆœ!\n            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])\n\n    return dp[W]\n\n# í…ŒìŠ¤íŠ¸\nW = 7\nweights = [3, 4, 2, 5]\nvalues = [4, 5, 3, 7]\nprint(knapsack_1d(W, weights, values))"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| í‰ë²”í•œ ë°°ë‚­ (12865) | ê¸°ë³¸ |\n| ë™ì „ 2 (2294) | ìµœì†Œ ê°œìˆ˜ |\n| Target Sum | LeetCode |"
      }
    ]
  },
  "11_DP/dp-lcs": {
    "id": "11_DP/dp-lcs",
    "title": "Dp Lcs",
    "category": "algorithm",
    "subCategory": "11_DP",
    "language": "Python",
    "description": "ë‘ ë¬¸ìì—´ì˜ ìµœì¥ ê³µí†µ ë¶€ë¶„ ìˆ˜ì—´ì„ êµ¬í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ LCS",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ë‘ ìˆ˜ì—´ì—ì„œ ê³µí†µìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” ê°€ì¥ ê¸´ ë¶€ë¶„ ìˆ˜ì—´**\n\n### ì í™”ì‹\n```\nif A[i] == B[j]:\n    dp[i][j] = dp[i-1][j-1] + 1\nelse:\n    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n```\n\n### ì˜ˆì‹œ\n```\nA = \"ABCBDAB\"\nB = \"BDCAB\"\nLCS = \"BCAB\" â†’ ê¸¸ì´ 4\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def lcs_length(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    return dp[m][n]\n\n# LCS ë¬¸ìì—´ ë³µì›\ndef lcs_string(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    # ì—­ì¶”ì \n    result = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if s1[i-1] == s2[j-1]:\n            result.append(s1[i-1])\n            i -= 1\n            j -= 1\n        elif dp[i-1][j] > dp[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return ''.join(reversed(result))\n\nprint(lcs_string(\"ABCBDAB\", \"BDCAB\"))  # BCAB"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| LCS (9251) | ê¸¸ì´ |\n| LCS 2 (9252) | ë¬¸ìì—´ ë³µì› |\n| Longest Common Subsequence | LeetCode |"
      }
    ]
  },
  "11_DP/dp-lis": {
    "id": "11_DP/dp-lis",
    "title": "Dp Lis",
    "category": "algorithm",
    "subCategory": "11_DP",
    "language": "Python",
    "description": "O(n log n) LIS ì•Œê³ ë¦¬ì¦˜ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ LIS",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì›ì†Œ ìˆœì„œ ìœ ì§€í•˜ë©° ì¦ê°€í•˜ëŠ” ê°€ì¥ ê¸´ ë¶€ë¶„ ìˆ˜ì—´**\n\n### ë°©ë²•\n- O(nÂ²): dp[i] = iì—ì„œ ëë‚˜ëŠ” LIS ê¸¸ì´\n- O(n log n): ì´ì§„ íƒìƒ‰ í™œìš©\n\n### ì˜ˆì‹œ\n```\n[10, 20, 10, 30, 20, 50]\nLIS: [10, 20, 30, 50] â†’ ê¸¸ì´ 4\n```"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# O(nÂ²) DP\ndef lis_n2(arr):\n    n = len(arr)\n    dp = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n# O(n log n) ì´ì§„ íƒìƒ‰\nfrom bisect import bisect_left\n\ndef lis_nlogn(arr):\n    tails = []\n\n    for num in arr:\n        pos = bisect_left(tails, num)\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n\n    return len(tails)\n\nprint(lis_nlogn([10, 20, 10, 30, 20, 50]))  # 4"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´ (11053) | O(nÂ²) |\n| ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´ 2 (12015) | O(n log n) |\n| Longest Increasing Subsequence | LeetCode |"
      }
    ]
  },
  "11_DP/dp-matrix-chain": {
    "id": "11_DP/dp-matrix-chain",
    "title": "Dp Matrix Chain",
    "category": "algorithm",
    "subCategory": "11_DP",
    "language": "Python",
    "description": "êµ¬ê°„ DPë¡œ ìµœì  ì—°ì‚° ìˆœì„œë¥¼ ì°¾ìŠµë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ êµ¬ê°„ DP",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **êµ¬ê°„ì„ ë‚˜ëˆ„ëŠ” ëª¨ë“  ê²½ìš°ë¥¼ ê³ ë ¤** - ì‘ì€ êµ¬ê°„ â†’ í° êµ¬ê°„\n\n### ì í™”ì‹\n```\ndp[i][j] = min(dp[i][k] + dp[k+1][j] + cost)\n```\n\n### ì˜ˆì‹œ: í–‰ë ¬ ê³±ì…ˆ\n- A(10Ã—30) Ã— B(30Ã—5) Ã— C(5Ã—60)\n- (AB)C vs A(BC) ì—°ì‚° íšŸìˆ˜ê°€ ë‹¤ë¦„"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def matrix_chain_order(dims):\n    n = len(dims) - 1\n    dp = [[0] * n for _ in range(n)]\n\n    # ê¸¸ì´ë³„ë¡œ ê³„ì‚°\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            for k in range(i, j):\n                cost = dp[i][k] + dp[k+1][j] + dims[i] * dims[k+1] * dims[j+1]\n                dp[i][j] = min(dp[i][j], cost)\n\n    return dp[0][n-1]\n\ndims = [10, 30, 5, 60]  # 3ê°œ í–‰ë ¬\nprint(matrix_chain_order(dims))"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| í–‰ë ¬ ê³±ì…ˆ ìˆœì„œ (11049) | êµ¬ê°„ DP |\n| íŒŒì¼ í•©ì¹˜ê¸° (11066) | ìœ ì‚¬ ë¬¸ì œ |"
      }
    ]
  },
  "11_DP/practice-dp": {
    "id": "11_DP/practice-dp",
    "title": "Practice Dp",
    "category": "algorithm",
    "subCategory": "11_DP",
    "language": "Python",
    "description": "DP ë¬¸ì œ ì ‘ê·¼ë²•ê³¼ íŒ¨í„´ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ¯ DP ì ‘ê·¼ë²•",
        "content": "## DP ë¬¸ì œ í’€ì´ ìˆœì„œ\n\n1. **ë¬¸ì œ ë¶„ì„**: ìµœì í™”/ì¹´ìš´íŒ… ë¬¸ì œì¸ê°€?\n2. **ìƒíƒœ ì •ì˜**: dp[i]ê°€ ë¬´ì—‡ì„ ì˜ë¯¸í•˜ëŠ”ì§€\n3. **ì í™”ì‹**: dp[i]ë¥¼ ì–´ë–»ê²Œ êµ¬í•˜ëŠ”ì§€\n4. **ì´ˆê¸°ê°’**: ê¸°ì € ì¡°ê±´\n5. **ìˆœì„œ**: ì–´ë–¤ ìˆœì„œë¡œ ì±„ìš¸ì§€\n6. **ì •ë‹µ**: ì–´ë””ì„œ ë‹µì„ ê°€ì ¸ì˜¬ì§€\n\n## ìœ í˜•\n- ì„ í˜•: 1ì°¨ì› dp[i]\n- êµ¬ê°„: 2ì°¨ì› dp[i][j]\n- ë°°ë‚­: dp[i][w]\n- ë¹„íŠ¸ë§ˆìŠ¤í¬: dp[state][...]"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# DP í…œí”Œë¦¿\n\n# ì„ í˜• DP\ndef linear_dp(n):\n    dp = [0] * (n + 1)\n    dp[0] = base_case\n\n    for i in range(1, n + 1):\n        dp[i] = transition(dp[i-1], ...)\n\n    return dp[n]\n\n# 2ì°¨ì› DP\ndef grid_dp(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(m):\n        for j in range(n):\n            dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])\n\n    return dp[m-1][n-1]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ í•„ìˆ˜ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | ìœ í˜• |\n|-----|-----|\n| 1ë¡œ ë§Œë“¤ê¸° (1463) | ì„ í˜• |\n| RGBê±°ë¦¬ (1149) | ì„ í˜• |\n| í‰ë²”í•œ ë°°ë‚­ (12865) | ë°°ë‚­ |\n| LCS (9251) | 2ì°¨ì› |\n| ê°€ì¥ ê¸´ ì¦ê°€í•˜ëŠ” ë¶€ë¶„ ìˆ˜ì—´ (11053) | LIS |"
      }
    ]
  },
  "12_ê·¸ë¦¬ë””/activity-selection": {
    "id": "12_ê·¸ë¦¬ë””/activity-selection",
    "title": "Activity Selection",
    "category": "algorithm",
    "subCategory": "12_ê·¸ë¦¬ë””",
    "language": "Python",
    "description": "ê²¹ì¹˜ì§€ ì•ŠëŠ” ìµœëŒ€ í™œë™ ìˆ˜ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ í™œë™ ì„ íƒ ë¬¸ì œ",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ëë‚˜ëŠ” ì‹œê°„ì´ ë¹ ë¥¸ ê²ƒ ë¨¼ì €** - ë‹¤ìŒ í™œë™ ì„ íƒ ì—¬ì§€ ìµœëŒ€í™”\n\n### ì •ë‹¹ì„±\nëë‚˜ëŠ” ì‹œê°„ì´ ë¹ ë¥¸ í™œë™ì„ ì„ íƒí•˜ë©´\në‚˜ë¨¸ì§€ ì‹œê°„ì— ë” ë§ì€ í™œë™ì„ ë„£ì„ ìˆ˜ ìˆìŒ"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def activity_selection(activities):\n    # ëë‚˜ëŠ” ì‹œê°„ìœ¼ë¡œ ì •ë ¬\n    activities.sort(key=lambda x: x[1])\n\n    selected = []\n    end_time = 0\n\n    for start, end in activities:\n        if start >= end_time:\n            selected.append((start, end))\n            end_time = end\n\n    return selected\n\nmeetings = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11)]\nprint(activity_selection(meetings))\n# [(1, 4), (5, 7), (8, 11)]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| íšŒì˜ì‹¤ ë°°ì • (1931) | ê¸°ë³¸ |\n| ê°•ì˜ì‹¤ ë°°ì • (11000) | ìµœì†Œ ê°•ì˜ì‹¤ |"
      }
    ]
  },
  "12_ê·¸ë¦¬ë””/greedy-concept": {
    "id": "12_ê·¸ë¦¬ë””/greedy-concept",
    "title": "Greedy Concept",
    "category": "algorithm",
    "subCategory": "12_ê·¸ë¦¬ë””",
    "language": "Python",
    "description": "íƒìš• ì•Œê³ ë¦¬ì¦˜ì˜ ì›ë¦¬ì™€ ì ìš© ì¡°ê±´ì„ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ê·¸ë¦¬ë””ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ë§¤ ìˆœê°„ ìµœì„ ì˜ ì„ íƒ** - ì§€ì—­ ìµœì  â†’ ì „ì—­ ìµœì  (ë³´ì¥ í•„ìš”!)\n\n### ê·¸ë¦¬ë”” ì ìš© ì¡°ê±´\n1. **íƒìš• ì„ íƒ ì†ì„±**: ì§€ê¸ˆì˜ ìµœì„ ì´ ì „ì²´ì˜ ìµœì„ \n2. **ìµœì  ë¶€ë¶„ êµ¬ì¡°**: ë¶€ë¶„ í•´ê°€ ì „ì²´ í•´ êµ¬ì„±\n\n### ê·¸ë¦¬ë”” vs DP\n- ê·¸ë¦¬ë””: ì§€ê¸ˆ ìµœì„  ì„ íƒ, ëŒì•„ë³´ì§€ ì•ŠìŒ\n- DP: ëª¨ë“  ê²½ìš° ê³ ë ¤, ìµœì  ì„ íƒ"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ê±°ìŠ¤ë¦„ëˆ - ëŒ€í‘œì  ê·¸ë¦¬ë””\ndef min_coins_greedy(amount, coins):\n    coins.sort(reverse=True)  # í° ë™ì „ë¶€í„°\n    count = 0\n    for coin in coins:\n        count += amount // coin\n        amount %= coin\n    return count\n\n# ì£¼ì˜: ê·¸ë¦¬ë””ê°€ í•­ìƒ ë§ì§„ ì•ŠìŒ!\n# coins = [1, 5, 12]\n# amount = 15\n# ê·¸ë¦¬ë””: 12 + 1 + 1 + 1 = 4ê°œ\n# ìµœì : 5 + 5 + 5 = 3ê°œ\n\n# íšŒì˜ì‹¤ ë°°ì • - ê·¸ë¦¬ë”” ì •ë‹¹ì„± O\ndef max_meetings(meetings):\n    meetings.sort(key=lambda x: x[1])  # ëë‚˜ëŠ” ì‹œê°„ ìˆœ\n    count = 0\n    end_time = 0\n\n    for start, end in meetings:\n        if start >= end_time:\n            count += 1\n            end_time = end\n\n    return count"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ë™ì „ 0 (11047) | ê±°ìŠ¤ë¦„ëˆ |\n| íšŒì˜ì‹¤ ë°°ì • (1931) | í™œë™ ì„ íƒ |\n| ATM (11399) | ìˆœì„œ ì •í•˜ê¸° |"
      }
    ]
  },
  "12_ê·¸ë¦¬ë””/greedy-interval": {
    "id": "12_ê·¸ë¦¬ë””/greedy-interval",
    "title": "Greedy Interval",
    "category": "algorithm",
    "subCategory": "12_ê·¸ë¦¬ë””",
    "language": "Python",
    "description": "êµ¬ê°„ ê´€ë ¨ ê·¸ë¦¬ë”” ë¬¸ì œë¥¼ í•™ìŠµí•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ êµ¬ê°„ ë¬¸ì œ",
        "content": "## êµ¬ê°„ ê·¸ë¦¬ë”” íŒ¨í„´\n\n### 1. ìµœëŒ€ ë¹„ê²¹ì¹¨ (í™œë™ ì„ íƒ)\n- ëë‚˜ëŠ” ì‹œê°„ ìˆœ ì •ë ¬\n\n### 2. ìµœì†Œ ê°œìˆ˜ë¡œ ì»¤ë²„\n- ì‹œì‘ì  ìˆœ ì •ë ¬\n\n### 3. ê²¹ì¹˜ëŠ” êµ¬ê°„ ë³‘í•©\n- ì‹œì‘ì  ìˆœ ì •ë ¬ + ëì  ê°±ì‹ "
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# êµ¬ê°„ ë³‘í•©\ndef merge_intervals(intervals):\n    if not intervals:\n        return []\n\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n\n    for start, end in intervals[1:]:\n        if start <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], end)\n        else:\n            merged.append([start, end])\n\n    return merged\n\n# ìµœì†Œ í™”ì‚´ë¡œ í’ì„  í„°ëœ¨ë¦¬ê¸°\ndef min_arrows(points):\n    if not points:\n        return 0\n\n    points.sort(key=lambda x: x[1])\n    arrows = 1\n    end = points[0][1]\n\n    for s, e in points[1:]:\n        if s > end:\n            arrows += 1\n            end = e\n\n    return arrows"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Merge Intervals | LeetCode |\n| Minimum Number of Arrows | LeetCode |"
      }
    ]
  },
  "12_ê·¸ë¦¬ë””/greedy-vs-dp": {
    "id": "12_ê·¸ë¦¬ë””/greedy-vs-dp",
    "title": "Greedy Vs Dp",
    "category": "algorithm",
    "subCategory": "12_ê·¸ë¦¬ë””",
    "language": "Python",
    "description": "ê·¸ë¦¬ë””ì™€ DPì˜ ì°¨ì´ì™€ ì„ íƒ ê¸°ì¤€ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ë¹„êµ",
        "content": "## ê·¸ë¦¬ë”” vs DP\n\n| íŠ¹ì„± | ê·¸ë¦¬ë”” | DP |\n|-----|------|-----|\n| ì ‘ê·¼ | ì§€ê¸ˆ ìµœì„  | ëª¨ë“  ê²½ìš° |\n| ì‹œê°„ | ë³´í†µ ë¹ ë¦„ | ìƒíƒœ ìˆ˜ Ã— ì „ì´ |\n| ì •ë‹¹ì„± | ì¦ëª… í•„ìš” | í•­ìƒ ìµœì  |\n\n### ê·¸ë¦¬ë”” ê°€ëŠ¥ ì—¬ë¶€ íŒë‹¨\n1. ë°˜ë¡€ ì°¾ì•„ë³´ê¸°\n2. ìˆ˜í•™ì  ì¦ëª…\n3. ì‘ì€ ì˜ˆì œë¡œ í™•ì¸"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ê·¸ë¦¬ë”” ì‹¤íŒ¨ ì˜ˆì‹œ: ë™ì „\n\n# ê·¸ë¦¬ë”” (ì‹¤íŒ¨)\ncoins = [1, 5, 12]\namount = 15\n# ê·¸ë¦¬ë””: 12 + 1 + 1 + 1 = 4ê°œ\n\n# DP (ì •ë‹µ)\ndef min_coins_dp(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i and dp[i - coin] != float('inf'):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount]\n\n# DP: 5 + 5 + 5 = 3ê°œ"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "ë¬¸ì œ ì ‘ê·¼:\n1. ê·¸ë¦¬ë””ë¡œ í•´ê²° ê°€ëŠ¥? â†’ ë°˜ë¡€ í™•ì¸\n2. ë°˜ë¡€ ìˆìœ¼ë©´ â†’ DP ê³ ë ¤"
      }
    ]
  },
  "12_ê·¸ë¦¬ë””/practice-greedy": {
    "id": "12_ê·¸ë¦¬ë””/practice-greedy",
    "title": "Practice Greedy",
    "category": "algorithm",
    "subCategory": "12_ê·¸ë¦¬ë””",
    "language": "Python",
    "description": "ê·¸ë¦¬ë”” ë¬¸ì œ í’€ì´ íŒ¨í„´ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ¯ íŒ¨í„´",
        "content": "## ê·¸ë¦¬ë”” íŒ¨í„´\n\n### 1. ì •ë ¬ ê¸°ë°˜\n- ì–´ë–¤ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬?\n- ì‘ì€ ê²ƒë¶€í„°? í° ê²ƒë¶€í„°?\n\n### 2. êµí™˜ ë…¼ì¦\n- í˜„ì¬ ì„ íƒì´ ìµœì ì´ ì•„ë‹ˆë©´?\n- ë°”ê¿”ë„ ì†í•´ ì—†ê±°ë‚˜ ì´ë“?\n\n### 3. ìš°ì„ ìˆœìœ„ í\n- í•­ìƒ ìµœì„ ì˜ ê²ƒì„ ì„ íƒ"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "import heapq\n\n# í—ˆí”„ë§Œ ì½”ë”© - ìš°ì„ ìˆœìœ„ í ê·¸ë¦¬ë””\ndef huffman(freqs):\n    heap = list(freqs)\n    heapq.heapify(heap)\n    total = 0\n\n    while len(heap) > 1:\n        a = heapq.heappop(heap)\n        b = heapq.heappop(heap)\n        total += a + b\n        heapq.heappush(heap, a + b)\n\n    return total\n\n# ë¶„í•  ê°€ëŠ¥ ë°°ë‚­ - ë‹¨ê°€ ê¸°ì¤€ ê·¸ë¦¬ë””\ndef fractional_knapsack(W, items):\n    # ë‹¨ê°€ìˆœ ì •ë ¬\n    items.sort(key=lambda x: x[1]/x[0], reverse=True)\n    total = 0\n\n    for weight, value in items:\n        if W >= weight:\n            total += value\n            W -= weight\n        else:\n            total += value * (W / weight)\n            break\n\n    return total"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ í•„ìˆ˜ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ë™ì „ 0 (11047) | ê±°ìŠ¤ë¦„ëˆ |\n| íšŒì˜ì‹¤ ë°°ì • (1931) | í™œë™ ì„ íƒ |\n| ìƒì–´ë²„ë¦° ê´„í˜¸ (1541) | íŒŒì‹± |\n| ë¡œí”„ (2217) | ì •ë ¬ |"
      }
    ]
  },
  "13_ë°±íŠ¸ë˜í‚¹/backtracking-concept": {
    "id": "13_ë°±íŠ¸ë˜í‚¹/backtracking-concept",
    "title": "Backtracking Concept",
    "category": "algorithm",
    "subCategory": "13_ë°±íŠ¸ë˜í‚¹",
    "language": "Python",
    "description": "ê°€ì§€ì¹˜ê¸°ë¡œ íƒìƒ‰ ê³µê°„ì„ ì¤„ì´ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ë°±íŠ¸ë˜í‚¹ì´ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **í•´ê°€ ë  ê°€ëŠ¥ì„± ì—†ìœ¼ë©´ ê°€ì§€ì¹˜ê¸°** - ì™„ì „íƒìƒ‰ ìµœì í™”\n\n### DFS + ê°€ì§€ì¹˜ê¸°\n- ìœ ë§í•˜ì§€ ì•Šì€ ë…¸ë“œ = ë” ì´ìƒ íƒìƒ‰ X\n- ì‹œê°„ ë³µì¡ë„ í¬ê²Œ ê°ì†Œ ê°€ëŠ¥\n\n### í™œìš©\n- ìˆœì—´/ì¡°í•©\n- N-Queen\n- ìŠ¤ë„ì¿ \n- ë¶€ë¶„ì§‘í•© í•©"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ë°±íŠ¸ë˜í‚¹ í…œí”Œë¦¿\ndef backtrack(state):\n    if is_goal(state):\n        process_solution(state)\n        return\n\n    for candidate in get_candidates(state):\n        if is_promising(candidate):  # ê°€ì§€ì¹˜ê¸°\n            state.add(candidate)\n            backtrack(state)\n            state.remove(candidate)  # ë˜ëŒë¦¬ê¸°\n\n# ë¶€ë¶„ì§‘í•© í•©\ndef subset_sum(nums, target):\n    results = []\n\n    def backtrack(start, path, total):\n        if total == target:\n            results.append(path[:])\n            return\n        if total > target:  # ê°€ì§€ì¹˜ê¸°\n            return\n\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path, total + nums[i])\n            path.pop()\n\n    backtrack(0, [], 0)\n    return results"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Nê³¼ M (15649~) | ìˆœì—´/ì¡°í•© |\n| N-Queen (9663) | ì²´ìŠ¤íŒ |\n| ìŠ¤ë„ì¿  (2580) | ìœ íš¨ì„± ê²€ì‚¬ |"
      }
    ]
  },
  "13_ë°±íŠ¸ë˜í‚¹/backtracking-nqueen": {
    "id": "13_ë°±íŠ¸ë˜í‚¹/backtracking-nqueen",
    "title": "Backtracking Nqueen",
    "category": "algorithm",
    "subCategory": "13_ë°±íŠ¸ë˜í‚¹",
    "language": "Python",
    "description": "N-Queen ìµœì í™” ê¸°ë²•ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ìµœì í™”",
        "content": "## ë¹„íŠ¸ë§ˆìŠ¤í¬ ìµœì í™”\n\n### ê¸°ì¡´: O(nÂ²) ì¶©ëŒ ê²€ì‚¬\n### ìµœì í™”: O(1) ë¹„íŠ¸ ì—°ì‚°\n\n- col: ì‚¬ìš©ëœ ì—´\n- diag1: ìš°ìƒí–¥ ëŒ€ê°ì„ \n- diag2: ì¢Œìƒí–¥ ëŒ€ê°ì„ "
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def n_queens_optimized(n):\n    def backtrack(row, cols, diag1, diag2):\n        if row == n:\n            return 1\n\n        count = 0\n        available = ((1 << n) - 1) & ~(cols | diag1 | diag2)\n\n        while available:\n            pos = available & -available  # ê°€ì¥ ì˜¤ë¥¸ìª½ 1\n            available -= pos\n            count += backtrack(\n                row + 1,\n                cols | pos,\n                (diag1 | pos) << 1,\n                (diag2 | pos) >> 1\n            )\n\n        return count\n\n    return backtrack(0, 0, 0, 0)\n\nprint(n_queens_optimized(14))  # ë¹ ë¦„!"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "ë¹„íŠ¸ë§ˆìŠ¤í¬ë¡œ N=15 ì´ìƒë„ ë¹ ë¥´ê²Œ í•´ê²° ê°€ëŠ¥!"
      }
    ]
  },
  "13_ë°±íŠ¸ë˜í‚¹/backtracking-permutation": {
    "id": "13_ë°±íŠ¸ë˜í‚¹/backtracking-permutation",
    "title": "Backtracking Permutation",
    "category": "algorithm",
    "subCategory": "13_ë°±íŠ¸ë˜í‚¹",
    "language": "Python",
    "description": "ì¤‘ë³µ ìˆœì—´ê³¼ ê°™ì€ ìˆ˜ ì²˜ë¦¬ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ìˆœì—´ ë³€í˜•",
        "content": "## ë³€í˜•\n\n### ì¤‘ë³µ ìˆœì—´\n- ê°™ì€ ìˆ˜ ì—¬ëŸ¬ ë²ˆ ì„ íƒ ê°€ëŠ¥\n\n### ê°™ì€ ìˆ˜ê°€ ìˆëŠ” ìˆœì—´\n- [1,1,2]ì˜ ìˆœì—´ = 3ê°œ (6ê°œ ì•„ë‹˜)\n- ì •ë ¬ í›„ ê°™ì€ ìˆ˜ ì—°ì† ì²˜ë¦¬"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ì¤‘ë³µ ìˆœì—´\ndef permutations_with_repetition(nums, r):\n    results = []\n\n    def backtrack(path):\n        if len(path) == r:\n            results.append(path[:])\n            return\n        for num in nums:\n            path.append(num)\n            backtrack(path)\n            path.pop()\n\n    backtrack([])\n    return results\n\n# ê°™ì€ ìˆ˜ê°€ ìˆëŠ” ìˆœì—´\ndef unique_permutations(nums):\n    nums.sort()\n    results = []\n    used = [False] * len(nums)\n\n    def backtrack(path):\n        if len(path) == len(nums):\n            results.append(path[:])\n            return\n\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            # ê°™ì€ ìˆ˜ë©´ì„œ ì´ì „ ê²ƒì´ ì•ˆ ì“°ì˜€ìœ¼ë©´ ìŠ¤í‚µ\n            if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            backtrack(path)\n            path.pop()\n            used[i] = False\n\n    backtrack([])\n    return results\n\nprint(unique_permutations([1, 1, 2]))\n# [[1,1,2], [1,2,1], [2,1,1]]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Nê³¼ M (3) (15651) | ì¤‘ë³µ ìˆœì—´ |\n| Nê³¼ M (9) (15663) | ê°™ì€ ìˆ˜ |"
      }
    ]
  },
  "13_ë°±íŠ¸ë˜í‚¹/combination": {
    "id": "13_ë°±íŠ¸ë˜í‚¹/combination",
    "title": "Combination",
    "category": "algorithm",
    "subCategory": "13_ë°±íŠ¸ë˜í‚¹",
    "language": "Python",
    "description": "nê°œ ì¤‘ rê°œë¥¼ ìˆœì„œ ì—†ì´ ë½‘ëŠ” ì¡°í•©ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì¡°í•©",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ìˆœì„œ ìƒê´€ì—†ì´ ì„ íƒ** - nCr = n!/r!(n-r)!\n\n### íŠ¹ì§•\n- ìˆœì„œ X: [1,2]ì™€ [2,1]ì€ ê°™ìŒ\n- ì‹œì‘ ì¸ë±ìŠ¤ë¡œ ì¤‘ë³µ ë°©ì§€"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ë°±íŠ¸ë˜í‚¹ ì¡°í•©\ndef combinations(nums, r):\n    results = []\n\n    def backtrack(start, path):\n        if len(path) == r:\n            results.append(path[:])\n            return\n\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)  # ë‹¤ìŒ ì¸ë±ìŠ¤ë¶€í„°\n            path.pop()\n\n    backtrack(0, [])\n    return results\n\n# itertools ì‚¬ìš©\nfrom itertools import combinations\nlist(combinations([1,2,3], 2))\n# [(1,2), (1,3), (2,3)]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Nê³¼ M (2) (15650) | ê¸°ë³¸ ì¡°í•© |\n| ë¡œë˜ (6603) | ì¡°í•© ì¶œë ¥ |"
      }
    ]
  },
  "13_ë°±íŠ¸ë˜í‚¹/n-queen": {
    "id": "13_ë°±íŠ¸ë˜í‚¹/n-queen",
    "title": "N Queen",
    "category": "algorithm",
    "subCategory": "13_ë°±íŠ¸ë˜í‚¹",
    "language": "Python",
    "description": "NÃ—N ì²´ìŠ¤íŒì— Nê°œì˜ í€¸ì„ ë°°ì¹˜í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ N-Queen",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì„œë¡œ ê³µê²©í•˜ì§€ ì•Šê²Œ í€¸ ë°°ì¹˜** - ë°±íŠ¸ë˜í‚¹ ëŒ€í‘œ ë¬¸ì œ\n\n### ê°€ì§€ì¹˜ê¸° ì¡°ê±´\ní€¸ì€ ê°™ì€ í–‰, ì—´, ëŒ€ê°ì„  ê³µê²©:\n- ê°™ì€ ì—´ X\n- ê°™ì€ ëŒ€ê°ì„  X (|row1-row2| == |col1-col2|)"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def n_queens(n):\n    def is_safe(queens, row, col):\n        for r, c in enumerate(queens):\n            if c == col:  # ê°™ì€ ì—´\n                return False\n            if abs(r - row) == abs(c - col):  # ëŒ€ê°ì„ \n                return False\n        return True\n\n    def backtrack(row, queens):\n        if row == n:\n            return 1\n\n        count = 0\n        for col in range(n):\n            if is_safe(queens, row, col):\n                queens.append(col)\n                count += backtrack(row + 1, queens)\n                queens.pop()\n        return count\n\n    return backtrack(0, [])\n\nprint(n_queens(8))  # 92"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| N-Queen (9663) | ê°œìˆ˜ ì„¸ê¸° |"
      }
    ]
  },
  "13_ë°±íŠ¸ë˜í‚¹/permutation": {
    "id": "13_ë°±íŠ¸ë˜í‚¹/permutation",
    "title": "Permutation",
    "category": "algorithm",
    "subCategory": "13_ë°±íŠ¸ë˜í‚¹",
    "language": "Python",
    "description": "nê°œ ì¤‘ rê°œë¥¼ ìˆœì„œ ìˆê²Œ ë½‘ëŠ” ìˆœì—´ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ìˆœì—´",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ìˆœì„œê°€ ì¤‘ìš”í•œ ë‚˜ì—´** - nPr = n!/(n-r)!\n\n### íŠ¹ì§•\n- ìˆœì„œ O: [1,2]ì™€ [2,1]ì€ ë‹¤ë¦„\n- ì¤‘ë³µ X: í•œ ë²ˆ ì‚¬ìš©í•˜ë©´ ë‹¤ì‹œ ì‚¬ìš© X"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ë°±íŠ¸ë˜í‚¹ ìˆœì—´\ndef permutations(nums, r):\n    results = []\n    used = [False] * len(nums)\n\n    def backtrack(path):\n        if len(path) == r:\n            results.append(path[:])\n            return\n\n        for i in range(len(nums)):\n            if not used[i]:\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                used[i] = False\n\n    backtrack([])\n    return results\n\n# itertools ì‚¬ìš©\nfrom itertools import permutations\nlist(permutations([1,2,3], 2))\n# [(1,2), (1,3), (2,1), (2,3), (3,1), (3,2)]"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Nê³¼ M (1) (15649) | ê¸°ë³¸ ìˆœì—´ |\n| ëª¨ë“  ìˆœì—´ (10974) | ì „ì²´ ìˆœì—´ |"
      }
    ]
  },
  "13_ë°±íŠ¸ë˜í‚¹/practice-backtracking": {
    "id": "13_ë°±íŠ¸ë˜í‚¹/practice-backtracking",
    "title": "Practice Backtracking",
    "category": "algorithm",
    "subCategory": "13_ë°±íŠ¸ë˜í‚¹",
    "language": "Python",
    "description": "ë°±íŠ¸ë˜í‚¹ ë¬¸ì œ ì ‘ê·¼ë²•ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ¯ íŒ¨í„´",
        "content": "## ë°±íŠ¸ë˜í‚¹ = DFS + ê°€ì§€ì¹˜ê¸°\n\n### ì½”ë“œ êµ¬ì¡°\n1. ì¢…ë£Œ ì¡°ê±´ (ëª©í‘œ ë„ë‹¬)\n2. í›„ë³´ ìƒì„±\n3. ìœ ë§ì„± ê²€ì‚¬ (ê°€ì§€ì¹˜ê¸°)\n4. ì„ íƒ â†’ ì¬ê·€ â†’ ì·¨ì†Œ"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ìŠ¤ë„ì¿  í’€ê¸°\ndef solve_sudoku(board):\n    def is_valid(r, c, num):\n        # í–‰, ì—´, 3x3 ë°•ìŠ¤ ê²€ì‚¬\n        for i in range(9):\n            if board[r][i] == num:\n                return False\n            if board[i][c] == num:\n                return False\n        br, bc = 3 * (r // 3), 3 * (c // 3)\n        for i in range(br, br + 3):\n            for j in range(bc, bc + 3):\n                if board[i][j] == num:\n                    return False\n        return True\n\n    def solve():\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == 0:\n                    for num in range(1, 10):\n                        if is_valid(r, c, num):\n                            board[r][c] = num\n                            if solve():\n                                return True\n                            board[r][c] = 0\n                    return False\n        return True\n\n    solve()\n    return board"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ í•„ìˆ˜ ë¬¸ì œ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| Nê³¼ M ì‹œë¦¬ì¦ˆ | ìˆœì—´/ì¡°í•© |\n| N-Queen (9663) | ê°€ì§€ì¹˜ê¸° |\n| ìŠ¤ë„ì¿  (2580) | ìœ íš¨ì„± ê²€ì‚¬ |\n| ë¶€ë¶„ìˆ˜ì—´ì˜ í•© (1182) | ë¶€ë¶„ì§‘í•© |"
      }
    ]
  },
  "14_ê³ ê¸‰/mst-prim": {
    "id": "14_ê³ ê¸‰/mst-prim",
    "title": "Mst Prim",
    "category": "algorithm",
    "subCategory": "14_ê³ ê¸‰",
    "language": "Python",
    "description": "ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ êµ¬í•˜ëŠ” í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ í”„ë¦¼",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° ì—°ê²°** - ìš°ì„ ìˆœìœ„ í ì‚¬ìš©\n\n### ì‹œê°„ë³µì¡ë„\nO(E log V) - í™ ì‚¬ìš© ì‹œ"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "import heapq\n\ndef prim(n, graph):\n    visited = [False] * (n + 1)\n    heap = [(0, 1)]  # (ê°€ì¤‘ì¹˜, ë…¸ë“œ)\n    total = 0\n    count = 0\n\n    while heap and count < n:\n        weight, node = heapq.heappop(heap)\n        if visited[node]:\n            continue\n        visited[node] = True\n        total += weight\n        count += 1\n\n        for next_node, next_weight in graph[node]:\n            if not visited[next_node]:\n                heapq.heappush(heap, (next_weight, next_node))\n\n    return total if count == n else -1"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ (1197) | ê¸°ë³¸ |\n| ë„¤íŠ¸ì›Œí¬ ì—°ê²° (1922) | ì‘ìš© |"
      }
    ]
  },
  "14_ê³ ê¸‰/segment-tree": {
    "id": "14_ê³ ê¸‰/segment-tree",
    "title": "Segment Tree",
    "category": "algorithm",
    "subCategory": "14_ê³ ê¸‰",
    "language": "Python",
    "description": "êµ¬ê°„ ì¿¼ë¦¬ë¥¼ O(log n)ì— ì²˜ë¦¬í•©ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **êµ¬ê°„ ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” íŠ¸ë¦¬** - ì¿¼ë¦¬/ì—…ë°ì´íŠ¸ O(log n)\n\n### í™œìš©\n- êµ¬ê°„ í•©\n- êµ¬ê°„ ìµœì†Ÿê°’/ìµœëŒ“ê°’\n- êµ¬ê°„ ì—…ë°ì´íŠ¸"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "class SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.build(arr, 1, 0, self.n - 1)\n\n    def build(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build(arr, 2*node, start, mid)\n            self.build(arr, 2*node+1, mid+1, end)\n            self.tree[node] = self.tree[2*node] + self.tree[2*node+1]\n\n    def update(self, node, start, end, idx, val):\n        if start == end:\n            self.tree[node] = val\n        else:\n            mid = (start + end) // 2\n            if idx <= mid:\n                self.update(2*node, start, mid, idx, val)\n            else:\n                self.update(2*node+1, mid+1, end, idx, val)\n            self.tree[node] = self.tree[2*node] + self.tree[2*node+1]\n\n    def query(self, node, start, end, left, right):\n        if right < start or end < left:\n            return 0\n        if left <= start and end <= right:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return (self.query(2*node, start, mid, left, right) +\n                self.query(2*node+1, mid+1, end, left, right))"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| êµ¬ê°„ í•© êµ¬í•˜ê¸° (2042) | ê¸°ë³¸ |\n| ìµœì†Ÿê°’ê³¼ ìµœëŒ“ê°’ (2357) | ìµœì†Ÿê°’ |"
      }
    ]
  },
  "14_ê³ ê¸‰/trie": {
    "id": "14_ê³ ê¸‰/trie",
    "title": "Trie",
    "category": "algorithm",
    "subCategory": "14_ê³ ê¸‰",
    "language": "Python",
    "description": "ë¬¸ìì—´ ê²€ìƒ‰ì— íŠ¹í™”ëœ íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ íŠ¸ë¼ì´ë€?",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ë¬¸ìì—´ì„ ì €ì¥í•˜ëŠ” íŠ¸ë¦¬** - ê²€ìƒ‰/ì‚½ì… O(ë¬¸ìì—´ ê¸¸ì´)\n\n### í™œìš©\n- ìë™ì™„ì„±\n- ì‚¬ì „ êµ¬í˜„\n- ì ‘ë‘ì‚¬ ê²€ìƒ‰"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n\n    def starts_with(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\ntrie = Trie()\ntrie.insert(\"apple\")\nprint(trie.search(\"apple\"))    # True\nprint(trie.starts_with(\"app\")) # True"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ì „í™”ë²ˆí˜¸ ëª©ë¡ (5052) | ì ‘ë‘ì‚¬ |\n| Implement Trie | LeetCode |"
      }
    ]
  },
  "14_ê¸°íƒ€/mst-kruskal": {
    "id": "14_ê¸°íƒ€/mst-kruskal",
    "title": "Mst Kruskal",
    "category": "algorithm",
    "subCategory": "14_ê¸°íƒ€",
    "language": "Python",
    "description": "Union-Findë¥¼ ì´ìš©í•œ MST ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ í¬ë£¨ìŠ¤ì¹¼",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ê°€ì¤‘ì¹˜ ì‘ì€ ê°„ì„ ë¶€í„° ì—°ê²°** - Union-Findë¡œ ì‚¬ì´í´ ê²€ì‚¬\n\n### ì‹œê°„ë³µì¡ë„\nO(E log E) - ê°„ì„  ì •ë ¬"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "def kruskal(n, edges):\n    edges.sort(key=lambda x: x[2])  # ê°€ì¤‘ì¹˜ ì •ë ¬\n    uf = UnionFind(n + 1)\n    total = 0\n    count = 0\n\n    for u, v, w in edges:\n        if uf.union(u, v):  # ì‚¬ì´í´ ì•„ë‹ˆë©´ ì¶”ê°€\n            total += w\n            count += 1\n            if count == n - 1:\n                break\n\n    return total if count == n - 1 else -1\n\n# Union-Find í´ë˜ìŠ¤ëŠ” ìœ„ ì½”ë“œ ì°¸ì¡°"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ (1197) | ê¸°ë³¸ |\n| ë„ì‹œ ë¶„í•  ê³„íš (1647) | MST ë³€í˜• |"
      }
    ]
  },
  "14_ê¸°íƒ€/union-find": {
    "id": "14_ê¸°íƒ€/union-find",
    "title": "Union Find",
    "category": "algorithm",
    "subCategory": "14_ê¸°íƒ€",
    "language": "Python",
    "description": "ì§‘í•©ì˜ í•©ì§‘í•©ê³¼ ì°¾ê¸° ì—°ì‚°ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ Union-Find",
        "content": "## ğŸ”¥ í•œ ì¤„ ìš”ì•½\n> **ì§‘í•©ì˜ í•©ì¹˜ê¸°/ì°¾ê¸°** - ê±°ì˜ O(1) (ê²½ë¡œ ì••ì¶• + rank)\n\n### í™œìš©\n- ì—°ê²° ìš”ì†Œ\n- ì‚¬ì´í´ ê²€ì¶œ\n- í¬ë£¨ìŠ¤ì¹¼ MST"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])  # ê²½ë¡œ ì••ì¶•\n        return self.parent[x]\n\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False\n        # rank ê¸°ë°˜ í•©ì¹˜ê¸°\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        return True\n\n    def connected(self, x, y):\n        return self.find(x) == self.find(y)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "| ë¬¸ì œ | í¬ì¸íŠ¸ |\n|-----|-------|\n| ì§‘í•©ì˜ í‘œí˜„ (1717) | ê¸°ë³¸ |\n| ì—¬í–‰ ê°€ì (1976) | ì—°ê²° í™•ì¸ |"
      }
    ]
  },
  "15_ì‹¤ì „/coding-test-tip": {
    "id": "15_ì‹¤ì „/coding-test-tip",
    "title": "Coding Test Tip",
    "category": "algorithm",
    "subCategory": "15_ì‹¤ì „",
    "language": "Python",
    "description": "ì‹¤ì „ ì½”ë”© í…ŒìŠ¤íŠ¸ ì „ëµê³¼ íŒì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ì‹¤ì „ íŒ",
        "content": "## ì‹œê°„ ê´€ë¦¬\n\n| ë‚œì´ë„ | ì‹œê°„ ë°°ë¶„ |\n|------|---------|\n| ì‰¬ì›€ | 15ë¶„ |\n| ë³´í†µ | 30ë¶„ |\n| ì–´ë ¤ì›€ | 45ë¶„ |\n\n## ì ‘ê·¼ ìˆœì„œ\n1. ë¬¸ì œ ì½ê¸° (ì…ì¶œë ¥ í™•ì¸)\n2. ì˜ˆì œ ì†ìœ¼ë¡œ í’€ê¸°\n3. ì•Œê³ ë¦¬ì¦˜ ì„ íƒ\n4. ì½”ë“œ ì‘ì„±\n5. ì˜ˆì œ í…ŒìŠ¤íŠ¸\n6. ì—£ì§€ ì¼€ì´ìŠ¤ í™•ì¸"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ë¹ ë¥¸ ì…ë ¥\nimport sys\ninput = sys.stdin.readline\n\n# ì¬ê·€ ì œí•œ í•´ì œ\nsys.setrecursionlimit(10**6)\n\n# ìì£¼ ì“°ëŠ” import\nfrom collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, combinations\nfrom functools import lru_cache\n\n# ë””ë²„ê¹… íŒ\ndef debug(*args):\n    import sys\n    print(*args, file=sys.stderr)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì²´í¬ë¦¬ìŠ¤íŠ¸",
        "content": "- [ ] ì…ì¶œë ¥ í˜•ì‹ í™•ì¸\n- [ ] ì‹œê°„ë³µì¡ë„ ê³„ì‚°\n- [ ] ì—£ì§€ ì¼€ì´ìŠ¤ (0, 1, ìµœëŒ€ê°’)\n- [ ] ì¸ë±ìŠ¤ ë²”ìœ„ í™•ì¸\n- [ ] ì •ìˆ˜ ì˜¤ë²„í”Œë¡œìš°"
      }
    ]
  },
  "15_ì‹¤ì „/interview-algorithm": {
    "id": "15_ì‹¤ì „/interview-algorithm",
    "title": "Interview Algorithm",
    "category": "algorithm",
    "subCategory": "15_ì‹¤ì „",
    "language": "Python",
    "description": "ê¸°ìˆ  ë©´ì ‘ì—ì„œ ìì£¼ ë‚˜ì˜¤ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ ë©´ì ‘ í•„ìˆ˜",
        "content": "## ìì£¼ ë‚˜ì˜¤ëŠ” ì£¼ì œ\n\n### ìë£Œêµ¬ì¡°\n- ë°°ì—´, ì—°ê²° ë¦¬ìŠ¤íŠ¸, ìŠ¤íƒ, í\n- í•´ì‹œ í…Œì´ë¸”, íŠ¸ë¦¬, í™\n\n### ì•Œê³ ë¦¬ì¦˜\n- ì´ì§„ íƒìƒ‰\n- DFS/BFS\n- ë™ì  í”„ë¡œê·¸ë˜ë°\n- ì •ë ¬\n\n### ì„¤ëª… í¬ì¸íŠ¸\n- ì‹œê°„/ê³µê°„ ë³µì¡ë„\n- ë‹¤ë¥¸ ë°©ë²•ê³¼ ë¹„êµ\n- ì‹¤ì œ í™œìš© ì‚¬ë¡€"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ë©´ì ‘ì—ì„œ ìì£¼ ë¬¼ì–´ë³´ëŠ” ê²ƒë“¤\n\n# 1. í•´ì‹œ í…Œì´ë¸” ì¶©ëŒ í•´ê²°\n# - ì²´ì´ë‹, ê°œë°© ì£¼ì†Œë²•\n\n# 2. í™ vs ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬\n# - í™: ìµœëŒ€/ìµœì†Œ O(1), ì‚½ì… O(log n)\n# - BST: íƒìƒ‰/ì‚½ì…/ì‚­ì œ O(log n)\n\n# 3. í€µì†ŒíŠ¸ vs ë¨¸ì§€ì†ŒíŠ¸\n# - í€µ: í‰ê·  O(n log n), ìµœì•… O(nÂ²), in-place\n# - ë¨¸ì§€: í•­ìƒ O(n log n), O(n) ê³µê°„, ì•ˆì •\n\n# 4. DFS vs BFS\n# - DFS: ê²½ë¡œ, ë°±íŠ¸ë˜í‚¹\n# - BFS: ìµœë‹¨ ê±°ë¦¬, ë ˆë²¨ íƒìƒ‰"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì¤€ë¹„",
        "content": "ìì£¼ ë‚˜ì˜¤ëŠ” ë¬¸ì œ:\n- Two Sum\n- LRU Cache\n- ì´ì§„ íƒìƒ‰\n- íŠ¸ë¦¬ ìˆœíšŒ\n- ê·¸ë˜í”„ íƒìƒ‰"
      }
    ]
  },
  "15_ì‹¤ì „/problem-pattern": {
    "id": "15_ì‹¤ì „/problem-pattern",
    "title": "Problem Pattern",
    "category": "algorithm",
    "subCategory": "15_ì‹¤ì „",
    "language": "Python",
    "description": "ë¬¸ì œ ìœ í˜•ë³„ ì ‘ê·¼ íŒ¨í„´ì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ”¥ íŒ¨í„´ ì¸ì‹",
        "content": "## í‚¤ì›Œë“œ â†’ ì•Œê³ ë¦¬ì¦˜\n\n| í‚¤ì›Œë“œ | ì•Œê³ ë¦¬ì¦˜ |\n|-------|---------|\n| ìµœë‹¨ ê²½ë¡œ | BFS, ë‹¤ìµìŠ¤íŠ¸ë¼ |\n| ì¡°í•©/ìˆœì—´ | ë°±íŠ¸ë˜í‚¹ |\n| ìµœì í™” | DP, ê·¸ë¦¬ë”” |\n| ì •ë ¬ëœ ë°°ì—´ | ì´ì§„ íƒìƒ‰ |\n| ì—°ì† êµ¬ê°„ | ìŠ¬ë¼ì´ë”© ìœˆë„ìš° |\n| ë¹ˆë„ìˆ˜ | í•´ì‹œë§µ |\n| ê·¸ë˜í”„ ì—°ê²° | DFS/BFS, Union-Find |"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# ë¬¸ì œ ì ‘ê·¼ í…œí”Œë¦¿\n\ndef solve():\n    # 1. ì…ë ¥ ì²˜ë¦¬\n    n = int(input())\n\n    # 2. ì‹œê°„ë³µì¡ë„ ì˜ˆì¸¡\n    # N <= 10ë§Œ â†’ O(n log n) ì´í•˜\n\n    # 3. ì•Œê³ ë¦¬ì¦˜ ì„ íƒ\n    # - ìµœë‹¨ ê²½ë¡œ? â†’ BFS/ë‹¤ìµìŠ¤íŠ¸ë¼\n    # - ëª¨ë“  ê²½ìš°? â†’ ë°±íŠ¸ë˜í‚¹/DP\n    # - ì •ë ¬ëœ ë°°ì—´? â†’ ì´ì§„ íƒìƒ‰\n\n    # 4. êµ¬í˜„\n\n    # 5. ì¶œë ¥\n    print(answer)"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ ì—°ìŠµ",
        "content": "íŒ¨í„´ ì¸ì‹ â†’ ë¹ ë¥¸ ë¬¸ì œ í’€ì´!\n\në§ì€ ë¬¸ì œë¥¼ í’€ë©° íŒ¨í„´ ìµíˆê¸°."
      }
    ]
  },
  "index": {
    "id": "index",
    "title": "ì•Œê³ ë¦¬ì¦˜ & ìë£Œêµ¬ì¡°",
    "category": "algorithm",
    "subCategory": null,
    "language": "Python",
    "description": "ì•Œê³ ë¦¬ì¦˜ê³¼ ìë£Œêµ¬ì¡° í•™ìŠµ ê°€ì´ë“œì…ë‹ˆë‹¤.",
    "isPlaceholder": false,
    "sections": [
      {
        "type": "concept",
        "title": "ğŸ¯ í•™ìŠµ ë¡œë“œë§µ",
        "content": "## ì¶”ì²œ í•™ìŠµ ìˆœì„œ\n\n### Phase 1: ê¸°ì´ˆ (1-2ì£¼)\n1. ì‹œê°„/ê³µê°„ ë³µì¡ë„\n2. ë°°ì—´, ë¬¸ìì—´\n3. ìŠ¤íƒ, í\n\n### Phase 2: íƒìƒ‰ (2-3ì£¼)\n1. ì´ì§„ íƒìƒ‰\n2. DFS, BFS\n3. ê·¸ë˜í”„ ê¸°ì´ˆ\n\n### Phase 3: ìµœì í™” (3-4ì£¼)\n1. ë™ì  í”„ë¡œê·¸ë˜ë°\n2. ê·¸ë¦¬ë””\n3. ë°±íŠ¸ë˜í‚¹\n\n### Phase 4: ì‹¬í™” (4ì£¼+)\n1. ìµœë‹¨ ê²½ë¡œ\n2. íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜\n3. ê³ ê¸‰ ìë£Œêµ¬ì¡°"
      },
      {
        "type": "code",
        "language": "Python",
        "code": "# í•µì‹¬ ìë£Œêµ¬ì¡° ì •ë¦¬\n\n# ë°°ì—´ - ì¸ë±ìŠ¤ ì ‘ê·¼ O(1)\n# ì—°ê²° ë¦¬ìŠ¤íŠ¸ - ì‚½ì…/ì‚­ì œ O(1)\n# ìŠ¤íƒ - LIFO, O(1)\n# í - FIFO, O(1)\n# í•´ì‹œ - ì¡°íšŒ/ì‚½ì… O(1)\n# í™ - ìµœì†Œ/ìµœëŒ€ O(1), ì‚½ì… O(log n)\n# íŠ¸ë¦¬ - ê³„ì¸µì  êµ¬ì¡°\n# ê·¸ë˜í”„ - ê´€ê³„ í‘œí˜„"
      },
      {
        "type": "practice",
        "title": "ğŸ¯ í•™ìŠµ ìë£Œ",
        "content": "### ì¶”ì²œ ë¬¸ì œì§‘\n- ë°±ì¤€ ë‹¨ê³„ë³„ë¡œ í’€ì–´ë³´ê¸°\n- LeetCode 75\n- í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ê³ ë“ì  Kit\n\n### í•„ìˆ˜ ë¬¸ì œ (50ì„ )\nê¸°ì´ˆ, ì •ë ¬/íƒìƒ‰, ê·¸ë˜í”„, DP, ê·¸ë¦¬ë”” ê° 10ë¬¸ì œì”© ì—°ìŠµ!"
      }
    ]
  }
}